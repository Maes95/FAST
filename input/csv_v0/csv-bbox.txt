/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *   *      http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.csv;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;  import org.junit.Test;  import static org.junit.Assert.*;  public class CSVFormatTest {      @Test     public void testImmutalibity() {         CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, "\r\n", null);                  format.withDelimiter('?');         format.withEncapsulator('?');         format.withCommentStart('?');         format.withLineSeparator("?");         format.withEscape('?');         format.withSurroundingSpacesIgnored(false);         format.withEmptyLinesIgnored(false);                  assertEquals('!', format.getDelimiter());         assertEquals('!', format.getEncapsulator());         assertEquals('!', format.getCommentStart());         assertEquals('!', format.getEscape());         assertEquals("\r\n", format.getLineSeparator());                  assertTrue(format.isSurroundingSpacesIgnored());         assertTrue(format.isEmptyLinesIgnored());     }      @Test     public void testMutators() {         CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, "\r\n", null);                  assertEquals('?', format.withDelimiter('?').getDelimiter());         assertEquals('?', format.withEncapsulator('?').getEncapsulator());         assertEquals('?', format.withCommentStart('?').getCommentStart());         assertEquals("?", format.withLineSeparator("?").getLineSeparator());         assertEquals('?', format.withEscape('?').getEscape());                  assertFalse(format.withSurroundingSpacesIgnored(false).isSurroundingSpacesIgnored());         assertFalse(format.withEmptyLinesIgnored(false).isEmptyLinesIgnored());     }      @Test     public void testFormat() {         CSVFormat format = CSVFormat.DEFAULT;                  assertEquals("", format.format());         assertEquals("a,b,c", format.format("a", "b", "c"));         assertEquals("\"x,y\",z", format.format("x,y", "z"));     }          @Test     public void testValidation() {         CSVFormat format = CSVFormat.DEFAULT;                  try {             format.withDelimiter('\n');             fail();         } catch (IllegalArgumentException e) {             // expected         }                  try {             format.withEscape('\r');             fail();         } catch (IllegalArgumentException e) {             // expected         }                  try {             format.withEncapsulator('\n');             fail();         } catch (IllegalArgumentException e) {             // expected         }                  try {             format.withCommentStart('\r');             fail();         } catch (IllegalArgumentException e) {             // expected         }                  try {             format.withDelimiter('!').withEscape('!').validate();             fail();         } catch (IllegalArgumentException e) {             // expected         }                  try {             format.withDelimiter('!').withCommentStart('!').validate();             fail();         } catch (IllegalArgumentException e) {             // expected         }                  try {             format.withEncapsulator('!').withCommentStart('!').validate();             fail();         } catch (IllegalArgumentException e) {             // expected         }                  format.withEncapsulator(CSVFormat.DISABLED).withCommentStart(CSVFormat.DISABLED).validate();                  try {             format.withEscape('!').withCommentStart('!').validate();             fail();         } catch (IllegalArgumentException e) {             // expected         }                  format.withEscape(CSVFormat.DISABLED).withCommentStart(CSVFormat.DISABLED).validate();                           try {             format.withEncapsulator('!').withDelimiter('!').validate();             fail();         } catch (IllegalArgumentException e) {             // expected         }     }      @SuppressWarnings("boxing") // no need to worry about boxing here     @Test     public void testSerialization() throws Exception {         ByteArrayOutputStream out = new ByteArrayOutputStream();                  ObjectOutputStream oos = new ObjectOutputStream(out);         oos.writeObject(CSVFormat.DEFAULT);         oos.flush();         oos.close();                  ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));         CSVFormat format = (CSVFormat) in.readObject();                  assertNotNull(format);         assertEquals("delimiter", CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter());         assertEquals("encapsulator", CSVFormat.DEFAULT.getEncapsulator(), format.getEncapsulator());         assertEquals("comment start", CSVFormat.DEFAULT.getCommentStart(), format.getCommentStart());         assertEquals("line separator", CSVFormat.DEFAULT.getLineSeparator(), format.getLineSeparator());         assertEquals("escape", CSVFormat.DEFAULT.getEscape(), format.getEscape());         assertEquals("trim", CSVFormat.DEFAULT.isSurroundingSpacesIgnored(), format.isSurroundingSpacesIgnored());         assertEquals("empty lines", CSVFormat.DEFAULT.isEmptyLinesIgnored(), format.isEmptyLinesIgnored());     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *   *      http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.csv;  import java.io.IOException; import java.io.StringReader;  import org.junit.Test;  import static org.apache.commons.csv.Token.Type.*; import static org.junit.Assert.*;  public class CSVLexerTest {          private CSVLexer getLexer(String input, CSVFormat format) {         return new CSVLexer(format, new ExtendedBufferedReader(new StringReader(input)));     }      private void assertTokenEquals(Token.Type expectedType, String expectedContent, Token token) {         assertEquals("Token type", expectedType, token.type);         assertEquals("Token content", expectedContent, token.content.toString());     }          // Single line (without comment)     @Test     public void testNextToken1() throws IOException {         String code = "abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,";         CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));         assertTokenEquals(TOKEN, "abc", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "def", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "hijk", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "lmnop", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "qrst", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "uv", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "wxy", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "z", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "", parser.nextToken(new Token()));         assertTokenEquals(EOF, "", parser.nextToken(new Token()));     }      // multiline including comments (and empty lines)     @Test     public void testNextToken2() throws IOException {         /*   file:   1,2,3,         *           a,b x,c         *         *           # this is a comment         *           d,e,         *         */         String code = "1,2,3,\na,b x,c\n#foo\n\nd,e,\n\n";         CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');                  CSVLexer parser = getLexer(code, format);           assertTokenEquals(TOKEN, "1", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "2", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "3", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "a", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "b x", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "c", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "d", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "e", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "", parser.nextToken(new Token()));         assertTokenEquals(EOF, "", parser.nextToken(new Token()));         assertTokenEquals(EOF, "", parser.nextToken(new Token()));      }      // simple token with escaping     @Test     public void testNextToken3() throws IOException {         /* file: a,\,,b         *       \,,         */         String code = "a,\\,,b\n\\,,";         CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');         CSVLexer parser = getLexer(code, format);          assertTokenEquals(TOKEN, "a", parser.nextToken(new Token()));         // an unquoted single backslash is not an escape char         assertTokenEquals(TOKEN, "\\", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "b", parser.nextToken(new Token()));         // an unquoted single backslash is not an escape char         assertTokenEquals(TOKEN, "\\", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "", parser.nextToken(new Token()));         assertTokenEquals(EOF, "", parser.nextToken(new Token()));     }      // encapsulator tokenizer (sinle line)     @Test     public void testNextToken4() throws IOException {         /* file:  a,"foo",b         *        a,   " foo",b         *        a,"foo "   ,b     // whitespace after closing encapsulator         *        a,  " foo " ,b         */         String code = "a,\"foo\",b\na,   \" foo\",b\na,\"foo \"  ,b\na,  \" foo \"  ,b";         CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));         assertTokenEquals(TOKEN, "a", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "foo", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "b", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "a", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, " foo", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "b", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "a", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "foo ", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "b", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "a", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, " foo ", parser.nextToken(new Token())); //      assertTokenEquals(EORECORD, "b", parser.nextToken(new Token()));         assertTokenEquals(EOF, "b", parser.nextToken(new Token()));     }      // encapsulator tokenizer (multi line, delimiter in string)     @Test     public void testNextToken5() throws IOException {         String code = "a,\"foo\n\",b\n\"foo\n  baar ,,,\"\n\"\n\t \n\"";         CSVLexer parser = getLexer(code, CSVFormat.DEFAULT);         assertTokenEquals(TOKEN, "a", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "foo\n", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "b", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "foo\n  baar ,,,", parser.nextToken(new Token()));         assertTokenEquals(EOF, "\n\t \n", parser.nextToken(new Token()));      }      // change delimiters, comment, encapsulater     @Test     public void testNextToken6() throws IOException {         /* file: a;'b and \' more         *       '         *       !comment;;;;         *       ;;         */         String code = "a;'b and '' more\n'\n!comment;;;;\n;;";         CSVFormat format = CSVFormat.DEFAULT.withDelimiter(';').withEncapsulator('\'').withCommentStart('!');         CSVLexer parser = getLexer(code, format);         assertTokenEquals(TOKEN, "a", parser.nextToken(new Token()));         assertTokenEquals(EORECORD, "b and ' more\n", parser.nextToken(new Token()));     }      // From CSV-1     @Test     public void testDelimiterIsWhitespace() throws IOException {         String code = "one\ttwo\t\tfour \t five\t six";         CSVLexer parser = getLexer(code, CSVFormat.TDF);         assertTokenEquals(TOKEN, "one", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "two", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "four", parser.nextToken(new Token()));         assertTokenEquals(TOKEN, "five", parser.nextToken(new Token()));         assertTokenEquals(EOF, "six", parser.nextToken(new Token()));     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *   *      http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.csv;  import java.io.IOException; import java.io.Reader; import java.io.StringReader; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.NoSuchElementException;  import org.junit.Ignore; import org.junit.Test;  import static org.junit.Assert.*;  /**  * CSVParserTest  *  * The test are organized in three different sections:  * The 'setter/getter' section, the lexer section and finally the parser  * section. In case a test fails, you should follow a top-down approach for  * fixing a potential bug (its likely that the parser itself fails if the lexer  * has problems...).  */ public class CSVParserTest {      String code = "a,b,c,d\n"                     + " a , b , 1 2 \n"                     + "\"foo baar\", b,\n"                     // + "   \"foo\n,,\n\"\",,\n\\\"\",d,e\n";                     + "   \"foo\n,,\n\"\",,\n\"\"\",d,e\n";   // changed to use standard CSV escaping     String[][] res = {             {"a", "b", "c", "d"},             {"a", "b", "1 2"},             {"foo baar", "b", ""},             {"foo\n,,\n\",,\n\"", "d", "e"}     };      @Test     public void testGetLine() throws IOException {         CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));         for (String[] re : res) {             assertArrayEquals(re, parser.getRecord().values());         }                  assertNull(parser.getRecord());     }      @Test     public void testGetRecords() throws IOException {         CSVParser parser = new CSVParser(new StringReader(code), CSVFormat.DEFAULT.withSurroundingSpacesIgnored(true));         List<CSVRecord> records = parser.getRecords();         assertEquals(res.length, records.size());         assertTrue(records.size() > 0);         for (int i = 0; i < res.length; i++) {             assertArrayEquals(res[i], records.get(i).values());         }     }      @Test     public void testExcelFormat1() throws IOException {         String code =                 "value1,value2,value3,value4\r\na,b,c,d\r\n  x,,,"                         + "\r\n\r\n\"\"\"hello\"\"\",\"  \"\"world\"\"\",\"abc\ndef\",\r\n";         String[][] res = {                 {"value1", "value2", "value3", "value4"},                 {"a", "b", "c", "d"},                 {"  x", "", "", ""},                 {""},                 {"\"hello\"", "  \"world\"", "abc\ndef", ""}         };         CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);         List<CSVRecord> records = parser.getRecords();         assertEquals(res.length, records.size());         assertTrue(records.size() > 0);         for (int i = 0; i < res.length; i++) {             assertArrayEquals(res[i], records.get(i).values());         }     }      @Test     public void testExcelFormat2() throws Exception {         String code = "foo,baar\r\n\r\nhello,\r\n\r\nworld,\r\n";         String[][] res = {                 {"foo", "baar"},                 {""},                 {"hello", ""},                 {""},                 {"world", ""}         };         CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);         List<CSVRecord> records = parser.getRecords();         assertEquals(res.length, records.size());         assertTrue(records.size() > 0);         for (int i = 0; i < res.length; i++) {             assertArrayEquals(res[i], records.get(i).values());         }     }      @Test     public void testEndOfFileBehaviourExcel() throws Exception {         String[] codes = {                 "hello,\r\n\r\nworld,\r\n",                 "hello,\r\n\r\nworld,",                 "hello,\r\n\r\nworld,\"\"\r\n",                 "hello,\r\n\r\nworld,\"\"",                 "hello,\r\n\r\nworld,\n",                 "hello,\r\n\r\nworld,",                 "hello,\r\n\r\nworld,\"\"\n",                 "hello,\r\n\r\nworld,\"\""         };         String[][] res = {                 {"hello", ""},                 {""},  // Excel format does not ignore empty lines                 {"world", ""}         };                  for (String code : codes) {             CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);             List<CSVRecord> records = parser.getRecords();             assertEquals(res.length, records.size());             assertTrue(records.size() > 0);             for (int i = 0; i < res.length; i++) {                 assertArrayEquals(res[i], records.get(i).values());             }         }     }      @Test     public void testEndOfFileBehaviorCSV() throws Exception {         String[] codes = {                 "hello,\r\n\r\nworld,\r\n",                 "hello,\r\n\r\nworld,",                 "hello,\r\n\r\nworld,\"\"\r\n",                 "hello,\r\n\r\nworld,\"\"",                 "hello,\r\n\r\nworld,\n",                 "hello,\r\n\r\nworld,",                 "hello,\r\n\r\nworld,\"\"\n",                 "hello,\r\n\r\nworld,\"\""         };         String[][] res = {                 {"hello", ""},  // CSV format ignores empty lines                 {"world", ""}         };         for (String code : codes) {             CSVParser parser = new CSVParser(new StringReader(code));             List<CSVRecord> records = parser.getRecords();             assertEquals(res.length, records.size());             assertTrue(records.size() > 0);             for (int i = 0; i < res.length; i++) {                 assertArrayEquals(res[i], records.get(i).values());             }         }     }      @Test     public void testEmptyLineBehaviourExcel() throws Exception {         String[] codes = {                 "hello,\r\n\r\n\r\n",                 "hello,\n\n\n",                 "hello,\"\"\r\n\r\n\r\n",                 "hello,\"\"\n\n\n"         };         String[][] res = {                 {"hello", ""},                 {""},  // Excel format does not ignore empty lines                 {""}         };         for (String code : codes) {             CSVParser parser = new CSVParser(code, CSVFormat.EXCEL);             List<CSVRecord> records = parser.getRecords();             assertEquals(res.length, records.size());             assertTrue(records.size() > 0);             for (int i = 0; i < res.length; i++) {                 assertArrayEquals(res[i], records.get(i).values());             }         }     }      @Test     public void testEmptyLineBehaviourCSV() throws Exception {         String[] codes = {                 "hello,\r\n\r\n\r\n",                 "hello,\n\n\n",                 "hello,\"\"\r\n\r\n\r\n",                 "hello,\"\"\n\n\n"         };         String[][] res = {                 {"hello", ""}  // CSV format ignores empty lines         };         for (String code : codes) {             CSVParser parser = new CSVParser(new StringReader(code));             List<CSVRecord> records = parser.getRecords();             assertEquals(res.length, records.size());             assertTrue(records.size() > 0);             for (int i = 0; i < res.length; i++) {                 assertArrayEquals(res[i], records.get(i).values());             }         }     }      @Test     public void testEmptyFile() throws Exception {         CSVParser parser = new CSVParser("", CSVFormat.DEFAULT);         assertNull(parser.getRecord());     }      @Test     @Ignore     public void testBackslashEscapingOld() throws IOException {         String code =                 "one,two,three\n"                         + "on\\\"e,two\n"                         + "on\"e,two\n"                         + "one,\"tw\\\"o\"\n"                         + "one,\"t\\,wo\"\n"                         + "one,two,\"th,ree\"\n"                         + "\"a\\\\\"\n"                         + "a\\,b\n"                         + "\"a\\\\,b\"";         String[][] res = {                 {"one", "two", "three"},                 {"on\\\"e", "two"},                 {"on\"e", "two"},                 {"one", "tw\"o"},                 {"one", "t\\,wo"},  // backslash in quotes only escapes a delimiter (",")                 {"one", "two", "th,ree"},                 {"a\\\\"},     // backslash in quotes only escapes a delimiter (",")                 {"a\\", "b"},  // a backslash must be returnd                 {"a\\\\,b"}    // backslash in quotes only escapes a delimiter (",")         };         CSVParser parser = new CSVParser(new StringReader(code));         List<CSVRecord> records = parser.getRecords();         assertEquals(res.length, records.size());         assertTrue(records.size() > 0);         for (int i = 0; i < res.length; i++) {             assertArrayEquals(res[i], records.get(i).values());         }     }      @Test     public void testBackslashEscaping() throws IOException {          // To avoid confusion over the need for escaping chars in java code,         // We will test with a forward slash as the escape char, and a single         // quote as the encapsulator.          String code =                 "one,two,three\n" // 0                         + "'',''\n"       // 1) empty encapsulators                         + "/',/'\n"       // 2) single encapsulators                         + "'/'','/''\n"   // 3) single encapsulators encapsulated via escape                         + "'''',''''\n"   // 4) single encapsulators encapsulated via doubling                         + "/,,/,\n"       // 5) separator escaped                         + "//,//\n"       // 6) escape escaped                         + "'//','//'\n"   // 7) escape escaped in encapsulation                         + "   8   ,   \"quoted \"\" /\" // string\"   \n"     // don't eat spaces                         + "9,   /\n   \n"  // escaped newline                         + "";         String[][] res = {                 {"one", "two", "three"}, // 0                 {"", ""},                // 1                 {"'", "'"},              // 2                 {"'", "'"},              // 3                 {"'", "'"},              // 4                 {",", ","},              // 5                 {"/", "/"},              // 6                 {"/", "/"},              // 7                 {"   8   ", "   \"quoted \"\" \" / string\"   "},                 {"9", "   \n   "},         };           CSVFormat format = new CSVFormat(',', '\'', CSVFormat.DISABLED, '/', false, true, "\r\n", null);          CSVParser parser = new CSVParser(code, format);         List<CSVRecord> records = parser.getRecords();         assertTrue(records.size() > 0);         for (int i = 0; i < res.length; i++) {             assertArrayEquals(res[i], records.get(i).values());         }     }      @Test     public void testBackslashEscaping2() throws IOException {          // To avoid confusion over the need for escaping chars in java code,         // We will test with a forward slash as the escape char, and a single         // quote as the encapsulator.          String code = ""                 + " , , \n"           // 1)                 + " \t ,  , \n"       // 2)                 + " // , /, , /,\n"   // 3)                 + "";         String[][] res = {                 {" ", " ", " "},         // 1                 {" \t ", "  ", " "},     // 2                 {" / ", " , ", " ,"},    // 3         };           CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, true, "\r\n", null);          CSVParser parser = new CSVParser(code, format);         List<CSVRecord> records = parser.getRecords();         assertTrue(records.size() > 0);          assertTrue(CSVPrinterTest.equals(res, records));     }      @Test     public void testDefaultFormat() throws IOException {         String code = ""                 + "a,b\n"            // 1)                 + "\"\n\",\" \"\n"   // 2)                 + "\"\",#\n"   // 2)                 ;         String[][] res = {                 {"a", "b"},                 {"\n", " "},                 {"", "#"},         };          CSVFormat format = CSVFormat.DEFAULT;         assertEquals(CSVFormat.DISABLED, format.getCommentStart());          CSVParser parser = new CSVParser(code, format);         List<CSVRecord> records = parser.getRecords();         assertTrue(records.size() > 0);          assertTrue(CSVPrinterTest.equals(res, records));          String[][] res_comments = {                 {"a", "b"},                 {"\n", " "},                 {""},         };          format = CSVFormat.DEFAULT.withCommentStart('#');         parser = new CSVParser(code, format);         records = parser.getRecords();                  assertTrue(CSVPrinterTest.equals(res_comments, records));     }      @Test     public void testCarriageReturnLineFeedEndings() throws IOException {         String code = "foo\r\nbaar,\r\nhello,world\r\n,kanu";         CSVParser parser = new CSVParser(new StringReader(code));         List<CSVRecord> records = parser.getRecords();         assertEquals(4, records.size());     }      @Test     public void testCarriageReturnEndings() throws IOException {         String code = "foo\rbaar,\rhello,world\r,kanu";         CSVParser parser = new CSVParser(new StringReader(code));         List<CSVRecord> records = parser.getRecords();         assertEquals(4, records.size());     }      @Test     public void testLineFeedEndings() throws IOException {         String code = "foo\nbaar,\nhello,world\n,kanu";         CSVParser parser = new CSVParser(new StringReader(code));         List<CSVRecord> records = parser.getRecords();         assertEquals(4, records.size());     }      @Test     public void testIgnoreEmptyLines() throws IOException {         String code = "\nfoo,baar\n\r\n,\n\n,world\r\n\n";         //String code = "world\r\n\n";         //String code = "foo;baar\r\n\r\nhello;\r\n\r\nworld;\r\n";         CSVParser parser = new CSVParser(new StringReader(code));         List<CSVRecord> records = parser.getRecords();         assertEquals(3, records.size());     }      @Test     public void testForEach() throws Exception {         List<CSVRecord> records = new ArrayList<CSVRecord>();                  Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z");                  for (CSVRecord record : CSVFormat.DEFAULT.parse(in)) {             records.add(record);         }                  assertEquals(3, records.size());         assertArrayEquals(new String[]{"a", "b", "c"}, records.get(0).values());         assertArrayEquals(new String[]{"1", "2", "3"}, records.get(1).values());         assertArrayEquals(new String[]{"x", "y", "z"}, records.get(2).values());     }      @Test     public void testIterator() throws Exception {         Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z");                  Iterator<CSVRecord> iterator = CSVFormat.DEFAULT.parse(in).iterator();                  assertTrue(iterator.hasNext());         try {             iterator.remove();             fail("expected UnsupportedOperationException");         } catch (UnsupportedOperationException expected) {         }         assertArrayEquals(new String[]{"a", "b", "c"}, iterator.next().values());         assertArrayEquals(new String[]{"1", "2", "3"}, iterator.next().values());         assertTrue(iterator.hasNext());         assertTrue(iterator.hasNext());         assertTrue(iterator.hasNext());         assertArrayEquals(new String[]{"x", "y", "z"}, iterator.next().values());         assertFalse(iterator.hasNext());                  try {             iterator.next();             fail("NoSuchElementException expected");         } catch (NoSuchElementException e) {             // expected         }     }          @Test     public void testHeader() throws Exception {         Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z");          Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();                  for (int i = 0; i < 2; i++) {             assertTrue(records.hasNext());             CSVRecord record = records.next();             assertEquals(record.get(0), record.get("a"));             assertEquals(record.get(1), record.get("b"));             assertEquals(record.get(2), record.get("c"));         }                  assertFalse(records.hasNext());     }      @Test     public void testProvidedHeader() throws Exception {         Reader in = new StringReader("a,b,c\n1,2,3\nx,y,z");          Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader("A", "B", "C").parse(in).iterator();          for (int i = 0; i < 3; i++) {             assertTrue(records.hasNext());             CSVRecord record = records.next();             assertEquals(record.get(0), record.get("A"));             assertEquals(record.get(1), record.get("B"));             assertEquals(record.get(2), record.get("C"));         }          assertFalse(records.hasNext());     }      @Test     public void testGetLineNumberWithLF() throws Exception {         CSVParser parser = new CSVParser("a\nb\nc", CSVFormat.DEFAULT.withLineSeparator("\n"));                  assertEquals(0, parser.getLineNumber());         assertNotNull(parser.getRecord());         assertEquals(1, parser.getLineNumber());         assertNotNull(parser.getRecord());         assertEquals(2, parser.getLineNumber());         assertNotNull(parser.getRecord());         assertEquals(2, parser.getLineNumber());         assertNull(parser.getRecord());     }      @Test     public void testGetLineNumberWithCRLF() throws Exception {         CSVParser parser = new CSVParser("a\r\nb\r\nc", CSVFormat.DEFAULT.withLineSeparator("\r\n"));                  assertEquals(0, parser.getLineNumber());         assertNotNull(parser.getRecord());         assertEquals(1, parser.getLineNumber());         assertNotNull(parser.getRecord());         assertEquals(2, parser.getLineNumber());         assertNotNull(parser.getRecord());         assertEquals(2, parser.getLineNumber());         assertNull(parser.getRecord());     }      @Test     public void testGetLineNumberWithCR() throws Exception {         CSVParser parser = new CSVParser("a\rb\rc", CSVFormat.DEFAULT.withLineSeparator("\r"));                  assertEquals(0, parser.getLineNumber());         assertNotNull(parser.getRecord());         assertEquals(1, parser.getLineNumber());         assertNotNull(parser.getRecord());         assertEquals(2, parser.getLineNumber());         assertNotNull(parser.getRecord());         assertEquals(2, parser.getLineNumber());         assertNull(parser.getRecord());     } } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *   *      http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.csv;  import java.io.IOException; import java.io.StringWriter; import java.util.List; import java.util.Random;  import org.junit.Test;  import static org.junit.Assert.*;  public class CSVPrinterTest {      String lineSeparator = CSVFormat.DEFAULT.getLineSeparator();      @Test     public void testPrinter1() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);         printer.println("a", "b");         assertEquals("a,b" + lineSeparator, sw.toString());     }      @Test     public void testPrinter2() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);         printer.println("a,b", "b");         assertEquals("\"a,b\",b" + lineSeparator, sw.toString());     }      @Test     public void testPrinter3() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);         printer.println("a, b", "b ");         assertEquals("\"a, b\",\"b \"" + lineSeparator, sw.toString());     }      @Test     public void testPrinter4() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);         printer.println("a", "b\"c");         assertEquals("a,\"b\"\"c\"" + lineSeparator, sw.toString());     }      @Test     public void testPrinter5() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);         printer.println("a", "b\nc");         assertEquals("a,\"b\nc\"" + lineSeparator, sw.toString());     }      @Test     public void testPrinter6() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);         printer.println("a", "b\r\nc");         assertEquals("a,\"b\r\nc\"" + lineSeparator, sw.toString());     }      @Test     public void testPrinter7() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);         printer.println("a", "b\\c");         assertEquals("a,b\\c" + lineSeparator, sw.toString());     }      @Test     public void testExcelPrinter1() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);         printer.println("a", "b");         assertEquals("a,b" + lineSeparator, sw.toString());     }      @Test     public void testExcelPrinter2() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.EXCEL);         printer.println("a,b", "b");         assertEquals("\"a,b\",b" + lineSeparator, sw.toString());     }      @Test     public void testPrintNullValues() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);         printer.println("a", null, "b");         assertEquals("a,,b" + lineSeparator, sw.toString());     }      @Test     public void testDisabledComment() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT);         printer.printComment("This is a comment");                  assertEquals("", sw.toString());     }      @Test     public void testSingleLineComment() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));         printer.printComment("This is a comment");                  assertEquals("# This is a comment" + lineSeparator, sw.toString());     }      @Test     public void testMultiLineComment() throws IOException {         StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));         printer.printComment("This is a comment\non multiple lines");                  assertEquals("# This is a comment" + lineSeparator + "# on multiple lines" + lineSeparator, sw.toString());     }      @Test     public void testRandom() throws Exception {         int iter = 10000;         doRandom(CSVFormat.DEFAULT, iter);         doRandom(CSVFormat.EXCEL, iter);         doRandom(CSVFormat.MYSQL, iter);     }      public void doRandom(CSVFormat format, int iter) throws Exception {         for (int i = 0; i < iter; i++) {             doOneRandom(format);         }     }      public void doOneRandom(CSVFormat format) throws Exception {         Random r = new Random();                  int nLines = r.nextInt(4) + 1;         int nCol = r.nextInt(3) + 1;         // nLines=1;nCol=2;         String[][] lines = new String[nLines][];         for (int i = 0; i < nLines; i++) {             String[] line = new String[nCol];             lines[i] = line;             for (int j = 0; j < nCol; j++) {                 line[j] = randStr();             }         }          StringWriter sw = new StringWriter();         CSVPrinter printer = new CSVPrinter(sw, format);          for (int i = 0; i < nLines; i++) {             // for (int j=0; j<lines[i].length; j++) System.out.println("### VALUE=:" + printable(lines[i][j]));             printer.println(lines[i]);         }          printer.flush();         String result = sw.toString();         // System.out.println("### :" + printable(result));          CSVParser parser = new CSVParser(result, format);         List<CSVRecord> parseResult = parser.getRecords();          if (!equals(lines, parseResult)) {             System.out.println("Printer output :" + printable(result));             assertTrue(false);         }     }      public static boolean equals(String[][] a, List<CSVRecord> b) {         if (a.length != b.size()) {             return false;         }         for (int i = 0; i < a.length; i++) {             String[] linea = a[i];             String[] lineb = b.get(i).values();             if (linea.length != lineb.length) {                 return false;             }             for (int j = 0; j < linea.length; j++) {                 String aval = linea[j];                 String bval = lineb[j];                 if (!aval.equals(bval)) {                     System.out.println("expected  :" + printable(aval));                     System.out.println("got       :" + printable(bval));                     return false;                 }             }         }         return true;     }      public static String printable(String s) {         StringBuilder sb = new StringBuilder();         for (int i = 0; i < s.length(); i++) {             char ch = s.charAt(i);             if (ch <= ' ' || ch >= 128) {                 sb.append("(").append((int) ch).append(")");             } else {                 sb.append(ch);             }         }         return sb.toString();     }      public String randStr() {         Random r = new Random();                  int sz = r.nextInt(20);         // sz = r.nextInt(3);         char[] buf = new char[sz];         for (int i = 0; i < sz; i++) {             // stick in special chars with greater frequency             char ch;             int what = r.nextInt(20);             switch (what) {                 case 0:                     ch = '\r';                     break;                 case 1:                     ch = '\n';                     break;                 case 2:                     ch = '\t';                     break;                 case 3:                     ch = '\f';                     break;                 case 4:                     ch = ' ';                     break;                 case 5:                     ch = ',';                     break;                 case 6:                     ch = '"';                     break;                 case 7:                     ch = '\'';                     break;                 case 8:                     ch = '\\';                     break;                 default:                     ch = (char) r.nextInt(300);                     break;                 // default: ch = 'a'; break;             }             buf[i] = ch;         }         return new String(buf);     }  } 
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *   *      http://www.apache.org/licenses/LICENSE-2.0  *   * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */  package org.apache.commons.csv;  import java.io.StringReader;  import org.junit.Test;  import static org.junit.Assert.*;  public class ExtendedBufferedReaderTest {      @Test     public void testEmptyInput() throws Exception {         ExtendedBufferedReader br = getBufferedReader("");         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.readAgain());         assertNull(br.readLine());         assertEquals(0, br.read(new char[10], 0, 0));     }      @Test     public void testReadLookahead1() {} // Defects4J: flaky method //     @Test //     public void testReadLookahead1() throws Exception { //         ExtendedBufferedReader br = getBufferedReader("1\n2\r3\n"); //         assertEquals('1', br.lookAhead()); //         assertEquals(ExtendedBufferedReader.UNDEFINED, br.readAgain()); //         assertEquals('1', br.read()); //         assertEquals('1', br.readAgain()); //  //         assertEquals(0, br.getLineNumber()); //         assertEquals('\n', br.lookAhead()); //         assertEquals(0, br.getLineNumber()); //         assertEquals('1', br.readAgain()); //         assertEquals('\n', br.read()); //         assertEquals(1, br.getLineNumber()); //         assertEquals('\n', br.readAgain()); //         assertEquals(1, br.getLineNumber()); //  //         assertEquals('2', br.lookAhead()); //         assertEquals(1, br.getLineNumber()); //         assertEquals('\n', br.readAgain()); //         assertEquals(1, br.getLineNumber()); //         assertEquals('2', br.read()); //         assertEquals('2', br.readAgain()); //  //         assertEquals('\r', br.lookAhead()); //         assertEquals('2', br.readAgain()); //         assertEquals('\r', br.read()); //         assertEquals('\r', br.readAgain()); //  //         assertEquals('3', br.lookAhead()); //         assertEquals('\r', br.readAgain()); //         assertEquals('3', br.read()); //         assertEquals('3', br.readAgain()); //  //         assertEquals('\n', br.lookAhead()); //         assertEquals(1, br.getLineNumber()); // will need fixing for CSV-75 //         assertEquals('3', br.readAgain()); //         assertEquals('\n', br.read()); //         assertEquals(2, br.getLineNumber()); // will need fixing for CSV-75 //         assertEquals('\n', br.readAgain()); //         assertEquals(2, br.getLineNumber()); // will need fixing for CSV-75 //  //         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead()); //         assertEquals('\n', br.readAgain()); //         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read()); //         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.readAgain()); //         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read()); //         assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead()); //  //     }      @Test     public void testReadLookahead2() throws Exception {         char[] ref = new char[5];         char[] res = new char[5];                  ExtendedBufferedReader br = getBufferedReader("abcdefg");         ref[0] = 'a';         ref[1] = 'b';         ref[2] = 'c';         assertEquals(3, br.read(res, 0, 3));         assertArrayEquals(ref, res);         assertEquals('c', br.readAgain());          assertEquals('d', br.lookAhead());         ref[4] = 'd';         assertEquals(1, br.read(res, 4, 1));         assertArrayEquals(ref, res);         assertEquals('d', br.readAgain());     }      @Test     public void testReadLine() throws Exception {         ExtendedBufferedReader br = getBufferedReader("");         assertNull(br.readLine());          br = getBufferedReader("\n");         assertEquals("",br.readLine());         assertNull(br.readLine());          br = getBufferedReader("foo\n\nhello");         assertEquals(0, br.getLineNumber());         assertEquals("foo",br.readLine());         assertEquals(1, br.getLineNumber());         assertEquals("",br.readLine());         assertEquals(2, br.getLineNumber());         assertEquals("hello",br.readLine());         assertEquals(3, br.getLineNumber());         assertNull(br.readLine());         assertEquals(3, br.getLineNumber());          br = getBufferedReader("foo\n\nhello");         assertEquals('f', br.read());         assertEquals('o', br.lookAhead());         assertEquals("oo",br.readLine());         assertEquals(1, br.getLineNumber());         assertEquals('\n', br.lookAhead());         assertEquals("",br.readLine());         assertEquals(2, br.getLineNumber());         assertEquals('h', br.lookAhead());         assertEquals("hello",br.readLine());         assertNull(br.readLine());         assertEquals(3, br.getLineNumber());           br = getBufferedReader("foo\rbaar\r\nfoo");         assertEquals("foo",br.readLine());         assertEquals('b', br.lookAhead());         assertEquals("baar",br.readLine());         assertEquals('f', br.lookAhead());         assertEquals("foo",br.readLine());         assertNull(br.readLine());     }      /*      * Test to illustrate  https://issues.apache.org/jira/browse/CSV-75      *       * TODO fix checks when code is fixed      */     @Test     public void testReadChar() {} // Defects4J: flaky method //     @Test //     public void testReadChar() throws Exception { //         String LF="\n"; String CR="\r"; String CRLF=CR+LF; String LFCR=LF+CR;// easier to read the string below //         String test="a" + LF + "b" + CR + "c" + LF + LF + "d" + CR + CR + "e" + LFCR + "f "+ CRLF; //         //                EOL        eol        EOL  EOL        eol  eol        EOL+CR        EOL //         // EOL = current EOL behaviour with read() methods //         // eol = additional behaviour with readLine() //         final int EOLct=5; //         final int EOLeolct=9; //         ExtendedBufferedReader br; //          //         br = getBufferedReader(test); //         assertEquals(0, br.getLineNumber()); //         while(br.readLine()!=null) {} //         assertEquals(EOLeolct, br.getLineNumber()); //  //         br = getBufferedReader(test); //         assertEquals(0, br.getLineNumber()); //         while(br.read()!=-1) {} //         assertEquals(EOLct, br.getLineNumber()); // will need fixing for CSV-75 //  //         br = getBufferedReader(test); //         assertEquals(0, br.getLineNumber()); //         char[] buff = new char[10]; //         while(br.read(buff ,0, 3)!=-1) {} //         assertEquals(EOLct, br.getLineNumber()); // will need fixing for CSV-75 //     }      private ExtendedBufferedReader getBufferedReader(String s) {         return new ExtendedBufferedReader(new StringReader(s));     } } 
