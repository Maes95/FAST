/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.Assert;import org.junit.Test;import org.kurento.client.HttpPostEndpoint;import org.kurento.client.PlayerEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.client.test.util.MediaPipelineBaseTest;public class BasicPipelineTest extends MediaPipelineBaseTest {  @Test  public void basicPipelineTest() {    PlayerEndpoint player =        new PlayerEndpoint.Builder(pipeline, "http://" + getTestFilesHttpPath()            + "/video/format/small.webm").build();    HttpPostEndpoint httpEndpoint = new HttpPostEndpoint.Builder(pipeline).build();    player.connect(httpEndpoint);    for (int i = 0; i < 100; i++) {      WebRtcEndpoint webRtc = new WebRtcEndpoint.Builder(pipeline).build();      player.connect(webRtc);    }    System.out.println("Dot length: " + pipeline.getGstreamerDot().getBytes().length);    String url = httpEndpoint.getUrl();    player.release();    Assert.assertNotSame("The URL shouldn't be empty", "", url);  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.kurento.client.EndOfStreamEvent;import org.kurento.client.FaceOverlayFilter;import org.kurento.client.PlayerEndpoint;import org.kurento.client.test.util.AsyncEventManager;import org.kurento.client.test.util.AsyncResultManager;/** * {@link FaceOverlayFilter} test suite. * * @author Ivan Gracia (igracia@gsyc.es) * @since 2.0.1 * */public class FaceOverlayFilterAsyncTest extends MediaPipelineAsyncBaseTest {  private PlayerEndpoint player;  private FaceOverlayFilter overlayFilter;  @Before  public void setupMediaElements() throws InterruptedException {    player = new PlayerEndpoint.Builder(pipeline, URL_POINTER_DETECTOR).build();    AsyncResultManager<FaceOverlayFilter> async =        new AsyncResultManager<>("FaceOverlayFilter creation");    new FaceOverlayFilter.Builder(pipeline).buildAsync(async.getContinuation());    overlayFilter = async.waitForResult();  }  @After  public void teardownMediaElements() throws InterruptedException {    player.release();    releaseMediaObject(overlayFilter);  }  /**   * Test if a {@link FaceOverlayFilter} can be created in the KMS. The filter is pipelined with a   * {@link PlayerEndpoint}, which feeds video to the filter. This test depends on the correct   * behaviour of the player and its events.   *   * @throws InterruptedException   */  @Test  public void testFaceOverlayFilter() throws InterruptedException {    player.connect(overlayFilter);    AsyncEventManager<EndOfStreamEvent> async = new AsyncEventManager<>("EndOfStream event");    player.addEndOfStreamListener(async.getMediaEventListener());    player.play();    async.waitForResult();  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.kurento.client.EndOfStreamEvent;import org.kurento.client.FaceOverlayFilter;import org.kurento.client.PlayerEndpoint;import org.kurento.client.test.util.AsyncEventManager;import org.kurento.client.test.util.MediaPipelineBaseTest;/** * {@link FaceOverlayFilter} test suite. * * @author Ivan Gracia (igracia@gsyc.es) * @since 2.0.1 * */public class FaceOverlayFilterTest extends MediaPipelineBaseTest {  private FaceOverlayFilter overlayFilter;  @Before  public void setupMediaElements() {    overlayFilter = new FaceOverlayFilter.Builder(pipeline).build();  }  @After  public void teardownMediaElements() {    overlayFilter.release();  }  /**   * Test if a {@link FaceOverlayFilter} can be created in the KMS. The filter is pipelined with a   * {@link PlayerEndpoint}, which feeds video to the filter. This test depends on the correct   * behaviour of the player and its events.   *   * @throws InterruptedException   */  @Test  public void testFaceOverlayFilter() throws InterruptedException {    PlayerEndpoint player = new PlayerEndpoint.Builder(pipeline, URL_POINTER_DETECTOR).build();    player.connect(overlayFilter);    AsyncEventManager<EndOfStreamEvent> async = new AsyncEventManager<>("EndOfStream event");    player.addEndOfStreamListener(async.getMediaEventListener());    player.play();    async.waitForResult();    player.stop();    player.release();  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.kurento.client.EventListener;import org.kurento.client.GStreamerFilter;import org.kurento.client.PlayerEndpoint;import org.kurento.client.test.util.AsyncResultManager;import org.kurento.module.platedetector.PlateDetectorFilter;/** * {@link PlateDetectorFilter} test suite. * * Events tested: * <ul> * <li>{@link PlateDetectorFilter#addPlateDetectedListener(EventListener)} * </ul> * * * @author Ivan Gracia (igracia@gsyc.es) * @version 2.0.1 * */public class GStreamerFilterAsyncTest extends MediaPipelineAsyncBaseTest {  private GStreamerFilter filter;  private PlayerEndpoint player;  @Before  public void setupMediaElements() {    player = new PlayerEndpoint.Builder(pipeline, URL_PLATES).build();  }  @After  public void teardownMediaElements() {    player.release();  }  @Test  public void testInstantiation() throws InterruptedException {    AsyncResultManager<GStreamerFilter> async =        new AsyncResultManager<GStreamerFilter>("GStreamerFilter creation");    new GStreamerFilter.Builder(pipeline, "videoflip method=horizontal-flip")        .buildAsync(async.getContinuation());    filter = async.waitForResult();    releaseMediaObject(filter);  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.kurento.client.EndOfStreamEvent;import org.kurento.client.GStreamerFilter;import org.kurento.client.PlayerEndpoint;import org.kurento.client.test.util.AsyncEventManager;import org.kurento.client.test.util.MediaPipelineBaseTest;/** * {@link GStreamerFilter} test suite. * * * @author Ivan Gracia (igracia@gsyc.es) * @since 3.0.1 * */public class GStreamerFilterTest extends MediaPipelineBaseTest {  private GStreamerFilter filter;  private PlayerEndpoint player;  @Before  public void setupMediaElements() {    player = new PlayerEndpoint.Builder(pipeline, URL_SMALL).build();  }  @After  public void teardownMediaElements() {    player.release();  }  @Test  public void testInstantiation() throws InterruptedException {    filter = new GStreamerFilter.Builder(pipeline, "videoflip method=horizontal-flip").build();    Assert.assertNotNull(filter);    player.connect(filter);    AsyncEventManager<EndOfStreamEvent> async =        new AsyncEventManager<EndOfStreamEvent>("EndOfStream event");    player.addEndOfStreamListener(async.getMediaEventListener());    player.play();    async.waitForResult();    filter.release();  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.kurento.client.EndOfStreamEvent;import org.kurento.client.EventListener;import org.kurento.client.ListenerSubscription;import org.kurento.client.PlayerEndpoint;import org.kurento.client.test.util.AsyncEventManager;import org.kurento.client.test.util.AsyncResultManager;/** * {@link PlayerEndpoint} test suite. * * <p> * Methods tested: * <ul> * <li>{@link PlayerEndpoint#getUri()} * <li>{@link PlayerEndpoint#play()} * <li>{@link PlayerEndpoint#pause()} * <li>{@link PlayerEndpoint#stop()} * </ul> * <p> * Events tested: * <ul> * <li>{@link PlayerEndpoint#addEndOfStreamListener(EventListener)} * </ul> * * * @author Ivan Gracia (igracia@gsyc.es) * @version 1.0.0 * */public class PlayerEndpointAsyncTest extends MediaPipelineAsyncBaseTest {  private PlayerEndpoint player;  @Before  public void setupMediaElements() throws InterruptedException {    AsyncResultManager<PlayerEndpoint> async = new AsyncResultManager<>("PlayerEndpoint creation");    new PlayerEndpoint.Builder(pipeline, URL_SMALL).buildAsync(async.getContinuation());    player = async.waitForResult();    Assert.assertNotNull(player);  }  @After  public void teardownMediaElements() throws InterruptedException {    releaseMediaObject(player);  }  @Test  public void testGetUri() throws InterruptedException {    AsyncResultManager<String> async = new AsyncResultManager<>("player.getUri() invocation");    player.getUri(async.getContinuation());    String uri = async.waitForResult();    Assert.assertEquals(URL_SMALL, uri);  }  /**   * start/pause/stop sequence test   *   * @throws InterruptedException   */  @Test  public void testPlayer() throws InterruptedException {    AsyncResultManager<Void> async = new AsyncResultManager<>("player.play() invocation");    player.play(async.getContinuation());    async.waitForResult();    AsyncResultManager<Void> async2 = new AsyncResultManager<>("player.pause() invocation");    player.pause(async2.getContinuation());    async2.waitForResult();    AsyncResultManager<Void> async3 = new AsyncResultManager<>("player.stop() invocation");    player.stop(async3.getContinuation());    async3.waitForResult();  }  @Test  public void testEventEndOfStream() throws InterruptedException {    AsyncResultManager<ListenerSubscription> asyncListener =        new AsyncResultManager<>("EndOfStream Listener registration");    AsyncEventManager<EndOfStreamEvent> asyncEvent = new AsyncEventManager<>("EndOfStream event");    player.addEndOfStreamListener(asyncEvent.getMediaEventListener(),        asyncListener.getContinuation());    asyncListener.waitForResult();    player.play();    asyncEvent.waitForResult();  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.kurento.client.EndOfStreamEvent;import org.kurento.client.EventListener;import org.kurento.client.PlayerEndpoint;import org.kurento.client.test.util.AsyncEventManager;import org.kurento.client.test.util.MediaPipelineBaseTest;import org.kurento.commons.exception.KurentoException;/** * {@link PlayerEndpoint} test suite. * * <p> * Methods tested: * <ul> * <li>{@link PlayerEndpoint#getUri()} * <li>{@link PlayerEndpoint#play()} * <li>{@link PlayerEndpoint#pause()} * <li>{@link PlayerEndpoint#stop()} * </ul> * <p> * Events tested: * <ul> * <li>{@link PlayerEndpoint#addEndOfStreamListener(EventListener)} * </ul> * * * @author Ivan Gracia (igracia@gsyc.es) * @version 1.0.0 * */public class PlayerEndpointTest extends MediaPipelineBaseTest {  private PlayerEndpoint player;  @Before  public void setupMediaElements() throws KurentoException {    player = new PlayerEndpoint.Builder(pipeline, URL_SMALL).build();  }  @After  public void teardownMediaElements() {    if (player != null) {      player.release();    }  }  /**   * start/pause/stop sequence test   */  @Test  public void testPlayer() {    player.play();    player.pause();    player.stop();  }  @Test  public void testEventEndOfStream() throws InterruptedException {    AsyncEventManager<EndOfStreamEvent> async = new AsyncEventManager<>("EndOfStream event");    player.addEndOfStreamListener(async.getMediaEventListener());    player.play();    async.waitForResult();  }  @Test  public void testCommandGetUri() {    Assert.assertTrue(URL_SMALL.equals(player.getUri()));  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.kurento.client.RecorderEndpoint;import org.kurento.client.test.util.AsyncResultManager;/** * {@link RecorderEndpoint} test suite. * * <p> * Methods tested: * <ul> * <li>{@link RecorderEndpoint#getUri()} * <li>{@link RecorderEndpoint#record()} * <li>{@link RecorderEndpoint#pause()} * <li>{@link RecorderEndpoint#stop()} * </ul> * * @author Ivan Gracia (igracia@gsyc.es) * @version 1.0.0 * */public class RecorderEndpointAsyncTest extends MediaPipelineAsyncBaseTest {  private RecorderEndpoint recorder;  @Before  public void setupMediaElements() throws InterruptedException {    AsyncResultManager<RecorderEndpoint> async =        new AsyncResultManager<>("RecorderEndpoint creation");    new RecorderEndpoint.Builder(pipeline, URL_SMALL).buildAsync(async.getContinuation());    recorder = async.waitForResult();    Assert.assertNotNull(recorder);  }  @After  public void teardownMediaElements() throws InterruptedException {    releaseMediaObject(recorder);  }  @Test  public void testGetUri() throws InterruptedException {    AsyncResultManager<String> async = new AsyncResultManager<>("recorder.getUri() invocation");    recorder.getUri(async.getContinuation());    String uri = async.waitForResult();    Assert.assertEquals(URL_SMALL, uri);  }  @Test  public void testRecorder() throws InterruptedException {    AsyncResultManager<Void> asyncRecord = new AsyncResultManager<>("recorder.record() invocation");    recorder.record(asyncRecord.getContinuation());    asyncRecord.waitForResult();    AsyncResultManager<Void> asyncPause = new AsyncResultManager<>("recorder.pause() invocation");    recorder.pause(asyncPause.getContinuation());    asyncPause.waitForResult();    AsyncResultManager<Void> asyncStop = new AsyncResultManager<>("recorder.stop() invocation");    recorder.pause(asyncStop.getContinuation());    asyncStop.waitForResult();  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.After;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.kurento.client.RecorderEndpoint;import org.kurento.client.test.util.MediaPipelineBaseTest;/** * {@link RecorderEndpoint} test suite. * * <p> * Methods tested: * <ul> * <li>{@link RecorderEndpoint#getUri()} * <li>{@link RecorderEndpoint#record()} * <li>{@link RecorderEndpoint#pause()} * <li>{@link RecorderEndpoint#stop()} * </ul> * * @author Ivan Gracia (igracia@gsyc.es) * @version 1.0.0 * */public class RecorderEndpointTest extends MediaPipelineBaseTest {  private RecorderEndpoint recorder;  @Before  public void setupMediaElements() {    recorder = new RecorderEndpoint.Builder(pipeline, URL_SMALL).build();  }  @After  public void teardownMediaElements() {    recorder.release();  }  /**   * start/pause/stop sequence test   */  @Test  public void testRecorder() {    recorder.record();    recorder.pause();    recorder.stop();  }  @Test  public void testCommandGetUri() {    Assert.assertEquals(URL_SMALL, recorder.getUri());  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.Assert;import org.junit.Before;import org.junit.Test;import org.kurento.client.EventListener;import org.kurento.client.MediaType;import org.kurento.client.PlayerEndpoint;import org.kurento.client.RtpEndpoint;import org.kurento.client.test.util.AsyncResultManager;import org.kurento.client.test.util.SdpAsyncBaseTest;/** * {@link RtpEndpoint} test suite. * * <p> * Methods tested: * <ul> * <li>{@link RtpEndpoint#getLocalSessionDescriptor()} * <li>{@link RtpEndpoint#getRemoteSessionDescriptor()} * <li>{@link RtpEndpoint#generateOffer()} * <li>{@link RtpEndpoint#processOffer(String)} * <li>{@link RtpEndpoint#processAnswer(String)} * </ul> * <p> * Events tested: * <ul> * <li>{@link RtpEndpoint#addMediaSessionStartedListener(EventListener)} * <li>{@link RtpEndpoint#addMediaSessionTerminatedListener(EventListener)} * </ul> * * * @author Ivan Gracia (igracia@gsyc.es) * @version 1.0.0 * */public class RtpEndpointAsyncTest extends SdpAsyncBaseTest<RtpEndpoint> {  @Before  public void setupMediaElements() throws InterruptedException {    AsyncResultManager<RtpEndpoint> async = new AsyncResultManager<>("RtpEndpoint creation");    new RtpEndpoint.Builder(pipeline).buildAsync(async.getContinuation());    sdp = async.waitForResult();    Assert.assertNotNull(sdp);    AsyncResultManager<RtpEndpoint> async2 = new AsyncResultManager<>("RtpEndpoint creation");    new RtpEndpoint.Builder(pipeline).buildAsync(async2.getContinuation());    sdp2 = async2.waitForResult();    Assert.assertNotNull(sdp2);  }  @Test  public void testRtpEndpointSimulatingAndroidSdp() throws InterruptedException {    PlayerEndpoint player = new PlayerEndpoint.Builder(pipeline, URL_BARCODES).build();    RtpEndpoint rtpEndpoint = new RtpEndpoint.Builder(pipeline).build();    String requestSdp = "v=0\r\n" + "o=- 12345 12345 IN IP4 95.125.31.136\r\n" + "s=-\r\n"        + "c=IN IP4 95.125.31.136\r\n" + "t=0 0\r\n" + "m=video 52126 RTP/AVP 96 97 98\r\n"        + "a=rtpmap:96 H264/90000\r\n" + "a=rtpmap:97 MP4V-ES/90000\r\n"        + "a=rtpmap:98 H263-1998/90000\r\n" + "a=recvonly\r\n" + "b=AS:384\r\n";    rtpEndpoint.processOffer(requestSdp);    player.connect(rtpEndpoint, MediaType.VIDEO);    player.play();    // just a little bit of time before destroying    Thread.sleep(2000);  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.Before;import org.kurento.client.EventListener;import org.kurento.client.RtpEndpoint;import org.kurento.client.test.util.SdpBaseTest;/** * {@link RtpEndpoint} test suite. * * <p> * Methods tested: * <ul> * <li>{@link RtpEndpoint#getLocalSessionDescriptor()} * <li>{@link RtpEndpoint#getRemoteSessionDescriptor()} * <li>{@link RtpEndpoint#generateOffer()} * <li>{@link RtpEndpoint#processOffer(String)} * <li>{@link RtpEndpoint#processAnswer(String)} * </ul> * <p> * Events tested: * <ul> * <li>{@link RtpEndpoint#addMediaSessionStartedListener(EventListener)} * <li>{@link RtpEndpoint#addMediaSessionTerminatedListener(EventListener)} * </ul> * * * @author Ivan Gracia (igracia@gsyc.es) * @version 1.0.0 * */public class RtpEndpointTest extends SdpBaseTest<RtpEndpoint> {  @Before  public void setupMediaElements() {    sdp = new RtpEndpoint.Builder(pipeline).build();    sdp2 = new RtpEndpoint.Builder(pipeline).build();  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.Assert;import org.junit.Before;import org.kurento.client.EventListener;import org.kurento.client.WebRtcEndpoint;import org.kurento.client.test.util.AsyncResultManager;import org.kurento.client.test.util.SdpAsyncBaseTest;/** * {@link WebRtcEndpoint} test suite. * * <p> * Methods tested: * <ul> * <li>{@link WebRtcEndpoint#getLocalSessionDescriptor()} * <li>{@link WebRtcEndpoint#getRemoteSessionDescriptor()} * <li>{@link WebRtcEndpoint#generateOffer()} * <li>{@link WebRtcEndpoint#processOffer(String)} * <li>{@link WebRtcEndpoint#processAnswer(String)} * </ul> * <p> * Events tested: * <ul> * <li>{@link WebRtcEndpoint#addMediaSessionStartedListener(EventListener)} * <li>{@link WebRtcEndpoint#addMediaSessionTerminatedListener(EventListener)} * </ul> * * * @author Jose Antonio Santos Cadenas (santoscadenas@gmail.com) * @version 1.0.0 * */public class WebRtcEndpointAsyncTest extends SdpAsyncBaseTest<WebRtcEndpoint> {  @Before  public void setupMediaElements() throws InterruptedException {    AsyncResultManager<WebRtcEndpoint> async = new AsyncResultManager<>("RtpEndpoint creation");    new WebRtcEndpoint.Builder(pipeline).buildAsync(async.getContinuation());    sdp = async.waitForResult();    Assert.assertNotNull(sdp);    AsyncResultManager<WebRtcEndpoint> async2 = new AsyncResultManager<>("RtpEndpoint creation");    new WebRtcEndpoint.Builder(pipeline).buildAsync(async2.getContinuation());    sdp2 = async2.waitForResult();    Assert.assertNotNull(sdp2);  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.Before;import org.kurento.client.WebRtcEndpoint;import org.kurento.client.test.util.SdpBaseTest;/** * {@link WebRtcEndpoint} test suite. * * * * @author Ivan Gracia (igracia@gsyc.es) * @version 1.0.0 * */public class WebRtcEndpointTest extends SdpBaseTest<WebRtcEndpoint> {  @Before  public void setupMediaElements() {    sdp = new WebRtcEndpoint.Builder(pipeline).build();    sdp2 = new WebRtcEndpoint.Builder(pipeline).build();  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.kurento.client.CodeFoundEvent;import org.kurento.client.EventListener;import org.kurento.client.HttpEndpoint;import org.kurento.client.PlayerEndpoint;import org.kurento.client.ZBarFilter;import org.kurento.client.test.util.AsyncEventManager;import org.kurento.client.test.util.MediaPipelineBaseTest;/** * {@link HttpEndpoint} test suite. * * <p> * Methods tested: * <ul> * <li>{@link HttpEndpoint#getUrl()} * </ul> * <p> * Events tested: * <ul> * <li>{@link HttpEndpoint#addMediaSessionStartListener(EventListener)} * <li>{@link HttpEndpoint#addMediaSessionTerminatedListener(EventListener)} * </ul> * * * @author Ivan Gracia (igracia@gsyc.es) * @version 1.0.0 * */public class ZBarFilterTest extends MediaPipelineBaseTest {  private ZBarFilter zbar;  @Before  public void setupMediaElements() {    zbar = new ZBarFilter.Builder(pipeline).build();  }  @After  public void teardownMediaElements() {    zbar.release();  }  @Test  public void testCodeFoundEvent() throws InterruptedException {    PlayerEndpoint player = new PlayerEndpoint.Builder(pipeline, URL_BARCODES).build();    player.connect(zbar);    AsyncEventManager<CodeFoundEvent> async = new AsyncEventManager<>("CodeFound event");    zbar.addCodeFoundListener(async.getMediaEventListener());    player.play();    async.waitForResult();    player.stop();    player.release();  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;public class AsyncServerTest extends JsonRpcConnectorBaseTest {  public static class Handler extends DefaultJsonRpcHandler<String> {    @Override    public void handleRequest(final Transaction transaction, Request<String> request)        throws Exception {      transaction.startAsync();      // Poor man method scheduling      new Thread() {        @Override        public void run() {          try {            Thread.sleep(1000);            transaction.sendResponse("AsyncHello");          } catch (Exception e) {          }        }      }.start();    }  }  @Test  public void test() throws IOException, InterruptedException {    JsonRpcClient client = createJsonRpcClient("/async_handler");    String response = client.sendRequest("count", "fakeparams", String.class);    Assert.assertEquals("AsyncHello", response);    client.close();  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.client.Continuation;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.google.gson.JsonElement;import com.google.gson.JsonObject;public class BasicAsyncClientEchoTest extends JsonRpcConnectorBaseTest {  private static final Logger log = LoggerFactory.getLogger(BasicAsyncClientEchoTest.class);  static class Params {    String param1;    String param2;  }  @Test  public void test() throws IOException, InterruptedException {    log.debug("Client started");    JsonRpcClient client = createJsonRpcClient("/jsonrpc");    final JsonObject params = new JsonObject();    params.addProperty("param1", "Value1");    params.addProperty("param2", "Value2");    CountDownLatch finishTestLatch = new CountDownLatch(1);    client.sendRequest("echo", params, new Continuation<JsonElement>() {      @Override      public void onSuccess(JsonElement result) {        log.debug("Response:" + result);        Assert.assertEquals(params.get("param1").getAsString(), "Value1");        Assert.assertEquals(params.get("param2").getAsString(), "Value2");      }      @Override      public void onError(Throwable cause) {        cause.printStackTrace();      }    });    finishTestLatch.await(5, TimeUnit.SECONDS);    client.close();    log.debug("Client finished");  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class BasicEchoTest extends JsonRpcConnectorBaseTest {  private static final Logger log = LoggerFactory.getLogger(BasicEchoTest.class);  static class Params {    String param1;    String param2;  }  @Test  public void test() throws IOException {    log.debug("Client started");    JsonRpcClient client = createJsonRpcClient("/jsonrpc");    Params params = new Params();    params.param1 = "Value1";    params.param2 = "Value2";    Params result = client.sendRequest("echo", params, Params.class);    log.debug("Response:" + result);    Assert.assertEquals(params.param1, result.param1);    Assert.assertEquals(params.param2, result.param2);    client.close();    log.debug("Client finished");  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Session;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class BidirectionalMultiTest extends JsonRpcConnectorBaseTest {  public static class Handler extends DefaultJsonRpcHandler<Integer> {    private static Logger log = LoggerFactory.getLogger(Handler.class);    @Override    public void handleRequest(Transaction transaction, Request<Integer> request) throws Exception {      log.debug("Request id:" + request.getId());      log.debug("Request method:" + request.getMethod());      log.debug("Request params:" + request.getParams());      transaction.sendResponse(request.getParams());      final Session session = transaction.getSession();      final Object params = request.getParams();      new Thread() {        @Override        public void run() {          asyncReverseSend(session, params);        }      }.start();    }    public void asyncReverseSend(Session session, Object params) {      try {        Thread.sleep(1000);        try {          for (int i = 0; i < 5; i++) {            Object response = session.sendRequest("method", params);            session.sendRequest("method", response);          }        } catch (IOException e) {          e.printStackTrace();        }      } catch (InterruptedException e) {      }    }  }  private static final Logger log = LoggerFactory.getLogger(BidirectionalMultiTest.class);  @Test  public void test() throws IOException, InterruptedException {    log.debug("Client started");    JsonRpcClient client = createJsonRpcClient("/BidirectionalMultiTest");    client.setServerRequestHandler(new DefaultJsonRpcHandler<Integer>() {      @Override      public void handleRequest(Transaction transaction, Request<Integer> request)          throws Exception {        log.debug("Reverse request: " + request);        transaction.sendResponse(request.getParams() + 1);      }    });    for (int i = 0; i < 60; i++) {      client.sendRequest("echo", i, Integer.class);    }    client.close();    log.debug("Client finished");  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import java.util.concurrent.CountDownLatch;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Session;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class BidirectionalTest extends JsonRpcConnectorBaseTest {  public static class Handler extends DefaultJsonRpcHandler<Object> {    private static Logger log = LoggerFactory.getLogger(Handler.class);    @Override    public void handleRequest(Transaction transaction, Request<Object> request) throws Exception {      log.debug("Request id:" + request.getId());      log.debug("Request method:" + request.getMethod());      log.debug("Request params:" + request.getParams());      transaction.sendResponse(request.getParams());      final Session session = transaction.getSession();      final Object params = request.getParams();      new Thread() {        @Override        public void run() {          asyncReverseSend(session, params);        }      }.start();    }    public void asyncReverseSend(Session session, Object params) {      try {        Thread.sleep(1000);        try {          Object response = session.sendRequest("method", params);          session.sendRequest("method", response);        } catch (IOException e) {          e.printStackTrace();        }      } catch (InterruptedException e) {      }    }  }  private static final Logger log = LoggerFactory.getLogger(BidirectionalTest.class);  public static class Params {    String param1;    String param2;  }  @Test  public void test() throws IOException, InterruptedException {    log.debug("Client started");    JsonRpcClient client = createJsonRpcClient("/jsonrpcreverse");    final CountDownLatch inverseRequestLatch = new CountDownLatch(2);    final Params[] inverseRequestParams = new Params[1];    client.setServerRequestHandler(new DefaultJsonRpcHandler<Params>() {      @Override      public void handleRequest(Transaction transaction, Request<Params> request) throws Exception {        log.debug("Reverse request: " + request);        transaction.sendResponse(request.getParams());        inverseRequestParams[0] = request.getParams();        inverseRequestLatch.countDown();      }    });    Params params = new Params();    params.param1 = "Value1";    params.param2 = "Value2";    Params result = client.sendRequest("echo", params, Params.class);    log.debug("Response:" + result);    Assert.assertEquals(params.param1, result.param1);    Assert.assertEquals(params.param2, result.param2);    inverseRequestLatch.await();    Params newResult = inverseRequestParams[0];    Assert.assertEquals(params.param1, newResult.param1);    Assert.assertEquals(params.param2, newResult.param2);    client.close();    log.debug("Client finished");  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Session;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class ClientEventsTest extends JsonRpcConnectorBaseTest {  private static final Logger log = LoggerFactory.getLogger(ClientEventsTest.class);  private static final long TIMEOUT = 5000;  @Test  public void test() throws IOException, InterruptedException {    log.debug("Client started");    JsonRpcClient client = createJsonRpcClient("/jsonrpcreverse");    final CountDownLatch afterConnectionEstablishedLatch = new CountDownLatch(1);    final CountDownLatch afterConnectionClosedLatch = new CountDownLatch(1);    final CountDownLatch inverseRequestLatch = new CountDownLatch(2);    final String[] inverseRequestParams = new String[1];    client.setServerRequestHandler(new DefaultJsonRpcHandler<String>() {      @Override      public void afterConnectionEstablished(Session session) throws Exception {        log.debug("Connection established with sessionId: " + session.getSessionId());        afterConnectionEstablishedLatch.countDown();      }      @Override      public void handleRequest(Transaction transaction, Request<String> request) throws Exception {        log.debug("Reverse request: " + request);        transaction.sendResponse(request.getParams());        inverseRequestParams[0] = request.getParams();        inverseRequestLatch.countDown();      }      @Override      public void afterConnectionClosed(Session session, String status) throws Exception {        log.debug("Connection closed: " + status);        afterConnectionClosedLatch.countDown();      }    });    String result = client.sendRequest("echo", "params", String.class);    Assert.assertTrue("The method 'afterConnectionEstablished' is not invoked",        afterConnectionEstablishedLatch.await(TIMEOUT, TimeUnit.MILLISECONDS));    log.debug("Response:" + result);    Assert.assertEquals("params", result);    Assert.assertTrue("The method 'handleRequest' is not invoked",        inverseRequestLatch.await(TIMEOUT, TimeUnit.MILLISECONDS));    String newResult = inverseRequestParams[0];    Assert.assertEquals("params", newResult);    client.close();    Assert.assertTrue("The method 'afterConnectionClosed' is not invoked",        afterConnectionClosedLatch.await(TIMEOUT, TimeUnit.MILLISECONDS));    log.debug("Client finished");  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.client.JsonRpcClientWebSocket;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;public class CloseMessageTest extends JsonRpcConnectorBaseTest {  @Test  public void test() throws IOException, InterruptedException {    JsonRpcClientWebSocket client = (JsonRpcClientWebSocket) createJsonRpcClient("/reconnection");    client.setSendCloseMessage(true);    Assert.assertEquals("new", client.sendRequest("sessiontest", String.class));    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    String sessionId = client.getSession().getSessionId();    client.close();    JsonRpcClient client2 = createJsonRpcClient("/reconnection");    client2.connect();    client2.setSessionId(sessionId);    Assert.assertEquals("new", client2.sendRequest("sessiontest", String.class));    Assert.assertEquals("old", client2.sendRequest("sessiontest", String.class));  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Session;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;public class CloseSessionTest extends JsonRpcConnectorBaseTest {  public static class Handler extends DefaultJsonRpcHandler<String> {    int counter = 0;    @Override    public void handleRequest(final Transaction transaction, Request<String> request)        throws Exception {      Session session = transaction.getSession();      if (session.isNew()) {        transaction.sendResponse("new");      } else {        transaction.sendResponse("old");      }      if (counter == 2) {        session.close();      }      counter++;    }  }  @Test  public void test() throws IOException, InterruptedException {    JsonRpcClient client = createJsonRpcClient("/close_session_handler");    Assert.assertEquals("new", client.sendRequest("sessiontest", String.class));    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    client = createJsonRpcClient("/close_session_handler");    Assert.assertEquals("new", client.sendRequest("sessiontest", String.class));    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    client.close();  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.client.test;import static org.junit.Assert.fail;import java.io.IOException;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Test;import org.kurento.client.HttpPostEndpoint;import org.kurento.client.KurentoClient;import org.kurento.client.KurentoConnectionListener;import org.kurento.client.MediaPipeline;import org.kurento.client.PlayerEndpoint;import org.kurento.test.base.KurentoClientTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class ConnectionListenerTest extends KurentoClientTest {  private static Logger log = LoggerFactory.getLogger(ConnectionListenerTest.class);  @Test  public void disconnectionEventTest() throws InterruptedException, IOException {    final CountDownLatch disconnectedLatch = new CountDownLatch(1);    String kmsUrl = kms.getWsUri();    log.debug("Connecting to KMS in " + kmsUrl);    KurentoClient kurentoClient = KurentoClient.create(kmsUrl, new KurentoConnectionListener() {      @Override      public void disconnected() {        log.debug("disconnected from KMS");        disconnectedLatch.countDown();      }      @Override      public void connectionFailed() {      }      @Override      public void connected() {      }      @Override      public void reconnected(boolean sameServer) {      }    });    MediaPipeline pipeline = kurentoClient.createMediaPipeline();    PlayerEndpoint player =        new PlayerEndpoint.Builder(pipeline, "http://" + getTestFilesHttpPath()            + "/video/format/small.webm").build();    HttpPostEndpoint httpEndpoint = new HttpPostEndpoint.Builder(pipeline).build();    player.connect(httpEndpoint);    try {      kms.stopKms();    } catch (Exception e) {      fail("Exception thrown when destroying kms. " + e);    }    log.debug("Waiting for disconnection event");    if (!disconnectedLatch.await(60, TimeUnit.SECONDS)) {      fail("Event disconnected should be thrown when kcs is destroyed");    }    log.debug("Disconnection event received");  }  @Test  public void reconnectTest() throws InterruptedException, IOException {    String kmsUrl = kms.getWsUri();    log.debug("Connecting to KMS in " + kmsUrl);    KurentoClient kurentoClient = KurentoClient.create(kmsUrl);    kurentoClient.createMediaPipeline();    kms.stopKms();    Thread.sleep(3000);    kms.start();    kurentoClient.createMediaPipeline();    kms.stopKms();  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import static org.junit.Assert.fail;import java.io.IOException;import org.junit.Test;import org.kurento.jsonrpc.client.JsonRpcClientHttp;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;public class JsonRpcClientConnectTest extends JsonRpcConnectorBaseTest {  @Test  public void correctConnectTest() {    try {      try (JsonRpcClientHttp client =          new JsonRpcClientHttp("http://localhost:" + getPort() + "/jsonrpc")) {        client.connect();      }    } catch (IOException e) {      fail("IOException shouldn't be thrown");    }  }  @Test  public void incorrectConnectTest() {    try {      try (JsonRpcClientHttp client = new JsonRpcClientHttp("http://localhost:9999/jsonrpc")) {        client.connect();      }    } catch (IOException e) {      return;    }    fail("IOException should be thrown");  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;public class LargePackageTest extends JsonRpcConnectorBaseTest {  public static class Handler extends DefaultJsonRpcHandler<Integer> {    @Override    public void handleRequest(final Transaction transaction, Request<Integer> request)        throws Exception {      String largeString = newLargeString();      System.out.println(largeString.getBytes().length);      transaction.sendResponse(largeString);    }    private String newLargeString() {      StringBuilder sb = new StringBuilder();      for (int i = 0; i < 6600; i++) {        sb.append("aaaaaaaaaa");      }      return sb.toString();    }  }  @Test  public void test() throws IOException, InterruptedException {    JsonRpcClient client = createJsonRpcClient("/largepackage");    String largePackage = client.sendRequest("echo", String.class);    System.out.println(largePackage);    Thread.sleep(2000);    client.close();  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import static org.junit.Assert.fail;import java.net.URI;import java.util.ArrayList;import java.util.List;import org.eclipse.jetty.util.ssl.SslContextFactory;import org.eclipse.jetty.websocket.api.Session;import org.eclipse.jetty.websocket.api.annotations.OnWebSocketClose;import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;import org.eclipse.jetty.websocket.api.annotations.WebSocket;import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;import org.eclipse.jetty.websocket.client.WebSocketClient;import org.junit.Test;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class MaxWsConnectionsTest extends JsonRpcConnectorBaseTest {  private static final Logger log = LoggerFactory.getLogger(MaxWsConnectionsTest.class);  @WebSocket  public static class WebSocketClientSocket {    @OnWebSocketClose    public void onClose(int statusCode, String closeReason) {    }    @OnWebSocketConnect    public void onConnect(Session session) {    }    @OnWebSocketMessage    public void onMessage(String message) {    }  }  @Test  public void test() throws Exception {    List<Session> clients = new ArrayList<>();    while (true) {      URI wsUri = new URI("ws", null, "localhost", Integer.parseInt(getPort()), "/jsonrpc", null,          null);      WebSocketClient jettyClient = new WebSocketClient(new SslContextFactory(true));      jettyClient.start();      Session session = jettyClient          .connect(new WebSocketClientSocket(), wsUri, new ClientUpgradeRequest()).get();      clients.add(session);      log.debug("WebSocket client {} connected", clients.size());      Thread.sleep(100);      if (!session.isOpen()) {        if (clients.size() < MAX_WS_CONNECTIONS) {          fail("WebSocket num " + clients.size() + " disconnected. MAX_WS_CONNECTION="              + MAX_WS_CONNECTIONS);        } else {          log.debug("WebSocket client {} disconnected from server", clients.size());          break;        }      } else {        if (clients.size() > MAX_WS_CONNECTIONS) {          fail("Server should close automatically WebSocket connection above " + MAX_WS_CONNECTIONS              + " but it has " + clients.size() + " open connections");        }      }    }  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Ignore;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.DemoBean;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.springframework.beans.factory.annotation.Autowired;public class MultipleSessionsTest extends JsonRpcConnectorBaseTest {  public static class Handler extends DefaultJsonRpcHandler<String> {    @Autowired    DemoBean demoBean;    private int counter = 0;    @Override    public void handleRequest(Transaction transaction, Request<String> request) throws Exception {      if (demoBean == null) {        throw new RuntimeException("Not autowired dependencies");      }      transaction.sendResponse(counter);      counter++;    }  }  @Ignore  @Test  public void test() throws InterruptedException {    ExecutorService executorService = Executors.newFixedThreadPool(5);    List<Callable<Void>> callables = new ArrayList<>();    for (int i = 0; i < 5; i++) {      callables.add(new Callable<Void>() {        @Override        public Void call() throws Exception {          counterSession();          return null;        }      });    }    List<Future<Void>> futures = executorService.invokeAll(callables);    executorService.shutdown();    executorService.awaitTermination(99999, TimeUnit.DAYS);    for (Future<Void> future : futures) {      try {        future.get();      } catch (ExecutionException e) {        throw new RuntimeException(e);      }    }  }  @Test  public void beanNameTest() throws IOException {    createJsonRpcClient("/jsonrpc_multiple2").sendRequest("count");  }  private void counterSession() {    JsonRpcClient client = createJsonRpcClient("/jsonrpc_multiple");    try {      for (int i = 0; i < 5; i++) {        int counter = client.sendRequest("count", null, Integer.class);        Assert.assertEquals(i, counter);      }      client.close();    } catch (IOException e) {      throw new RuntimeException(e);    }  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;public class NewSessionTest extends JsonRpcConnectorBaseTest {  public static class Handler extends DefaultJsonRpcHandler<String> {    @Override    public void handleRequest(final Transaction transaction, Request<String> request)        throws Exception {      if (transaction.getSession().isNew()) {        transaction.sendResponse("new");      } else {        transaction.sendResponse("old");      }    }  }  @Test  public void test() throws IOException, InterruptedException {    JsonRpcClient client = createJsonRpcClient("/new_session_handler");    Assert.assertEquals("new", client.sendRequest("sessiontest", String.class));    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    client.close();  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;public class NotificationTest extends JsonRpcConnectorBaseTest {  private static CountDownLatch serverRequestLatch;  public static class Handler extends DefaultJsonRpcHandler<Integer> {    @Override    public void handleRequest(final Transaction transaction, Request<Integer> request)        throws Exception {      if (!transaction.isNotification()) {        throw new RuntimeException("Notification expected");      }      Thread.sleep(1000);      transaction.getSession().sendNotification("response", request.getParams());    }  }  @Test  public void test() throws IOException, InterruptedException {    serverRequestLatch = new CountDownLatch(3);    JsonRpcClient client = createJsonRpcClient("/notification");    client.setServerRequestHandler(new DefaultJsonRpcHandler<Integer>() {      @Override      public void handleRequest(Transaction transaction, Request<Integer> request)          throws Exception {        serverRequestLatch.countDown();      }    });    client.sendNotification("echo", 1);    client.sendNotification("echo", 2);    client.sendNotification("echo", 3);    Assert.assertTrue("The server has not invoked requests",        serverRequestLatch.await(5000, TimeUnit.MILLISECONDS));    client.close();  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.client.JsonRpcWSConnectionAdapter;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class PingPongTest extends JsonRpcConnectorBaseTest {  private static final Logger log = LoggerFactory.getLogger(PingPongTest.class);  public static class Handler extends DefaultJsonRpcHandler<String> {    @Override    public void handleRequest(final Transaction transaction, Request<String> request)        throws Exception {      transaction.sendResponse("OK");    }    @Override    public boolean isPingWatchdog() {      return true;    }  }  @Test  public void test() throws IOException, InterruptedException {    log.debug("Client started");    JsonRpcClient client = createJsonRpcClient("/pingpong", new JsonRpcWSConnectionAdapter() {      @Override      public void connectionFailed() {        System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");      }      @Override      public void disconnected() {        System.out.println("#######################################");      }    });    client.setHeartbeatInterval(500);    client.enableHeartbeat();    String result = client.sendRequest("echo", "Params", String.class);    log.debug("Response:" + result);    Assert.assertEquals(result, "OK");    Thread.sleep(20000);    log.debug("----------------- Disabling heartbeat in client ----------------");    client.disableHeartbeat();    // This should lead to reconnect clients    Thread.sleep(30000);    log.debug("----------------- Enabling heartbeat in client ----------------");    client.enableHeartbeat();    Thread.sleep(30000);    log.debug("Client finished");  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.Semaphore;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Session;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.client.JsonRpcClientWebSocket;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.google.gson.JsonElement;public class ReconnectionFromServerTest extends JsonRpcConnectorBaseTest {  private static final Logger log = LoggerFactory.getLogger(ReconnectionFromServerTest.class);  private static final long TIMEOUT = 2;  private static Semaphore s = new Semaphore(0);  public static class Handler extends DefaultJsonRpcHandler<String> {    private Session session;    private ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);    @Override    public void handleRequest(final Transaction transaction, Request<String> request)        throws Exception {      log.debug("Receive request in server: " + request);      if (session == null) {        session = transaction.getSession();      }      if (session.isNew()) {        transaction.sendResponse("new");      } else {        transaction.sendResponse("old");      }      log.debug("Response sent from server");      executor.schedule(new Runnable() {        @Override        public void run() {          try {            log.debug("Request send from server");            JsonElement result = session.sendRequest("hello");            log.debug("Response received in server");            log.debug("Result: " + result);            s.release();          } catch (IOException e) {            e.printStackTrace();          }        }      }, 500, TimeUnit.MILLISECONDS);    }    @Override    public void afterConnectionEstablished(Session session) throws Exception {      session.setReconnectionTimeout(5000);    }  }  @Test  public void test() throws IOException, InterruptedException {    JsonRpcClient client = new JsonRpcClientWebSocket(        "ws://localhost:" + getPort() + "/reconnection2");    client.setServerRequestHandler(new DefaultJsonRpcHandler<JsonElement>() {      @Override      public void handleRequest(Transaction transaction, Request<JsonElement> request)          throws Exception {        log.debug("Receive request in client: " + request);        transaction.sendResponse("world");        log.debug("Response sent from client");      }    });    Assert.assertEquals("new", client.sendRequest("sessiontest", String.class));    waitForServer();    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    waitForServer();    log.debug("SessionId: " + client.getSession().getSessionId());    JsonRpcClientWebSocket webSocketClient = (JsonRpcClientWebSocket) client;    webSocketClient.closeNativeClient();    Thread.sleep(100);    Assert.assertEquals("old", client.sendRequest("sessiontest", String.class));    waitForServer();    log.debug("Acquired");    client.close();  }  private void waitForServer() throws InterruptedException {    if (!s.tryAcquire(TIMEOUT, TimeUnit.SECONDS)) {      throw new RuntimeException("Timeout waiting for request from server");    }  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import static org.assertj.core.api.Assertions.assertThat;import java.io.IOException;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Session;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.Handler;import org.kurento.jsonrpc.client.JsonRpcClientWebSocket;import org.kurento.jsonrpc.client.JsonRpcWSConnectionAdapter;import org.kurento.jsonrpc.client.ReconnectedHandler;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.kurento.jsonrpc.test.util.EventWaiter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class ReconnectionTest extends JsonRpcConnectorBaseTest {  private static final Logger log = LoggerFactory.getLogger(ReconnectionTest.class);  public static class ServerHandler extends DefaultJsonRpcHandler<String> {    @Override    public void handleRequest(final Transaction transaction, Request<String> request)        throws Exception {      Session session = transaction.getSession();      if (session.isNew()) {        transaction.sendResponse("new");      } else {        transaction.sendResponse("old");      }    }    @Override    public void afterConnectionEstablished(Session session) throws Exception {      session.setReconnectionTimeout(5000);    }  }  @Test  public void givenReconnectedSession_whenSessionIdIsRemovedFromClient_thenServerUsesWebSocketAsSessionIdSource()      throws IOException, InterruptedException {    try (JsonRpcClientWebSocket client = new JsonRpcClientWebSocket(        "ws://localhost:" + getPort() + "/reconnection")) {      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("new");      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");      String sessionId = client.getSession().getSessionId();      client.closeNativeClient();      // Wait for reconnection      Thread.sleep(100);      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");      client.setSessionId(null);      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");      assertThat(client.getSession().getSessionId()).isEqualTo(sessionId);    }  }  @Test  public void givenClient_whenNativeSocketIsClosed_thenSessionIsAutomaticallyReconnected()      throws IOException, InterruptedException {    final EventWaiter reconnecting = new EventWaiter("reconnecting");    final EventWaiter reconnected = new EventWaiter("reconnected");    final EventWaiter reconnectingHandler = new EventWaiter("reconnectingHandler");    final EventWaiter reconnectedHandler = new EventWaiter("reconnectedHandler");    JsonRpcWSConnectionAdapter listener = new JsonRpcWSConnectionAdapter() {      @Override      public void reconnecting() {        reconnecting.eventReceived();      }      @Override      public void reconnected(boolean sameServer) {        reconnected.eventReceived();      }    };    try (JsonRpcClientWebSocket client = new JsonRpcClientWebSocket(        "ws://localhost:" + getPort() + "/reconnection", listener)) {      client.onReconnecting(new Handler() {        @Override        public void run() {          reconnectingHandler.eventReceived();        }      });      client.onReconnected(new ReconnectedHandler() {        @Override        public void run(boolean sameServer) {          reconnectedHandler.eventReceived();        }      });      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("new");      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");      client.closeNativeClient();      // Wait for reconnection      Thread.sleep(100);      reconnecting.waitFor(3000);      reconnectingHandler.waitFor(3000);      reconnected.waitFor(3000);      reconnectedHandler.waitFor(3000);      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");      assertThat(client.sendRequest("sessiontest", String.class)).isEqualTo("old");    }  }  @Test  public void givenJsonRpcClientAndServer_whenServerIsDown_thenClientKeepsReconnectingUntilServerIsUpAgain()      throws Exception {    final EventWaiter reconnecting = new EventWaiter("reconnecting");    final EventWaiter reconnected = new EventWaiter("reconnected");    JsonRpcWSConnectionAdapter listener = new JsonRpcWSConnectionAdapter() {      @Override      public void reconnecting() {        reconnecting.eventReceived();      }      @Override      public void reconnected(boolean sameServer) {        reconnected.eventReceived();      }    };    try (JsonRpcClientWebSocket client = new JsonRpcClientWebSocket(        "ws://localhost:" + getPort() + "/reconnection", listener)) {      client.setTryReconnectingForever(true);      client.enableHeartbeat(2000);      Thread.sleep(1000);      client.connect();      log.debug("--------> Client connected to server");      server.close();      log.debug("--------> Server closed");      reconnecting.waitFor(3000);      log.debug("--------> Event reconnecting received in client");      assertThat(reconnected.isEventRecived()).isFalse();      // Wait some time to verify client is reconnecting      Thread.sleep(20000);      assertThat(reconnected.isEventRecived()).isFalse();      log.debug("--------> Starting new server after 20s");      startServer();      log.debug("--------> New server started");      log.debug("--------> Waiting 10s to client reconnection");      reconnected.waitFor(10000);      log.debug("--------> Client reconnected event received");    }  }  @Test  public void givenJsonRpcClientAndServer_whenServerIsDown_thenClientKeepsReconnectingUntilMaxTime()      throws Exception {    final EventWaiter reconnecting = new EventWaiter("reconnecting");    final EventWaiter disconnected = new EventWaiter("disconnected");    JsonRpcWSConnectionAdapter listener = new JsonRpcWSConnectionAdapter() {      @Override      public void reconnecting() {        reconnecting.eventReceived();      }      @Override      public void disconnected() {        disconnected.eventReceived();      }    };    try (JsonRpcClientWebSocket client = new JsonRpcClientWebSocket(        "ws://localhost:" + getPort() + "/reconnection", listener)) {      client.setTryReconnectingMaxTime(7000);      client.enableHeartbeat(2000);      Thread.sleep(1000);      client.connect();      log.debug("--------> Client connected to server");      server.close();      log.debug("--------> Server closed");      reconnecting.waitFor(3000);      log.debug("--------> Event reconnecting received in client");      assertThat(disconnected.isEventRecived()).isFalse();      Thread.sleep(7000);      disconnected.waitFor(20000);    } finally {      startServer();    }  }  @Test  public void givenClientWithHeartbeat_whenWaitMoreThanIdleTimeout_thenClientIsNotDisconnected()      throws IOException, InterruptedException {    final EventWaiter reconnecting = new EventWaiter("reconnecting");    final EventWaiter reconnected = new EventWaiter("reconnected");    JsonRpcWSConnectionAdapter listener = new JsonRpcWSConnectionAdapter() {      @Override      public void reconnecting() {        reconnecting.eventReceived();      }      @Override      public void reconnected(boolean sameServer) {        reconnected.eventReceived();      }    };    try (JsonRpcClientWebSocket client = new JsonRpcClientWebSocket(        "ws://localhost:" + getPort() + "/reconnection", listener)) {      client.setIdleTimeout(5000);      client.enableHeartbeat(4000);      for (int i = 0; i < 5; i++) {        client.sendRequest("sessiontest", String.class);        Thread.sleep(10000);      }    }    assertThat(reconnecting.isEventRecived()).as("Event reconnecting received").isEqualTo(false);    assertThat(reconnecting.isEventRecived()).as("Event reconnected received").isEqualTo(false);  }  @Test  public void givenReconnectingClient_whenClientIsClosed_thenClientIsNotReconnectedWhenServerIsUpAgain()      throws Exception {    final EventWaiter reconnecting = new EventWaiter("reconnecting");    final EventWaiter reconnected = new EventWaiter("reconnected");    final EventWaiter disconnected = new EventWaiter("disconnected");    JsonRpcWSConnectionAdapter listener = new JsonRpcWSConnectionAdapter() {      @Override      public void reconnecting() {        reconnecting.eventReceived();      }      @Override      public void reconnected(boolean sameServer) {        reconnected.eventReceived();      }      @Override      public void disconnected() {        disconnected.eventReceived();      }    };    try (JsonRpcClientWebSocket client = new JsonRpcClientWebSocket(        "ws://localhost:" + getPort() + "/reconnection", listener)) {      client.setTryReconnectingForever(true);      client.enableHeartbeat(2000);      Thread.sleep(1000);      client.connect();      log.debug("--------> Client connected to server");      server.close();      log.debug("--------> Server closed");      reconnecting.waitFor(3000);      log.debug("--------> Event reconnecting received in client");      assertThat(reconnected.isEventRecived()).isFalse();      // Wait some time to verify client is reconnecting      Thread.sleep(20000);      assertThat(reconnected.isEventRecived()).isFalse();      log.debug("--------> Starting new server after 20s");      client.close();      disconnected.waitFor(20000);      log.debug("--------> Client is disconnected");      startServer();      log.debug("--------> New server started");      Thread.sleep(10000);      assertThat(reconnected.isEventRecived()).isFalse();      log.debug("--------> Client is not reconnected after 10s after closing it");    }  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.jsonrpc.test;import java.io.IOException;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.kurento.jsonrpc.DefaultJsonRpcHandler;import org.kurento.jsonrpc.Session;import org.kurento.jsonrpc.Transaction;import org.kurento.jsonrpc.client.JsonRpcClient;import org.kurento.jsonrpc.message.Request;import org.kurento.jsonrpc.test.base.JsonRpcConnectorBaseTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class ServerEventsTest extends JsonRpcConnectorBaseTest {  private static CountDownLatch afterConnectionEstablishedLatch = new CountDownLatch(1);  private static CountDownLatch afterConnectionClosedLatch = new CountDownLatch(1);  private static CountDownLatch requestLatch = new CountDownLatch(1);  public static class Handler extends DefaultJsonRpcHandler<String> {    private static Logger log = LoggerFactory.getLogger(Handler.class);    @Override    public void afterConnectionEstablished(Session session) throws Exception {      session.setReconnectionTimeout(500);      log.debug("Connection established with sessionId: " + session.getSessionId());      afterConnectionEstablishedLatch.countDown();    }    @Override    public void handleRequest(Transaction transaction, Request<String> request) throws Exception {      log.debug("Request: " + request);      transaction.sendResponse(request.getParams());      requestLatch.countDown();    }    @Override    public void afterConnectionClosed(Session session, String status) throws Exception {      log.debug("Connection closed: " + status);      afterConnectionClosedLatch.countDown();    }  }  private static final Logger log = LoggerFactory.getLogger(ServerEventsTest.class);  private static final long TIMEOUT = 5000;  @Test  public void test() throws IOException, InterruptedException {    log.debug("Client started");    JsonRpcClient client = createJsonRpcClient("/serverevents");    String result = client.sendRequest("echo", "params", String.class);    Assert.assertTrue("The method 'afterConnectionEstablished' is not invoked",        afterConnectionEstablishedLatch.await(TIMEOUT, TimeUnit.MILLISECONDS));    log.debug("Response:" + result);    Assert.assertEquals("params", result);    Assert.assertTrue("The method 'handleRequest' is not invoked",        requestLatch.await(TIMEOUT, TimeUnit.MILLISECONDS));    client.close();    Assert.assertTrue("The method 'afterConnectionClosed' is not invoked",        afterConnectionClosedLatch.await(TIMEOUT, TimeUnit.MILLISECONDS));    log.debug("Client finished");  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.repository.test;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Test;import org.kurento.repository.HttpSessionErrorEvent;import org.kurento.repository.HttpSessionStartedEvent;import org.kurento.repository.RepositoryHttpEventListener;import org.kurento.repository.RepositoryHttpRecorder;import org.kurento.repository.RepositoryItem;import org.kurento.repository.test.util.BaseRepositoryTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class ErrorEventsTest extends BaseRepositoryTest {  private static final Logger log = LoggerFactory.getLogger(ErrorEventsTest.class);  @Test  public void testFileUploadAndDownload() throws Exception {    RepositoryItem item = getRepository().createRepositoryItem();    final RepositoryHttpRecorder recorder = item.createRepositoryHttpRecorder();    final CountDownLatch started = new CountDownLatch(1);    recorder.addSessionStartedListener(new RepositoryHttpEventListener<HttpSessionStartedEvent>() {      @Override      public void onEvent(HttpSessionStartedEvent event) {        started.countDown();      }    });    final CountDownLatch errorLatch = new CountDownLatch(1);    recorder.addSessionErrorListener(new RepositoryHttpEventListener<HttpSessionErrorEvent>() {      @Override      public void onEvent(HttpSessionErrorEvent event) {        log.debug("Error event sent");        log.debug("Exception:" + event.getCause());        errorLatch.countDown();      }    });    log.debug(        "Start writing to URL " + recorder.getURL() + " the item with id '" + item.getId() + "'");    new Thread() {      @Override      public void run() {        try {          uploadFileWithPOST(recorder.getURL(), new File("test-files/logo.png"));        } catch (Exception e) {          e.printStackTrace();        }      }    }.start();    started.await();    // Sleep to give time to open the outputStream to write the uploading    // file.    Thread.sleep(2000);    getRepository().remove(item);    assertTrue("Error event was not fired in the next 5 seconds before deletion of the file",        errorLatch.await(5, TimeUnit.SECONDS));  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.repository.test;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertNotNull;import java.io.File;import java.io.IOException;import java.util.List;import org.junit.Test;import org.kurento.repository.Repository;import org.kurento.repository.internal.repoimpl.mongo.MongoRepository;import org.kurento.repository.test.util.BaseRepositoryTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import com.mongodb.DBObject;import com.mongodb.gridfs.GridFS;import com.mongodb.gridfs.GridFSDBFile;import com.mongodb.gridfs.GridFSInputFile;import com.mongodb.util.JSON;public class FilenameAsIdTest extends BaseRepositoryTest {  private static final Logger log = LoggerFactory.getLogger(FilenameAsIdTest.class);  @Test  public void test() throws IOException {    Repository repository = getRepository();    if (repository instanceof MongoRepository) {      MongoRepository mongoRepository = (MongoRepository) repository;      GridFS gridFS = mongoRepository.getGridFS();      GridFSInputFile file = gridFS.createFile(new File("test-files/sample.txt"));      file.setId("sample.txt");      file.save();      List<GridFSDBFile> files = gridFS.find((DBObject) JSON.parse("{ _id : 'sample.txt' }"));      assertNotNull(files);      assertEquals(1, files.size());    } else {      log.debug("Repository is not MongoDB");    }  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.repository.test;import static org.junit.Assert.assertEquals;import static org.junit.Assert.fail;import java.io.IOException;import java.io.OutputStream;import java.util.List;import java.util.NoSuchElementException;import org.junit.Test;import org.kurento.repository.DuplicateItemException;import org.kurento.repository.Repository;import org.kurento.repository.RepositoryItem;import org.kurento.repository.test.util.BaseRepositoryTest;public class ItemManagmentTest extends BaseRepositoryTest {  @Test(expected = DuplicateItemException.class)  public void duplicateTest() throws IOException {    Repository repository = getRepository();    RepositoryItem item = repository.createRepositoryItem("file1");    item.createOutputStreamToWrite().close();    RepositoryItem item2 = repository.createRepositoryItem("file1");    item2.createOutputStreamToWrite().close();  }  @Test  public void metadataTest() throws IOException {    Repository repository = getRepository();    for (int i = 0; i < 10; i++) {      try {        RepositoryItem item = repository.findRepositoryItemById("File" + i + ".txt");        repository.remove(item);      } catch (NoSuchElementException e) {        // Do nothing if repository item doesn't exist      }    }    for (int i = 0; i < 10; i++) {      RepositoryItem item = repository.createRepositoryItem("File" + i + ".txt");      item.putMetadataEntry("numFile", Integer.toString(i));      item.putMetadataEntry("att", "value");      item.putMetadataEntry("regexAtt", "token" + Integer.toString(i));      OutputStream os = item.createOutputStreamToWrite();      os.write(0);      os.close();    }    for (int i = 0; i < 10; i++) {      try {        RepositoryItem item = repository.findRepositoryItemById("File" + i + ".txt");        String numString = item.getMetadata().get("numFile");        assertEquals(numString, Integer.toString(i));        assertEquals(item.getMetadata().get("att"), "value");      } catch (NoSuchElementException e) {        fail("Element 'File" + i + ".txt' doesn't exist");      }    }    List<RepositoryItem> items = repository.findRepositoryItemsByAttValue("att", "value");    assertEquals("Found different items than expected", 10, items.size());    items = repository.findRepositoryItemsByAttRegex("regexAtt", "token.*");    assertEquals("Found different items than expected", 10, items.size());  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.repository.test;import static org.junit.Assert.assertEquals;import java.io.File;import java.io.IOException;import java.util.Map;import org.junit.Test;import org.junit.experimental.categories.Category;import org.kurento.commons.testing.RepositoryApiTests;import org.kurento.repository.internal.repoimpl.filesystem.ItemsMetadata;@Category(RepositoryApiTests.class)public class ItemsMetadataTest {  @Test  public void test() throws IOException {    File tempFile = File.createTempFile("metadata", "");    ItemsMetadata itemsMetadata = new ItemsMetadata(tempFile);    for (int i = 0; i < 10; i++) {      Map<String, String> md1 = itemsMetadata.loadMetadata("o" + i);      md1.put("differentAtt", "value" + i);      md1.put("sameAtt", "value");    }    itemsMetadata.save();    itemsMetadata = new ItemsMetadata(tempFile);    assertEquals(10, itemsMetadata.findByAttValue("sameAtt", "value").size());    assertEquals(1, itemsMetadata.findByAttValue("differentAtt", "value1").size());    assertEquals(10, itemsMetadata.findByAttRegex("differentAtt", "value.*").size());  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.repository.test;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import org.apache.commons.io.IOUtils;import org.junit.After;import org.junit.Before;import org.junit.Test;import org.junit.experimental.categories.Category;import org.kurento.commons.testing.RepositoryApiTests;import org.kurento.repository.OneRecordingServer;import org.kurento.repository.test.util.TestUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.client.RestTemplate;@Category(RepositoryApiTests.class)public class OneRecordingServerTest {  private static final Logger log = LoggerFactory.getLogger(OneRecordingServerTest.class);  @Before  public void setUp() {    OneRecordingServer.startServerAndWait();  }  @After  public void tearDown() {    OneRecordingServer.stop();  }  @Test  public void test() throws Exception {    String publicWebappURL = OneRecordingServer.getPublicWebappUrl();    log.debug("Start uploading content");    File fileToUpload = new File("test-files/logo.png");    uploadFileWithCURL(publicWebappURL + "repository_servlet/video-upload", fileToUpload);    log.debug("Waiting 10 seconds to auto-termination...");    Thread.sleep(10 * 1000);    File downloadedFile = new File("test-files/sampleDownload.txt");    log.debug("Start downloading file");    downloadFromURL(publicWebappURL + "repository_servlet/video-download", downloadedFile);    boolean equalFiles = TestUtils.equalFiles(fileToUpload, downloadedFile);    if (equalFiles) {      log.debug("The uploadad and downloaded files are equal");    } else {      log.debug("The uploadad and downloaded files are different");    }    assertTrue("The uploadad and downloaded files are different", equalFiles);  }  protected void downloadFromURL(String urlToDownload, File downloadedFile) throws Exception {    if (!downloadedFile.exists()) {      downloadedFile.createNewFile();    }    log.debug(urlToDownload);    RestTemplate client = new RestTemplate();    ResponseEntity<byte[]> response = client.getForEntity(urlToDownload, byte[].class);    assertEquals(HttpStatus.OK, response.getStatusCode());    FileOutputStream os = new FileOutputStream(downloadedFile);    os.write(response.getBody());    os.close();  }  protected void uploadFileWithCURL(String uploadURL, File fileToUpload)      throws FileNotFoundException, IOException {    log.debug("Start uploading file with curl");    long startTime = System.currentTimeMillis();    ProcessBuilder builder = new ProcessBuilder("curl", "-i", "-F",        "filedata=@" + fileToUpload.getAbsolutePath(), uploadURL);    builder.redirectOutput();    Process process = builder.start();    try {      process.waitFor();    } catch (InterruptedException e) {      e.printStackTrace();    }    long duration = System.currentTimeMillis() - startTime;    log.debug("Finished uploading content in " + (double) duration / 1000 + " seconds.");  }  protected void uploadFileWithPOST(String uploadURL, File fileToUpload)      throws FileNotFoundException, IOException {    RestTemplate template = new RestTemplate();    ByteArrayOutputStream fileBytes = new ByteArrayOutputStream();    IOUtils.copy(new FileInputStream(fileToUpload), fileBytes);    ResponseEntity<String> entity =        template.postForEntity(uploadURL, fileBytes.toByteArray(), String.class);    assertEquals("Returned response: " + entity.getBody(), HttpStatus.OK, entity.getStatusCode());  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.repository.test;import static org.junit.Assert.assertTrue;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.net.URISyntaxException;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Test;import org.kurento.repository.HttpSessionStartedEvent;import org.kurento.repository.HttpSessionTerminatedEvent;import org.kurento.repository.RepositoryHttpEventListener;import org.kurento.repository.RepositoryHttpPlayer;import org.kurento.repository.RepositoryHttpRecorder;import org.kurento.repository.RepositoryItem;import org.kurento.repository.test.util.BaseRepositoryTest;import org.kurento.repository.test.util.TestUtils;public class PlayerEventsTest extends BaseRepositoryTest {  @Test  public void testFileUploadAndDownload() throws Exception {    RepositoryItem repositoryItem = getRepository().createRepositoryItem();    String id = repositoryItem.getId();    File fileToUpload = new File("test-files/sample.txt");    uploadWithEvents(repositoryItem, fileToUpload);    File downloadedFile = downloadWithEvents(id);    assertTrue("The uploaded file and the result of download it again are different",        TestUtils.equalFiles(fileToUpload, downloadedFile));  }  private void uploadWithEvents(RepositoryItem repositoryItem, File fileToUpload)      throws URISyntaxException, FileNotFoundException, IOException, InterruptedException {    RepositoryHttpRecorder recorder = repositoryItem.createRepositoryHttpRecorder();    final CountDownLatch started = new CountDownLatch(1);    recorder.addSessionStartedListener(new RepositoryHttpEventListener<HttpSessionStartedEvent>() {      @Override      public void onEvent(HttpSessionStartedEvent event) {        started.countDown();      }    });    final CountDownLatch terminated = new CountDownLatch(1);    recorder.addSessionTerminatedListener(        new RepositoryHttpEventListener<HttpSessionTerminatedEvent>() {          @Override          public void onEvent(HttpSessionTerminatedEvent event) {            terminated.countDown();          }        });    uploadFileWithPOST(recorder.getURL(), fileToUpload);    // TODO We need to be sure that this events appear in the order    // specified. This test doesn't control this    assertTrue("Started event didn't sent in 10 seconds", started.await(10, TimeUnit.SECONDS));    assertTrue("Terminated event didn't sent in 10 seconds",        terminated.await(10, TimeUnit.SECONDS));  }  private File downloadWithEvents(String id) throws Exception, InterruptedException {    RepositoryItem newRepositoryItem = getRepository().findRepositoryItemById(id);    RepositoryHttpPlayer player = newRepositoryItem.createRepositoryHttpPlayer();    final CountDownLatch started = new CountDownLatch(1);    player.addSessionStartedListener(new RepositoryHttpEventListener<HttpSessionStartedEvent>() {      @Override      public void onEvent(HttpSessionStartedEvent event) {        started.countDown();      }    });    final CountDownLatch terminated = new CountDownLatch(1);    player.addSessionTerminatedListener(        new RepositoryHttpEventListener<HttpSessionTerminatedEvent>() {          @Override          public void onEvent(HttpSessionTerminatedEvent event) {            terminated.countDown();          }        });    File downloadedFile = new File("test-files/tmp/" + id);    downloadFromURL(player.getURL(), downloadedFile);    // TODO We need to be sure that this events appear in the order    // specified. This test doesn't control this    assertTrue("Started event didn't sent in 10 seconds", started.await(10, TimeUnit.SECONDS));    assertTrue("Terminated event didn't sent in 10 seconds",        terminated.await(10, TimeUnit.SECONDS));    return downloadedFile;  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.repository.test;import static org.junit.Assert.assertEquals;import static org.junit.Assert.assertTrue;import java.io.File;import java.util.NoSuchElementException;import org.junit.Test;import org.kurento.repository.RepositoryHttpPlayer;import org.kurento.repository.RepositoryItem;import org.kurento.repository.test.util.BaseRepositoryTest;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpMethod;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.util.LinkedMultiValueMap;import org.springframework.util.MultiValueMap;import org.springframework.web.client.RestTemplate;public class RangeGetTest extends BaseRepositoryTest {  private static final Logger log = LoggerFactory.getLogger(RangeGetTest.class);  @Test  public void test() throws Exception {    String id = "logo.png";    RepositoryItem item;    try {      item = getRepository().findRepositoryItemById(id);    } catch (NoSuchElementException e) {      item = getRepository().createRepositoryItem(id);      uploadFile(new File("test-files/" + id), item);    }    RepositoryHttpPlayer player = item.createRepositoryHttpPlayer();    String url = player.getURL();    player.setAutoTerminationTimeout(10000);    // Following sample    // http://stackoverflow.com/questions/8293687/sample-http-range-request-session    RestTemplate httpClient = getRestTemplate();    acceptRanges(url, httpClient);    log.debug("Accept ranges test passed");    long fileLength = rangeFrom0(url, httpClient);    log.debug("Range from 0 test passed");    randomRange(url, httpClient, fileLength);    log.debug("Random range test passed");  }  private void randomRange(String url, RestTemplate httpClient, long fileLength) {    HttpHeaders requestHeaders = new HttpHeaders();    long firstByte = fileLength - 3000;    long lastByte = fileLength - 1;    long numBytes = lastByte - firstByte + 1;    requestHeaders.set("Range", "bytes=" + firstByte + "-" + lastByte);    MultiValueMap<String, String> postParameters = new LinkedMultiValueMap<String, String>();    HttpEntity<MultiValueMap<String, String>> requestEntity =        new HttpEntity<MultiValueMap<String, String>>(postParameters, requestHeaders);    ResponseEntity<byte[]> response =        httpClient.exchange(url, HttpMethod.GET, requestEntity, byte[].class);    log.debug("Response: " + response);    assertEquals("The server doesn't respond with http status code 206 to a request with ranges",        response.getStatusCode(), HttpStatus.PARTIAL_CONTENT);    long responseContentLength = Long.parseLong(response.getHeaders().get("Content-Length").get(0));    assertEquals("The server doesn't send the requested bytes", numBytes, responseContentLength);    assertEquals("The server doesn't send the requested bytes", responseContentLength,        response.getBody().length);  }  private long rangeFrom0(String url, RestTemplate httpClient) {    // Range: bytes=0-    HttpHeaders requestHeaders = new HttpHeaders();    requestHeaders.set("Range", "bytes=0-");    MultiValueMap<String, String> postParameters = new LinkedMultiValueMap<String, String>();    HttpEntity<MultiValueMap<String, String>> requestEntity =        new HttpEntity<MultiValueMap<String, String>>(postParameters, requestHeaders);    ResponseEntity<byte[]> response =        httpClient.exchange(url, HttpMethod.GET, requestEntity, byte[].class);    log.debug("Response: " + response);    assertEquals("The server doesn't respond with http status code 206 to a request with ranges",        HttpStatus.PARTIAL_CONTENT, response.getStatusCode());    return Long.parseLong(response.getHeaders().get("Content-Length").get(0));  }  private void acceptRanges(String url, RestTemplate httpClient) {    HttpHeaders requestHeaders = new HttpHeaders();    MultiValueMap<String, String> postParameters = new LinkedMultiValueMap<String, String>();    HttpEntity<MultiValueMap<String, String>> requestEntity =        new HttpEntity<MultiValueMap<String, String>>(postParameters, requestHeaders);    ResponseEntity<byte[]> response =        httpClient.exchange(url, HttpMethod.GET, requestEntity, byte[].class);    log.debug("Response: " + response);    assertTrue("The server doesn't accept ranges",        response.getHeaders().containsKey("Accept-ranges"));    assertTrue("The server doesn't accept ranges with bytes",        response.getHeaders().get("Accept-ranges").contains("bytes"));  }}
/* * (C) Copyright 2013 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.repository.test;import static org.junit.Assert.assertTrue;import java.io.File;import org.junit.Test;import org.kurento.repository.RepositoryHttpRecorder;import org.kurento.repository.RepositoryItem;import org.kurento.repository.test.util.BaseRepositoryTest;import org.kurento.repository.test.util.TestUtils;public class RepositoryItemsTest extends BaseRepositoryTest {  @Test  public void testFileUpload() throws Exception {    uploadFile(new File("test-files/sample.txt"));  }  @Test  public void testFileUploadWithPOSTAndDownload() throws Exception {    RepositoryItem repositoryItem = getRepository().createRepositoryItem();    String id = repositoryItem.getId();    File fileToUpload = new File("test-files/sample.txt");    RepositoryHttpRecorder recorder = repositoryItem.createRepositoryHttpRecorder();    uploadFileWithPOST(recorder.getURL(), fileToUpload);    recorder.stop();    RepositoryItem newRepositoryItem = getRepository().findRepositoryItemById(id);    File downloadedFile = new File("test-files/tmp/" + id);    downloadFromURL(newRepositoryItem.createRepositoryHttpPlayer().getURL(), downloadedFile);    assertTrue(TestUtils.equalFiles(fileToUpload, downloadedFile));  }}
/* * (C) Copyright 2015 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.agnostic;import static org.kurento.test.config.Protocol.FILE;import java.awt.Color;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Continuation;import org.kurento.client.CryptoSuite;import org.kurento.client.EventListener;import org.kurento.client.MediaFlowInStateChangeEvent;import org.kurento.client.MediaPipeline;import org.kurento.client.RtpEndpoint;import org.kurento.client.SDES;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;import org.kurento.test.utils.Shell;/** * Test agnostic. * </p> * Media Pipeline(s): * <ul> * <li>RtpEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) Create a RtpEndpoint and connect to WebRtcEndpoint</li> * <li>Use a specific sdp for RtpEndpoint</li> * <li>Get the port that processOffer returns * <li>Run a ffmpeg command for starting the media * <li>(Browser) WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Color of the video should remain when a filter is created and connected again</li> * </ul> * Secondary assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * </ul> * * @author Raul Benitez (raulbenitezmejias@gmail.com) * @since 6.5.1 */public class AgnosticRtpEndpointToWebRtcWithFfmpegTest extends FunctionalTest {  private String port = "";  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromeAndFirefox();  }  @Test  public void agnosticRtpEndpointToWebRtcWithFfmpeg() throws Exception {    final CountDownLatch proccessOfferLatch = new CountDownLatch(1);    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    SDES sdes = new SDES();    sdes.setCrypto(CryptoSuite.AES_128_CM_HMAC_SHA1_80);    RtpEndpoint rtpEp = new RtpEndpoint.Builder(mp).withCrypto(sdes).build();    WebRtcEndpoint webRtcEp = new WebRtcEndpoint.Builder(mp).build();    final CountDownLatch flowingInLatch = new CountDownLatch(1);    webRtcEp.addMediaFlowInStateChangeListener(new EventListener<MediaFlowInStateChangeEvent>() {      @Override      public void onEvent(MediaFlowInStateChangeEvent event) {        flowingInLatch.countDown();      }    });    rtpEp.connect(webRtcEp);    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEp, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    String sdp = "v=0\r\n" + "o=- 0 0 IN IP4 0.0.0.0\r\n" + "s=-\r\n" + "t=0 0\r\n"        + "m=video 1 RTP/SAVP 96\r\n" + "c=IN IP4 0.0.0.0\r\n" + "a=rtpmap:96 H264/90000\r\n"        + "a=fmtp:96 packetization-mode=1\r\n"        + "a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:ZDJ4Ump3N0xtRTg0V0k4OWJNaXpKRFl3ejZ0QVJW";    rtpEp.processOffer(sdp, new Continuation<String>() {      @Override      public void onSuccess(String result) throws Exception {        String[] parse = result.split("m=video");        String port_ = parse[1].split(" ")[1];        port = port_;        proccessOfferLatch.countDown();      }      @Override      public void onError(Throwable cause) throws Exception {        log.debug("Error:{}", cause.getMessage());      }    });    proccessOfferLatch.await(getPage().getTimeout(), TimeUnit.SECONDS);    String[] kmsUriParse = kms.getWsUri().split("//");    String kmsIp = kmsUriParse[1].split(":")[0];    String mediaPath = FILE + "://" + getTestFilesDiskPath() + "/video/30sec/rgb.mp4";    String ffmpegCmd = "ffmpeg -re -i " + mediaPath        + " -an -vcodec libx264 -profile:v baseline -level 3.0 -f rtp -srtp_out_suite AES_CM_128_HMAC_SHA1_80 -srtp_out_params ZDJ4Ump3N0xtRTg0V0k4OWJNaXpKRFl3ejZ0QVJW srtp://"        + kmsIp + ":" + port;    log.debug("Media Path: {}", mediaPath);    log.debug("Uri: {}:{}", kmsIp, port);    log.debug("Ffmpeg cmd: {}", ffmpegCmd);    Shell.run(ffmpegCmd.split(" "));    Assert.assertTrue("Not received FLOWING IN event in webRtcEp:",        flowingInLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage().waitForEvent("playing"));    Color[] expectedColors = { Color.RED, Color.GREEN, Color.BLUE };    for (Color expectedColor : expectedColors) {      Assert.assertTrue("The color of the video should be " + expectedColor,          getPage().similarColor(expectedColor));    }    mp.release();  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.composite;import java.awt.Color;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Composite;import org.kurento.client.Continuation;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.MediaType;import org.kurento.client.PlayerEndpoint;import org.kurento.client.RecorderEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.config.Protocol;import org.kurento.test.config.TestScenario;import org.kurento.test.functional.recorder.BaseRecorder;/** * Four synthetic videos are played by four PlayerEndpoint and mixed by a Composite. Only audio is * connected for three players. The resulting video is recording using a RecorderEndpoint. The * recorded video is played using a PlayerEndpoint. * </p> * Media Pipeline(s): * <ul> * <li>4xPlayerEndpoint -> Composite -> RecorderEndpoint</li> * <li>PlayerEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) Media server mix the media from 4 PlayerEndpoints and it records the grid using the * RecorderEndpoint. Only red color (video from first player) and audio from four players.</li> * <li>(KMS) Media server implements a player to reproduce the video recorded in step 1.</li> * <li>(Browser) WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Color of the video should be the expected in the recorded video (red)</li> * </ul> * Secondary assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * </ul> * * @author David Fernandez (d.fernandezlop@gmail.com) * @since 6.1.1 */public class CompositeAudioRecorderTest extends BaseRecorder {  private static int RECORDTIME = 20; // seconds  private static int PLAYTIME = 20; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromeAndFirefox();  }  @Test  public void testCompositeRecorder() throws Exception {    // MediaPipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    PlayerEndpoint playerRed =        new PlayerEndpoint.Builder(mp, "http://" + getTestFilesHttpPath() + "/video/30sec/red.webm")            .build();    PlayerEndpoint playerGreen = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/green.webm").build();    PlayerEndpoint playerBlue = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/blue.webm").build();    Composite composite = new Composite.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(composite).build();    HubPort hubPort2 = new HubPort.Builder(composite).build();    HubPort hubPort3 = new HubPort.Builder(composite).build();    playerRed.connect(hubPort1);    playerGreen.connect(hubPort2, MediaType.AUDIO);    playerBlue.connect(hubPort3, MediaType.AUDIO);    PlayerEndpoint playerWhite = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/white.webm").build();    HubPort hubPort4 = new HubPort.Builder(composite).build();    playerWhite.connect(hubPort4, MediaType.AUDIO);    HubPort hubPort5 = new HubPort.Builder(composite).build();    String recordingFile = getDefaultOutputFile(EXTENSION_WEBM);    RecorderEndpoint recorderEp =        new RecorderEndpoint.Builder(mp, Protocol.FILE + recordingFile).build();    hubPort5.connect(recorderEp);    playerRed.play();    playerGreen.play();    playerBlue.play();    playerWhite.play();    recorderEp.record();    Thread.sleep(RECORDTIME * 1000);    final CountDownLatch recorderLatch = new CountDownLatch(1);    recorderEp.stopAndWait(new Continuation<Void>() {      @Override      public void onSuccess(Void result) throws Exception {        recorderLatch.countDown();      }      @Override      public void onError(Throwable cause) throws Exception {        recorderLatch.countDown();      }    });    Assert.assertTrue("Not stop properly",        recorderLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    playerRed.stop();    playerGreen.stop();    playerBlue.stop();    playerWhite.stop();    mp.release();    // Media Pipeline #2    MediaPipeline mp2 = kurentoClient.createMediaPipeline();    PlayerEndpoint playerEp2 =        new PlayerEndpoint.Builder(mp2, Protocol.FILE + recordingFile).build();    WebRtcEndpoint webRtcEp2 = new WebRtcEndpoint.Builder(mp2).build();    playerEp2.connect(webRtcEp2);    // Playing the recording    launchBrowser(mp, webRtcEp2, playerEp2, null, EXPECTED_VIDEO_CODEC_WEBM,        EXPECTED_AUDIO_CODEC_WEBM, recordingFile, Color.RED, 0, 0, PLAYTIME);    // Release Media Pipeline #2    mp2.release();    success = true;  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.composite;import java.awt.Color;import java.util.Collection;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Composite;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.PlayerEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * Four synthetic videos are played by four PlayerEndpoint and mixed by a Composite. The resulting * video is played in an WebRtcEndpoint * </p> * Media Pipeline(s): * <ul> * <li>4xPlayerEndpoint -> Composite -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) Media server implements a grid with the media from 4 PlayerEndpoints</li> * <li>(Browser) WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Color of the video should be the expected in the right position (grid)</li> * </ul> * Secondary assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */public class CompositePlayerTest extends FunctionalTest {  private static int PLAYTIME = 5; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromeAndFirefox();  }  @Test  public void testCompositePlayer() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    PlayerEndpoint playerRed =        new PlayerEndpoint.Builder(mp, "http://" + getTestFilesHttpPath() + "/video/30sec/red.webm")            .build();    PlayerEndpoint playerGreen = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/green.webm").build();    PlayerEndpoint playerBlue = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/blue.webm").build();    Composite composite = new Composite.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(composite).build();    HubPort hubPort2 = new HubPort.Builder(composite).build();    HubPort hubPort3 = new HubPort.Builder(composite).build();    playerRed.connect(hubPort1);    playerGreen.connect(hubPort2);    playerBlue.connect(hubPort3);    PlayerEndpoint playerWhite = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/white.webm").build();    HubPort hubPort4 = new HubPort.Builder(composite).build();    playerWhite.connect(hubPort4);    WebRtcEndpoint webRtcEp = new WebRtcEndpoint.Builder(mp).build();    HubPort hubPort5 = new HubPort.Builder(composite).build();    hubPort5.connect(webRtcEp);    // Test execution    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEp, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    playerRed.play();    playerGreen.play();    playerBlue.play();    playerWhite.play();    // Assertions    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage().waitForEvent("playing"));    Assert.assertTrue("Upper left part of the video must be red",        getPage().similarColorAt(Color.RED, 0, 0));    Assert.assertTrue("Upper right part of the video must be green",        getPage().similarColorAt(Color.GREEN, 450, 0));    Assert.assertTrue("Lower left part of the video must be blue",        getPage().similarColorAt(Color.BLUE, 0, 450));    Assert.assertTrue("Lower right part of the video must be white",        getPage().similarColorAt(Color.WHITE, 450, 450));    // Guard time to see the composite result    Thread.sleep(TimeUnit.SECONDS.toMillis(PLAYTIME));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.composite;import java.awt.Color;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Composite;import org.kurento.client.Continuation;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.PlayerEndpoint;import org.kurento.client.RecorderEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.config.Protocol;import org.kurento.test.config.TestScenario;import org.kurento.test.functional.recorder.BaseRecorder;/** * Four synthetic videos are played by four PlayerEndpoint and mixed by a Composite. The resulting * video is recording using a RecorderEndpoint. The recorded video is played using a PlayerEndpoint. * </p> * Media Pipeline(s): * <ul> * <li>4xPlayerEndpoint -> Composite -> RecorderEndpoint</li> * <li>PlayerEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) Media server implements a grid with the media from 4 PlayerEndpoints and it records the * grid using the RecorderEndpoint.</li> * <li>(KMS) Media server implements a player to reproduce the video recorded in step 1.</li> * <li>(Browser) WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Color of the video should be the expected in the recorded video (red, green, blue, and white) * Endpoint</li> * </ul> * Secondary assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * </ul> * * @author David Fernandez (d.fernandezlop@gmail.com) * @since 6.1.1 */public class CompositeRecorderTest extends BaseRecorder {  private static int RECORDTIME = 20; // seconds  private static int PLAYTIME = 20; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromeAndFirefox();  }  @Test  public void testCompositeRecorder() throws Exception {    // MediaPipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    PlayerEndpoint playerRed =        new PlayerEndpoint.Builder(mp, "http://" + getTestFilesHttpPath() + "/video/30sec/red.webm")            .build();    PlayerEndpoint playerGreen = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/green.webm").build();    PlayerEndpoint playerBlue = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/blue.webm").build();    Composite composite = new Composite.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(composite).build();    HubPort hubPort2 = new HubPort.Builder(composite).build();    HubPort hubPort3 = new HubPort.Builder(composite).build();    playerRed.connect(hubPort1);    playerGreen.connect(hubPort2);    playerBlue.connect(hubPort3);    PlayerEndpoint playerWhite = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/white.webm").build();    HubPort hubPort4 = new HubPort.Builder(composite).build();    playerWhite.connect(hubPort4);    HubPort hubPort5 = new HubPort.Builder(composite).build();    String recordingFile = getDefaultOutputFile(EXTENSION_WEBM);    RecorderEndpoint recorderEp =        new RecorderEndpoint.Builder(mp, Protocol.FILE + recordingFile).build();    hubPort5.connect(recorderEp);    playerRed.play();    playerGreen.play();    playerBlue.play();    playerWhite.play();    recorderEp.record();    Thread.sleep(RECORDTIME * 1000);    final CountDownLatch recorderLatch = new CountDownLatch(1);    recorderEp.stopAndWait(new Continuation<Void>() {      @Override      public void onSuccess(Void result) throws Exception {        recorderLatch.countDown();      }      @Override      public void onError(Throwable cause) throws Exception {        recorderLatch.countDown();      }    });    Assert.assertTrue("Not stop properly",        recorderLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    playerRed.stop();    playerGreen.stop();    playerBlue.stop();    playerWhite.stop();    mp.release();    // Media Pipeline #2    MediaPipeline mp2 = kurentoClient.createMediaPipeline();    PlayerEndpoint playerEp2 =        new PlayerEndpoint.Builder(mp2, Protocol.FILE + recordingFile).build();    WebRtcEndpoint webRtcEp2 = new WebRtcEndpoint.Builder(mp2).build();    playerEp2.connect(webRtcEp2);    // Playing the recording    launchBrowser(mp, webRtcEp2, playerEp2, null, EXPECTED_VIDEO_CODEC_WEBM,        EXPECTED_AUDIO_CODEC_WEBM, recordingFile, Color.RED, 0, 0, PLAYTIME);    // Assertions    Assert.assertTrue("Upper left part of the video must be red",        getPage().similarColorAt(Color.RED, 0, 0));    Assert.assertTrue("Upper right part of the video must be green",        getPage().similarColorAt(Color.GREEN, 450, 0));    Assert.assertTrue("Lower left part of the video must be blue",        getPage().similarColorAt(Color.BLUE, 0, 450));    Assert.assertTrue("Lower right part of the video must be white",        getPage().similarColorAt(Color.WHITE, 450, 450));    // Release Media Pipeline #2    mp2.release();    success = true;  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.composite;import java.awt.Color;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Composite;import org.kurento.client.Continuation;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.MediaType;import org.kurento.client.PlayerEndpoint;import org.kurento.client.RecorderEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.Protocol;import org.kurento.test.config.TestScenario;import org.kurento.test.functional.recorder.BaseRecorder;/** * Four synthetic videos are played by four WebRtcEndpoint (Connect only audio for thres videos) and * mixed by a Composite. The resulting video is recording using a RecorderEndpoint. The recorded * video is played using a PlayerEndpoint. * </p> * Media Pipeline(s): * <ul> * <li>4xWebRtcEndpoint -> Composite -> RecorderEndpoint</li> * <li>PlayerEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) Media server mix the media from 4 WebRtcEndpoint and it records the grid using the * RecorderEndpoint. Only red color (video from first player) and audio from four players.</li> * <li>(KMS) Media server implements a player to reproduce the video recorded in step 1.</li> * <li>(Browser) WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Color of the video should be the expected in the recorded video (red)</li> * </ul> * Secondary assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * </ul> * * @author David Fernandez (d.fernandezlop@gmail.com) * @since 6.1.1 */public class CompositeWebRtcRecorderTest extends BaseRecorder {  private static int PLAYTIME = 10; // seconds  private static final String BROWSER1 = "browser1";  private static final String BROWSER2 = "browser2";  private static final String BROWSER3 = "browser3";  private static final String BROWSER4 = "browser4";  private static final String BROWSER5 = "browser5";  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    // Test: 5 local Chrome's    TestScenario test = new TestScenario();    test.addBrowser(BROWSER1, new Browser.Builder().browserType(BrowserType.CHROME)        .webPageType(WebPageType.WEBRTC).scope(BrowserScope.LOCAL).build());    test.addBrowser(BROWSER2,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/red.y4m")            .build());    test.addBrowser(BROWSER3,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/green.y4m")            .build());    test.addBrowser(BROWSER4,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/blue.y4m")            .build());    test.addBrowser(BROWSER5,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/white.y4m")            .build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testCompositeRecorder() throws Exception {    // MediaPipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    Composite composite = new Composite.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(composite).build();    WebRtcEndpoint webRtcEpRed = new WebRtcEndpoint.Builder(mp).build();    webRtcEpRed.connect(hubPort1);    HubPort hubPort2 = new HubPort.Builder(composite).build();    WebRtcEndpoint webRtcEpGreen = new WebRtcEndpoint.Builder(mp).build();    webRtcEpGreen.connect(hubPort2, MediaType.AUDIO);    HubPort hubPort3 = new HubPort.Builder(composite).build();    WebRtcEndpoint webRtcEpBlue = new WebRtcEndpoint.Builder(mp).build();    webRtcEpBlue.connect(hubPort3, MediaType.AUDIO);    HubPort hubPort4 = new HubPort.Builder(composite).build();    WebRtcEndpoint webRtcEpWhite = new WebRtcEndpoint.Builder(mp).build();    webRtcEpWhite.connect(hubPort4, MediaType.AUDIO);    String recordingFile = getDefaultOutputFile(EXTENSION_WEBM);    RecorderEndpoint recorderEp =        new RecorderEndpoint.Builder(mp, Protocol.FILE + recordingFile).build();    HubPort hubPort5 = new HubPort.Builder(composite).build();    hubPort5.connect(recorderEp);    // WebRTC browsers    getPage(BROWSER2).initWebRtc(webRtcEpRed, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_ONLY);    getPage(BROWSER3).initWebRtc(webRtcEpGreen, WebRtcChannel.AUDIO_AND_VIDEO,        WebRtcMode.SEND_ONLY);    getPage(BROWSER4).initWebRtc(webRtcEpBlue, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_ONLY);    getPage(BROWSER5).initWebRtc(webRtcEpWhite, WebRtcChannel.AUDIO_AND_VIDEO,        WebRtcMode.SEND_ONLY);    recorderEp.record();    Thread.sleep(PLAYTIME * 1000);    final CountDownLatch recorderLatch = new CountDownLatch(1);    recorderEp.stopAndWait(new Continuation<Void>() {      @Override      public void onSuccess(Void result) throws Exception {        recorderLatch.countDown();      }      @Override      public void onError(Throwable cause) throws Exception {        recorderLatch.countDown();      }    });    Assert.assertTrue("Not stop properly",        recorderLatch.await(getPage(BROWSER1).getTimeout(), TimeUnit.SECONDS));    mp.release();    // Media Pipeline #2    MediaPipeline mp2 = kurentoClient.createMediaPipeline();    PlayerEndpoint playerEp2 =        new PlayerEndpoint.Builder(mp2, Protocol.FILE + recordingFile).build();    WebRtcEndpoint webRtcEp2 = new WebRtcEndpoint.Builder(mp2).build();    playerEp2.connect(webRtcEp2);    // Playing the recorded file    launchBrowser(mp2, webRtcEp2, playerEp2, null, EXPECTED_VIDEO_CODEC_WEBM,        EXPECTED_AUDIO_CODEC_WEBM, recordingFile, Color.RED, 0, 0, PLAYTIME);    // Release Media Pipeline #2    mp2.release();    success = true;  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.composite;import java.awt.Color;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Composite;import org.kurento.client.GStreamerFilter;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;/** * Four synthetic videos are played by four WebRtcEndpoint and mixed by a Composite. The resulting * video is played in an WebRtcEndpoint. At the end, a B&N filter is connected in one of the * WebRTC's * </p> * Media Pipeline(s): * <ul> * <li>4xWebRtcEndpoint -> Composite -> WebRtcEndpoint</li> * <li>1xWebRtcEndpoint -> GStreamerFilter</li> * </ul> * Browser(s): * <ul> * <li>5 x Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) Media server implements a grid with the media from 4 WebRtcEndpoints and sends the * resulting media to another WebRtcEndpoint. Then the media of one the WebRtcEndpoint is filtered * with GStreamerFilter (B&N video)</li> * <li>(Browser) WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Color of the video should be the expected in the right position (grid)</li> * </ul> * Secondary assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */public class CompositeWebRtcTest extends FunctionalTest {  private static final String BROWSER1 = "browser1";  private static final String BROWSER2 = "browser2";  private static final String BROWSER3 = "browser3";  private static final String BROWSER4 = "browser4";  private static final String BROWSER5 = "browser5";  private static int PLAYTIME = 5;  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    // Test: 5 local Chrome's    TestScenario test = new TestScenario();    test.addBrowser(BROWSER1, new Browser.Builder().browserType(BrowserType.CHROME)        .webPageType(WebPageType.WEBRTC).scope(BrowserScope.LOCAL).build());    test.addBrowser(BROWSER2,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/red.y4m")            .build());    test.addBrowser(BROWSER3,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/green.y4m")            .build());    test.addBrowser(BROWSER4,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/blue.y4m")            .build());    test.addBrowser(BROWSER5,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/white.y4m")            .build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testCompositeWebRtc() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEpRed = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEpGreen = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEpBlue = new WebRtcEndpoint.Builder(mp).build();    Composite composite = new Composite.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(composite).build();    HubPort hubPort2 = new HubPort.Builder(composite).build();    HubPort hubPort3 = new HubPort.Builder(composite).build();    webRtcEpRed.connect(hubPort1);    webRtcEpGreen.connect(hubPort2);    webRtcEpBlue.connect(hubPort3);    WebRtcEndpoint webRtcEpWhite = new WebRtcEndpoint.Builder(mp).build();    HubPort hubPort4 = new HubPort.Builder(composite).build();    webRtcEpWhite.connect(hubPort4);    WebRtcEndpoint webRtcEpComposite = new WebRtcEndpoint.Builder(mp).build();    HubPort hubPort5 = new HubPort.Builder(composite).build();    hubPort5.connect(webRtcEpComposite);    // WebRTC browsers    getPage(BROWSER2).initWebRtc(webRtcEpRed, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_ONLY);    getPage(BROWSER3).initWebRtc(webRtcEpGreen, WebRtcChannel.AUDIO_AND_VIDEO,        WebRtcMode.SEND_ONLY);    getPage(BROWSER4).initWebRtc(webRtcEpBlue, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_ONLY);    getPage(BROWSER5).initWebRtc(webRtcEpWhite, WebRtcChannel.AUDIO_AND_VIDEO,        WebRtcMode.SEND_ONLY);    getPage(BROWSER1).subscribeEvents("playing");    getPage(BROWSER1).initWebRtc(webRtcEpComposite, WebRtcChannel.AUDIO_AND_VIDEO,        WebRtcMode.RCV_ONLY);    // Assertions    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage(BROWSER1).waitForEvent("playing"));    Assert.assertTrue("Upper left part of the video must be red",        getPage(BROWSER1).similarColorAt(Color.RED, 0, 0));    Assert.assertTrue("Upper right part of the video must be green",        getPage(BROWSER1).similarColorAt(Color.GREEN, 450, 0));    Assert.assertTrue("Lower left part of the video must be blue",        getPage(BROWSER1).similarColorAt(Color.BLUE, 0, 450));    Assert.assertTrue("Lower right part of the video must be white",        getPage(BROWSER1).similarColorAt(Color.WHITE, 450, 450));    // Finally, a black & white filter is connected to one WebRTC    GStreamerFilter bwFilter =        new GStreamerFilter.Builder(mp, "videobalance saturation=0.0").build();    webRtcEpRed.connect(bwFilter);    bwFilter.connect(hubPort1);    Thread.sleep(TimeUnit.SECONDS.toMillis(PLAYTIME));    Assert.assertTrue("When connecting the filter, the upper left part of the video must be gray",        getPage(BROWSER1).similarColorAt(new Color(75, 75, 75), 0, 0));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.composite;import java.awt.Color;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Composite;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;/** * Four synthetic videos are played by four WebRtcEndpoint and mixed by a Composite. The resulting * video is played in an WebRtcEndpoint * </p> * Media Pipeline(s): * <ul> * <li>4xWebRtcEndpoint -> Composite -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>5 x Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) Media server implements a grid with the media from 4 WebRtcEndpoints and sends the</li> * <li>resulting media to another WebRtcEndpoint (Browser) WebRtcPeer in rcv-only receives media * Endpoint</li> * </ol> * Main assertion(s): * <ul> * <li>Color of the video should be the expected in the right position (grid)</li> * </ul> * Secondary assertion(s): * <ul> * Endpoint</li>Playing event should be received in remote video tag</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @author David Fernandez (d.fernandezlop@gmail.com) * @since 5.0.5 */public class CompositeWebRtcUsersTest extends FunctionalTest {  private static final String BROWSER1 = "browser1";  private static final String BROWSER2 = "browser2";  private static final String BROWSER3 = "browser3";  private static final String BROWSER4 = "browser4";  private static final String BROWSER5 = "browser5";  private static int PLAYTIME = 5;  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    // Test: 5 local Chrome's    TestScenario test = new TestScenario();    test.addBrowser(BROWSER1, new Browser.Builder().browserType(BrowserType.CHROME)        .webPageType(WebPageType.WEBRTC).scope(BrowserScope.LOCAL).build());    test.addBrowser(BROWSER2,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/red.y4m")            .build());    test.addBrowser(BROWSER3,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/green.y4m")            .build());    test.addBrowser(BROWSER4,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/blue.y4m")            .build());    test.addBrowser(BROWSER5,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/white.y4m")            .build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testCompositeWebRtcUsers() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    Composite composite = new Composite.Builder(mp).build();    WebRtcEndpoint webRtcEpRed = new WebRtcEndpoint.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(composite).build();    webRtcEpRed.connect(hubPort1);    WebRtcEndpoint webRtcEpGreen = new WebRtcEndpoint.Builder(mp).build();    HubPort hubPort2 = new HubPort.Builder(composite).build();    webRtcEpGreen.connect(hubPort2);    WebRtcEndpoint webRtcEpComposite = new WebRtcEndpoint.Builder(mp).build();    HubPort hubPort5 = new HubPort.Builder(composite).build();    hubPort5.connect(webRtcEpComposite);    WebRtcEndpoint webRtcEpBlue = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEpWhite = new WebRtcEndpoint.Builder(mp).build();    // Test execution    getPage(BROWSER2).initWebRtc(webRtcEpRed, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_ONLY);    getPage(BROWSER3).initWebRtc(webRtcEpGreen, WebRtcChannel.AUDIO_AND_VIDEO,        WebRtcMode.SEND_ONLY);    getPage(BROWSER4).initWebRtc(webRtcEpBlue, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_ONLY);    getPage(BROWSER5).initWebRtc(webRtcEpWhite, WebRtcChannel.AUDIO_AND_VIDEO,        WebRtcMode.SEND_ONLY);    getPage(BROWSER1).subscribeEvents("playing");    getPage(BROWSER1).initWebRtc(webRtcEpComposite, WebRtcChannel.AUDIO_AND_VIDEO,        WebRtcMode.RCV_ONLY);    // Assertions    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage(BROWSER1).waitForEvent("playing"));    Assert.assertTrue("Left part of the video must be red",        getPage(BROWSER1).similarColorAt(Color.RED, 0, 200));    Assert.assertTrue("Upper right part of the video must be green",        getPage(BROWSER1).similarColorAt(Color.GREEN, 450, 300));    hubPort2.release();    Thread.sleep(3000);    Assert.assertTrue("All the video must be red",        getPage(BROWSER1).similarColorAt(Color.RED, 300, 200));    HubPort hubPort4 = new HubPort.Builder(composite).build();    webRtcEpWhite.connect(hubPort4);    Thread.sleep(TimeUnit.SECONDS.toMillis(PLAYTIME));    Assert.assertTrue("Left part of the video must be red",        getPage(BROWSER1).similarColorAt(Color.RED, 0, 300));    Assert.assertTrue("Left part of the video must be white",        getPage(BROWSER1).similarColorAt(Color.WHITE, 450, 300));    hubPort4.release();    hubPort2 = new HubPort.Builder(composite).build();    hubPort4 = new HubPort.Builder(composite).build();    webRtcEpGreen.connect(hubPort2);    HubPort hubPort3 = new HubPort.Builder(composite).build();    webRtcEpBlue.connect(hubPort3);    webRtcEpWhite.connect(hubPort4);    Thread.sleep(TimeUnit.SECONDS.toMillis(PLAYTIME));    Assert.assertTrue("The red color must be in some position",        (getPage(BROWSER1).similarColorAt(Color.RED, 0, 0)            || getPage(BROWSER1).similarColorAt(Color.RED, 450, 0)            || getPage(BROWSER1).similarColorAt(Color.RED, 0, 450)            || getPage(BROWSER1).similarColorAt(Color.RED, 450, 450)));    Assert.assertTrue("The blue color must be in some position",        (getPage(BROWSER1).similarColorAt(Color.BLUE, 450, 450)            || getPage(BROWSER1).similarColorAt(Color.BLUE, 0, 450)            || getPage(BROWSER1).similarColorAt(Color.BLUE, 450, 0)            || getPage(BROWSER1).similarColorAt(Color.BLUE, 0, 0)));    Assert.assertTrue("The green color must be in some position",        (getPage(BROWSER1).similarColorAt(Color.GREEN, 450, 0)            || getPage(BROWSER1).similarColorAt(Color.GREEN, 0, 450)            || getPage(BROWSER1).similarColorAt(Color.GREEN, 0, 0)            || getPage(BROWSER1).similarColorAt(Color.GREEN, 450, 450)));    Assert.assertTrue("The white color must be in some position",        (getPage(BROWSER1).similarColorAt(Color.WHITE, 0, 450)            || getPage(BROWSER1).similarColorAt(Color.WHITE, 450, 0)            || getPage(BROWSER1).similarColorAt(Color.WHITE, 0, 0)            || getPage(BROWSER1).similarColorAt(Color.WHITE, 450, 450)));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.dispatcher;import java.awt.Color;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Dispatcher;import org.kurento.client.EndOfStreamEvent;import org.kurento.client.EventListener;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.PlayerEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * A PlayerEndpoint is connected to a WebRtcEndpoint through a Dispatcher * </p> * Media Pipeline(s): * <ul> * <li>2xPlayerEndpoint -> Dispatcher -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) Media server switchs the media from two PlayerEndpoint using a Dispatcher, streaming * the result through a WebRtcEndpoint</li> * <li>(Browser) WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>The color of the received video should be as expected (red and the blue)</li> * <li>EOS event should arrive to player</li> * <li>Play time in remote video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */public class DispatcherPlayerTest extends FunctionalTest {  private static final int PLAYTIME = 10; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromeAndFirefox();  }  @Test  public void testDispatcherPlayer() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    PlayerEndpoint playerEp =        new PlayerEndpoint.Builder(mp, "http://" + getTestFilesHttpPath() + "/video/10sec/red.webm")            .build();    PlayerEndpoint playerEp2 = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/10sec/blue.webm").build();    WebRtcEndpoint webRtcEp = new WebRtcEndpoint.Builder(mp).build();    Dispatcher dispatcher = new Dispatcher.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(dispatcher).build();    HubPort hubPort2 = new HubPort.Builder(dispatcher).build();    HubPort hubPort3 = new HubPort.Builder(dispatcher).build();    playerEp.connect(hubPort1);    playerEp2.connect(hubPort3);    hubPort2.connect(webRtcEp);    dispatcher.connect(hubPort1, hubPort2);    final CountDownLatch eosLatch = new CountDownLatch(1);    playerEp2.addEndOfStreamListener(new EventListener<EndOfStreamEvent>() {      @Override      public void onEvent(EndOfStreamEvent event) {        eosLatch.countDown();      }    });    // Test execution    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEp, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    playerEp.play();    // Assertions    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage().waitForEvent("playing"));    Assert.assertTrue("The color of the video should be red", getPage().similarColor(Color.RED));    Thread.sleep(5000);    playerEp2.play();    dispatcher.connect(hubPort3, hubPort2);    Assert.assertTrue("The color of the video should be blue", getPage().similarColor(Color.BLUE));    Assert.assertTrue("Not received EOS event in player",        eosLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    double currentTime = getPage().getCurrentTime();    Assert.assertTrue(        "Error in play time (expected: " + PLAYTIME + " sec, real: " + currentTime + " sec)",        getPage().compare(PLAYTIME, currentTime));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.dispatcher;import java.awt.Color;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Dispatcher;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;/** * A WebRtcEndpoint is connected to another WebRtcEndpoint through a Dispatcher * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> Dispatcher -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>3 x Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) Media server switchs the media from two WebRtcEndpoint using a Dispatcher, streaming * the result through antoher WebRtcEndpoint</li> * <li>(Browser) WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>The color of the received video should be as expected (green and the blue)</li> * <li>EOS event should arrive to player</li> * <li>Play time in remote video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */public class DispatcherWebRtcTest extends FunctionalTest {  private static final int PLAYTIME = 10; // seconds  private static final String BROWSER1 = "browser1";  private static final String BROWSER2 = "browser2";  private static final String BROWSER3 = "browser3";  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    TestScenario test = new TestScenario();    test.addBrowser(BROWSER1, new Browser.Builder().browserType(BrowserType.CHROME)        .webPageType(WebPageType.WEBRTC).scope(BrowserScope.LOCAL).build());    test.addBrowser(BROWSER2,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/green.y4m")            .build());    test.addBrowser(BROWSER3,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/blue.y4m")            .build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testDispatcherWebRtc() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEp1 = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEp2 = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEp3 = new WebRtcEndpoint.Builder(mp).build();    Dispatcher dispatcher = new Dispatcher.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(dispatcher).build();    HubPort hubPort2 = new HubPort.Builder(dispatcher).build();    HubPort hubPort3 = new HubPort.Builder(dispatcher).build();    webRtcEp1.connect(hubPort1);    webRtcEp3.connect(hubPort3);    hubPort2.connect(webRtcEp2);    dispatcher.connect(hubPort1, hubPort2);    // Test execution    getPage(BROWSER2).initWebRtc(webRtcEp1, WebRtcChannel.VIDEO_ONLY, WebRtcMode.SEND_ONLY);    getPage(BROWSER3).initWebRtc(webRtcEp3, WebRtcChannel.VIDEO_ONLY, WebRtcMode.SEND_ONLY);    getPage(BROWSER1).subscribeEvents("playing");    getPage(BROWSER1).initWebRtc(webRtcEp2, WebRtcChannel.VIDEO_ONLY, WebRtcMode.RCV_ONLY);    Thread.sleep(TimeUnit.SECONDS.toMillis(PLAYTIME));    // Assertions    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage(BROWSER1).waitForEvent("playing"));    Assert.assertTrue("The color of the video should be green",        getPage(BROWSER1).similarColor(Color.GREEN));    Thread.sleep(5000);    dispatcher.connect(hubPort3, hubPort2);    Assert.assertTrue("The color of the video should be blue (BLUE)",        getPage(BROWSER1).similarColor(Color.BLUE));    Thread.sleep(2000);    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.dispatcheronetomany;import java.awt.Color;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.DispatcherOneToMany;import org.kurento.client.EndOfStreamEvent;import org.kurento.client.EventListener;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.PlayerEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;/** * * <strong>Description</strong>: A PlayerEndpoint is connected to a WebRtcEndpoint through a * Dispatcher.<br/> * <strong>Pipeline</strong>: * <ul> * <li>PlayerEndpoint -> Dispatcher -> WebRtcEndpoint</li> * </ul> * <strong>Pass criteria</strong>: * <ul> * <li>Media should be received in the video tag</li> * <li>EOS event should arrive to player</li> * <li>Play time should be the expected</li> * <li>Color of the video should be the expected</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @author David Fernandez (d.fernandezlop@gmail.com) * @since 6.0.0 */public class DispatcherOneToManyPlayerTest extends FunctionalTest {  private static final int TIMEOUT_EOS = 60; // seconds  private static final String BROWSER1 = "browser1";  private static final String BROWSER2 = "browser2";  private static final String BROWSER3 = "browser3";  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    TestScenario test = new TestScenario();    test.addBrowser(BROWSER1, new Browser.Builder().browserType(BrowserType.CHROME)        .webPageType(WebPageType.WEBRTC).scope(BrowserScope.LOCAL).build());    test.addBrowser(BROWSER2, new Browser.Builder().browserType(BrowserType.CHROME)        .webPageType(WebPageType.WEBRTC).scope(BrowserScope.LOCAL).build());    test.addBrowser(BROWSER3, new Browser.Builder().browserType(BrowserType.CHROME)        .webPageType(WebPageType.WEBRTC).scope(BrowserScope.LOCAL).build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testDispatcherOneToManyPlayer() throws Exception {    MediaPipeline mp = kurentoClient.createMediaPipeline();    PlayerEndpoint playerEp =        new PlayerEndpoint.Builder(mp, "http://" + getTestFilesHttpPath() + "/video/30sec/red.webm")            .build();    PlayerEndpoint playerEp2 = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/30sec/blue.webm").build();    WebRtcEndpoint webRtcEp1 = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEp2 = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEp3 = new WebRtcEndpoint.Builder(mp).build();    DispatcherOneToMany dispatcherOneToMany = new DispatcherOneToMany.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(dispatcherOneToMany).build();    HubPort hubPort2 = new HubPort.Builder(dispatcherOneToMany).build();    HubPort hubPort3 = new HubPort.Builder(dispatcherOneToMany).build();    HubPort hubPort4 = new HubPort.Builder(dispatcherOneToMany).build();    HubPort hubPort5 = new HubPort.Builder(dispatcherOneToMany).build();    playerEp.connect(hubPort1);    playerEp2.connect(hubPort2);    hubPort3.connect(webRtcEp1);    hubPort4.connect(webRtcEp2);    hubPort5.connect(webRtcEp3);    dispatcherOneToMany.setSource(hubPort1);    final CountDownLatch eosLatch = new CountDownLatch(1);    playerEp2.addEndOfStreamListener(new EventListener<EndOfStreamEvent>() {      @Override      public void onEvent(EndOfStreamEvent event) {        eosLatch.countDown();      }    });    // Test execution    getPage(BROWSER1).subscribeEvents("playing");    getPage(BROWSER1).initWebRtc(webRtcEp2, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    getPage(BROWSER2).subscribeEvents("playing");    getPage(BROWSER2).initWebRtc(webRtcEp1, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    getPage(BROWSER3).subscribeEvents("playing");    getPage(BROWSER3).initWebRtc(webRtcEp3, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    playerEp.play();    // Assertions    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage(BROWSER1).waitForEvent("playing"));    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage(BROWSER2).waitForEvent("playing"));    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage(BROWSER3).waitForEvent("playing"));    Assert.assertTrue("The color of the video should be red",        getPage(BROWSER1).similarColor(Color.RED));    Assert.assertTrue("The color of the video should be red",        getPage(BROWSER2).similarColor(Color.RED));    Assert.assertTrue("The color of the video should be red",        getPage(BROWSER3).similarColor(Color.RED));    Thread.sleep(3000);    playerEp2.play();    dispatcherOneToMany.setSource(hubPort2);    Assert.assertTrue("The color of the video should be blue",        getPage(BROWSER1).similarColor(Color.BLUE));    Assert.assertTrue("The color of the video should be blue",        getPage(BROWSER2).similarColor(Color.BLUE));    Assert.assertTrue("The color of the video should be blue",        getPage(BROWSER3).similarColor(Color.BLUE));    Thread.sleep(3000);    dispatcherOneToMany.setSource(hubPort1);    Assert.assertTrue("The color of the video should be red",        getPage(BROWSER1).similarColor(Color.RED));    Assert.assertTrue("The color of the video should be red",        getPage(BROWSER2).similarColor(Color.RED));    Assert.assertTrue("The color of the video should be red",        getPage(BROWSER3).similarColor(Color.RED));    Thread.sleep(3000);    dispatcherOneToMany.setSource(hubPort2);    Assert.assertTrue("The color of the video should be red",        getPage(BROWSER1).similarColor(Color.BLUE));    Assert.assertTrue("The color of the video should be red",        getPage(BROWSER2).similarColor(Color.BLUE));    Assert.assertTrue("The color of the video should be red",        getPage(BROWSER3).similarColor(Color.BLUE));    Thread.sleep(3000);    Assert.assertTrue("Not received EOS event in player",        eosLatch.await(TIMEOUT_EOS, TimeUnit.SECONDS));  }}
/* * (C) Copyright 2016 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.dispatcheronetomany;import java.awt.Color;import java.util.Arrays;import java.util.Collection;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.DispatcherOneToMany;import org.kurento.client.HubPort;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;/** * * <strong>Description</strong>: A WebRtcEndpoint is connected to another WebRtcEndpoint through a * Dispatcher.<br/> * <strong>Pipeline</strong>: * <ul> * <li>WebRtcEndpoint -> Dispatcher -> WebRtcEndpoint</li> * </ul> * <strong>Pass criteria</strong>: * <ul> * <li>Media should be received in the video tag</li> * <li>Color of the video should be the expected</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @author David Fernandez (d.fernandezlop@gmail.com) * @since 6.0.0 */public class DispatcherOneToManyWebRtcTest extends FunctionalTest {  private static final int PLAYTIME = 10; // seconds  private static final String BROWSER1 = "browser1";  private static final String BROWSER2 = "browser2";  private static final String BROWSER3 = "browser3";  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    TestScenario test = new TestScenario();    test.addBrowser(BROWSER1,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/green.y4m")            .build());    test.addBrowser(BROWSER2,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/blue.y4m")            .build());    test.addBrowser(BROWSER3,        new Browser.Builder().browserType(BrowserType.CHROME).webPageType(WebPageType.WEBRTC)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/10sec/red.y4m")            .build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testDispatcherOneToManyWebRtc() throws Exception {    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEp1 = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEp2 = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEp3 = new WebRtcEndpoint.Builder(mp).build();    DispatcherOneToMany dispatcherOneToMany = new DispatcherOneToMany.Builder(mp).build();    HubPort hubPort1 = new HubPort.Builder(dispatcherOneToMany).build();    HubPort hubPort2 = new HubPort.Builder(dispatcherOneToMany).build();    HubPort hubPort3 = new HubPort.Builder(dispatcherOneToMany).build();    webRtcEp1.connect(hubPort1);    webRtcEp2.connect(hubPort2);    webRtcEp3.connect(hubPort3);    hubPort1.connect(webRtcEp1);    hubPort2.connect(webRtcEp2);    hubPort3.connect(webRtcEp3);    dispatcherOneToMany.setSource(hubPort1);    getPage(BROWSER1).subscribeEvents("playing");    getPage(BROWSER1).initWebRtc(webRtcEp1, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    getPage(BROWSER2).subscribeEvents("playing");    getPage(BROWSER2).initWebRtc(webRtcEp2, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    getPage(BROWSER3).subscribeEvents("playing");    getPage(BROWSER3).initWebRtc(webRtcEp3, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    Thread.sleep(PLAYTIME * 1000);    // Assertions    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage(BROWSER1).waitForEvent("playing"));    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage(BROWSER2).waitForEvent("playing"));    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage(BROWSER3).waitForEvent("playing"));    Assert.assertTrue("The color of the video should be green (GREEN)",        getPage(BROWSER1).similarColor(Color.GREEN));    Assert.assertTrue("The color of the video should be green (GREEN)",        getPage(BROWSER2).similarColor(Color.GREEN));    Assert.assertTrue("The color of the video should be green (GREEN)",        getPage(BROWSER3).similarColor(Color.GREEN));    Thread.sleep(3000);    dispatcherOneToMany.setSource(hubPort2);    Assert.assertTrue("The color of the video should be blue (BLUE)",        getPage(BROWSER1).similarColor(Color.BLUE));    Assert.assertTrue("The color of the video should be blue (BLUE)",        getPage(BROWSER2).similarColor(Color.BLUE));    Assert.assertTrue("The color of the video should be blue (BLUE)",        getPage(BROWSER3).similarColor(Color.BLUE));    Thread.sleep(3000);    dispatcherOneToMany.setSource(hubPort3);    Assert.assertTrue("The color of the video should be red (RED)",        getPage(BROWSER1).similarColor(Color.RED));    Assert.assertTrue("The color of the video should be red (RED)",        getPage(BROWSER2).similarColor(Color.RED));    Assert.assertTrue("The color of the video should be red (RED)",        getPage(BROWSER3).similarColor(Color.RED));    Thread.sleep(3000);    dispatcherOneToMany.removeSource();    Assert.assertTrue("The color of the video should be red (RED)",        getPage(BROWSER1).similarColor(Color.RED));    Assert.assertTrue("The color of the video should be red (RED)",        getPage(BROWSER2).similarColor(Color.RED));    Assert.assertTrue("The color of the video should be red (RED)",        getPage(BROWSER3).similarColor(Color.RED));    Thread.sleep(2000);  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.repository;import java.awt.Color;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.Continuation;import org.kurento.client.EndOfStreamEvent;import org.kurento.client.EventListener;import org.kurento.client.MediaPipeline;import org.kurento.client.PlayerEndpoint;import org.kurento.client.RecorderEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.repository.RepositoryHttpRecorder;import org.kurento.repository.RepositoryItem;import org.kurento.test.base.RepositoryFunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * Test of a Recorder in the repository, using the stream source from a PlayerEndpoint through an * WebRtcEndpoint * </p> * Media Pipeline(s): * <ul> * <li>PlayerEndpoint -> RecorderEndpoint & WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) Media server switchs the media from two WebRtcEndpoint using a Dispatcher, streaming * the result through antoher WebRtcEndpoint</li> * <li>(Browser) WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>The color of the received video should be as expected (green and the blue) <br> * <li>EOS event should arrive to player</li> * <li>Play time in remote video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.0.4 */public class RepositoryRecorderTest extends RepositoryFunctionalTest {  private static final int PLAYTIME = 10; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromeAndFirefox();  }  @Test  public void testRepositoryRecorder() throws Exception {    final CountDownLatch recorderLatch = new CountDownLatch(1);    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    PlayerEndpoint playerEp = new PlayerEndpoint.Builder(mp,        "http://" + getTestFilesHttpPath() + "/video/10sec/ball.webm").build();    WebRtcEndpoint webRtcEp1 = new WebRtcEndpoint.Builder(mp).build();    RepositoryItem repositoryItem = repository.createRepositoryItem();    RepositoryHttpRecorder recorder = repositoryItem.createRepositoryHttpRecorder();    RecorderEndpoint recorderEp = new RecorderEndpoint.Builder(mp, recorder.getURL()).build();    playerEp.connect(webRtcEp1);    playerEp.connect(recorderEp);    final CountDownLatch eosLatch = new CountDownLatch(1);    playerEp.addEndOfStreamListener(new EventListener<EndOfStreamEvent>() {      @Override      public void onEvent(EndOfStreamEvent event) {        eosLatch.countDown();      }    });    // Test execution #1. Play the video while it is recorded    launchBrowser(webRtcEp1, playerEp, recorderEp);    // Wait for EOS    Assert.assertTrue("Not received EOS event in player",        eosLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    // Release Media Pipeline #1    recorderEp.stopAndWait(new Continuation<Void>() {      @Override      public void onSuccess(Void result) throws Exception {        recorderLatch.countDown();      }      @Override      public void onError(Throwable cause) throws Exception {        recorderLatch.countDown();      }    });    Assert.assertTrue("Not stop properly",        recorderLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    mp.release();    Thread.sleep(500);  }  private void launchBrowser(WebRtcEndpoint webRtcEp, PlayerEndpoint playerEp,      RecorderEndpoint recorderEp) throws InterruptedException {    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEp, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    playerEp.play();    final CountDownLatch eosLatch = new CountDownLatch(1);    playerEp.addEndOfStreamListener(new EventListener<EndOfStreamEvent>() {      @Override      public void onEvent(EndOfStreamEvent event) {        eosLatch.countDown();      }    });    if (recorderEp != null) {      recorderEp.record();    }    // Assertions    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage().waitForEvent("playing"));    Assert.assertTrue("The color of the video should be black",        getPage().similarColor(Color.BLACK));    Assert.assertTrue("Not received EOS event in player",        eosLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    double currentTime = getPage().getCurrentTime();    Assert.assertTrue(        "Error in play time (expected: " + PLAYTIME + " sec, real: " + currentTime + " sec)",        getPage().compare(PLAYTIME, currentTime));  }}
/* * (C) Copyright 2018 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.EventListener;import org.kurento.client.MediaFlowInStateChangeEvent;import org.kurento.client.MediaFlowState;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * WebRTC in loopback with fake WebRTC media. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback<br> * <li>(Browser) WebRtcPeer in send-receive mode sends and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Play time in remote video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */public class WebRtcFakeMediaTest extends FunctionalTest {  private static final int PLAYTIME = 10; // seconds to play in WebRTC  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromesWithRgbVideo(1);  }  @Test  public void testWebRtcLoopback() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    webRtcEndpoint.connect(webRtcEndpoint);    final CountDownLatch flowingLatch = new CountDownLatch(1);    webRtcEndpoint        .addMediaFlowInStateChangeListener(new EventListener<MediaFlowInStateChangeEvent>() {          @Override          public void onEvent(MediaFlowInStateChangeEvent event) {            if (event.getState().equals(MediaFlowState.FLOWING)) {              flowingLatch.countDown();            }          }        });    // Start WebRTC and wait for playing event    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    Assert.assertTrue("Not received FLOWING IN event in webRtcEp: " + WebRtcChannel.AUDIO_AND_VIDEO,        flowingLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    Assert.assertTrue(        "Not received media (timeout waiting playing event): " + WebRtcChannel.AUDIO_AND_VIDEO,        getPage().waitForEvent("playing"));    // Guard time to play the video    waitSeconds(PLAYTIME);    // Assertions    double currentTime = getPage().getCurrentTime();    Assert.assertTrue(        "Error in play time (expected: " + PLAYTIME + " sec, real: " + currentTime + " sec)",        getPage().compare(PLAYTIME, currentTime));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2015 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import static org.kurento.commons.PropertiesManager.getProperty;import java.io.IOException;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserConfig;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;import org.kurento.test.latency.LatencyController;import org.kurento.test.monitor.SystemMonitorManager;/** * WebRTC one to many test. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> N X WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint presenter connected to N viewers</li> * <li>(Browser) 1 WebRtcPeer in send-only sends media. N WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag of the viewers</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.0.5 */public class WebRtcFourOneToManyTest extends FunctionalTest {  private static final int PLAYTIME = 40; // seconds  private static final int DEFAULT_NUM_VIEWERS = 3;  private static int numViewers;  private SystemMonitorManager monitor;  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    numViewers = getProperty("webrtc.one2many.numviewers", DEFAULT_NUM_VIEWERS);    // Test: 1 presenter + N viewers (all local Chrome's)    TestScenario test = new TestScenario();    test.addBrowser(BrowserConfig.PRESENTER,        new Browser.Builder().webPageType(WebPageType.WEBRTC).browserType(BrowserType.CHROME)            .scope(BrowserScope.LOCAL).video(getTestFilesDiskPath() + "/video/15sec/rgbHD.y4m")            .build());    test.addBrowser(BrowserConfig.VIEWER,        new Browser.Builder().webPageType(WebPageType.WEBRTC).browserType(BrowserType.CHROME)            .scope(BrowserScope.LOCAL).numInstances(numViewers).build());    return Arrays.asList(new Object[][] { { test } });  }  // TODO: Commented due to Hijack issue on Docker  // @Before  // public void setupMonitor() {  // setDeleteLogsIfSuccess(false);  // monitor = new SystemMonitorManager();  // monitor.setShowLantency(true);  // monitor.startMonitoring();  // }  //  // @After  // public void teardownMonitor() throws IOException {  // if (monitor != null) {  // monitor.stop();  // monitor.writeResults(getDefaultOutputFile("-monitor.csv"));  // monitor.destroy();  // }  // }  @Test  public void testWebRtcOneToManyChrome() throws InterruptedException, IOException {    // Media Pipeline    final MediaPipeline mp = kurentoClient.createMediaPipeline();    final WebRtcEndpoint masterWebRtcEp = new WebRtcEndpoint.Builder(mp).build();    // Assets for viewers    final LatencyController[] cs = new LatencyController[numViewers];    final WebRtcEndpoint[] viewerWebRtcEPs = new WebRtcEndpoint[numViewers];    final CountDownLatch latch = new CountDownLatch(numViewers);    // Presenter    getPresenter().subscribeLocalEvents("playing");    getPresenter().initWebRtc(masterWebRtcEp, WebRtcChannel.VIDEO_ONLY, WebRtcMode.SEND_ONLY);    if (monitor != null) {      monitor.addWebRtcClientAndActivateOutboundStats(getPresenter().getBrowser().getId(),          masterWebRtcEp, getPresenter(), "webRtcPeer.peerConnection");    }    // Viewers    ExecutorService exec = Executors.newFixedThreadPool(numViewers);    for (int j = 0; j < numViewers; j++) {      final int i = j;      Thread thread = new Thread() {        @Override        public void run() {          try {            viewerWebRtcEPs[i] = new WebRtcEndpoint.Builder(mp).build();            masterWebRtcEp.connect(viewerWebRtcEPs[i]);            if (monitor != null) {              monitor.incrementNumClients();            }            // Latency control            String name = getViewer(i).getBrowser().getId();            cs[i] = new LatencyController(name, monitor);            // WebRTC            getViewer(i).subscribeEvents("playing");            getViewer(i).initWebRtc(viewerWebRtcEPs[i], WebRtcChannel.VIDEO_ONLY,                WebRtcMode.RCV_ONLY);            if (monitor != null) {              monitor.addWebRtcClientAndActivateInboundStats(getViewer(i).getBrowser().getId(),                  viewerWebRtcEPs[i], getViewer(i), "webRtcPeer.peerConnection");            }            // Latency assessment            cs[i].checkLatency(PLAYTIME, TimeUnit.SECONDS, getPresenter(), getViewer(i));            cs[i].drawChart(getDefaultOutputFile("-" + name + "-latency.png"), 500, 270);            cs[i].writeCsv(getDefaultOutputFile("-" + name + "-latency.csv"));            cs[i].logLatencyErrorrs();          } catch (Exception e) {            e.printStackTrace();          } finally {            latch.countDown();            if (monitor != null) {              monitor.decrementNumClients();            }          }        }      };      exec.execute(thread);    }    // Wait to finish viewers threads    latch.await();    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Collection;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.FaceOverlayFilter;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * WebRTC in loopback with a FaceOverlayFilter. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> FaceOverlayFilter -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback with a FaceOverlayFilter</li> * <li>(Browser) WebRtcPeer in send-receive mode and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Play time in remote video should be as expected</li> * <li>The color of the received video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.0.5 */public class WebRtcOneFaceOverlayTest extends FunctionalTest {  private static final int DEFAULT_PLAYTIME = 10; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromeAndFirefox();  }  @Test  public void testWebRtcFaceOverlay() throws InterruptedException {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    FaceOverlayFilter faceOverlayFilter = new FaceOverlayFilter.Builder(mp).build();    webRtcEndpoint.connect(faceOverlayFilter);    faceOverlayFilter.connect(webRtcEndpoint);    // Start WebRTC and wait for playing event    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage().waitForEvent("playing"));    // Guard time to play the video    int playTime = Integer.parseInt(        System.getProperty("test.webrtcfaceoverlay.playtime", String.valueOf(DEFAULT_PLAYTIME)));    waitSeconds(playTime);    // Assertions    double currentTime = getPage().getCurrentTime();    Assert.assertTrue(        "Error in play time (expected: " + playTime + " sec, real: " + currentTime + " sec)",        getPage().compare(playTime, currentTime));    Assert.assertTrue("The color of the video should be green",        getPage().similarColor(CHROME_VIDEOTEST_COLOR));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.EventListener;import org.kurento.client.MediaFlowInStateChangeEvent;import org.kurento.client.MediaFlowState;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * WebRTC in loopback. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback <br> * <li>(Browser) WebRtcPeer in send-receive mode sends and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Play time in remote video should be as expected</li> * <li>The color of the received video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */public class WebRtcOneLoopbackTest extends FunctionalTest {  private static final int PLAYTIME = 10; // seconds to play in WebRTC  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChrome();  }  @Test  public void testWebRtcLoopback() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    webRtcEndpoint.connect(webRtcEndpoint);    final CountDownLatch flowingLatch = new CountDownLatch(1);    webRtcEndpoint        .addMediaFlowInStateChangeListener(new EventListener<MediaFlowInStateChangeEvent>() {          @Override          public void onEvent(MediaFlowInStateChangeEvent event) {            if (event.getState().equals(MediaFlowState.FLOWING)) {              flowingLatch.countDown();            }          }        });    // Start WebRTC and wait for playing event    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    Assert.assertTrue("Not received FLOWING IN event in webRtcEp: " + WebRtcChannel.AUDIO_AND_VIDEO,        flowingLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    Assert.assertTrue(        "Not received media (timeout waiting playing event): " + WebRtcChannel.AUDIO_AND_VIDEO,        getPage().waitForEvent("playing"));    // Guard time to play the video    waitSeconds(PLAYTIME);    // Assertions    double currentTime = getPage().getCurrentTime();    Assert.assertTrue(        "Error in play time (expected: " + PLAYTIME + " sec, real: " + currentTime + " sec)",        getPage().compare(PLAYTIME, currentTime));    Assert.assertTrue("The color of the video should be green",        getPage().similarColor(CHROME_VIDEOTEST_COLOR));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2018 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Arrays;import java.util.Collection;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserConfig;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;/** * WebRTC one to one test. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint presenter connected to 1 viewer</li> * <li>(Browser) 1 WebRtcPeer in send-only sends media. 1 WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag of the viewers</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 6.7.2 */public class WebRtcOneToOneTest extends FunctionalTest {  private static final int PLAYTIME = 30; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    // Test: 1 presenter and 1 viewer    TestScenario test = new TestScenario();    test.addBrowser(BrowserConfig.PRESENTER,        new Browser.Builder().webPageType(WebPageType.WEBRTC).browserType(BrowserType.CHROME)            .scope(BrowserScope.LOCAL).build());    test.addBrowser(BrowserConfig.VIEWER,        new Browser.Builder().webPageType(WebPageType.WEBRTC).browserType(BrowserType.CHROME)            .scope(BrowserScope.LOCAL).build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testWebRtcOneToOneChrome() throws Exception {    // Media Pipeline    final MediaPipeline mp = kurentoClient.createMediaPipeline();    final WebRtcEndpoint masterWebRtcEp = new WebRtcEndpoint.Builder(mp).build();    final WebRtcEndpoint viewerWebRtcEP = new WebRtcEndpoint.Builder(mp).build();    masterWebRtcEp.connect(viewerWebRtcEP);        // WebRTC setup    getPresenter().initWebRtc(masterWebRtcEp, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_ONLY);    getViewer().initWebRtc(viewerWebRtcEP, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    getViewer().subscribeEvents("playing");    // Guard time to play the video    waitSeconds(PLAYTIME);    // Assertions    double currentTime = getViewer().getCurrentTime();    Assert.assertTrue("Error in play time (expected: " + PLAYTIME + " sec, real: "        + currentTime + " sec)", getViewer().compare(PLAYTIME, currentTime));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Collection;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.ConsoleLogLevel;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * Back-To-Back WebRTC switch. Three clients: A,B,C sets up WebRTC send-recv with audio/video. * Switch between following scenarios: A<->B, A<->C, B<->C. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback</li> * <li>(Browser) WebRtcPeer in send-receive mode and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Play time in remote video should be as expected</li> * <li>The color of the received video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */public class WebRtcThreeSwitchTest extends FunctionalTest {  private static final int PLAYTIME = 5; // seconds  private static final int NUM_BROWSERS = 3;  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromesAndFirefoxs(NUM_BROWSERS);  }  @Test  public void testWebRtcSwitch() throws InterruptedException {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint[] webRtcEndpoints = new WebRtcEndpoint[NUM_BROWSERS];    for (int i = 0; i < NUM_BROWSERS; i++) {      webRtcEndpoints[i] = new WebRtcEndpoint.Builder(mp).build();      webRtcEndpoints[i].connect(webRtcEndpoints[i]);      // Start WebRTC in loopback in each browser      getPage(i).subscribeEvents("playing");      getPage(i).initWebRtc(webRtcEndpoints[i], WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);      // Delay time (to avoid the same timing in videos)      waitSeconds(1);      // Wait until event playing in the remote streams      Assert.assertTrue("Not received media #1 (timeout waiting playing event)",          getPage(i).waitForEvent("playing"));      // Assert color      assertColor(i);    }    // Guard time to see switching #0    waitSeconds(PLAYTIME);    // Switching (round #1)    for (int i = 0; i < NUM_BROWSERS; i++) {      int next = i + 1 >= NUM_BROWSERS ? 0 : i + 1;      webRtcEndpoints[i].connect(webRtcEndpoints[next]);      getPage(i).consoleLog(ConsoleLogLevel.INFO,          "Switch #1: webRtcEndpoint" + i + " -> webRtcEndpoint" + next);      // Assert color      assertColor(i);    }    // Guard time to see switching #1    waitSeconds(PLAYTIME);    // Switching (round #2)    for (int i = 0; i < NUM_BROWSERS; i++) {      int previous = i - 1 < 0 ? NUM_BROWSERS - 1 : i - 1;      webRtcEndpoints[i].connect(webRtcEndpoints[previous]);      getPage(i).consoleLog(ConsoleLogLevel.INFO,          "Switch #2: webRtcEndpoint" + i + " -> webRtcEndpoint" + previous);      // Assert color      assertColor(i);    }    // Guard time to see switching #2    waitSeconds(PLAYTIME);    // Release Media Pipeline    mp.release();  }  public void assertColor(int index) {    Assert.assertTrue("The color of the video should be green",        getPage(index).similarColor(CHROME_VIDEOTEST_COLOR));  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Collection;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.FaceOverlayFilter;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * WebRTC in loopback with a FaceOverlayFilter. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> FaceOverlayFilter -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback with a FaceOverlayFilter</li> * <li>(Browser) WebRtcPeer in send-receive mode and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Play time in remote video should be as expected</li> * <li>The color of the received video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.0.5 */public class WebRtcOneFaceOverlayTest extends FunctionalTest {  private static final int DEFAULT_PLAYTIME = 10; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromeAndFirefox();  }  @Test  public void testWebRtcFaceOverlay() throws InterruptedException {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    FaceOverlayFilter faceOverlayFilter = new FaceOverlayFilter.Builder(mp).build();    webRtcEndpoint.connect(faceOverlayFilter);    faceOverlayFilter.connect(webRtcEndpoint);    // Start WebRTC and wait for playing event    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage().waitForEvent("playing"));    // Guard time to play the video    int playTime = Integer.parseInt(        System.getProperty("test.webrtcfaceoverlay.playtime", String.valueOf(DEFAULT_PLAYTIME)));    waitSeconds(playTime);    // Assertions    double currentTime = getPage().getCurrentTime();    Assert.assertTrue(        "Error in play time (expected: " + playTime + " sec, real: " + currentTime + " sec)",        getPage().compare(playTime, currentTime));    Assert.assertTrue("The color of the video should be green",        getPage().similarColor(CHROME_VIDEOTEST_COLOR));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.EventListener;import org.kurento.client.MediaFlowInStateChangeEvent;import org.kurento.client.MediaFlowState;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * WebRTC in loopback. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback <br> * <li>(Browser) WebRtcPeer in send-receive mode sends and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Play time in remote video should be as expected</li> * <li>The color of the received video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */public class WebRtcOneLoopbackTest extends FunctionalTest {  private static final int PLAYTIME = 10; // seconds to play in WebRTC  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChrome();  }  @Test  public void testWebRtcLoopback() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    webRtcEndpoint.connect(webRtcEndpoint);    final CountDownLatch flowingLatch = new CountDownLatch(1);    webRtcEndpoint        .addMediaFlowInStateChangeListener(new EventListener<MediaFlowInStateChangeEvent>() {          @Override          public void onEvent(MediaFlowInStateChangeEvent event) {            if (event.getState().equals(MediaFlowState.FLOWING)) {              flowingLatch.countDown();            }          }        });    // Start WebRTC and wait for playing event    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    Assert.assertTrue("Not received FLOWING IN event in webRtcEp: " + WebRtcChannel.AUDIO_AND_VIDEO,        flowingLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    Assert.assertTrue(        "Not received media (timeout waiting playing event): " + WebRtcChannel.AUDIO_AND_VIDEO,        getPage().waitForEvent("playing"));    // Guard time to play the video    waitSeconds(PLAYTIME);    // Assertions    double currentTime = getPage().getCurrentTime();    Assert.assertTrue(        "Error in play time (expected: " + PLAYTIME + " sec, real: " + currentTime + " sec)",        getPage().compare(PLAYTIME, currentTime));    Assert.assertTrue("The color of the video should be green",        getPage().similarColor(CHROME_VIDEOTEST_COLOR));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2018 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Arrays;import java.util.Collection;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserConfig;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;/** * WebRTC one to one test. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint presenter connected to 1 viewer</li> * <li>(Browser) 1 WebRtcPeer in send-only sends media. 1 WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag of the viewers</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 6.7.2 */public class WebRtcOneToOneTest extends FunctionalTest {  private static final int PLAYTIME = 30; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    // Test: 1 presenter and 1 viewer    TestScenario test = new TestScenario();    test.addBrowser(BrowserConfig.PRESENTER,        new Browser.Builder().webPageType(WebPageType.WEBRTC).browserType(BrowserType.CHROME)            .scope(BrowserScope.LOCAL).build());    test.addBrowser(BrowserConfig.VIEWER,        new Browser.Builder().webPageType(WebPageType.WEBRTC).browserType(BrowserType.CHROME)            .scope(BrowserScope.LOCAL).build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testWebRtcOneToOneChrome() throws Exception {    // Media Pipeline    final MediaPipeline mp = kurentoClient.createMediaPipeline();    final WebRtcEndpoint masterWebRtcEp = new WebRtcEndpoint.Builder(mp).build();    final WebRtcEndpoint viewerWebRtcEP = new WebRtcEndpoint.Builder(mp).build();    masterWebRtcEp.connect(viewerWebRtcEP);        // WebRTC setup    getPresenter().initWebRtc(masterWebRtcEp, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_ONLY);    getViewer().initWebRtc(viewerWebRtcEP, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    getViewer().subscribeEvents("playing");    // Guard time to play the video    waitSeconds(PLAYTIME);    // Assertions    double currentTime = getViewer().getCurrentTime();    Assert.assertTrue("Error in play time (expected: " + PLAYTIME + " sec, real: "        + currentTime + " sec)", getViewer().compare(PLAYTIME, currentTime));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Collection;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.FaceOverlayFilter;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * WebRTC in loopback with a FaceOverlayFilter. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> FaceOverlayFilter -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback with a FaceOverlayFilter</li> * <li>(Browser) WebRtcPeer in send-receive mode and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Play time in remote video should be as expected</li> * <li>The color of the received video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.0.5 */public class WebRtcOneFaceOverlayTest extends FunctionalTest {  private static final int DEFAULT_PLAYTIME = 10; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromeAndFirefox();  }  @Test  public void testWebRtcFaceOverlay() throws InterruptedException {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    FaceOverlayFilter faceOverlayFilter = new FaceOverlayFilter.Builder(mp).build();    webRtcEndpoint.connect(faceOverlayFilter);    faceOverlayFilter.connect(webRtcEndpoint);    // Start WebRTC and wait for playing event    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage().waitForEvent("playing"));    // Guard time to play the video    int playTime = Integer.parseInt(        System.getProperty("test.webrtcfaceoverlay.playtime", String.valueOf(DEFAULT_PLAYTIME)));    waitSeconds(playTime);    // Assertions    double currentTime = getPage().getCurrentTime();    Assert.assertTrue(        "Error in play time (expected: " + playTime + " sec, real: " + currentTime + " sec)",        getPage().compare(playTime, currentTime));    Assert.assertTrue("The color of the video should be green",        getPage().similarColor(CHROME_VIDEOTEST_COLOR));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Collection;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.EventListener;import org.kurento.client.MediaFlowInStateChangeEvent;import org.kurento.client.MediaFlowState;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * WebRTC in loopback. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * <li>Firefox</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback <br> * <li>(Browser) WebRtcPeer in send-receive mode sends and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Play time in remote video should be as expected</li> * <li>The color of the received video should be as expected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 4.2.3 */public class WebRtcOneLoopbackTest extends FunctionalTest {  private static final int PLAYTIME = 10; // seconds to play in WebRTC  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChrome();  }  @Test  public void testWebRtcLoopback() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    webRtcEndpoint.connect(webRtcEndpoint);    final CountDownLatch flowingLatch = new CountDownLatch(1);    webRtcEndpoint        .addMediaFlowInStateChangeListener(new EventListener<MediaFlowInStateChangeEvent>() {          @Override          public void onEvent(MediaFlowInStateChangeEvent event) {            if (event.getState().equals(MediaFlowState.FLOWING)) {              flowingLatch.countDown();            }          }        });    // Start WebRTC and wait for playing event    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_RCV);    Assert.assertTrue("Not received FLOWING IN event in webRtcEp: " + WebRtcChannel.AUDIO_AND_VIDEO,        flowingLatch.await(getPage().getTimeout(), TimeUnit.SECONDS));    Assert.assertTrue(        "Not received media (timeout waiting playing event): " + WebRtcChannel.AUDIO_AND_VIDEO,        getPage().waitForEvent("playing"));    // Guard time to play the video    waitSeconds(PLAYTIME);    // Assertions    double currentTime = getPage().getCurrentTime();    Assert.assertTrue(        "Error in play time (expected: " + PLAYTIME + " sec, real: " + currentTime + " sec)",        getPage().compare(PLAYTIME, currentTime));    Assert.assertTrue("The color of the video should be green",        getPage().similarColor(CHROME_VIDEOTEST_COLOR));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2018 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.webrtc;import java.util.Arrays;import java.util.Collection;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserConfig;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;/** * WebRTC one to one test. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint presenter connected to 1 viewer</li> * <li>(Browser) 1 WebRtcPeer in send-only sends media. 1 WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag of the viewers</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 6.7.2 */public class WebRtcOneToOneTest extends FunctionalTest {  private static final int PLAYTIME = 30; // seconds  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    // Test: 1 presenter and 1 viewer    TestScenario test = new TestScenario();    test.addBrowser(BrowserConfig.PRESENTER,        new Browser.Builder().webPageType(WebPageType.WEBRTC).browserType(BrowserType.CHROME)            .scope(BrowserScope.LOCAL).build());    test.addBrowser(BrowserConfig.VIEWER,        new Browser.Builder().webPageType(WebPageType.WEBRTC).browserType(BrowserType.CHROME)            .scope(BrowserScope.LOCAL).build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testWebRtcOneToOneChrome() throws Exception {    // Media Pipeline    final MediaPipeline mp = kurentoClient.createMediaPipeline();    final WebRtcEndpoint masterWebRtcEp = new WebRtcEndpoint.Builder(mp).build();    final WebRtcEndpoint viewerWebRtcEP = new WebRtcEndpoint.Builder(mp).build();    masterWebRtcEp.connect(viewerWebRtcEP);        // WebRTC setup    getPresenter().initWebRtc(masterWebRtcEp, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.SEND_ONLY);    getViewer().initWebRtc(viewerWebRtcEP, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY);    getViewer().subscribeEvents("playing");    // Guard time to play the video    waitSeconds(PLAYTIME);    // Assertions    double currentTime = getViewer().getCurrentTime();    Assert.assertTrue("Error in play time (expected: " + PLAYTIME + " sec, real: "        + currentTime + " sec)", getViewer().compare(PLAYTIME, currentTime));    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.functional.datachannels;import java.util.Collection;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.FunctionalTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;/** * Test Datachannel Back2Back Browser - WebRTC - WebRTC - Browser * </ul> * Browser(s): * <ul> * ·CHROME CHROME <br> * ·CHROME FIREFOX <br> * ·CHROME FIREFOX-BETA <br> * ·CHROME-BETA CHROME-BETA <br> * ·CHROME-BETA FIREFOX <br> * ·CHROME-BETA FIREFOX-BETA <br> * ·CHROME-DEV CHROME-DEV <br> * ·CHROME-DEV FIREFOX <br> * ·CHROME-DEV FIREFOX-BETA <br> * ·FIREFOX FIREFOX <br> * ·FIREFOX CHROME <br> * ·FIREFOX CHROME-BETA <br> * ·FIREFOX CHROME-DEV <br> * ·FIREFOX-BETA FIREFOX-BETA <br> * ·FIREFOX-BETA CHROME <br> * ·FIREFOX-BETA CHROME-BETA <br> * ·FIREFOX-BETA CHROME-DEV <br> * </ul> * Test logic: * <ol> * <li>Start two browsers with data channel</li> * <li>Send 50 messages between both browsers</li> * </ol> * Main assertion(s): <br> * All messages must be right in both browsers * * @author Raul Benitez (rbenitez@gsyc.es) * @since 6.4.1 */public class DatachannelsB2BTest extends FunctionalTest {  private Integer TIMES = 50;  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localChromesAndFirefoxs(2);  }  @Test  public void testDispatcherPlayer() throws Exception {    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEp = new WebRtcEndpoint.Builder(mp).useDataChannels().build();    WebRtcEndpoint webRtcEp2 = new WebRtcEndpoint.Builder(mp).useDataChannels().build();    webRtcEp.connect(webRtcEp2);    webRtcEp2.connect(webRtcEp);    // Test execution    getPage(0).initWebRtc(webRtcEp, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY, true);    getPage(1).initWebRtc(webRtcEp2, WebRtcChannel.AUDIO_AND_VIDEO, WebRtcMode.RCV_ONLY, true);    Thread.sleep(8000);    for (int i = 0; i < TIMES; i++) {      String messageSentBrower0 = "Data sent from the browser0. Message" + i;      String messageSentBrower1 = "Data sent from the browser1. Message" + i;      getPage(0).sendDataByDataChannel(messageSentBrower0);      getPage(1).sendDataByDataChannel(messageSentBrower1);      Assert.assertTrue("The message should be: " + messageSentBrower1,          getPage(0).compareDataChannelMessage(messageSentBrower1));      Assert.assertTrue("The message should be: " + messageSentBrower0,          getPage(1).compareDataChannelMessage(messageSentBrower0));    }    // Release Media Pipeline    mp.release();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.stability.pipeline;import java.util.ArrayList;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.kurento.client.EventListener;import org.kurento.client.ListenerSubscription;import org.kurento.client.MediaPipeline;import org.kurento.client.ObjectCreatedEvent;import org.kurento.client.ObjectDestroyedEvent;/** * Stability test for Pipelines. <br/> * Test logic: <br/> * The logic is executed twice, the first is to stabilize the memory on the KMS, and in the second * the memory is checked. * <ol> * <li>N grows exponentially in base 2</li> * <li>Create N pipelines.</li> * <li>Release N pipelines</li> * </ol> * Main assertion(s): * <ul> * <li>N Object_Created are received</li> * <li>N Object_Destroyed are received</li> * <li>The % of the memory is between 0 and 10. * </ul> * * * @author Raul Benitez (rbenitez@gsyc.es) * @since 6.5.1 */public class PipelineStabilityCreateDestroyPipelinesTest extends BasePipeline {  private int INCREASE_EXPONENTIAL = 2;  private int ITERATIONS = 13;  private ObjectsLatch objectsLatch;  @Test  public void testCreateDestroyPipelines() throws Exception {    doTest(false);    doTest(true);  }  /**   *   * @param checkMemory   *          Activate the memory assert.   * @throws Exception   */  private void doTest(boolean checkMemory) throws Exception {    initMemory();    ListenerSubscription listenerObjectCreated =        getServerManager().addObjectCreatedListener(new EventListener<ObjectCreatedEvent>() {          @Override          public void onEvent(ObjectCreatedEvent event) {            objectsLatch.getObjectsCreatedLatch().countDown();          }        });    ListenerSubscription listenerObjectDestroyed =        getServerManager().addObjectDestroyedListener(new EventListener<ObjectDestroyedEvent>() {          @Override          public void onEvent(ObjectDestroyedEvent event) {            objectsLatch.getObjectsDestroyedLatch().countDown();          }        });    int objectsToCreate = 0;    for (int i = 1; i <= ITERATIONS; i++) {      objectsToCreate = (int) Math.pow(INCREASE_EXPONENTIAL, i);      log.debug("Create {} MediaPipelines", objectsToCreate);      ArrayList<MediaPipeline> mediaPipelines = new ArrayList<MediaPipeline>();      objectsLatch = new ObjectsLatch(objectsToCreate);      for (int j = 0; j < objectsToCreate; j++) {        MediaPipeline mp = kurentoClient.createMediaPipeline();        mediaPipelines.add(mp);      }      // Wait to all pipelines are created      Assert.assertTrue(          "The Objects are not created properly. Expected: " + objectsToCreate + ". No received "              + (objectsToCreate - objectsLatch.getObjectsCreatedLatch().getCount())              + " ObjectCreated event(s)",          objectsLatch.getObjectsCreatedLatch().await(TIMEOUT, TimeUnit.SECONDS));      // Release each MediaPipeline      for (MediaPipeline pipeline : mediaPipelines) {        pipeline.release();      }      Assert.assertTrue(          "The Objects are not destroyed properly. Expected: " + objectsToCreate + ". No received "              + (objectsToCreate - objectsLatch.getObjectsDestroyedLatch().getCount())              + " ObjectDestroyed event(s)",          objectsLatch.getObjectsDestroyedLatch().await(TIMEOUT, TimeUnit.SECONDS));      // Verify the memory      double percentageMemory = getMemoryIncrease();      if (checkMemory) {        Assert.assertTrue(            "The memory increases more than 0%. The percentage memory was " + percentageMemory,            percentageMemory >= 0.0 && percentageMemory <= 10.0);      }    }    getServerManager().removeObjectCreatedListener(listenerObjectCreated);    getServerManager().removeObjectDestroyedListener(listenerObjectDestroyed);  }}
/* * (C) Copyright 2015 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.stability.webrtc;import java.util.Collection;import java.util.concurrent.TimeUnit;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.StabilityTest;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.TestScenario;import org.kurento.test.latency.LatencyController;/** * Stability test for switching a WebRTC in one to one communication. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint (back-to-back)(x2)</li> * </ul> * Browser(s): * <ul> * <li>2 x Chrome (presenter and viewer)</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint presenter and viewer</li> * <li>(Browser) 1 WebRtcPeer in send-only sends media. N WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Color change should be detected on local/remote video tag of browsers</li> * <li>Test fail when 3 consecutive latency errors (latency > 3sec) are detected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.1.0 */public class WebRtcStabilityBack2BackTest extends StabilityTest {  private static final int DEFAULT_PLAYTIME = 30; // minutes  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return TestScenario.localPresenterAndViewerRgb();  }  @Test  public void testWebRtcStabilityBack2Back() throws Exception {    final int playTime = Integer.parseInt(System        .getProperty("test.webrtc.stability.back2back.playtime", String.valueOf(DEFAULT_PLAYTIME)));    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint1 = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEndpoint2 = new WebRtcEndpoint.Builder(mp).build();    webRtcEndpoint1.connect(webRtcEndpoint2);    webRtcEndpoint2.connect(webRtcEndpoint1);    // Latency control    LatencyController cs = new LatencyController("WebRTC latency control");    // WebRTC    getPresenter().subscribeLocalEvents("playing");    getPresenter().initWebRtc(webRtcEndpoint1, WebRtcChannel.VIDEO_ONLY, WebRtcMode.SEND_ONLY);    getViewer().subscribeEvents("playing");    getViewer().initWebRtc(webRtcEndpoint2, WebRtcChannel.VIDEO_ONLY, WebRtcMode.RCV_ONLY);    // Latency assessment    cs.checkLatency(playTime, TimeUnit.MINUTES, getPresenter(), getViewer());    // Release Media Pipeline    mp.release();    // Draw latency results (PNG chart and CSV file)    cs.drawChart(getDefaultOutputFile(".png"), 500, 270);    cs.writeCsv(getDefaultOutputFile(".csv"));    cs.logLatencyErrorrs();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.stability.webrtc;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.TimeUnit;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.KurentoTest;import org.kurento.test.base.StabilityTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserConfig;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;import org.kurento.test.latency.LatencyController;import org.kurento.test.latency.VideoTagType;/** * Stability test for WebRTC in loopback during a long time (configurable). * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint (loopback)</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback.</li> * <li>(Browser) WebRtcPeer in send-receive mode sends and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Color change should be detected on local/remote video tag of browsers</li> * <li>Test fail when 3 consecutive latency errors (latency > 3sec) are detected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.0.5 */public class WebRtcStabilityLoopbackTest extends StabilityTest {  private static final int DEFAULT_PLAYTIME = 30; // minutes  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    String videoPath = KurentoTest.getTestFilesDiskPath() + "/video/15sec/rgbHD.y4m";    TestScenario test = new TestScenario();    test.addBrowser(BrowserConfig.BROWSER, new Browser.Builder().webPageType(WebPageType.WEBRTC)        .browserType(BrowserType.CHROME).scope(BrowserScope.LOCAL).video(videoPath).build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testWebRtcStabilityLoopback() throws Exception {    final int playTime = Integer.parseInt(        System.getProperty("test.webrtcstability.playtime", String.valueOf(DEFAULT_PLAYTIME)));    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    webRtcEndpoint.connect(webRtcEndpoint);    // WebRTC    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.VIDEO_ONLY, WebRtcMode.SEND_RCV);    // Latency assessment    LatencyController cs = new LatencyController("WebRTC in loopback");    getPage().activateLatencyControl(VideoTagType.LOCAL.getId(), VideoTagType.REMOTE.getId());    cs.checkLatency(playTime, TimeUnit.MINUTES, getPage());    // Release Media Pipeline    mp.release();    // Draw latency results (PNG chart and CSV file)    cs.drawChart(getDefaultOutputFile(".png"), 500, 270);    cs.writeCsv(getDefaultOutputFile(".csv"));    cs.logLatencyErrorrs();  }}
/* * (C) Copyright 2015 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.stability.webrtc;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.RtpEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.KurentoTest;import org.kurento.test.base.StabilityTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserConfig;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;import org.kurento.test.latency.LatencyController;import org.kurento.test.latency.VideoTagType;import org.kurento.test.sdp.SdpUtils;/** * Stability test for switching a WebRTC connected to RTP performing H264 transcoding. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> RtpEndpoint1</li> * <li>RtpEndpoint1 -> RtpEndpoint2 (RTP session)</li> * <li>RtpEndpoint2 -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint to RtpEndpoint. RtpEndpoint to RtpEndpoint. RtpEndpoint to * WebRtcEndpoint.</li> * <li>(Browser) WebRtcPeer in send-receive mode sends and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Color change should be detected on local and remote video tags</li> * <li>Test fail when 3 consecutive latency errors (latency > 3sec) are detected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.1.0 */public class WebRtcStabilityRtpH264Test extends StabilityTest {  private static final int DEFAULT_PLAYTIME = 30; // minutes  private static final String[] REMOVE_CODECS = { "H263-1998", "VP8", "MP4V-ES" };  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    String videoPath = KurentoTest.getTestFilesDiskPath() + "/video/15sec/rgbHD.y4m";    TestScenario test = new TestScenario();    test.addBrowser(BrowserConfig.BROWSER, new Browser.Builder().webPageType(WebPageType.WEBRTC)        .browserType(BrowserType.CHROME).scope(BrowserScope.LOCAL).video(videoPath).build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testWebRtcStabilityRtpH264() throws Exception {    final int playTime =        Integer.parseInt(System.getProperty("test.webrtc.stability.switch.webrtc2rtp.playtime",            String.valueOf(DEFAULT_PLAYTIME)));    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    RtpEndpoint rtpEndpoint1 = new RtpEndpoint.Builder(mp).build();    RtpEndpoint rtpEndpoint2 = new RtpEndpoint.Builder(mp).build();    webRtcEndpoint.connect(rtpEndpoint1);    rtpEndpoint2.connect(webRtcEndpoint);    // RTP session (rtpEndpoint1 --> rtpEndpoint2)    String sdpOffer = rtpEndpoint1.generateOffer();    log.debug("SDP offer in rtpEndpoint1\n{}", sdpOffer);    // SDP mangling    sdpOffer = SdpUtils.mangleSdp(sdpOffer, REMOVE_CODECS);    log.debug("SDP offer in rtpEndpoint1 after mangling\n{}", sdpOffer);    String sdpAnswer1 = rtpEndpoint2.processOffer(sdpOffer);    log.debug("SDP answer in rtpEndpoint2\n{}", sdpAnswer1);    String sdpAnswer2 = rtpEndpoint1.processAnswer(sdpAnswer1);    log.debug("SDP answer in rtpEndpoint1\n{}", sdpAnswer2);    // Latency controller    LatencyController cs = new LatencyController();    // WebRTC    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.VIDEO_ONLY, WebRtcMode.SEND_RCV);    // Assertion: wait to playing event in browser    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage().waitForEvent("playing"));    // Latency assessment    getPage().activateLatencyControl(VideoTagType.LOCAL.getId(), VideoTagType.REMOTE.getId());    cs.checkLatency(playTime, TimeUnit.MINUTES, getPage());    // Release Media Pipeline    mp.release();    // Draw latency results (PNG chart and CSV file)    cs.drawChart(getDefaultOutputFile(".png"), 500, 270);    cs.writeCsv(getDefaultOutputFile(".csv"));    cs.logLatencyErrorrs();  }}
/* * (C) Copyright 2015 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.stability.webrtc;import java.util.Arrays;import java.util.Collection;import java.util.concurrent.TimeUnit;import org.junit.Assert;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.RtpEndpoint;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.KurentoTest;import org.kurento.test.base.StabilityTest;import org.kurento.test.browser.Browser;import org.kurento.test.browser.BrowserType;import org.kurento.test.browser.WebPageType;import org.kurento.test.browser.WebRtcChannel;import org.kurento.test.browser.WebRtcMode;import org.kurento.test.config.BrowserConfig;import org.kurento.test.config.BrowserScope;import org.kurento.test.config.TestScenario;import org.kurento.test.latency.LatencyController;import org.kurento.test.latency.VideoTagType;import org.kurento.test.sdp.SdpUtils;/** * Stability test for switching a WebRTC connected to RTP performing H264 transcoding. * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> RtpEndpoint1</li> * <li>RtpEndpoint1 -> RtpEndpoint2 (RTP session)</li> * <li>RtpEndpoint2 -> WebRtcEndpoint</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint to RtpEndpoint. RtpEndpoint to RtpEndpoint. RtpEndpoint to * WebRtcEndpoint.</li> * <li>(Browser) WebRtcPeer in send-receive mode sends and receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Playing event should be received in remote video tag</li> * <li>Color change should be detected on local and remote video tags</li> * <li>Test fail when 3 consecutive latency errors (latency > 3sec) are detected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.1.0 */public class WebRtcStabilitySwitchRtpH264Test extends StabilityTest {  private static final int DEFAULT_PLAYTIME = 30; // minutes  private static final String[] REMOVE_CODECS = { "H263-1998", "VP8", "MP4V-ES" };  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    String videoPath = KurentoTest.getTestFilesDiskPath() + "/video/15sec/rgbHD.y4m";    TestScenario test = new TestScenario();    test.addBrowser(BrowserConfig.BROWSER, new Browser.Builder().webPageType(WebPageType.WEBRTC)        .browserType(BrowserType.CHROME).scope(BrowserScope.LOCAL).video(videoPath).build());    return Arrays.asList(new Object[][] { { test } });  }  @Test  public void testWebRtcStabilitySwitchRtpH264() throws Exception {    final int playTime =        Integer.parseInt(System.getProperty("test.webrtc.stability.switch.webrtc2rtp.playtime",            String.valueOf(DEFAULT_PLAYTIME)));    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint = new WebRtcEndpoint.Builder(mp).build();    RtpEndpoint rtpEndpoint1 = new RtpEndpoint.Builder(mp).build();    RtpEndpoint rtpEndpoint2 = new RtpEndpoint.Builder(mp).build();    webRtcEndpoint.connect(rtpEndpoint1);    rtpEndpoint2.connect(webRtcEndpoint);    // RTP session (rtpEndpoint1 --> rtpEndpoint2)    String sdpOffer = rtpEndpoint1.generateOffer();    log.debug("SDP offer in rtpEndpoint1\n{}", sdpOffer);    // SDP mangling    sdpOffer = SdpUtils.mangleSdp(sdpOffer, REMOVE_CODECS);    log.debug("SDP offer in rtpEndpoint1 after mangling\n{}", sdpOffer);    String sdpAnswer1 = rtpEndpoint2.processOffer(sdpOffer);    log.debug("SDP answer in rtpEndpoint2\n{}", sdpAnswer1);    String sdpAnswer2 = rtpEndpoint1.processAnswer(sdpAnswer1);    log.debug("SDP answer in rtpEndpoint1\n{}", sdpAnswer2);    // Latency controller    LatencyController cs = new LatencyController();    // WebRTC    getPage().subscribeEvents("playing");    getPage().initWebRtc(webRtcEndpoint, WebRtcChannel.VIDEO_ONLY, WebRtcMode.SEND_RCV);    // Assertion: wait to playing event in browser    Assert.assertTrue("Not received media (timeout waiting playing event)",        getPage().waitForEvent("playing"));    // Latency assessment    getPage().activateLatencyControl(VideoTagType.LOCAL.getId(), VideoTagType.REMOTE.getId());    cs.checkLatencyInBackground(playTime, TimeUnit.MINUTES, getPage());    // Connect-disconnect each second    for (int i = 0; i < DEFAULT_PLAYTIME * 60; i++) {      Thread.sleep(TimeUnit.SECONDS.toMillis(1));      rtpEndpoint2.disconnect(webRtcEndpoint);      rtpEndpoint2.connect(webRtcEndpoint);    }    // Release Media Pipeline    mp.release();    // Draw latency results (PNG chart and CSV file)    cs.drawChart(getDefaultOutputFile(".png"), 500, 270);    cs.writeCsv(getDefaultOutputFile(".csv"));    cs.logLatencyErrorrs();  }}
/* * (C) Copyright 2014 Kurento (http://kurento.org/) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */package org.kurento.test.stability.webrtc;import static java.lang.Integer.parseInt;import static java.lang.String.valueOf;import static java.lang.System.getProperty;import static java.lang.Thread.sleep;import static java.util.concurrent.TimeUnit.SECONDS;import static org.kurento.test.browser.WebRtcChannel.VIDEO_ONLY;import static org.kurento.test.browser.WebRtcMode.SEND_RCV;import static org.kurento.test.config.TestScenario.localPresenterAndViewer;import java.util.Collection;import org.junit.Test;import org.junit.runners.Parameterized.Parameters;import org.kurento.client.MediaPipeline;import org.kurento.client.WebRtcEndpoint;import org.kurento.test.base.StabilityTest;/** * Stability test for switching 2 WebRTC (looback to back-2-back) a configurable number of times * (each switch holds 1 second). * </p> * Media Pipeline(s): * <ul> * <li>WebRtcEndpoint -> WebRtcEndpoint (loopback)</li> * <li>WebRtcEndpoint -> WebRtcEndpoint (back to back)</li> * </ul> * Browser(s): * <ul> * <li>Chrome</li> * </ul> * Test logic: * <ol> * <li>(KMS) WebRtcEndpoint in loopback to WebRtcEndpoint in B2B.</li> * <li>(Browser) 1 WebRtcPeer in send-only sends media. N WebRtcPeer in rcv-only receives media</li> * </ol> * Main assertion(s): * <ul> * <li>Color change should be detected on local/remote video tag of browsers</li> * <li>Test fail when 3 consecutive latency errors (latency > 3sec) are detected</li> * </ul> * Secondary assertion(s): * <ul> * <li>--</li> * </ul> * * @author Boni Garcia (bgarcia@gsyc.es) * @since 5.0.5 */public class WebRtcStabilitySwitchTest extends StabilityTest {  private static final int DEFAULT_NUM_SWITCH = 10;  private static final int PLAYTIME_PER_SWITCH = 15; // seconds  // test time = PLAYTIME_PER_SWITCH * 2 * DEFAULT_NUM_SWITCH  @Parameters(name = "{index}: {0}")  public static Collection<Object[]> data() {    return localPresenterAndViewer();  }  @Test  public void testWebRtcStabilitySwitch() throws Exception {    final int numSwitch = parseInt(getProperty("test.webrtcstability.switch", valueOf(DEFAULT_NUM_SWITCH)));    // Media Pipeline    MediaPipeline mp = kurentoClient.createMediaPipeline();    WebRtcEndpoint webRtcEndpoint1 = new WebRtcEndpoint.Builder(mp).build();    WebRtcEndpoint webRtcEndpoint2 = new WebRtcEndpoint.Builder(mp).build();    webRtcEndpoint1.connect(webRtcEndpoint1);    webRtcEndpoint2.connect(webRtcEndpoint2);    // WebRTC    getPresenter().subscribeEvents("playing");    getPresenter().initWebRtc(webRtcEndpoint1, VIDEO_ONLY, SEND_RCV);    getViewer().subscribeEvents("playing");    getViewer().initWebRtc(webRtcEndpoint2, VIDEO_ONLY, SEND_RCV);    for (int i = 0; i < numSwitch; i++) {      if (i % 2 == 0) {        log.debug("Switch #" + i + ": loopback");        webRtcEndpoint1.connect(webRtcEndpoint1);        webRtcEndpoint2.connect(webRtcEndpoint2);      } else {        log.debug("Switch #" + i + ": B2B");        webRtcEndpoint1.connect(webRtcEndpoint2);        webRtcEndpoint2.connect(webRtcEndpoint1);      }      sleep(SECONDS.toMillis(PLAYTIME_PER_SWITCH));    }    // Release Media Pipeline    mp.release();  }}
