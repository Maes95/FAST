/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.concurrentmockito;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  //this test exposes the problem most of the time public class ThreadVerifiesContinuoslyInteractingMockTest extends TestBase {      @Mock private IMethods mock;      @Test     public void shouldAllowVerifyingInThreads() throws Exception {         for(int i = 0; i < 100; i++) {             performTest();         }     }      private void performTest() throws InterruptedException {         mock.simpleMethod();         final Thread[] listeners = new Thread[2];         for (int i = 0; i < listeners.length; i++) {             final int x = i;             listeners[i] = new Thread() {                 @Override                 public void run() {                     try {                         Thread.sleep(x * 10);                     } catch (InterruptedException e) {                         throw new RuntimeException(e);                     }                     mock.simpleMethod();                 }             };             listeners[i].start();         }                  verify(mock, atLeastOnce()).simpleMethod();                  for (int i = 0; i < listeners.length; i++) {             listeners[i].join();         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.concurrentmockito;  import java.util.LinkedList; import java.util.List; import org.junit.Test; import org.junit.runner.JUnitCore; import org.junit.runner.Result; import org.junit.runner.notification.Failure; import org.mockito.MockitoTest; import org.mockito.exceptions.ReporterTest; import org.mockito.exceptions.base.MockitoAssertionErrorTest; import org.mockito.exceptions.base.MockitoExceptionTest; import org.mockito.internal.AllInvocationsFinderTest; import org.mockito.internal.InvalidStateDetectionTest; import org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGeneratorTest; import org.mockito.internal.handler.MockHandlerImplTest; import org.mockito.internal.invocation.InvocationImplTest; import org.mockito.internal.invocation.InvocationMatcherTest; import org.mockito.internal.invocation.InvocationsFinderTest; import org.mockito.internal.matchers.ComparableMatchersTest; import org.mockito.internal.matchers.EqualsTest; import org.mockito.internal.matchers.MatchersToStringTest; import org.mockito.internal.progress.MockingProgressImplTest; import org.mockito.internal.progress.TimesTest; import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValuesTest; import org.mockito.internal.stubbing.defaultanswers.ReturnsGenericDeepStubsTest; import org.mockito.internal.util.MockUtilTest; import org.mockito.internal.util.collections.ListUtilTest; import org.mockito.internal.verification.DefaultRegisteredInvocationsTest; import org.mockito.internal.verification.checkers.MissingInvocationCheckerTest; import org.mockito.internal.verification.checkers.MissingInvocationInOrderCheckerTest; import org.mockito.internal.verification.checkers.NumberOfInvocationsCheckerTest; import org.mockito.internal.verification.checkers.NumberOfInvocationsInOrderCheckerTest; import org.mockitousage.basicapi.ReplacingObjectMethodsTest; import org.mockitousage.basicapi.ResetTest; import org.mockitousage.basicapi.UsingVarargsTest; import org.mockitousage.examples.use.ExampleTest; import org.mockitousage.matchers.CustomMatchersTest; import org.mockitousage.matchers.InvalidUseOfMatchersTest; import org.mockitousage.matchers.MatchersTest; import org.mockitousage.matchers.VerificationAndStubbingUsingMatchersTest; import org.mockitousage.misuse.InvalidUsageTest; import org.mockitousage.puzzlers.BridgeMethodPuzzleTest; import org.mockitousage.puzzlers.OverloadingPuzzleTest; import org.mockitousage.stacktrace.ClickableStackTracesTest; import org.mockitousage.stacktrace.PointingStackTraceToActualInvocationTest; import org.mockitousage.stacktrace.StackTraceFilteringTest; import org.mockitousage.stubbing.BasicStubbingTest; import org.mockitousage.stubbing.ReturningDefaultValuesTest; import org.mockitousage.stubbing.StubbingWithThrowablesTest; import org.mockitousage.verification.AtMostXVerificationTest; import org.mockitousage.verification.BasicVerificationInOrderTest; import org.mockitousage.verification.BasicVerificationTest; import org.mockitousage.verification.DescriptiveMessagesOnVerificationInOrderErrorsTest; import org.mockitousage.verification.DescriptiveMessagesWhenTimesXVerificationFailsTest; import org.mockitousage.verification.DescriptiveMessagesWhenVerificationFailsTest; import org.mockitousage.verification.ExactNumberOfTimesVerificationTest; import org.mockitousage.verification.NoMoreInteractionsVerificationTest; import org.mockitousage.verification.RelaxedVerificationInOrderTest; import org.mockitousage.verification.SelectedMocksInOrderVerificationTest; import org.mockitousage.verification.VerificationInOrderMixedWithOrdiraryVerificationTest; import org.mockitousage.verification.VerificationInOrderTest; import org.mockitousage.verification.VerificationOnMultipleMocksUsingMatchersTest; import org.mockitousage.verification.VerificationUsingMatchersTest; import org.mockitoutil.TestBase;  public class ThreadsRunAllTestsHalfManualTest extends TestBase {      private static class AllTestsRunner extends Thread {          private boolean failed;          public void run() {             Result result = JUnitCore.runClasses(                     EqualsTest.class,                     ListUtilTest.class,                     MockingProgressImplTest.class,                     TimesTest.class,                     MockHandlerImplTest.class,                     AllInvocationsFinderTest.class,                     ReturnsEmptyValuesTest.class,                     NumberOfInvocationsCheckerTest.class,                     DefaultRegisteredInvocationsTest.class,                     MissingInvocationCheckerTest.class,                     NumberOfInvocationsInOrderCheckerTest.class,                     MissingInvocationInOrderCheckerTest.class,                     CachingMockBytecodeGeneratorTest.class,                     InvocationMatcherTest.class,                     InvocationsFinderTest.class,                     InvocationImplTest.class,                     MockitoTest.class,                     MockUtilTest.class,                     ReporterTest.class,                     MockitoAssertionErrorTest.class,                     MockitoExceptionTest.class,                     StackTraceFilteringTest.class,                     BridgeMethodPuzzleTest.class,                     OverloadingPuzzleTest.class,                     InvalidUsageTest.class,                     UsingVarargsTest.class,                     CustomMatchersTest.class,                     ComparableMatchersTest.class,                     InvalidUseOfMatchersTest.class,                     MatchersTest.class,                     MatchersToStringTest.class,                     VerificationAndStubbingUsingMatchersTest.class,                     BasicStubbingTest.class,                     ReturningDefaultValuesTest.class,                     StubbingWithThrowablesTest.class,                     AtMostXVerificationTest.class,                     BasicVerificationTest.class,                     ExactNumberOfTimesVerificationTest.class,                     VerificationInOrderTest.class,                     NoMoreInteractionsVerificationTest.class,                     SelectedMocksInOrderVerificationTest.class,                     VerificationOnMultipleMocksUsingMatchersTest.class,                     VerificationUsingMatchersTest.class,                     RelaxedVerificationInOrderTest.class,                     DescriptiveMessagesWhenVerificationFailsTest.class,                     DescriptiveMessagesWhenTimesXVerificationFailsTest.class,                     BasicVerificationInOrderTest.class,                     VerificationInOrderMixedWithOrdiraryVerificationTest.class,                     DescriptiveMessagesOnVerificationInOrderErrorsTest.class,                     InvalidStateDetectionTest.class,                     ReplacingObjectMethodsTest.class,                     ClickableStackTracesTest.class,                     ExampleTest.class,                     PointingStackTraceToActualInvocationTest.class,                     VerificationInOrderFromMultipleThreadsTest.class,                     ResetTest.class,                     ReturnsGenericDeepStubsTest.class                 );                  if (!result.wasSuccessful()) {                     System.err.println("Thread[" + Thread.currentThread().getId() + "]: error!");                     List<Failure> failures = result.getFailures();                     System.err.println(failures.size());                     for (Failure failure : failures) {                         System.err.println(failure.getTrace());                         failed = true;                     }                 }         }          public boolean isFailed() {             return failed;         }     }      @Test     public void shouldRunInMultipleThreads() {} // Defects4J: flaky method //     @Test //     public void shouldRunInMultipleThreads() {} // Defects4J: flaky method //     @Test //     public void shouldRunInMultipleThreads() throws Exception { //         //this test ALWAYS fails if there is a single failing unit //         assertFalse("Run in multiple thread failed", runInMultipleThreads(3)); //     }      public static boolean runInMultipleThreads(int numberOfThreads) throws Exception {         List<AllTestsRunner> threads = new LinkedList<AllTestsRunner>();         for (int i = 1; i <= numberOfThreads; i++) {             threads.add(new AllTestsRunner());         }          for (Thread t : threads) {             t.start();         }          boolean failed = false;         for (AllTestsRunner t : threads) {             t.join();             failed = failed ? true : t.isFailed();         }          return failed;     }      public static void main(String[] args) throws Exception {         int numberOfThreads = 20;         long before = System.currentTimeMillis();         runInMultipleThreads(numberOfThreads);         long after = System.currentTimeMillis();         long executionTime = (after-before)/1000;         System.out.println("Finished tests in " + numberOfThreads + " threads in " + executionTime + " seconds.");     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.concurrentmockito;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class ThreadsShareAMockTest extends TestBase {      private IMethods mock;      @Test     public void shouldAllowVerifyingInThreads() throws Exception {         for(int i = 0; i < 100; i++) {             performTest();         }     }      private void performTest() throws InterruptedException {         mock = mock(IMethods.class);         final Thread[] listeners = new Thread[3];         for (int i = 0; i < listeners.length; i++) {             listeners[i] = new Thread() {                 @Override                 public void run() {                     mock.simpleMethod("foo");                 }             };             listeners[i].start();         }         for (int i = 0; i < listeners.length; i++) {             listeners[i].join();         }         verify(mock, times(listeners.length)).simpleMethod("foo");     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.concurrentmockito;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  //this test always passes but please keep looking sys err //this test should be run 10 times, manually public class ThreadsShareGenerouslyStubbedMockTest extends TestBase {      private IMethods mock;      @Test     public void shouldAllowVerifyingInThreads() throws Exception {         for(int i = 0; i < 50; i++) {             performTest();         }     }      private void performTest() throws InterruptedException {         mock = mock(IMethods.class);                  when(mock.simpleMethod("foo"))             .thenReturn("foo")             .thenReturn("bar")             .thenReturn("baz")             .thenReturn("foo")             .thenReturn("bar")             .thenReturn("baz");                  final Thread[] listeners = new Thread[100];         for (int i = 0; i < listeners.length; i++) {             listeners[i] = new Thread() {                 @Override                 public void run() {                     try {                         mock.simpleMethod("foo");                         mock.simpleMethod("foo");                         mock.simpleMethod("foo");                         mock.simpleMethod("foo");                         mock.simpleMethod("foo");                         mock.simpleMethod("foo");                     } catch (Exception e) {                         throw new RuntimeException(e);                     }                 }             };             listeners[i].start();         }         for (int i = 0; i < listeners.length; i++) {             listeners[i].join();         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.concurrentmockito;  import static org.mockito.Mockito.*;  import org.junit.Ignore; import org.junit.Test; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class ThreadsStubSharedMockTest extends TestBase {      private IMethods mock;      @Ignore("stubbing from multiple threads is not supported")     @Test     public void shouldStubFineConcurrently() throws Exception {         for(int i = 0; i < 100; i++) {             performTest();         }     }      private void performTest() throws InterruptedException {         mock = mock(IMethods.class);         final Thread[] listeners = new Thread[3];         for (int i = 0; i < listeners.length; i++) {             listeners[i] = new Thread() {                 @SuppressWarnings("deprecation")                 @Override                 public void run() {                     when(mock.simpleMethod(getId()))                         .thenReturn(getId() + "")                         .thenReturn("foo")                         .thenReturn("bar");                                              stubVoid(mock)                         .toThrow(new RuntimeException(getId() + ""))                         .toReturn()                         .toThrow(new RuntimeException())                         .on().differentMethod();                 }             };             listeners[i].start();         }         for (int i = 0; i < listeners.length; i++) {             listeners[i].join();         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.concurrentmockito; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.InOrder; import org.mockitoutil.TestBase;  public class VerificationInOrderFromMultipleThreadsTest extends TestBase {          @Test     public void shouldVerifyInOrderWhenMultipleThreadsInteractWithMock() throws Exception {         final Foo testInf = mock(Foo.class);                  Thread threadOne = new Thread(new Runnable(){             public void run() {                 testInf.methodOne();             }         });         threadOne.start();         threadOne.join();                  Thread threadTwo = new Thread(new Runnable(){             public void run() {                 testInf.methodTwo();             }         });         threadTwo.start();         threadTwo.join();                  InOrder inOrder = inOrder(testInf);         inOrder.verify(testInf).methodOne();         inOrder.verify(testInf).methodTwo();     }          public interface Foo {         void methodOne();         void methodTwo();     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito;  import org.junit.After; import org.junit.Test; import org.mockito.internal.progress.HandyReturnValues; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class ArgumentCaptorTest extends TestBase {          @Test     public void tell_handy_return_values_to_return_value_for() throws Exception {         //given         final Object expected = new Object();          ArgumentCaptor<Object> argumentCaptor = ArgumentCaptor.forClass(Object.class);         argumentCaptor.handyReturnValues = will_return(expected);                  //when         Object returned = argumentCaptor.capture();          //then         assertEquals(expected, returned);     }      private HandyReturnValues will_return(final Object expected) {         return new HandyReturnValues() {             @Override             public <T> T returnFor(Class<T> clazz) {                 return (T) expected;             }         };     }      @After     public void yes_I_know_some_matchers_are_misplaced() {         resetState();     } }
package org.mockito;  import org.junit.Test; import org.mockito.internal.MockitoCore; import org.mockito.invocation.Invocation; import org.mockitoutil.TestBase;  import java.util.ArrayList; import java.util.Collection; import java.util.List;  import static org.mockito.Mockito.mock;  public class MockingDetailsTest extends TestBase {          @Test     public void should_provide_invocations() {         List<String> methodsInvoked = new ArrayList<String>() {{             add("add");             add("remove");             add("clear");         }};                  List<String> mockedList = (List<String>) mock(List.class);                  mockedList.add("one");         mockedList.remove(0);         mockedList.clear();                  MockingDetails mockingDetails = new MockitoCore().mockingDetails(mockedList);         Collection<Invocation> invocations = mockingDetails.getInvocations();                  assertNotNull(invocations);         assertEquals(invocations.size(),3);         for (Invocation method : invocations) {             assertTrue(methodsInvoked.contains(method.getMethod().getName()));             if (method.getMethod().getName().equals("add")) {                 assertEquals(method.getArguments().length,1);                 assertEquals(method.getArguments()[0],"one");             }         }         }      @Test     public void should_handle_null_input() {         //TODO SF, decide how to handle it and ensure the there is a top level integ test for the mockingDetails().getInvocations()         //assertTrue(new MockitoCore().mockingDetails(null).getInvocations().isEmpty());     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito;  import org.junit.Test; import org.mockito.exceptions.misusing.NotAMockException; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.progress.ThreadSafeMockingProgress; import org.mockitoutil.TestBase;  import java.util.List;  import static org.mockito.Mockito.times;  @SuppressWarnings("unchecked") public class MockitoTest extends TestBase {      @Test     public void shouldRemoveStubbableFromProgressAfterStubbing() {         List mock = Mockito.mock(List.class);         Mockito.when(mock.add("test")).thenReturn(true);         //TODO Consider to move to separate test         assertNull(new ThreadSafeMockingProgress().pullOngoingStubbing());     }          @Test(expected=NotAMockException.class)     public void shouldValidateMockWhenVerifying() {         Mockito.verify("notMock");     }          @Test(expected=NotAMockException.class)     public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations() {         Mockito.verify("notMock", times(19));     }          @Test(expected=NotAMockException.class)     public void shouldValidateMockWhenVerifyingNoMoreInteractions() {         Mockito.verifyNoMoreInteractions("notMock");     }          @Test(expected=NotAMockException.class)     public void shouldValidateMockWhenVerifyingZeroInteractions() {         Mockito.verifyZeroInteractions("notMock");     }          @SuppressWarnings("deprecation")     @Test(expected=NotAMockException.class)     public void shouldValidateMockWhenStubbingVoid() {         Mockito.stubVoid("notMock");     }          @Test(expected=NotAMockException.class)     public void shouldValidateMockWhenCreatingInOrderObject() {         Mockito.inOrder("notMock");     }          @Test     public void shouldStartingMockSettingsContainDefaultBehavior() {         //when         MockSettingsImpl settings = (MockSettingsImpl) Mockito.withSettings();                  //then         assertEquals(Mockito.RETURNS_DEFAULTS, settings.getDefaultAnswer());     }          //TODO: stack filter does not work very well when it comes to threads? }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.exceptions;  import org.junit.Test; import org.mockito.Mockito; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.TooLittleActualInvocations; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.internal.exceptions.VerificationAwareInvocation; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.stubbing.answers.Returns; import org.mockito.invocation.Invocation; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import java.lang.reflect.Field; import java.util.Collections;  import static org.mockito.Mockito.mock;  public class ReporterTest extends TestBase {      @Test(expected = TooLittleActualInvocations.class)     public void should_let_passing_null_last_actual_stack_trace() throws Exception {         new Reporter().tooLittleActualInvocations(new org.mockito.internal.reporting.Discrepancy(1, 2), new InvocationBuilder().toInvocation(), null);     }      @Test(expected = MockitoException.class)     public void should_throw_correct_exception_for_null_invocation_listener() throws Exception {         new Reporter().invocationListenerDoesNotAcceptNullParameters();     }      @Test(expected = NoInteractionsWanted.class)     public void can_use_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted() throws Exception {         Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();         new Reporter().noMoreInteractionsWanted(invocation_with_bogus_default_answer, Collections.<VerificationAwareInvocation>emptyList());     }      @Test(expected = VerificationInOrderFailure.class)     public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_no_more_interaction_wanted_in_order() throws Exception {         Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();         new Reporter().noMoreInteractionsWantedInOrder(invocation_with_bogus_default_answer);     }      @Test(expected = MockitoException.class)     public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_invalid_argument_position() throws Exception {         Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();         new Reporter().invalidArgumentPositionRangeAtInvocationTime(invocation_with_bogus_default_answer, true, 0);     }      @Test(expected = MockitoException.class)     public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_wrong_argument_to_return() throws Exception {         Invocation invocation_with_bogus_default_answer = new InvocationBuilder().mock(mock(IMethods.class, new Returns(false))).toInvocation();         new Reporter().wrongTypeOfArgumentToReturn(invocation_with_bogus_default_answer, "", String.class, 0);     }      @Test(expected = MockitoException.class)     public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_dont_exists() throws Exception {         Invocation dumb_invocation = new InvocationBuilder().toInvocation();         IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));         new Reporter().delegatedMethodDoesNotExistOnDelegate(dumb_invocation.getMethod(), mock_with_bogus_default_answer, String.class);     }      @Test(expected = MockitoException.class)     public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_delegate_method_has_wrong_return_type() throws Exception {         Invocation dumb_invocation = new InvocationBuilder().toInvocation();         IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));         new Reporter().delegatedMethodHasWrongReturnType(dumb_invocation.getMethod(), dumb_invocation.getMethod(), mock_with_bogus_default_answer, String.class);     }      @Test(expected = MockitoException.class)     public void can_use_print_mock_name_even_when_mock_bogus_default_answer_and_when_reporting_injection_failure() throws Exception {         IMethods mock_with_bogus_default_answer = mock(IMethods.class, new Returns(false));         new Reporter().cannotInjectDependency(someField(), mock_with_bogus_default_answer, new Exception());     }      private Field someField() {         return Mockito.class.getDeclaredFields()[0];     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.exceptions.base;  import org.junit.Test; import org.mockitoutil.TestBase;  public class MockitoAssertionErrorTest extends TestBase {      private void throwIt() {         throw new MockitoAssertionError("boom");     }          @Test     public void shouldKeepUnfilteredStackTrace() {         try {             throwIt();             fail();         } catch (MockitoAssertionError e) {             assertEquals("throwIt", e.getUnfilteredStackTrace()[0].getMethodName());         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.exceptions.base;  import org.junit.Test; import org.mockitoutil.TestBase;  public class MockitoExceptionTest extends TestBase {      private void throwIt() {         throw new MockitoException("boom");     }          @Test     public void shouldKeepUnfilteredStackTrace() {         try {             throwIt();             fail();         } catch (MockitoException e) {             assertEquals("throwIt", e.getUnfilteredStackTrace()[0].getMethodName());         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal;  import org.junit.Before; import org.junit.Test; import org.mockito.internal.invocation.finder.AllInvocationsFinder; import org.mockito.invocation.Invocation; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import java.util.List;  import static java.util.Arrays.asList; import static org.mockito.Mockito.mock;  public class AllInvocationsFinderTest extends TestBase {          private AllInvocationsFinder finder;     private IMethods mockTwo;     private IMethods mockOne;      @Before     public void setup() {         finder = new AllInvocationsFinder();         mockOne = mock(IMethods.class);         mockTwo = mock(IMethods.class);     }          @Test     public void shouldGetAllInvocationsInOrder() throws Exception {         mockOne.simpleMethod(100);         mockTwo.simpleMethod(200);         mockOne.simpleMethod(300);                  List<Invocation> invocations = finder.find(asList(mockOne, mockTwo));                  assertEquals(3, invocations.size());         assertArgumentEquals(100, invocations.get(0));         assertArgumentEquals(200, invocations.get(1));         assertArgumentEquals(300, invocations.get(2));     }      @Test     public void shouldNotCountDuplicatedInteractions() throws Exception {         mockOne.simpleMethod(100);          List<Invocation> invocations = finder.find(asList(mockOne, mockOne, mockOne));          assertEquals(1, invocations.size());     }      private void assertArgumentEquals(Object argumentValue, Invocation invocation) {         assertEquals(argumentValue, invocation.getArguments()[0]);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal;  import static java.util.Arrays.*;  import java.util.List;  import org.junit.Test; import org.mockito.Mock; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.invocation.Invocation; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class InOrderImplTest extends TestBase {          @Mock IMethods mock;          @Test     public void shouldMarkVerifiedInOrder() throws Exception {         //given         InOrderImpl impl = new InOrderImpl((List) asList(mock));         Invocation i = new InvocationBuilder().toInvocation();         assertFalse(impl.isVerified(i));                  //when         impl.markVerified(i);                  //then         assertTrue(impl.isVerified(i));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.After; import org.junit.Test; import org.mockito.Mock; import org.mockito.StateMaster; import org.mockito.exceptions.misusing.InvalidUseOfMatchersException; import org.mockito.exceptions.misusing.UnfinishedStubbingException; import org.mockito.exceptions.misusing.UnfinishedVerificationException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  /**  * invalid state happens if:  *   *    -unfinished stubbing  *    -unfinished stubVoid  *    -unfinished doReturn()  *    -stubbing without actual method call  *    -verify without actual method call  *      * we should aim to detect invalid state in following scenarios:  *   *    -on method call on mock  *    -on verify  *    -on verifyZeroInteractions  *    -on verifyNoMoreInteractions  *    -on verify in order  *    -on stub  *    -on stubVoid  */ @SuppressWarnings({"unchecked", "deprecation"}) public class InvalidStateDetectionTest extends TestBase {      @Mock private IMethods mock;      @After     public void resetState() {         super.resetState();     }          @Test     public void shouldDetectUnfinishedStubbing() {         when(mock.simpleMethod());         detectsAndCleansUp(new OnMethodCallOnMock(), UnfinishedStubbingException.class);          when(mock.simpleMethod());         detectsAndCleansUp(new OnStub(), UnfinishedStubbingException.class);                  when(mock.simpleMethod());         detectsAndCleansUp(new OnStubVoid(), UnfinishedStubbingException.class);                  when(mock.simpleMethod());         detectsAndCleansUp(new OnVerify(), UnfinishedStubbingException.class);                  when(mock.simpleMethod());         detectsAndCleansUp(new OnVerifyInOrder(), UnfinishedStubbingException.class);                  when(mock.simpleMethod());         detectsAndCleansUp(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);                  when(mock.simpleMethod());         detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);          when(mock.simpleMethod());         detectsAndCleansUp(new OnDoAnswer(), UnfinishedStubbingException.class);     }          @Test     public void shouldDetectUnfinishedStubbingVoid() {         stubVoid(mock);         detectsAndCleansUp(new OnMethodCallOnMock(), UnfinishedStubbingException.class);                  stubVoid(mock);         detectsAndCleansUp(new OnStub(), UnfinishedStubbingException.class);                  stubVoid(mock);         detectsAndCleansUp(new OnStubVoid(), UnfinishedStubbingException.class);                  stubVoid(mock);         detectsAndCleansUp(new OnVerify(), UnfinishedStubbingException.class);                  stubVoid(mock);         detectsAndCleansUp(new OnVerifyInOrder(), UnfinishedStubbingException.class);                  stubVoid(mock);         detectsAndCleansUp(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);                  stubVoid(mock);         detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);                  stubVoid(mock);         detectsAndCleansUp(new OnDoAnswer(), UnfinishedStubbingException.class);     }          @Test     public void shouldDetectUnfinishedDoAnswerStubbing() {         doAnswer(null);         detectsAndCleansUp(new OnMethodCallOnMock(), UnfinishedStubbingException.class);                  doAnswer(null);         detectsAndCleansUp(new OnStub(), UnfinishedStubbingException.class);                  doAnswer(null);         detectsAndCleansUp(new OnStubVoid(), UnfinishedStubbingException.class);                  doAnswer(null);         detectsAndCleansUp(new OnVerify(), UnfinishedStubbingException.class);                  doAnswer(null);         detectsAndCleansUp(new OnVerifyInOrder(), UnfinishedStubbingException.class);                  doAnswer(null);         detectsAndCleansUp(new OnVerifyZeroInteractions(), UnfinishedStubbingException.class);                  doAnswer(null);         detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedStubbingException.class);                  doAnswer(null);         detectsAndCleansUp(new OnDoAnswer(), UnfinishedStubbingException.class);     }          @Test     public void shouldDetectUnfinishedVerification() {         verify(mock);         detectsAndCleansUp(new OnStub(), UnfinishedVerificationException.class);                  verify(mock);         detectsAndCleansUp(new OnStubVoid(), UnfinishedVerificationException.class);                  verify(mock);         detectsAndCleansUp(new OnVerify(), UnfinishedVerificationException.class);                  verify(mock);         detectsAndCleansUp(new OnVerifyInOrder(), UnfinishedVerificationException.class);                  verify(mock);         detectsAndCleansUp(new OnVerifyZeroInteractions(), UnfinishedVerificationException.class);                  verify(mock);         detectsAndCleansUp(new OnVerifyNoMoreInteractions(), UnfinishedVerificationException.class);                  verify(mock);         detectsAndCleansUp(new OnDoAnswer(), UnfinishedVerificationException.class);     }      @Test     public void shouldDetectMisplacedArgumentMatcher() {         anyObject();         detectsAndCleansUp(new OnStubVoid(), InvalidUseOfMatchersException.class);                  anyObject();         detectsAndCleansUp(new OnVerify(), InvalidUseOfMatchersException.class);                  anyObject();         detectsAndCleansUp(new OnVerifyInOrder(), InvalidUseOfMatchersException.class);                  anyObject();         detectsAndCleansUp(new OnVerifyZeroInteractions(), InvalidUseOfMatchersException.class);                  anyObject();         detectsAndCleansUp(new OnVerifyNoMoreInteractions(), InvalidUseOfMatchersException.class);                  anyObject();         detectsAndCleansUp(new OnDoAnswer(), InvalidUseOfMatchersException.class);     }          @Test     public void shouldCorrectStateAfterDetectingUnfinishedStubbing() {         stubVoid(mock).toThrow(new RuntimeException());                  try {             stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);             fail();         } catch (UnfinishedStubbingException e) {}                  stubVoid(mock).toThrow(new RuntimeException()).on().oneArg(true);         try {             mock.oneArg(true);             fail();         } catch (RuntimeException e) {}     }          @Test     public void shouldCorrectStateAfterDetectingUnfinishedVerification() {         mock.simpleMethod();         verify(mock);                  try {             verify(mock).simpleMethod();             fail();         } catch (UnfinishedVerificationException e) {}                  verify(mock).simpleMethod();     }          private interface DetectsInvalidState {         void detect(IMethods mock);     }          private static class OnVerify implements DetectsInvalidState {         public void detect(IMethods mock) {             verify(mock);         }     }          private static class OnVerifyInOrder implements DetectsInvalidState {         public void detect(IMethods mock) {             inOrder(mock).verify(mock);         }     }          private static class OnVerifyZeroInteractions implements DetectsInvalidState {         public void detect(IMethods mock) {             verifyZeroInteractions(mock);         }     }          private static class OnVerifyNoMoreInteractions implements DetectsInvalidState {         public void detect(IMethods mock) {             verifyNoMoreInteractions(mock);         }     }             private static class OnDoAnswer implements DetectsInvalidState {         public void detect(IMethods mock) {             doAnswer(null);         }     }            private static class OnStub implements DetectsInvalidState {         public void detect(IMethods mock) {             when(mock);         }     }          private static class OnStubVoid implements DetectsInvalidState {         public void detect(IMethods mock) {             stubVoid(mock);         }     }          private static class OnMethodCallOnMock implements DetectsInvalidState {         public void detect(IMethods mock) {             mock.simpleMethod();         }     }          private static class OnMockCreation implements DetectsInvalidState {         public void detect(IMethods mock) {             mock(IMethods.class);         }     }          private static class OnSpyCreation implements DetectsInvalidState {         public void detect(IMethods mock) {             spy(new Object());         }     }          private void detectsAndCleansUp(DetectsInvalidState detector, Class expected) {         try {             detector.detect(mock);             fail("Should throw an exception");         } catch (Exception e) {             assertEquals(expected, e.getClass());         }         //Make sure state is cleaned up         new StateMaster().validate();     } }
package org.mockito.internal.configuration;  import org.junit.Test; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.junit.Assert.assertEquals; import static org.mockito.Mockito.mock;  public class ClassPathLoaderTest extends TestBase {      @Test     public void shouldReadConfigurationClassFromClassPath() {         ConfigurationAccess.getConfig().overrideDefaultAnswer(new Answer<Object>() {             public Object answer(InvocationOnMock invocation) {                 return "foo";             }});          IMethods mock = mock(IMethods.class);         assertEquals("foo", mock.simpleMethod());     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.configuration;  import org.junit.After; import org.junit.Test; import org.mockito.internal.configuration.injection.MockInjection;  import java.lang.reflect.Field; import java.util.Collections; import java.util.Observer; import java.util.Set;  import static org.fest.assertions.Assertions.assertThat; import static org.mockito.Mockito.mock;  @SuppressWarnings("unchecked") public class MockInjectionTest {      private AnObjectWithConstructor withConstructor;     private AnObjectWithoutConstructor withoutConstructor;      @After     public void reset() throws Exception {         withConstructor = null;         withoutConstructor = null;     }      @Test(expected = NullPointerException.class)     public void should_not_allow_null_on_field() {         MockInjection.onField((Field) null, this);     }      @Test(expected = NullPointerException.class)     public void should_not_allow_null_on_fields() {         MockInjection.onFields((Set<Field>) null, this);     }      @Test(expected = NullPointerException.class)     public void should_not_allow_null_on_instance_owning_the_field() throws Exception {         MockInjection.onField(field("withConstructor"), null);     }      @Test(expected = NullPointerException.class)     public void should_not_allow_null_on_mocks() throws Exception {         MockInjection.onField(field("withConstructor"), this).withMocks(null);     }       @Test     public void can_try_constructor_injection() throws Exception {         MockInjection.onField(field("withConstructor"), this).withMocks(oneSetMock()).tryConstructorInjection().apply();          assertThat(withConstructor.initializedWithConstructor).isEqualTo(true);     }      @Test     public void should_not_fail_if_constructor_injection_is_not_possible() throws Exception {         MockInjection.onField(field("withoutConstructor"), this).withMocks(otherKindOfMocks()).tryConstructorInjection().apply();          assertThat(withoutConstructor).isNull();     }      @Test     public void can_try_property_or_setter_injection() throws Exception {         MockInjection.onField(field("withoutConstructor"), this).withMocks(oneSetMock()).tryPropertyOrFieldInjection().apply();          assertThat(withoutConstructor.theSet).isNotNull();     }      @Test     public void should_not_fail_if_property_or_field_injection_is_not_possible() throws Exception {         MockInjection.onField(field("withoutConstructor"), this).withMocks(otherKindOfMocks()).tryPropertyOrFieldInjection().apply();          assertThat(withoutConstructor.theSet).isNull();     }      private Set oneSetMock() {         return Collections.singleton(mock(Set.class));     }      private Set otherKindOfMocks() {         return Collections.singleton(mock(Observer.class));     }      private Field field(String field) throws NoSuchFieldException {         return getClass().getDeclaredField(field);     }       public static class AnObjectWithConstructor {         public boolean initializedWithConstructor = false;         public AnObjectWithConstructor(Set<String> strings) {             initializedWithConstructor = true;         }     }      public static class AnObjectWithoutConstructor {         private Set theSet;     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.configuration.injection;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Matchers; import org.mockito.Mock; import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver; import org.mockito.runners.MockitoJUnitRunner;  import java.lang.reflect.Field; import java.util.HashSet; import java.util.Observer; import java.util.Set;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertTrue; import static org.mockito.BDDMockito.given;  @RunWith(MockitoJUnitRunner.class) public class ConstructorInjectionTest {      @Mock private Observer observer;     private ArgConstructor whatever;      @Mock private ConstructorArgumentResolver resolver;     private ConstructorInjection underTest;      @Before     public void initialize_dependencies() {         underTest = new ConstructorInjection(resolver);     }      @Test     public void should_do_the_trick_of_instantiating() throws Exception {         given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[] { observer });          boolean result = underTest.process(field("whatever"), this, newSetOf(observer));          assertTrue(result);         assertNotNull(whatever);     }      private Set<Object> newSetOf(Object item) {         HashSet<Object> mocks = new HashSet<Object>();         mocks.add(item);         return mocks;     }      private Field field(String fieldName) throws NoSuchFieldException {         return this.getClass().getDeclaredField(fieldName);     }      private static class ArgConstructor {         ArgConstructor(Observer observer) {}     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.configuration.injection;  import org.junit.Test;  import java.io.ByteArrayOutputStream; import java.io.OutputStream; import java.util.*;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertTrue;  public class SimpleArgumentResolverTest {      @Test     public void should_return_object_matching_given_types() throws Exception {         ConstructorInjection.SimpleArgumentResolver resolver =                 new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream(), new HashMap()));          Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);          assertEquals(3, resolvedInstance.length);         assertTrue(resolvedInstance[0] instanceof Set);         assertTrue(resolvedInstance[1] instanceof Map);         assertTrue(resolvedInstance[2] instanceof OutputStream);     }      @Test     public void should_return_null_when_match_is_not_possible_on_given_types() throws Exception {         ConstructorInjection.SimpleArgumentResolver resolver =                 new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashSet(), new ByteArrayOutputStream()));          Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, OutputStream.class);          assertEquals(3, resolvedInstance.length);         assertTrue(resolvedInstance[0] instanceof Set);         assertNull(resolvedInstance[1]);         assertTrue(resolvedInstance[2] instanceof OutputStream);     }      @Test     public void should_return_null_when_types_are_primitives() throws Exception {         ConstructorInjection.SimpleArgumentResolver resolver =                 new ConstructorInjection.SimpleArgumentResolver(newSetOf(new HashMap(), new TreeSet()));          Object[] resolvedInstance = resolver.resolveTypeInstances(Set.class, Map.class, Boolean.class);          assertEquals(3, resolvedInstance.length);         assertTrue(resolvedInstance[0] instanceof Set);         assertTrue(resolvedInstance[1] instanceof Map);         assertNull(resolvedInstance[2]);     }      private Set<Object> newSetOf(Object... objects) {         return new HashSet<Object>(Arrays.asList(objects));     }   } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.configuration.plugins;  import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; import java.io.StringReader; import java.util.Arrays; import java.util.Collections; import static org.mockito.Mockito.*;  import junit.framework.Assert; import org.junit.Test; import org.mockito.internal.configuration.ClassPathLoader; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class PluginFileReaderTest extends TestBase {      PluginFileReader reader = new PluginFileReader();      @Test     public void no_class_in_resource() throws IOException {         //no class         assertNull(reader.readPluginClass(impl("")));         assertNull(reader.readPluginClass(impl("  ")));         assertNull(reader.readPluginClass(impl(" \n ")));          //commented out         assertNull(reader.readPluginClass(impl("#foo")));         assertNull(reader.readPluginClass(impl("  # foo  ")));         assertNull(reader.readPluginClass(impl("  # # # java.langString # ")));         assertNull(reader.readPluginClass(impl("  \n # foo \n # foo \n ")));     }      private InputStream impl(String s) {         return new ByteArrayInputStream(s.getBytes());     }      @Test     public void reads_class_name() throws IOException {         assertEquals("java.lang.String", reader.readPluginClass(impl("java.lang.String")));         assertEquals("x", reader.readPluginClass(impl("x")));         assertEquals("x y z", reader.readPluginClass(impl(" x y z ")));         assertEquals("foo.Foo", reader.readPluginClass(impl(" #my class\n  foo.Foo \n #other class ")));         assertEquals("foo.Foo", reader.readPluginClass(impl("foo.Foo  # cool class")));     } }
package org.mockito.internal.configuration.plugins;  import org.junit.Rule; import org.junit.Test; import org.junit.rules.TemporaryFolder; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.internal.util.io.IOUtil; import org.mockito.plugins.PluginSwitch; import org.mockitoutil.TestBase;  import java.io.File;  import static java.util.Arrays.asList; import static org.mockito.Matchers.anyString; import static org.mockito.Mockito.when;  public class PluginFinderTest extends TestBase {      @Mock     PluginSwitch switcher;     @InjectMocks PluginFinder finder;     public @Rule TemporaryFolder tmp = new TemporaryFolder();      @Test public void empty_resources() {         assertNull(finder.findPluginClass((Iterable) asList()));     }      @Test public void no_valid_impl() throws Exception {         File f = tmp.newFile();          //when         IOUtil.writeText("  \n  ", f);          //then         assertNull(finder.findPluginClass((Iterable) asList(f.toURI().toURL())));     }      @Test public void single_implementation() throws Exception {         File f = tmp.newFile();         when(switcher.isEnabled("foo.Foo")).thenReturn(true);          //when         IOUtil.writeText("  foo.Foo  ", f);          //then         assertEquals("foo.Foo", finder.findPluginClass((Iterable) asList(f.toURI().toURL())));     }      @Test public void single_implementation_disabled() throws Exception {         File f = tmp.newFile();         when(switcher.isEnabled("foo.Foo")).thenReturn(false);          //when         IOUtil.writeText("  foo.Foo  ", f);          //then         assertEquals(null, finder.findPluginClass((Iterable) asList(f.toURI().toURL())));     }      @Test public void multiple_implementations_only_one_enabled() throws Exception {         File f1 = tmp.newFile(); File f2 = tmp.newFile();          when(switcher.isEnabled("Bar")).thenReturn(true);          //when         IOUtil.writeText("Foo", f1); IOUtil.writeText("Bar", f2);          //then         assertEquals("Bar", finder.findPluginClass((Iterable) asList(f1.toURI().toURL(), f2.toURI().toURL())));     }      @Test public void multiple_implementations_only_one_useful() throws Exception {         File f1 = tmp.newFile(); File f2 = tmp.newFile();          when(switcher.isEnabled(anyString())).thenReturn(true);          //when         IOUtil.writeText("   ", f1); IOUtil.writeText("X", f2);          //then         assertEquals("X", finder.findPluginClass((Iterable) asList(f1.toURI().toURL(), f2.toURI().toURL())));     }      @Test public void multiple_empty_implementations() throws Exception {         File f1 = tmp.newFile(); File f2 = tmp.newFile();          when(switcher.isEnabled(anyString())).thenReturn(true);          //when         IOUtil.writeText("   ", f1); IOUtil.writeText("\n", f2);          //then         assertEquals(null, finder.findPluginClass((Iterable) asList(f1.toURI().toURL(), f2.toURI().toURL())));     }      @Test public void problems_loading_impl() throws Exception {         when(switcher.isEnabled(anyString())).thenThrow(new RuntimeException("Boo!"));          try {             //when             finder.findPluginClass((Iterable) asList(new File("xxx").toURI().toURL()));             //then             fail();         } catch(Exception e) {             assertContains("xxx", e.getMessage());             e.getCause().getMessage().equals("Boo!");         }     } }
package org.mockito.internal.creation;  import org.junit.Before; import org.junit.Test; import org.mockitoutil.TestBase;  import java.lang.reflect.Method;  public class DelegatingMethodTest extends TestBase {      private Method someMethod, otherMethod;     private DelegatingMethod delegatingMethod;      @Before     public void setup() throws Exception {         someMethod = Something.class.getMethod("someMethod", Object.class);         otherMethod = Something.class.getMethod("otherMethod", Object.class);         delegatingMethod = new DelegatingMethod(someMethod);     }      @Test     public void equals_should_return_false_when_not_equal() throws Exception {         DelegatingMethod notEqual = new DelegatingMethod(otherMethod);         assertFalse(delegatingMethod.equals(notEqual));     }      @Test     public void equals_should_return_true_when_equal() throws Exception {         DelegatingMethod equal = new DelegatingMethod(someMethod);         assertTrue(delegatingMethod.equals(equal));     }      @Test     public void equals_should_return_true_when_self() throws Exception {         assertTrue(delegatingMethod.equals(delegatingMethod));     }      @Test     public void equals_should_return_false_when_not_equal_to_method() throws Exception {         assertFalse(delegatingMethod.equals(otherMethod));     }      @Test     public void equals_should_return_true_when_equal_to_method() throws Exception {         assertTrue(delegatingMethod.equals(someMethod));     }      private interface Something {          public Object someMethod(Object param);          public Object otherMethod(Object param);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.creation;  import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.debugging.VerboseMockInvocationLogger; import org.mockito.listeners.InvocationListener; import org.mockitoutil.TestBase;  import java.util.LinkedList; import java.util.List; import java.util.Set;  public class MockSettingsImplTest extends TestBase {      private MockSettingsImpl mockSettingsImpl = new MockSettingsImpl();          @Mock private InvocationListener invocationListener;      @Test(expected=MockitoException.class)     public void shouldNotAllowSettingNullInterface() {         mockSettingsImpl.extraInterfaces(List.class, null);     }          @Test(expected=MockitoException.class)     public void shouldNotAllowNonInterfaces() {         mockSettingsImpl.extraInterfaces(List.class, LinkedList.class);     }          @Test(expected=MockitoException.class)     public void shouldNotAllowUsingTheSameInterfaceAsExtra() {         mockSettingsImpl.extraInterfaces(List.class, LinkedList.class);     }          @Test(expected=MockitoException.class)     public void shouldNotAllowEmptyExtraInterfaces() {         mockSettingsImpl.extraInterfaces();     }          @Test(expected=MockitoException.class)     public void shouldNotAllowNullArrayOfExtraInterfaces() {         mockSettingsImpl.extraInterfaces((Class[]) null);     }          @Test     public void shouldAllowMultipleInterfaces() {         //when         mockSettingsImpl.extraInterfaces(List.class, Set.class);                  //then         assertEquals(2, mockSettingsImpl.getExtraInterfaces().size());         assertTrue(mockSettingsImpl.getExtraInterfaces().contains(List.class));         assertTrue(mockSettingsImpl.getExtraInterfaces().contains(Set.class));     }      @Test     public void shouldSetMockToBeSerializable() throws Exception {         //when         mockSettingsImpl.serializable();          //then         assertTrue(mockSettingsImpl.isSerializable());     }      @Test     public void shouldKnowIfIsSerializable() throws Exception {         //given         assertFalse(mockSettingsImpl.isSerializable());          //when         mockSettingsImpl.serializable();          //then         assertTrue(mockSettingsImpl.isSerializable());     }      @Test     public void shouldAddVerboseLoggingListener() {         //given         assertFalse(mockSettingsImpl.hasInvocationListeners());          //when         mockSettingsImpl.verboseLogging();          //then         assertContainsType(mockSettingsImpl.getInvocationListeners(), VerboseMockInvocationLogger.class);     }      @Test     public void shouldAddVerboseLoggingListenerOnlyOnce() {         //given         assertFalse(mockSettingsImpl.hasInvocationListeners());                  //when         mockSettingsImpl.verboseLogging().verboseLogging();                  //then         Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).hasSize(1);     }      @SuppressWarnings("all")     @Test(expected=MockitoException.class)     public void shouldNotAllowNullListener() {         mockSettingsImpl.invocationListeners((InvocationListener[])null);     }      @Test     public void shouldAddInvocationListener() {         //given         assertFalse(mockSettingsImpl.hasInvocationListeners());                  //when         mockSettingsImpl.invocationListeners(invocationListener);                  //then         Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).contains(invocationListener);     }          @Test     public void canAddDuplicateInvocationListeners_ItsNotOurBusinessThere() {         //given         assertFalse(mockSettingsImpl.hasInvocationListeners());                  //when         mockSettingsImpl.invocationListeners(invocationListener, invocationListener).invocationListeners(invocationListener);                  //then         Assertions.assertThat(mockSettingsImpl.getInvocationListeners()).containsSequence(invocationListener, invocationListener, invocationListener);     }      @Test     public void shouldReportErrorWhenAddingNoInvocationListeners() throws Exception {         try {             mockSettingsImpl.invocationListeners();             fail();         } catch (Exception e) {             Assertions.assertThat(e.getMessage()).contains("at least one listener");         }     }      @Test     public void shouldReportErrorWhenAddingANullInvocationListener() throws Exception {         try {             mockSettingsImpl.invocationListeners(invocationListener, null);             fail();         } catch (Exception e) {             Assertions.assertThat(e.getMessage()).contains("does not accept null");         }     } } 
package org.mockito.internal.creation.instance;  import org.junit.Test; import org.mockitoutil.TestBase;  public class ConstructorInstantiatorTest extends TestBase {      static class SomeClass {}     class SomeInnerClass {}     class ChildOfThis extends ConstructorInstantiatorTest {}     static class SomeClass2 {         SomeClass2(String x) {}     }      @Test public void creates_instances() {         assertEquals(new ConstructorInstantiator(null).newInstance(SomeClass.class).getClass(), SomeClass.class);     }      @Test public void creates_instances_of_inner_classes() {         assertEquals(new ConstructorInstantiator(this).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);         assertEquals(new ConstructorInstantiator(new ChildOfThis()).newInstance(SomeInnerClass.class).getClass(), SomeInnerClass.class);     }      @Test public void explains_when_constructor_cannot_be_found() {         try {             new ConstructorInstantiator(null).newInstance(SomeClass2.class);             fail();         } catch (InstantiationException e) {             assertContains("Unable to create instance of 'SomeClass2'.\n" +                     "Please ensure it has 0-arg constructor which invokes cleanly.", e.getMessage());         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.debugging;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.util.MockitoLogger; import org.mockitoutil.TestBase;  public class LoggingListenerTest extends TestBase {      @Mock private MockitoLogger logger;      @Test     public void shouldLogUnusedStub() {         //given         LoggingListener listener = new LoggingListener(false, logger);          //when         listener.foundUnusedStub(new InvocationBuilder().toInvocation());          //then         verify(logger).log(notNull());     }      @Test     public void shouldLogUnstubbed() {         //given         LoggingListener listener = new LoggingListener(true, logger);          //when         listener.foundUnstubbed(new InvocationBuilder().toInvocationMatcher());          //then         verify(logger).log(notNull());     }      @Test     public void shouldNotLogUnstubbed() {         //given         LoggingListener listener = new LoggingListener(false, logger);          //when         listener.foundUnstubbed(new InvocationBuilder().toInvocationMatcher());          //then         verify(logger, never()).log(notNull());     }      @Test     public void shouldLogDifferentArgs() {         //given         LoggingListener listener = new LoggingListener(true, logger);          //when         listener.foundStubCalledWithDifferentArgs(new InvocationBuilder().toInvocation(), new InvocationBuilder().toInvocationMatcher());          //then         verify(logger).log(notNull());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.debugging;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.StubInfoImpl; import org.mockito.internal.listeners.NotifiedMethodInvocationReport; import org.mockito.invocation.DescribedInvocation; import org.mockito.invocation.Invocation;  import java.io.ByteArrayOutputStream; import java.io.PrintStream;  import static org.fest.assertions.Assertions.assertThat;  public class VerboseMockInvocationLoggerTest {      private VerboseMockInvocationLogger listener;      private ByteArrayOutputStream output;     private Invocation invocation = new InvocationBuilder().toInvocation();     private DescribedInvocation stubbedInvocation = new InvocationBuilder().toInvocation();      @Before     public void init_Listener() throws Exception {         output = new ByteArrayOutputStream();         listener = new VerboseMockInvocationLogger(new PrintStream(output));     }      @After     public void tearDown() throws Exception {         System.out.println(output);     }      @Test     public void should_print_to_system_out() {         assertThat(new VerboseMockInvocationLogger().printStream).isSameAs(System.out);     }      @Test     public void should_print_invocation_with_return_value() {         // when         listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, "return value"));          // then         assertThat(printed())                 .contains(invocation.toString())                 .contains(invocation.getLocation().toString())                 .contains("return value");     }      @Test     public void should_print_invocation_with_exception() {         // when         listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));          // then         assertThat(printed())                 .contains(invocation.toString())                 .contains(invocation.getLocation().toString())                 .contains(ThirdPartyException.class.getName());     }      @Test     public void should_print_if_method_has_not_been_stubbed() throws Exception {         listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, "whatever"));          assertThat(printed()).doesNotContain("stubbed");     }      @Test     public void should_print_stubbed_info_if_availbable() throws Exception {         invocation.markStubbed(new StubInfoImpl(stubbedInvocation));          listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, "whatever"));          assertThat(printed())                 .contains("stubbed")                 .contains(stubbedInvocation.getLocation().toString());     }      @Test     public void should_log_count_of_interactions() {         // when & then         listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));         assertThat(printed()).contains("#1");          listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));         assertThat(printed()).contains("#2");          listener.reportInvocation(new NotifiedMethodInvocationReport(invocation, new ThirdPartyException()));         assertThat(printed()).contains("#3");     }      private String printed() {         return output.toString();     }      private static class ThirdPartyException extends Exception {         private static final long serialVersionUID = 3022739107688491354L;     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.debugging;  import static java.util.Arrays.*; import static org.mockito.Mockito.*;  import java.util.Arrays;  import org.junit.Test; import org.mockito.Mock; import org.mockito.internal.invocation.InvocationImpl; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.invocation.Invocation; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class WarningsFinderTest extends TestBase {      @Mock private IMethods mock;     @Mock private FindingsListener listener;      @Test     public void shouldPrintUnusedStub() {         // given         Invocation unusedStub = new InvocationBuilder().simpleMethod().toInvocation();          // when         WarningsFinder finder = new WarningsFinder(asList(unusedStub), Arrays.<InvocationMatcher>asList());         finder.find(listener);          // then         verify(listener, only()).foundUnusedStub(unusedStub);     }      @Test     public void shouldPrintUnstubbedInvocation() {         // given         InvocationMatcher unstubbedInvocation = new InvocationBuilder().differentMethod().toInvocationMatcher();          // when         WarningsFinder finder = new WarningsFinder(Arrays.<Invocation>asList(), Arrays.<InvocationMatcher>asList(unstubbedInvocation));         finder.find(listener);          // then         verify(listener, only()).foundUnstubbed(unstubbedInvocation);     }      @Test     public void shouldPrintStubWasUsedWithDifferentArgs() {         // given         Invocation stub = new InvocationBuilder().arg("foo").mock(mock).toInvocation();         InvocationMatcher wrongArg = new InvocationBuilder().arg("bar").mock(mock).toInvocationMatcher();          // when         WarningsFinder finder = new WarningsFinder(Arrays.<Invocation> asList(stub), Arrays.<InvocationMatcher> asList(wrongArg));         finder.find(listener);          // then         verify(listener, only()).foundStubCalledWithDifferentArgs(stub, wrongArg);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.debugging;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.ArgumentCaptor; import org.mockito.Mock; import org.mockito.internal.util.MockitoLogger; import org.mockitoutil.TestBase;  public class WarningsPrinterImplTest extends TestBase {      @Mock private MockitoLogger logger;     @Mock private WarningsFinder finder;      @Test     public void shouldUseFinderCorrectly() {         // given         WarningsPrinterImpl printer = new WarningsPrinterImpl(false, finder);          // when         printer.print(logger);          // then         ArgumentCaptor<LoggingListener> arg = ArgumentCaptor.forClass(LoggingListener.class);         verify(finder).find(arg.capture());         assertEquals(logger, arg.getValue().getLogger());         assertEquals(false, arg.getValue().isWarnAboutUnstubbed());     }      @Test     public void shouldPassCorrectWarningFlag() {         // given         WarningsPrinterImpl printer = new WarningsPrinterImpl(true, finder);          // when         printer.print(logger);          // then         ArgumentCaptor<LoggingListener> arg = ArgumentCaptor.forClass(LoggingListener.class);         verify(finder).find(arg.capture());         assertEquals(true, arg.getValue().isWarnAboutUnstubbed());     }      @Test     public void shouldPrintToString() {         // given         WarningsPrinterImpl printer = spy(new WarningsPrinterImpl(true, finder));          // when         String out = printer.print();          // then         verify(printer).print((MockitoLogger) notNull());         assertNotNull(out);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.exceptions.stacktrace;  import org.junit.Test; import org.mockito.exceptions.base.TraceBuilder; import org.mockito.internal.configuration.ConfigurationAccess; import org.mockitoutil.TestBase;  import static org.mockitoutil.ExtraMatchers.hasOnlyThoseClassesInStackTrace;  public class ConditionalStackTraceFilterTest extends TestBase {          private ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();      @Test     public void shouldNotFilterWhenConfigurationSaysNo() {         ConfigurationAccess.getConfig().overrideCleansStackTrace(false);                  Throwable t = new TraceBuilder().classes(                 "org.test.MockitoSampleTest",                 "org.mockito.Mockito"          ).toThrowable();                  filter.filter(t);                  assertThat(t, hasOnlyThoseClassesInStackTrace("org.mockito.Mockito", "org.test.MockitoSampleTest"));     }      @Test     public void shouldFilterWhenConfigurationSaysYes() {         ConfigurationAccess.getConfig().overrideCleansStackTrace(true);                  Throwable t = new TraceBuilder().classes(                 "org.test.MockitoSampleTest",                 "org.mockito.Mockito"          ).toThrowable();                  filter.filter(t);                  assertThat(t, hasOnlyThoseClassesInStackTrace("org.test.MockitoSampleTest"));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.exceptions.stacktrace;  import org.junit.Test; import org.mockito.exceptions.base.TraceBuilder; import org.mockitoutil.TestBase;  import static org.mockitoutil.ExtraMatchers.hasOnlyThoseClasses;  public class StackTraceFilterTest extends TestBase {          private final StackTraceFilter filter = new StackTraceFilter();          @Test     public void shouldFilterOutCglibGarbage() {         StackTraceElement[] t = new TraceBuilder().classes(             "MockitoExampleTest",             "List$$EnhancerByMockitoWithCGLIB$$2c406024"         ).toTraceArray();                  StackTraceElement[] filtered = filter.filter(t, false);                  assertThat(filtered, hasOnlyThoseClasses("MockitoExampleTest"));     }          @Test     public void shouldFilterOutMockitoPackage() {         StackTraceElement[] t = new TraceBuilder().classes(             "org.test.MockitoSampleTest",             "org.mockito.Mockito"         ).toTraceArray();                      StackTraceElement[] filtered = filter.filter(t, false);                  assertThat(filtered, hasOnlyThoseClasses("org.test.MockitoSampleTest"));     }          @Test     public void shouldFilterOutTracesMiddleBadTraces() {         StackTraceElement[] t = new TraceBuilder().classes(                 "org.test.MockitoSampleTest",                 "org.test.TestSupport",                 "org.mockito.Mockito",                  "org.test.TestSupport",                 "org.mockito.Mockito"         ).toTraceArray();                  StackTraceElement[] filtered = filter.filter(t, false);                  assertThat(filtered, hasOnlyThoseClasses("org.test.TestSupport", "org.test.MockitoSampleTest"));     }          @Test     public void shouldKeepRunners() {         StackTraceElement[] t = new TraceBuilder().classes(                 "org.mockito.runners.Runner",                 "junit.stuff",                 "org.test.MockitoSampleTest",                 "org.mockito.Mockito"         ).toTraceArray();                  StackTraceElement[] filtered = filter.filter(t, false);                  assertThat(filtered, hasOnlyThoseClasses("org.test.MockitoSampleTest", "junit.stuff", "org.mockito.runners.Runner"));     }          @Test     public void shouldKeepInternalRunners() {         StackTraceElement[] t = new TraceBuilder().classes(                 "org.mockito.internal.runners.Runner",                 "org.test.MockitoSampleTest"         ).toTraceArray();                  StackTraceElement[] filtered = filter.filter(t, false);                  assertThat(filtered, hasOnlyThoseClasses("org.test.MockitoSampleTest", "org.mockito.internal.runners.Runner"));     }          @Test     public void shouldStartFilteringAndKeepTop() {         //given         StackTraceElement[] t = new TraceBuilder().classes(                 "org.test.Good",                 "org.mockito.internal.Bad",                 "org.test.MockitoSampleTest"         ).toTraceArray();                  //when         StackTraceElement[] filtered = filter.filter(t, true);                  //then         assertThat(filtered, hasOnlyThoseClasses("org.test.MockitoSampleTest", "org.test.Good"));     }      @Test     public void shouldKeepGoodTraceFromTheTopBecauseRealImplementationsOfSpiesSometimesThrowExceptions() {         StackTraceElement[] t = new TraceBuilder().classes(                 "org.good.Trace",                 "org.yet.another.good.Trace",                 "org.mockito.internal.to.be.Filtered",                 "org.test.MockitoSampleTest"         ).toTraceArray();                  StackTraceElement[] filtered = filter.filter(t, true);                  assertThat(filtered, hasOnlyThoseClasses(                 "org.test.MockitoSampleTest",                 "org.yet.another.good.Trace",                 "org.good.Trace"                 ));     }          @Test     public void shouldReturnEmptyArrayWhenInputIsEmpty() throws Exception {         //when         StackTraceElement[] filtered = filter.filter(new StackTraceElement[0], false);         //then         assertEquals(0, filtered.length);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.exceptions.util;  import static java.util.Arrays.*;  import java.util.List;  import org.junit.Test; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.invocation.Invocation; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class ScenarioPrinterTest extends TestBase {      ScenarioPrinter sp = new ScenarioPrinter();          @Test     public void shouldPrintInvocations() {         //given         Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();         Invocation unverified = new InvocationBuilder().differentMethod().toInvocation();                  //when         String out = sp.print((List) asList(verified, unverified));                  //then         assertContains("1. -> at", out);         assertContains("2. [?]-> at", out);     }          @Test     public void shouldNotPrintInvocationsWhenSingleUnwanted() {         //given         Invocation unverified = new InvocationBuilder().differentMethod().toInvocation();                  //when         String out = sp.print((List) asList(unverified));                  //then         assertContains("Actually, above is the only interaction with this mock.", out);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.handler;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.Spy; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.listeners.NotifiedMethodInvocationReport; import org.mockito.invocation.Invocation; import org.mockito.listeners.InvocationListener; import org.mockito.listeners.MethodInvocationReport; import org.mockito.runners.MockitoJUnitRunner; import org.mockito.stubbing.Answer; import org.mockitousage.IMethods;  import java.text.ParseException; import java.util.ArrayList;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import static org.mockito.BDDMockito.given; import static org.mockito.BDDMockito.willThrow; import static org.mockito.Matchers.any; import static org.mockito.Matchers.anyList; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.verify;   @RunWith(MockitoJUnitRunner.class) @SuppressWarnings("unchecked") public class InvocationNotifierHandlerTest {     private static final String SOME_LOCATION = "some location";     private static final RuntimeException SOME_EXCEPTION = new RuntimeException();     private static final OutOfMemoryError SOME_ERROR = new OutOfMemoryError();     private static final Answer SOME_ANSWER = mock(Answer.class);       @Mock private InvocationListener listener1;     @Mock private InvocationListener listener2;     @Spy private CustomListener customListener;      @Mock private Invocation invocation;     @Mock private MockHandlerImpl mockHandler;      private InvocationNotifierHandler notifier;      @Before     public void setUp() throws Exception {         notifier = new InvocationNotifierHandler(                 mockHandler,                 (MockSettingsImpl) new MockSettingsImpl().invocationListeners(customListener, listener1, listener2)         );     }      @Test     public void should_notify_all_listeners_when_calling_delegate_handler() throws Throwable {         // given         given(mockHandler.handle(invocation)).willReturn("returned value");          // when         notifier.handle(invocation);          // then         verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, "returned value"));         verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, "returned value"));     }      @Test     public void should_notify_all_listeners_when_called_delegate_handler_returns_ex() throws Throwable {         // given         Exception computedException = new Exception("computed");         given(mockHandler.handle(invocation)).willReturn(computedException);          // when         notifier.handle(invocation);          // then         verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));         verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, (Object) computedException));     }      @Test(expected = ParseException.class)     public void should_notify_all_listeners_when_called_delegate_handler_throws_exception_and_rethrow_it() throws Throwable {         // given         ParseException parseException = new ParseException("", 0);         given(mockHandler.handle(invocation)).willThrow(parseException);          // when         try {             notifier.handle(invocation);             fail();         } finally {             // then             verify(listener1).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));             verify(listener2).reportInvocation(new NotifiedMethodInvocationReport(invocation, parseException));         }     }      @Test     public void should_report_listener_exception() throws Throwable {         willThrow(new NullPointerException()).given(customListener).reportInvocation(any(MethodInvocationReport.class));          try {             notifier.handle(invocation);             fail();         } catch (MockitoException me) {             assertThat(me.getMessage())                     .contains("invocation listener")                     .contains("CustomListener")                     .contains("threw an exception")                     .contains("NullPointerException");         }     }      @Test     public void should_delegate_all_MockHandlerInterface_to_the_parameterized_MockHandler() throws Exception {         notifier.getInvocationContainer();         notifier.getMockSettings();         notifier.voidMethodStubbable(mock(IMethods.class));         notifier.setAnswersForStubbing(new ArrayList<Answer>());          verify(mockHandler).getInvocationContainer();         verify(mockHandler).getMockSettings();         verify(mockHandler).voidMethodStubbable(any());         verify(mockHandler).setAnswersForStubbing(anyList());     }      private static class CustomListener implements InvocationListener {         public void reportInvocation(MethodInvocationReport methodInvocationReport) {             // nop         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.handler;  import org.junit.Test; import org.mockito.Mockito; import org.mockito.internal.InternalMockHandler; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.stubbing.answers.Returns; import org.mockito.invocation.Invocation; import org.mockito.mock.MockCreationSettings; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  /**  * by Szczepan Faber, created at: 5/22/12  */ public class MockHandlerFactoryTest extends TestBase {      IMethods mock = Mockito.mock(IMethods.class);      @Test     //see issue 331     public void handle_result_must_not_be_null_for_primitives() throws Throwable {         //given:         MockCreationSettings settings = (MockCreationSettings) new MockSettingsImpl().defaultAnswer(new Returns(null));         InternalMockHandler handler = new MockHandlerFactory().create(settings);          mock.intReturningMethod();         Invocation invocation = super.getLastInvocation();          //when:         Object result = handler.handle(invocation);          //then null value is not a valid result for a primitive         assertNotNull(result);         assertEquals(0, result);     }      @Test     //see issue 331     public void valid_handle_result_is_permitted() throws Throwable {         //given:         MockCreationSettings settings = (MockCreationSettings) new MockSettingsImpl().defaultAnswer(new Returns(123));         InternalMockHandler handler = new MockHandlerFactory().create(settings);          mock.intReturningMethod();         Invocation invocation = super.getLastInvocation();          //when:         Object result = handler.handle(invocation);          //then         assertEquals(123, result);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.handler;  import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.misusing.InvalidUseOfMatchersException; import org.mockito.exceptions.misusing.WrongTypeOfReturnValue; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationImpl; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.internal.invocation.MatchersBinder; import org.mockito.internal.progress.ArgumentMatcherStorage; import org.mockito.internal.stubbing.InvocationContainerImpl; import org.mockito.internal.stubbing.StubbedInvocationMatcher; import org.mockito.internal.stubbing.answers.Returns; import org.mockito.internal.verification.VerificationModeFactory; import org.mockito.invocation.Invocation; import org.mockito.listeners.InvocationListener; import org.mockito.listeners.MethodInvocationReport; import org.mockitoutil.TestBase;  import java.util.Arrays;  import static org.mockito.BDDMockito.given; import static org.mockito.Matchers.any; import static org.mockito.Mockito.doThrow; import static org.mockito.Mockito.mock;  @SuppressWarnings({"unchecked", "serial"}) public class MockHandlerImplTest extends TestBase {      private StubbedInvocationMatcher stubbedInvocationMatcher = mock(StubbedInvocationMatcher.class);     private Invocation invocation = mock(InvocationImpl.class);       @Test     public void should_remove_verification_mode_even_when_invalid_matchers() throws Throwable {         // given         Invocation invocation = new InvocationBuilder().toInvocation();         @SuppressWarnings("rawtypes")         MockHandlerImpl<?> handler = new MockHandlerImpl(new MockSettingsImpl());         handler.mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());         handler.matchersBinder = new MatchersBinder() {             public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {                 throw new InvalidUseOfMatchersException();             }         };          try {             // when             handler.handle(invocation);              // then             fail();         } catch (InvalidUseOfMatchersException ignored) {         }          assertNull(handler.mockingProgress.pullVerificationMode());     }       @Test(expected = MockitoException.class)     public void should_throw_mockito_exception_when_invocation_handler_throws_anything() throws Throwable {         // given         InvocationListener throwingListener = mock(InvocationListener.class);         doThrow(new Throwable()).when(throwingListener).reportInvocation(any(MethodInvocationReport.class));         MockHandlerImpl<?> handler = create_correctly_stubbed_handler(throwingListener);          // when         handler.handle(invocation);     }      @Test(expected = WrongTypeOfReturnValue.class)     public void should_report_bogus_default_answer() throws Throwable {         MockSettingsImpl mockSettings = mock(MockSettingsImpl.class);         MockHandlerImpl<?> handler = new MockHandlerImpl(mockSettings);         given(mockSettings.getDefaultAnswer()).willReturn(new Returns(AWrongType.WRONG_TYPE));          @SuppressWarnings("unused") // otherwise cast is not done         String there_should_not_be_a_CCE_here = (String) handler.handle(                 new InvocationBuilder().method(Object.class.getDeclaredMethod("toString")).toInvocation()         );     }      private MockHandlerImpl<?> create_correctly_stubbed_handler(InvocationListener throwingListener) {         MockHandlerImpl<?> handler = create_handler_with_listeners(throwingListener);         stub_ordinary_invocation_with_given_return_value(handler);         return handler;     }      private void stub_ordinary_invocation_with_given_return_value(MockHandlerImpl<?> handler) {         stub_ordinary_invocation_with_invocation_matcher(handler, stubbedInvocationMatcher);     }       private void stub_ordinary_invocation_with_invocation_matcher(MockHandlerImpl<?> handler, StubbedInvocationMatcher value) {         handler.invocationContainerImpl = mock(InvocationContainerImpl.class);         given(handler.invocationContainerImpl.findAnswerFor(any(InvocationImpl.class))).willReturn(value);     }       private MockHandlerImpl<?> create_handler_with_listeners(InvocationListener... listener) {         @SuppressWarnings("rawtypes")         MockHandlerImpl<?> handler = new MockHandlerImpl(mock(MockSettingsImpl.class));         handler.matchersBinder = mock(MatchersBinder.class);         given(handler.getMockSettings().getInvocationListeners()).willReturn(Arrays.asList(listener));         return handler;     }      private static class AWrongType {         public static final AWrongType WRONG_TYPE = new AWrongType();     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.invocation;  import org.mockito.invocation.Invocation; import org.mockitoutil.TestBase; import org.junit.Test; import org.mockito.internal.matchers.*; import org.mockito.Mock; import org.mockitousage.IMethods;  import java.util.List; import static java.util.Arrays.asList;  @SuppressWarnings("unchecked") public class ArgumentsComparatorTest extends TestBase {      @Mock IMethods mock;     ArgumentsComparator comparator = new ArgumentsComparator();          @Test     public void shouldKnowWhenArgumentsMatch() {         //given         Invocation invocation = new InvocationBuilder().args("1", 100).toInvocation();         InvocationMatcher invocationMatcher = new InvocationBuilder().args("1", 100).toInvocationMatcher();          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertTrue(match);     }      @Test     public void shouldKnowWhenArgsDifferent() {         //given         Invocation invocation = new InvocationBuilder().args("1", 100).toInvocation();         InvocationMatcher invocationMatcher = new InvocationBuilder().args("100", 100).toInvocationMatcher();          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertFalse(match);     }      @Test     public void shouldKnowWhenActualArgsSizeIsDifferent() {         //given         Invocation invocation = new InvocationBuilder().args("100", 100).toInvocation();         InvocationMatcher invocationMatcher = new InvocationBuilder().args("100").toInvocationMatcher();          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertFalse(match);     }      @Test     public void shouldKnowWhenMatchersSizeIsDifferent() {         //given         Invocation invocation = new InvocationBuilder().args("100").toInvocation();         InvocationMatcher invocationMatcher = new InvocationBuilder().args("100", 100).toInvocationMatcher();          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertFalse(match);     }      @Test     public void shouldKnowWhenVarargsMatch() {         //given         mock.varargs("1", "2", "3");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals("1"), Any.ANY, new InstanceOf(String.class)));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertTrue(match);     }      @Test     public void shouldKnowWhenVarargsDifferent() {         //given         mock.varargs("1", "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals("100"), Any.ANY));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertFalse(match);     }      @Test     public void shouldNotAllowAnyObjectMatchEntireVararg() {         //given         mock.varargs("1", "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(Any.ANY));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertFalse(match);     }      @Test     public void shouldAllowAnyVarargMatchEntireVararg() {         //given         mock.varargs("1", "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertTrue(match);     }      @Test     public void shouldNotAllowAnyObjectWithMixedVarargs() {         //given         mock.mixedVarargs(1, "1", "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1)));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertFalse(match);     }      @Test     public void shouldAllowAnyObjectWithMixedVarargs() {         //given         mock.mixedVarargs(1, "1", "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), AnyVararg.ANY_VARARG));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertTrue(match);     }      @Test     public void shouldNotMatchWhenSomeOtherArgumentDoesNotMatch() {         //given         mock.mixedVarargs(1, "1", "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(100), AnyVararg.ANY_VARARG));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertFalse(match);     }      @Test     public void shouldAnyObjectVarargDealWithDifferentSizeOfArgs() {         //given         mock.mixedVarargs(1, "1", "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1)));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertFalse(match);     }      @Test     public void shouldMatchAnyVarargEvenIfOneOfTheArgsIsNull() {         //given         mock.mixedVarargs(null, null, "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(null), AnyVararg.ANY_VARARG));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertTrue(match);     }      @Test     public void shouldMatchAnyVarargEvenIfMatcherIsDecorated() {         //given         mock.varargs("1", "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));          //when         boolean match = comparator.argumentsMatch(invocationMatcher, invocation);          //then         assertTrue(match);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.invocation;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.invocation.realmethod.RealMethod; import org.mockito.internal.matchers.ArrayEquals; import org.mockito.internal.matchers.Equals; import org.mockito.invocation.Invocation; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; import java.util.Map;  @SuppressWarnings({"unchecked"}) public class InvocationImplTest extends TestBase {      private Invocation invocation;      @Before     public void setup() throws Exception {         invocation = new InvocationBuilder().args(" ").mock("mock").toInvocation();     }      @Test     public void shouldKnowIfIsEqualTo() {         Invocation equal =                  new InvocationBuilder().args(" ").mock("mock").toInvocation();         Invocation nonEqual =               new InvocationBuilder().args("X").mock("mock").toInvocation();         Invocation withNewStringInstance =  new InvocationBuilder().args(new String(" ")).mock("mock").toInvocation();          assertFalse(invocation.equals(null));         assertFalse(invocation.equals(""));         assertTrue(invocation.equals(equal));         assertFalse(invocation.equals(nonEqual));         assertTrue(invocation.equals(withNewStringInstance));     }          @Test     public void shouldEqualToNotConsiderSequenceNumber() {         Invocation equal = new InvocationBuilder().args(" ").mock("mock").seq(2).toInvocation();                  assertTrue(invocation.equals(equal));         assertTrue(invocation.getSequenceNumber() != equal.getSequenceNumber());     }          @Test     public void shouldBeACitizenOfHashes() {         Map map = new HashMap();         map.put(invocation, "one");         assertEquals("one", map.get(invocation));     }          @Test     public void shouldPrintMethodName() {         invocation = new InvocationBuilder().toInvocation();         assertEquals("iMethods.simpleMethod();", invocation.toString());     }          @Test     public void shouldPrintMethodArgs() {         invocation = new InvocationBuilder().args("foo").toInvocation();         assertThat(invocation.toString(), endsWith("simpleMethod(\"foo\");"));     }          @Test     public void shouldPrintMethodIntegerArgAndString() {         invocation = new InvocationBuilder().args("foo", 1).toInvocation();         assertThat(invocation.toString(), endsWith("simpleMethod(\"foo\", 1);"));     }          @Test     public void shouldPrintNull() {         invocation = new InvocationBuilder().args((String) null).toInvocation();         assertThat(invocation.toString(), endsWith("simpleMethod(null);"));     }          @Test     public void shouldPrintArray() {         invocation = new InvocationBuilder().method("oneArray").args(new int[] { 1, 2, 3 }).toInvocation();         assertThat(invocation.toString(), endsWith("oneArray([1, 2, 3]);"));     }          @Test     public void shouldPrintNullIfArrayIsNull() throws Exception {         Method m = IMethods.class.getMethod("oneArray", Object[].class);         invocation = new InvocationBuilder().method(m).args((Object) null).toInvocation();         assertThat(invocation.toString(), endsWith("oneArray(null);"));     }          @Test     public void shouldPrintArgumentsInMultilinesWhenGetsTooBig() {         invocation = new InvocationBuilder().args("veeeeery long string that makes it ugly in one line", 1).toInvocation();         assertThat(invocation.toString(), endsWith(                 "simpleMethod(" +                         "\n" +                         "    \"veeeeery long string that makes it ugly in one line\"," +                         "\n" +                         "    1" +                         "\n" +                         ");"));     }          @Test     public void shouldTransformArgumentsToMatchers() throws Exception {         Invocation i = new InvocationBuilder().args("foo", new String[]{"bar"}).toInvocation();         List matchers = ArgumentsProcessor.argumentsToMatchers(i.getArguments());          assertEquals(2, matchers.size());         assertEquals(Equals.class, matchers.get(0).getClass());         assertEquals(ArrayEquals.class, matchers.get(1).getClass());     }          class Foo {         public String bark() {             return "woof";         }     }          @Test     public void shouldBeAbleToCallRealMethod() throws Throwable {         //when         Invocation invocation = invocationOf(Foo.class, "bark", new RealMethod() {             public Object invoke(Object target, Object[] arguments) throws Throwable {                 return new Foo().bark();             }});         //then         assertEquals("woof", invocation.callRealMethod());     }          @Test     public void shouldScreamWhenCallingRealMethodOnInterface() throws Throwable {         //given         Invocation invocationOnInterface = new InvocationBuilder().toInvocation();          try {             //when             invocationOnInterface.callRealMethod();             //then             fail();         } catch(MockitoException e) {}     }          @Test     public void shouldReturnCastedArgumentAt(){         //given         int argument = 42;         Invocation invocationOnInterface = new InvocationBuilder().method("twoArgumentMethod").             argTypes(int.class, int.class).args(1, argument).toInvocation();          //when         int secondArgument = invocationOnInterface.getArgumentAt(1, int.class);          //then         assertTrue(secondArgument == argument);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.invocation;  import java.util.Arrays;  import org.junit.Test; import org.mockito.internal.util.ObjectBox; import org.mockito.internal.verification.InOrderContextImpl; import org.mockito.invocation.Invocation; import org.mockitoutil.TestBase;  public class InvocationMarkerTest extends TestBase {      @Test     public void shouldMarkInvocationAsVerified() {         //given         InvocationMarker marker = new InvocationMarker();         Invocation i = new InvocationBuilder().toInvocation();         InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();         assertFalse(i.isVerified());                  //when         marker.markVerified(Arrays.asList(i), im);                  //then         assertTrue(i.isVerified());     }          @Test     public void shouldCaptureArguments() {         //given         InvocationMarker marker = new InvocationMarker();         Invocation i = new InvocationBuilder().toInvocation();         final ObjectBox box = new ObjectBox();         CapturesArgumensFromInvocation c = new CapturesArgumensFromInvocation() {             public void captureArgumentsFrom(Invocation i) {                 box.put(i);             }};                  //when         marker.markVerified(Arrays.asList(i), c);                  //then         assertEquals(i, box.getObject());     }          @Test     public void shouldMarkInvocationsAsVerifiedInOrder() {         //given         InOrderContextImpl context = new InOrderContextImpl();         InvocationMarker marker = new InvocationMarker();         Invocation i = new InvocationBuilder().toInvocation();         InvocationMatcher im = new InvocationBuilder().toInvocationMatcher();         assertFalse(context.isVerified(i));         assertFalse(i.isVerified());                  //when         marker.markVerifiedInOrder(Arrays.asList(i), im, context);                  //then         assertTrue(context.isVerified(i));         assertTrue(i.isVerified());     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.invocation;  import org.fest.assertions.Assertions; import org.hamcrest.Matcher; import org.junit.Before; import org.junit.Test; import org.mockito.Mock; import org.mockito.internal.matchers.*; import org.mockito.invocation.Invocation; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import java.lang.reflect.Method; import java.util.HashMap; import java.util.List; import java.util.Map;  import static java.util.Arrays.asList;  @SuppressWarnings("unchecked") public class InvocationMatcherTest extends TestBase {      private InvocationMatcher simpleMethod;     @Mock private IMethods mock;      @Before     public void setup() {         simpleMethod = new InvocationBuilder().mock(mock).simpleMethod().toInvocationMatcher();     }      @Test     public void should_be_a_citizen_of_hashes() throws Exception {         Invocation invocation = new InvocationBuilder().toInvocation();         Invocation invocationTwo = new InvocationBuilder().args("blah").toInvocation();          Map map = new HashMap();         map.put(new InvocationMatcher(invocation), "one");         map.put(new InvocationMatcher(invocationTwo), "two");          assertEquals(2, map.size());     }      @Test     public void should_not_equal_if_number_of_arguments_differ() throws Exception {         InvocationMatcher withOneArg = new InvocationMatcher(new InvocationBuilder().args("test").toInvocation());         InvocationMatcher withTwoArgs = new InvocationMatcher(new InvocationBuilder().args("test", 100).toInvocation());          assertFalse(withOneArg.equals(null));         assertFalse(withOneArg.equals(withTwoArgs));     }      @Test     public void should_to_string_with_matchers() throws Exception {         Matcher m = NotNull.NOT_NULL;         InvocationMatcher notNull = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(m));         Matcher mTwo = new Equals('x');         InvocationMatcher equals = new InvocationMatcher(new InvocationBuilder().toInvocation(), asList(mTwo));          assertContains("simpleMethod(notNull())", notNull.toString());         assertContains("simpleMethod('x')", equals.toString());     }      @Test     public void should_know_if_is_similar_to() throws Exception {         Invocation same = new InvocationBuilder().mock(mock).simpleMethod().toInvocation();         assertTrue(simpleMethod.hasSimilarMethod(same));          Invocation different = new InvocationBuilder().mock(mock).differentMethod().toInvocation();         assertFalse(simpleMethod.hasSimilarMethod(different));     }      @Test     public void should_not_be_similar_to_verified_invocation() throws Exception {         Invocation verified = new InvocationBuilder().simpleMethod().verified().toInvocation();         assertFalse(simpleMethod.hasSimilarMethod(verified));     }      @Test     public void should_not_be_similar_if_mocks_are_different() throws Exception {         Invocation onDifferentMock = new InvocationBuilder().simpleMethod().mock("different mock").toInvocation();         assertFalse(simpleMethod.hasSimilarMethod(onDifferentMock));     }      @Test     public void should_not_be_similar_if_is_overloaded_but_used_with_the_same_arg() throws Exception {         Method method = IMethods.class.getMethod("simpleMethod", String.class);         Method overloadedMethod = IMethods.class.getMethod("simpleMethod", Object.class);          String sameArg = "test";          InvocationMatcher invocation = new InvocationBuilder().method(method).arg(sameArg).toInvocationMatcher();         Invocation overloadedInvocation = new InvocationBuilder().method(overloadedMethod).arg(sameArg).toInvocation();          assertFalse(invocation.hasSimilarMethod(overloadedInvocation));     }      @Test     public void should_be_similar_if_is_overloaded_but_used_with_different_arg() throws Exception {         Method method = IMethods.class.getMethod("simpleMethod", String.class);         Method overloadedMethod = IMethods.class.getMethod("simpleMethod", Object.class);          InvocationMatcher invocation = new InvocationBuilder().mock(mock).method(method).arg("foo").toInvocationMatcher();         Invocation overloadedInvocation = new InvocationBuilder().mock(mock).method(overloadedMethod).arg("bar").toInvocation();          assertTrue(invocation.hasSimilarMethod(overloadedInvocation));     }      @Test     public void should_capture_arguments_from_invocation() throws Exception {         //given         Invocation invocation = new InvocationBuilder().args("1", 100).toInvocation();         CapturingMatcher capturingMatcher = new CapturingMatcher();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals("1"), capturingMatcher));          //when         invocationMatcher.captureArgumentsFrom(invocation);          //then         assertEquals(1, capturingMatcher.getAllValues().size());         assertEquals(100, capturingMatcher.getLastValue());     }      @Test     public void should_match_varargs_using_any_varargs() throws Exception {         //given         mock.varargs("1", "2");         Invocation invocation = getLastInvocation();         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(AnyVararg.ANY_VARARG));          //when         boolean match = invocationMatcher.matches(invocation);          //then         assertTrue(match);     }      @Test     public void should_capture_varargs_as_vararg() {} // Defects4J: flaky method //     @Test //     public void should_capture_varargs_as_vararg() throws Exception { //         //given //         mock.mixedVarargs(1, "a", "b"); //         Invocation invocation = getLastInvocation(); //         CapturingMatcher m = new CapturingMatcher(); //         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new Equals(1), new LocalizedMatcher(m))); //  //         //when //         invocationMatcher.captureArgumentsFrom(invocation); //  //         //then //         Assertions.assertThat(m.getAllValues()).containsExactly("a", "b"); //     }      @Test  // like using several time the captor in the vararg     public void should_capture_arguments_when_args_count_does_NOT_match() throws Exception {         //given         mock.varargs();         Invocation invocation = getLastInvocation();          //when         InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, (List) asList(new LocalizedMatcher(AnyVararg.ANY_VARARG)));          //then         invocationMatcher.captureArgumentsFrom(invocation);     }      @Test     public void should_create_from_invocations() throws Exception {         //given         Invocation i = new InvocationBuilder().toInvocation();         //when         List<InvocationMatcher> out = InvocationMatcher.createFrom(asList(i));         //then         assertEquals(1, out.size());         assertEquals(i, out.get(0).getInvocation());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.invocation;  import static org.mockitoutil.ExtraMatchers.*;  import java.util.Arrays; import java.util.Collections; import java.util.LinkedList; import java.util.List;  import org.junit.Before; import org.junit.Test; import org.mockito.Mock; import org.mockito.internal.verification.InOrderContextImpl; import org.mockito.internal.verification.api.InOrderContext; import org.mockito.invocation.Invocation; import org.mockito.invocation.Location; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;   public class InvocationsFinderTest extends TestBase {          private LinkedList<Invocation> invocations = new LinkedList<Invocation>();     private Invocation simpleMethodInvocation;     private Invocation simpleMethodInvocationTwo;     private Invocation differentMethodInvocation;     private InvocationsFinder finder;     InOrderContext context = new InOrderContextImpl();          @Mock private IMethods mock;      @Before     public void setup() throws Exception {         simpleMethodInvocation = new InvocationBuilder().mock(mock).simpleMethod().seq(1).toInvocation();         simpleMethodInvocationTwo = new InvocationBuilder().mock(mock).simpleMethod().seq(2).toInvocation();         differentMethodInvocation = new InvocationBuilder().mock(mock).differentMethod().seq(3).toInvocation();         invocations.addAll(Arrays.asList(simpleMethodInvocation, simpleMethodInvocationTwo, differentMethodInvocation));         finder = new InvocationsFinder();     }      @Test     public void shouldFindActualInvocations() throws Exception {         List<Invocation> actual = finder.findInvocations(invocations, new InvocationMatcher(simpleMethodInvocation));         assertThat(actual, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));                  actual = finder.findInvocations(invocations, new InvocationMatcher(differentMethodInvocation));         assertThat(actual, hasExactlyInOrder(differentMethodInvocation));     }          @Test     public void shouldFindFirstUnverifiedInvocation() throws Exception {         assertSame(simpleMethodInvocation, finder.findFirstUnverified(invocations));                  simpleMethodInvocationTwo.markVerified();         simpleMethodInvocation.markVerified();                  assertSame(differentMethodInvocation, finder.findFirstUnverified(invocations));                  differentMethodInvocation.markVerified();         assertNull(finder.findFirstUnverified(invocations));     }          @Test     public void shouldFindFirstUnverifiedInOrder() throws Exception {         //given         InOrderContextImpl context = new InOrderContextImpl();         assertSame(simpleMethodInvocation, finder.findFirstUnverifiedInOrder(context, invocations));                          //when         context.markVerified(simpleMethodInvocationTwo);         context.markVerified(simpleMethodInvocation);                  //then         assertSame(differentMethodInvocation, finder.findFirstUnverifiedInOrder(context, invocations));                  //when         context.markVerified(differentMethodInvocation);                  //then         assertNull(finder.findFirstUnverifiedInOrder(context, invocations));     }          @Test     public void shouldFindFirstUnverifiedInOrderAndRespectSequenceNumber() throws Exception {         //given         InOrderContextImpl context = new InOrderContextImpl();         assertSame(simpleMethodInvocation, finder.findFirstUnverifiedInOrder(context, invocations));                          //when         //skipping verification of first invocation, then:         context.markVerified(simpleMethodInvocationTwo);         context.markVerified(differentMethodInvocation);                  //then         assertSame(null, finder.findFirstUnverifiedInOrder(context, invocations));             }          @Test     public void shouldFindFirstUnverifiedInvocationOnMock() throws Exception {         assertSame(simpleMethodInvocation, finder.findFirstUnverified(invocations, simpleMethodInvocation.getMock()));         assertNull(finder.findFirstUnverified(invocations, "different mock"));     }          @Test     public void shouldFindFirstSimilarInvocationByName() throws Exception {         Invocation overloadedSimpleMethod = new InvocationBuilder().mock(mock).simpleMethod().arg("test").toInvocation();                  Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedSimpleMethod));         assertSame(found, simpleMethodInvocation);     }          @Test     public void shouldFindInvocationWithTheSameMethod() throws Exception {         Invocation overloadedDifferentMethod = new InvocationBuilder().differentMethod().arg("test").toInvocation();                  invocations.add(overloadedDifferentMethod);                  Invocation found = finder.findSimilarInvocation(invocations, new InvocationMatcher(overloadedDifferentMethod));         assertSame(found, overloadedDifferentMethod);     }          @Test     public void shouldGetLastStackTrace() throws Exception {         Location last = finder.getLastLocation(invocations);         assertSame(differentMethodInvocation.getLocation(), last);                  assertNull(finder.getLastLocation(Collections.<Invocation>emptyList()));     }           @Test     public void shouldFindAllMatchingUnverifiedChunks() throws Exception {         List<Invocation> allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);         assertThat(allMatching, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));                  context.markVerified(simpleMethodInvocation);         allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);         assertThat(allMatching, hasExactlyInOrder(simpleMethodInvocationTwo));                  context.markVerified(simpleMethodInvocationTwo);         allMatching = finder.findAllMatchingUnverifiedChunks(invocations, new InvocationMatcher(simpleMethodInvocation), context);         assertTrue(allMatching.isEmpty());     }          @Test     public void shouldFindMatchingChunk() throws Exception {         List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 2, context);         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo));     }          @Test     public void shouldReturnAllChunksWhenModeIsAtLeastOnce() throws Exception {         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();         invocations.add(simpleMethodInvocationThree);                  List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));     }          @Test     public void shouldReturnAllChunksWhenWantedCountDoesntMatch() throws Exception {         Invocation simpleMethodInvocationThree = new InvocationBuilder().mock(mock).toInvocation();         invocations.add(simpleMethodInvocationThree);                  List<Invocation> chunk = finder.findMatchingChunk(invocations, new InvocationMatcher(simpleMethodInvocation), 1, context);         assertThat(chunk, hasExactlyInOrder(simpleMethodInvocation, simpleMethodInvocationTwo, simpleMethodInvocationThree));     }          @Test     public void shouldFindPreviousInOrder() throws Exception {         Invocation previous = finder.findPreviousVerifiedInOrder(invocations, context);         assertNull(previous);                  context.markVerified(simpleMethodInvocation);         context.markVerified(simpleMethodInvocationTwo);                  previous = finder.findPreviousVerifiedInOrder(invocations, context);         assertSame(simpleMethodInvocationTwo, previous);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.invocation;  import static org.junit.Assert.*;  import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Method;  import org.junit.Before; import org.junit.Test; import org.mockitoutil.TestBase;   public class SerializableMethodTest extends TestBase {      private MockitoMethod method;     private Method toStringMethod;     private Class<?>[] args;      @Before     public void createMethodToTestWith() throws SecurityException, NoSuchMethodException {         args = new Class<?>[0];         toStringMethod = this.getClass().getMethod("toString", args);         method = new SerializableMethod(toStringMethod);     }          @Test     public void shouldBeSerializable() throws Exception {         ByteArrayOutputStream serialized = new ByteArrayOutputStream();         new ObjectOutputStream(serialized).writeObject(method);     }          @Test     public void shouldBeAbleToRetrieveMethodExceptionTypes() throws Exception {         assertArrayEquals(toStringMethod.getExceptionTypes(), method.getExceptionTypes());     }          @Test     public void shouldBeAbleToRetrieveMethodName() throws Exception {         assertEquals(toStringMethod.getName(), method.getName());     }          @Test     public void shouldBeAbleToCheckIsArgVargs() throws Exception {         assertEquals(toStringMethod.isVarArgs(), method.isVarArgs());     }          @Test     public void shouldBeAbleToGetParameterTypes() throws Exception {         assertArrayEquals(toStringMethod.getParameterTypes(), method.getParameterTypes());     }          @Test     public void shouldBeAbleToGetReturnType() throws Exception {         assertEquals(toStringMethod.getReturnType(), method.getReturnType());     }          @Test     public void shouldBeEqualForTwoInstances() throws Exception {         assertTrue(new SerializableMethod(toStringMethod).equals(method));     }          @Test     public void shouldNotBeEqualForSameMethodFromTwoDifferentClasses() throws Exception {         Method testBaseToStringMethod = String.class.getMethod("toString", args);         assertFalse(new SerializableMethod(testBaseToStringMethod).equals(method));     }          //TODO: add tests for generated equals() method      }
package org.mockito.internal.junit;  import org.junit.Test; import org.junit.runners.model.Statement; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.MockitoAnnotations; import org.mockito.exceptions.misusing.UnfinishedStubbingException; import org.mockito.internal.junit.JUnitRule;  import static org.junit.Assert.*;  public class JUnitRuleTest {      private JUnitRule jUnitRule = new JUnitRule();     private InjectTestCase injectTestCase = new InjectTestCase();      @Test     public void shouldInjectIntoTestCase() throws Throwable {         jUnitRule.apply(new DummyStatement(), injectTestCase).evaluate();         assertNotNull("@Mock mock object created", injectTestCase.getInjected());         assertNotNull("@InjectMocks object created", injectTestCase.getInjectInto());         assertNotNull("Mock injected into the object", injectTestCase.getInjectInto().getInjected());     }      @Test     public void shouldRethrowException() throws Throwable {         try {             jUnitRule.apply(new ExceptionStatement(), injectTestCase).evaluate();             fail("Should throw exception");         } catch (RuntimeException e) {             assertEquals("Correct message", "Statement exception", e.getMessage());         }     }      @Test     public void shouldDetectUnfinishedStubbing() throws Throwable {         try {             jUnitRule.apply(new UnfinishedStubbingStatement(), injectTestCase).evaluate();             fail("Should detect invalid Mockito usage");         } catch (UnfinishedStubbingException e) {         }     }      private static class DummyStatement extends Statement {         @Override         public void evaluate() throws Throwable {         }     }      private static class ExceptionStatement extends Statement {         @Override         public void evaluate() throws Throwable {             throw new RuntimeException("Statement exception");         }     }      private static class UnfinishedStubbingStatement extends Statement {         @Override         public void evaluate() throws Throwable {             InjectTestCase injectTestCase = new InjectTestCase();             MockitoAnnotations.initMocks(injectTestCase);             injectTestCase.unfinishedStubbingThrowsException();         }     }      public static class InjectTestCase {          @Mock         private Injected injected;          @InjectMocks         private InjectInto injectInto;          @Test         public void dummy() throws Exception {         }          public void unfinishedStubbingThrowsException() throws Exception {             Mockito.when(injected.stringMethod());         }          public Injected getInjected() {             return injected;         }          public InjectInto getInjectInto() {             return injectInto;         }          public static class Injected {             public String stringMethod() {                 return "string";             }         }          public static class InjectInto {             private Injected injected;              public Injected getInjected() {                 return injected;             }         }      } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.matchers;  import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class CapturingMatcherTest extends TestBase {      @Test     public void should_capture_arguments() throws Exception {         //given         CapturingMatcher m = new CapturingMatcher();                  //when         m.captureFrom("foo");         m.captureFrom("bar");                  //then         Assertions.assertThat(m.getAllValues()).containsSequence("foo", "bar");     }          @Test     public void should_know_last_captured_value() throws Exception {         //given         CapturingMatcher m = new CapturingMatcher();                  //when         m.captureFrom("foo");         m.captureFrom("bar");                  //then         assertEquals("bar", m.getLastValue());     }          @Test     public void should_scream_when_nothing_yet_captured() throws Exception {         //given         CapturingMatcher m = new CapturingMatcher();          try {             //when             m.getLastValue();             //then             fail();         } catch (MockitoException e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.matchers;  import org.junit.Test; import org.mockitoutil.TestBase;  import java.math.BigDecimal;  public class ComparableMatchersTest extends TestBase {      @Test     public void testLessThan() {         test(new LessThan<String>("b"), true, false, false, "lt");     }      @Test     public void testGreaterThan() {         test(new GreaterThan<String>("b"), false, true, false, "gt");     }      @Test     public void testLessOrEqual() {         test(new LessOrEqual<String>("b"), true, false, true, "leq");     }      @Test     public void testGreaterOrEqual() {         test(new GreaterOrEqual<String>("b"), false, true, true, "geq");     }      @Test     public void testCompareEqual() {         test(new CompareEqual<String>("b"), false, false, true, "cmpEq");          // Make sure it works when equals provide a different result than compare         CompareEqual<BigDecimal> cmpEq = new CompareEqual<BigDecimal>(new BigDecimal("5.00"));         assertTrue(cmpEq.matches(new BigDecimal("5")));     }      private void test(CompareTo<String> compareTo, boolean lower, boolean higher,             boolean equals, String name) {          assertEquals(lower, compareTo.matches("a"));         assertEquals(equals, compareTo.matches("b"));         assertEquals(higher, compareTo.matches("c"));          assertEquals(name + "(b)", describe(compareTo));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.matchers;  import static org.mockito.internal.matchers.Equality.areEqual; import org.junit.Test; import org.mockitoutil.TestBase;  public class EqualityTest extends TestBase {          @Test     public void shouldKnowIfObjectsAreEqual() throws Exception {         int[] arr = new int[] {1, 2};         assertTrue(areEqual(arr, arr));         assertTrue(areEqual(new int[] {1, 2}, new int[] {1, 2}));         assertTrue(areEqual(new Double[] {1.0}, new Double[] {1.0}));         assertTrue(areEqual(new String[0], new String[0]));         assertTrue(areEqual(new Object[10], new Object[10]));         assertTrue(areEqual(new int[] {1}, new Integer[] {1}));         assertTrue(areEqual(new Object[] {"1"}, new String[] {"1"}));         Object badequals=new BadEquals();         assertTrue(areEqual(badequals,badequals));          assertFalse(areEqual(new Object[9], new Object[10]));         assertFalse(areEqual(new int[] {1, 2}, new int[] {1}));         assertFalse(areEqual(new int[] {1}, new double[] {1.0}));     }      private final class BadEquals {         @Override         public boolean equals(Object oth) {             throw new RuntimeException();         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.matchers;  import org.junit.Test; import org.mockitoutil.TestBase;   public class EqualsTest extends TestBase {      @Test     public void shouldBeEqual() {         assertEquals(new Equals(null), new Equals(null));         assertEquals(new Equals(new Integer(2)), new Equals(new Integer(2)));         assertFalse(new Equals(null).equals(null));         assertFalse(new Equals(null).equals("Test"));         assertEquals(1, new Equals(null).hashCode());     }      @Test     public void shouldArraysBeEqual() {         assertTrue(new Equals(new int[] {1, 2}).matches(new int[] {1, 2}));         assertFalse(new Equals(new Object[] {"1"}).matches(new Object[] {"1.0"}));     }          @Test     public void shouldDescribeWithExtraTypeInfo() throws Exception {         String descStr = describe(new Equals(100).withExtraTypeInfo());                  assertEquals("(Integer) 100", descStr);     }      @Test     public void shouldDescribeWithExtraTypeInfoOfLong() throws Exception {         String descStr = describe(new Equals(100L).withExtraTypeInfo());                  assertEquals("(Long) 100", descStr);     }          @Test     public void shouldAppendQuotingForString() {         String descStr = describe(new Equals("str"));                  assertEquals("\"str\"", descStr);     }      @Test     public void shouldAppendQuotingForChar() {         String descStr = describe(new Equals('s'));                  assertEquals("'s'", descStr);     }          @Test     public void shouldDescribeUsingToString() {         String descStr = describe(new Equals(100));                  assertEquals("100", descStr);     }      @Test     public void shouldDescribeNull() {         String descStr = describe(new Equals(null));                  assertEquals("null", descStr);     }          @Test     public void shouldMatchTypes() throws Exception {         //when         ContainsExtraTypeInformation equals = new Equals(10);                  //then         assertTrue(equals.typeMatches(10));         assertFalse(equals.typeMatches(10L));     }          @Test     public void shouldMatchTypesSafelyWhenActualIsNull() throws Exception {         //when         ContainsExtraTypeInformation equals = new Equals(null);                  //then         assertFalse(equals.typeMatches(10));     }      @Test     public void shouldMatchTypesSafelyWhenGivenIsNull() throws Exception {         //when         ContainsExtraTypeInformation equals = new Equals(10);                  //then         assertFalse(equals.typeMatches(null));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.matchers;  import org.hamcrest.Matcher; import org.junit.Test; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class LocalizedMatcherTest extends TestBase {          @Test     public void shouldMatchTypesWhenActualMatcherHasCorrectType() throws Exception {         //when         ContainsExtraTypeInformation equals10 = new Equals(10);         LocalizedMatcher m = new LocalizedMatcher((Matcher) equals10);                  //then         assertTrue(m.typeMatches(10));         assertFalse(m.typeMatches(10L));     }      @Test     public void shouldNotMatchTypesWhenActualMatcherDoesNotHaveCorrectType() throws Exception {         //when         LocalizedMatcher m = new LocalizedMatcher(Any.ANY);                  //then         assertFalse(m.typeMatches(10));     }          @Test     public void shouldDescribeWithTypeInfoWhenActualMatcherHasCorrectType() throws Exception {         //when         ContainsExtraTypeInformation equals10 = new Equals(10);         LocalizedMatcher m = new LocalizedMatcher((Matcher) equals10);                  //then         assertEquals("(Integer) 10", describe(m.withExtraTypeInfo()));     }          @Test     public void shouldNotDescribeWithTypeInfoWhenActualMatcherDoesNotHaveCorrectType() throws Exception {         //when         LocalizedMatcher m = new LocalizedMatcher(Any.ANY);                  //then         assertSame(m, m.withExtraTypeInfo());     }          @Test     public void shouldDelegateToCapturingMatcher() throws Exception {         //given         CapturingMatcher capturingMatcher = new CapturingMatcher();         LocalizedMatcher m = new LocalizedMatcher(capturingMatcher);                  //when         m.captureFrom("boo");                  //then         assertEquals("boo", capturingMatcher.getLastValue());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.matchers;  import java.util.Arrays; import java.util.List;  import org.junit.Test; import org.mockito.internal.reporting.PrintSettings; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class MatchersPrinterTest extends TestBase {      MatchersPrinter printer = new MatchersPrinter();      @Test     public void shouldGetArgumentsLine() {         String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());         assertEquals("(1, 2);", line);     }      @Test     public void shouldGetArgumentsBlock() {         String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1), new Equals(2)), new PrintSettings());         assertEquals("(\n    1,\n    2\n);", line);     }      @Test     public void shouldDescribeTypeInfoOnlyMarkedMatchers() {         //when         String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(1));         //then         assertEquals("(1, (Integer) 2);", line);     }      @Test     public void shouldGetVerboseArgumentsInBlock() {         //when         String line = printer.getArgumentsBlock((List) Arrays.asList(new Equals(1L), new Equals(2)), PrintSettings.verboseMatchers(0, 1));         //then         assertEquals("(\n    (Long) 1,\n    (Integer) 2\n);", line);     }      @Test     public void shouldGetVerboseArgumentsEvenIfSomeMatchersAreNotVerbose() {         //when         String line = printer.getArgumentsLine((List) Arrays.asList(new Equals(1L), NotNull.NOT_NULL), PrintSettings.verboseMatchers(0));         //then         assertEquals("((Long) 1, notNull());", line);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.matchers;  import java.util.ArrayList; import java.util.List;  import org.hamcrest.Matcher; import org.junit.Test; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class MatchersToStringTest extends TestBase {      @Test     public void sameToStringWithString() {         assertEquals("same(\"X\")", describe(new Same("X")));      }      @Test     public void nullToString() {         assertEquals("isNull()", describe(Null.NULL));     }      @Test     public void notNullToString() {         assertEquals("notNull()", describe(NotNull.NOT_NULL));     }      @Test     public void anyToString() {         assertEquals("<any>", describe(Any.ANY));     }      @Test     public void sameToStringWithChar() {         assertEquals("same('x')", describe(new Same('x')));     }      @Test     public void sameToStringWithObject() {         Object o = new Object() {             @Override             public String toString() {                 return "X";             }         };         assertEquals("same(X)", describe(new Same(o)));     }      @Test     public void equalsToStringWithString() {         assertEquals("\"X\"", describe(new Equals("X")));      }      @Test     public void equalsToStringWithChar() {         assertEquals("'x'", describe(new Equals('x')));     }      @Test     public void equalsToStringWithObject() {         Object o = new Object() {             @Override             public String toString() {                 return "X";             }         };         assertEquals("X", describe(new Equals(o)));     }      @Test     public void orToString() {         List<Matcher> matchers = new ArrayList<Matcher>();         matchers.add(new Equals(1));         matchers.add(new Equals(2));         assertEquals("or(1, 2)", describe(new Or(matchers)));     }      @Test     public void notToString() {         assertEquals("not(1)", describe(new Not(new Equals(1))));     }      @Test     public void andToString() {         List<Matcher> matchers = new ArrayList<Matcher>();         matchers.add(new Equals(1));         matchers.add(new Equals(2));         assertEquals("and(1, 2)", describe(new And(matchers)));     }      @Test     public void startsWithToString() {         assertEquals("startsWith(\"AB\")", describe(new StartsWith("AB")));     }      @Test     public void endsWithToString() {         assertEquals("endsWith(\"AB\")", describe(new EndsWith("AB")));     }      @Test     public void containsToString() {         assertEquals("contains(\"AB\")", describe(new Contains("AB")));     }      @Test     public void findToString() {         assertEquals("find(\"\\\\s+\")", describe(new Find("\\s+")));     }      @Test     public void matchesToString() {         assertEquals("matches(\"\\\\s+\")", describe(new Matches("\\s+")));     }  } 
package org.mockito.internal.matchers;   import org.junit.Test; import org.mockito.exceptions.base.MockitoException;  import static java.util.Arrays.asList; import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail;  public class VarargCapturingMatcherTest {     @Test     public void should_capture_simple_arguments() throws Exception {         //given         VarargCapturingMatcher m = new VarargCapturingMatcher();          //when         m.captureFrom("foo");         m.captureFrom("bar");          //then         assertThat(m.getAllVarargs()).containsSequence(asList("foo"), asList("bar"));     }      @Test     public void should_know_last_captured_vararg() throws Exception {         //given         VarargCapturingMatcher m = new VarargCapturingMatcher();          //when         m.captureFrom(new Object[] { "foo", "bar" });         m.captureFrom(new Object[] { "fool", "bard" });          //then         assertThat(m.getLastVarargs()).containsSequence("fool", "bard");     }      @Test     public void can_capture_primitive_varargs() throws Exception {         //given         VarargCapturingMatcher m = new VarargCapturingMatcher();          //when         m.captureFrom(new int[] { 1, 2, 3 });          //then         assertThat(m.getLastVarargs()).containsSequence(1, 2, 3);     }      @Test     public void should_scream_when_nothing_yet_captured() throws Exception {         //given         VarargCapturingMatcher m = new VarargCapturingMatcher();          try {             //when             m.getLastVarargs();             //then             fail();         } catch (MockitoException e) {}     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  //Class comes from Apache Commons Lang, added some tiny changes package org.mockito.internal.matchers.apachecommons;  import java.math.BigDecimal; import java.util.Arrays;  import org.junit.Test; import org.mockitoutil.TestBase;  /**  * @author <a href="mailto:sdowney@panix.com">Steve Downey</a>  * @author <a href="mailto:scolebourne@joda.org">Stephen Colebourne</a>  * @author <a href="mailto:ggregory@seagullsw.com">Gary Gregory</a>  * @author Maarten Coene  * @version $Id: EqualsBuilderTest.java 611543 2008-01-13 07:00:22Z bayard $  */ public class EqualsBuilderTest extends TestBase {          @Test     public void testname() throws Exception {              }      static class TestObject {         private int a;         public TestObject() {         }         public TestObject(int a) {             this.a = a;         }         public boolean equals(Object o) {             if (o == null) { return false; }             if (o == this) { return true; }             if (o.getClass() != getClass()) {                 return false;             }              TestObject rhs = (TestObject) o;             return (a == rhs.a);         }         public int hashCode() {             return super.hashCode();         }          public void setA(int a) {             this.a = a;         }          public int getA() {             return a;         }     }      static class TestSubObject extends TestObject {         private int b;         public TestSubObject() {             super(0);         }         public TestSubObject(int a, int b) {             super(a);             this.b = b;         }         public boolean equals(Object o) {             if (o == null) { return false; }             if (o == this) { return true; }             if (o.getClass() != getClass()) {                 return false;             }              TestSubObject rhs = (TestSubObject) o;             return super.equals(o) && (b == rhs.b);         }         public int hashCode() {             return 1;         }          public void setB(int b) {             this.b = b;         }          public int getB() {             return b;         }     }          static class TestEmptySubObject extends TestObject {         public TestEmptySubObject(int a) {             super(a);         }     }          @SuppressWarnings("unused")     static class TestTSubObject extends TestObject {         private transient int t;         public TestTSubObject(int a, int t) {             super(a);             this.t = t;         }     }      @SuppressWarnings("unused")     static class TestTTSubObject extends TestTSubObject {         private transient int tt;         public TestTTSubObject(int a, int t, int tt) {             super(a, t);             this.tt = tt;         }     }      @SuppressWarnings("unused")     static class TestTTLeafObject extends TestTTSubObject {         private int leafValue;         public TestTTLeafObject(int a, int t, int tt, int leafValue) {             super(a, t, tt);             this.leafValue = leafValue;         }     }      static class TestTSubObject2 extends TestObject {         private transient int t;         public TestTSubObject2(int a, int t) {             super(a);         }         public int getT() {             return t;         }         public void setT(int t) {             this.t = t;         }     }      @Test public void testReflectionEquals() {         TestObject o1 = new TestObject(4);         TestObject o2 = new TestObject(5);         assertTrue(EqualsBuilder.reflectionEquals(o1, o1));         assertTrue(!EqualsBuilder.reflectionEquals(o1, o2));         o2.setA(4);         assertTrue(EqualsBuilder.reflectionEquals(o1, o2));          assertTrue(!EqualsBuilder.reflectionEquals(o1, this));          assertTrue(!EqualsBuilder.reflectionEquals(o1, null));         assertTrue(!EqualsBuilder.reflectionEquals(null, o2));         assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null));     }          @Test public void testReflectionHierarchyEquals() {         testReflectionHierarchyEquals(false);         testReflectionHierarchyEquals(true);         // Transients         assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));         assertTrue(EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), false));         assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 0, 0, 4), new TestTTLeafObject(1, 2, 3, 4), true));         assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(1, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 0), true));         assertTrue(!EqualsBuilder.reflectionEquals(new TestTTLeafObject(0, 2, 3, 4), new TestTTLeafObject(1, 2, 3, 4), true));     }    private void testReflectionHierarchyEquals(boolean testTransients) {         TestObject to1 = new TestObject(4);         TestObject to1Bis = new TestObject(4);         TestObject to1Ter = new TestObject(4);         TestObject to2 = new TestObject(5);         TestEmptySubObject teso = new TestEmptySubObject(4);         TestTSubObject ttso = new TestTSubObject(4, 1);         TestTTSubObject tttso = new TestTTSubObject(4, 1, 2);         TestTTLeafObject ttlo = new TestTTLeafObject(4, 1, 2, 3);         TestSubObject tso1 = new TestSubObject(1, 4);         TestSubObject tso1bis = new TestSubObject(1, 4);         TestSubObject tso1ter = new TestSubObject(1, 4);         TestSubObject tso2 = new TestSubObject(2, 5);          testReflectionEqualsEquivalenceRelationship(to1, to1Bis, to1Ter, to2, new TestObject(), testTransients);         testReflectionEqualsEquivalenceRelationship(tso1, tso1bis, tso1ter, tso2, new TestSubObject(), testTransients);          // More sanity checks:          // same values         assertTrue(EqualsBuilder.reflectionEquals(ttlo, ttlo, testTransients));         assertTrue(EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 10), testTransients));         // same super values, diff sub values         assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(1, 11), testTransients));         assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 11), new TestSubObject(1, 10), testTransients));         // diff super values, same sub values         assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestSubObject(1, 10), testTransients));         assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(1, 10), new TestSubObject(0, 10), testTransients));          // mix super and sub types: equals         assertTrue(EqualsBuilder.reflectionEquals(to1, teso, testTransients));         assertTrue(EqualsBuilder.reflectionEquals(teso, to1, testTransients));          assertTrue(EqualsBuilder.reflectionEquals(to1, ttso, false)); // Force testTransients = false for this assert         assertTrue(EqualsBuilder.reflectionEquals(ttso, to1, false)); // Force testTransients = false for this assert          assertTrue(EqualsBuilder.reflectionEquals(to1, tttso, false)); // Force testTransients = false for this assert         assertTrue(EqualsBuilder.reflectionEquals(tttso, to1, false)); // Force testTransients = false for this assert          assertTrue(EqualsBuilder.reflectionEquals(ttso, tttso, false)); // Force testTransients = false for this assert         assertTrue(EqualsBuilder.reflectionEquals(tttso, ttso, false)); // Force testTransients = false for this assert          // mix super and sub types: NOT equals         assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestEmptySubObject(1), testTransients));         assertTrue(!EqualsBuilder.reflectionEquals(new TestEmptySubObject(1), new TestObject(0), testTransients));          assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(0), new TestTSubObject(1, 1), testTransients));         assertTrue(!EqualsBuilder.reflectionEquals(new TestTSubObject(1, 1), new TestObject(0), testTransients));          assertTrue(!EqualsBuilder.reflectionEquals(new TestObject(1), new TestSubObject(0, 10), testTransients));         assertTrue(!EqualsBuilder.reflectionEquals(new TestSubObject(0, 10), new TestObject(1), testTransients));          assertTrue(!EqualsBuilder.reflectionEquals(to1, ttlo));         assertTrue(!EqualsBuilder.reflectionEquals(tso1, this));     }      /**      * Equivalence relationship tests inspired by "Effective Java":      * <ul>      * <li>reflection</li>      * <li>symmetry</li>      * <li>transitive</li>      * <li>consistency</li>      * <li>non-null reference</li>      * </ul>      * @param to a TestObject      * @param toBis a TestObject, equal to to and toTer      * @param toTer Left hand side, equal to to and toBis      * @param to2 a different TestObject      * @param oToChange a TestObject that will be changed      */     private void testReflectionEqualsEquivalenceRelationship(         TestObject to,         TestObject toBis,         TestObject toTer,         TestObject to2,         TestObject oToChange,         boolean testTransients) {          // reflection test         assertTrue(EqualsBuilder.reflectionEquals(to, to, testTransients));         assertTrue(EqualsBuilder.reflectionEquals(to2, to2, testTransients));          // symmetry test         assertTrue(EqualsBuilder.reflectionEquals(to, toBis, testTransients) && EqualsBuilder.reflectionEquals(toBis, to, testTransients));          // transitive test         assertTrue(             EqualsBuilder.reflectionEquals(to, toBis, testTransients)                 && EqualsBuilder.reflectionEquals(toBis, toTer, testTransients)                 && EqualsBuilder.reflectionEquals(to, toTer, testTransients));          // consistency test         oToChange.setA(to.getA());         if (oToChange instanceof TestSubObject) {             ((TestSubObject) oToChange).setB(((TestSubObject) to).getB());         }         assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));         assertTrue(EqualsBuilder.reflectionEquals(oToChange, to, testTransients));         oToChange.setA(to.getA() + 1);         if (oToChange instanceof TestSubObject) {             ((TestSubObject) oToChange).setB(((TestSubObject) to).getB() + 1);         }         assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));         assertTrue(!EqualsBuilder.reflectionEquals(oToChange, to, testTransients));          // non-null reference test         assertTrue(!EqualsBuilder.reflectionEquals(to, null, testTransients));         assertTrue(!EqualsBuilder.reflectionEquals(to2, null, testTransients));         assertTrue(!EqualsBuilder.reflectionEquals(null, to, testTransients));         assertTrue(!EqualsBuilder.reflectionEquals(null, to2, testTransients));         assertTrue(EqualsBuilder.reflectionEquals((Object) null, (Object) null, testTransients));     }      @Test public void testSuper() {         TestObject o1 = new TestObject(4);         TestObject o2 = new TestObject(5);         assertEquals(true, new EqualsBuilder().appendSuper(true).append(o1, o1).isEquals());         assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o1).isEquals());         assertEquals(false, new EqualsBuilder().appendSuper(true).append(o1, o2).isEquals());         assertEquals(false, new EqualsBuilder().appendSuper(false).append(o1, o2).isEquals());     }      @Test public void testObject() {         TestObject o1 = new TestObject(4);         TestObject o2 = new TestObject(5);         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());         o2.setA(4);         assertTrue(new EqualsBuilder().append(o1, o2).isEquals());          assertTrue(!new EqualsBuilder().append(o1, this).isEquals());                  assertTrue(!new EqualsBuilder().append(o1, null).isEquals());         assertTrue(!new EqualsBuilder().append(null, o2).isEquals());         assertTrue(new EqualsBuilder().append((Object) null, (Object) null).isEquals());     }      @Test public void testLong() {         long o1 = 1L;         long o2 = 2L;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());     }      @Test public void testInt() {         int o1 = 1;         int o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());     }      @Test public void testShort() {         short o1 = 1;         short o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());     }      @Test public void testChar() {         char o1 = 1;         char o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());     }      @Test public void testByte() {         byte o1 = 1;         byte o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());     }      @Test public void testDouble() {         double o1 = 1;         double o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());         assertTrue(!new EqualsBuilder().append(o1, Double.NaN).isEquals());         assertTrue(new EqualsBuilder().append(Double.NaN, Double.NaN).isEquals());         assertTrue(new EqualsBuilder().append(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY).isEquals());     }      @Test public void testFloat() {         float o1 = 1;         float o2 = 2;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());         assertTrue(!new EqualsBuilder().append(o1, Float.NaN).isEquals());         assertTrue(new EqualsBuilder().append(Float.NaN, Float.NaN).isEquals());         assertTrue(new EqualsBuilder().append(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY).isEquals());     }      // https://issues.apache.org/jira/browse/LANG-393     @Test public void testBigDecimal() {         BigDecimal o1 = new BigDecimal("2.0");         BigDecimal o2 = new BigDecimal("2.00");         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(new EqualsBuilder().append(o1, o2).isEquals());     }      @Test public void testAccessors() {         EqualsBuilder equalsBuilder = new EqualsBuilder();         assertTrue(equalsBuilder.isEquals());         equalsBuilder.setEquals(true);         assertTrue(equalsBuilder.isEquals());         equalsBuilder.setEquals(false);         assertFalse(equalsBuilder.isEquals());     }          @Test public void testBoolean() {         boolean o1 = true;         boolean o2 = false;         assertTrue(new EqualsBuilder().append(o1, o1).isEquals());         assertTrue(!new EqualsBuilder().append(o1, o2).isEquals());     }      @Test public void testObjectArray() {         TestObject[] obj1 = new TestObject[3];         obj1[0] = new TestObject(4);         obj1[1] = new TestObject(5);         obj1[2] = null;         TestObject[] obj2 = new TestObject[3];         obj2[0] = new TestObject(4);         obj2[1] = new TestObject(5);         obj2[2] = null;                  assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj2, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1].setA(6);         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1].setA(5);         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[2] = obj1[1];         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[2] = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());                                 obj2 = null;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testLongArray() {         long[] obj1 = new long[2];         obj1[0] = 5L;         obj1[1] = 6L;         long[] obj2 = new long[2];         obj2[0] = 5L;         obj2[1] = 6L;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testIntArray() {         int[] obj1 = new int[2];         obj1[0] = 5;         obj1[1] = 6;         int[] obj2 = new int[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testShortArray() {         short[] obj1 = new short[2];         obj1[0] = 5;         obj1[1] = 6;         short[] obj2 = new short[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testCharArray() {         char[] obj1 = new char[2];         obj1[0] = 5;         obj1[1] = 6;         char[] obj2 = new char[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testByteArray() {         byte[] obj1 = new byte[2];         obj1[0] = 5;         obj1[1] = 6;         byte[] obj2 = new byte[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testDoubleArray() {         double[] obj1 = new double[2];         obj1[0] = 5;         obj1[1] = 6;         double[] obj2 = new double[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testFloatArray() {         float[] obj1 = new float[2];         obj1[0] = 5;         obj1[1] = 6;         float[] obj2 = new float[2];         obj2[0] = 5;         obj2[1] = 6;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testBooleanArray() {         boolean[] obj1 = new boolean[2];         obj1[0] = true;         obj1[1] = false;         boolean[] obj2 = new boolean[2];         obj2[0] = true;         obj2[1] = false;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         obj1[1] = true;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());          obj2 = null;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());         obj1 = null;         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testMultiLongArray() {         long[][] array1 = new long[2][2];         long[][] array2 = new long[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());     }      @Test public void testMultiIntArray() {         int[][] array1 = new int[2][2];         int[][] array2 = new int[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());     }      @Test public void testMultiShortArray() {         short[][] array1 = new short[2][2];         short[][] array2 = new short[2][2];         for (short i = 0; i < array1.length; ++i) {             for (short j = 0; j < array1[0].length; j++) {                 array1[i][j] = i;                 array2[i][j] = i;             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());     }      @Test public void testMultiCharArray() {         char[][] array1 = new char[2][2];         char[][] array2 = new char[2][2];         for (char i = 0; i < array1.length; ++i) {             for (char j = 0; j < array1[0].length; j++) {                 array1[i][j] = i;                 array2[i][j] = i;             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());     }      @Test public void testMultiByteArray() {         byte[][] array1 = new byte[2][2];         byte[][] array2 = new byte[2][2];         for (byte i = 0; i < array1.length; ++i) {             for (byte j = 0; j < array1[0].length; j++) {                 array1[i][j] = i;                 array2[i][j] = i;             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());     }     @Test public void testMultiFloatArray() {         float[][] array1 = new float[2][2];         float[][] array2 = new float[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());     }      @Test public void testMultiDoubleArray() {         double[][] array1 = new double[2][2];         double[][] array2 = new double[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());     }      @Test public void testMultiBooleanArray() {         boolean[][] array1 = new boolean[2][2];         boolean[][] array2 = new boolean[2][2];         for (int i = 0; i < array1.length; ++i) {             for (int j = 0; j < array1[0].length; j++) {                 array1[i][j] = (i == 1) || (j == 1);                 array2[i][j] = (i == 1) || (j == 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = false;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());                  // compare 1 dim to 2.         boolean[] array3 = new boolean[]{true, true};         assertFalse(new EqualsBuilder().append(array1, array3).isEquals());         assertFalse(new EqualsBuilder().append(array3, array1).isEquals());         assertFalse(new EqualsBuilder().append(array2, array3).isEquals());         assertFalse(new EqualsBuilder().append(array3, array2).isEquals());     }      @Test public void testRaggedArray() {         long[][] array1 = new long[2][];         long[][] array2 = new long[2][];         for (int i = 0; i < array1.length; ++i) {             array1[i] = new long[2];             array2[i] = new long[2];             for (int j = 0; j < array1[i].length; ++j) {                 array1[i][j] = (i + 1) * (j + 1);                 array2[i][j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         array1[1][1] = 0;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());     }      @Test public void testMixedArray() {         Object[] array1 = new Object[2];         Object[] array2 = new Object[2];         for (int i = 0; i < array1.length; ++i) {             array1[i] = new long[2];             array2[i] = new long[2];             for (int j = 0; j < 2; ++j) {                 ((long[]) array1[i])[j] = (i + 1) * (j + 1);                 ((long[]) array2[i])[j] = (i + 1) * (j + 1);             }         }         assertTrue(new EqualsBuilder().append(array1, array1).isEquals());         assertTrue(new EqualsBuilder().append(array1, array2).isEquals());         ((long[]) array1[1])[1] = 0;         assertTrue(!new EqualsBuilder().append(array1, array2).isEquals());     }      @Test public void testObjectArrayHiddenByObject() {         TestObject[] array1 = new TestObject[2];         array1[0] = new TestObject(4);         array1[1] = new TestObject(5);         TestObject[] array2 = new TestObject[2];         array2[0] = new TestObject(4);         array2[1] = new TestObject(5);         Object obj1 = array1;         Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1].setA(6);         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testLongArrayHiddenByObject() {         long[] array1 = new long[2];         array1[0] = 5L;         array1[1] = 6L;         long[] array2 = new long[2];         array2[0] = 5L;         array2[1] = 6L;         Object obj1 = array1;         Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testIntArrayHiddenByObject() {         int[] array1 = new int[2];         array1[0] = 5;         array1[1] = 6;         int[] array2 = new int[2];         array2[0] = 5;         array2[1] = 6;         Object obj1 = array1;         Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testShortArrayHiddenByObject() {         short[] array1 = new short[2];         array1[0] = 5;         array1[1] = 6;         short[] array2 = new short[2];         array2[0] = 5;         array2[1] = 6;         Object obj1 = array1;         Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testCharArrayHiddenByObject() {         char[] array1 = new char[2];         array1[0] = 5;         array1[1] = 6;         char[] array2 = new char[2];         array2[0] = 5;         array2[1] = 6;         Object obj1 = array1;         Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testByteArrayHiddenByObject() {         byte[] array1 = new byte[2];         array1[0] = 5;         array1[1] = 6;         byte[] array2 = new byte[2];         array2[0] = 5;         array2[1] = 6;         Object obj1 = array1;         Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testDoubleArrayHiddenByObject() {         double[] array1 = new double[2];         array1[0] = 5;         array1[1] = 6;         double[] array2 = new double[2];         array2[0] = 5;         array2[1] = 6;         Object obj1 = array1;         Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testFloatArrayHiddenByObject() {         float[] array1 = new float[2];         array1[0] = 5;         array1[1] = 6;         float[] array2 = new float[2];         array2[0] = 5;         array2[1] = 6;         Object obj1 = array1;         Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = 7;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());     }      @Test public void testBooleanArrayHiddenByObject() {         boolean[] array1 = new boolean[2];         array1[0] = true;         array1[1] = false;         boolean[] array2 = new boolean[2];         array2[0] = true;         array2[1] = false;         Object obj1 = array1;         Object obj2 = array2;         assertTrue(new EqualsBuilder().append(obj1, obj1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array1).isEquals());         assertTrue(new EqualsBuilder().append(obj1, obj2).isEquals());         assertTrue(new EqualsBuilder().append(obj1, array2).isEquals());         array1[1] = true;         assertTrue(!new EqualsBuilder().append(obj1, obj2).isEquals());     }          public static class TestACanEqualB {         private int a;          public TestACanEqualB(int a) {             this.a = a;         }          public boolean equals(Object o) {             if (o == this) {                 return true;             }             if (o instanceof TestACanEqualB) {                 return this.a == ((TestACanEqualB) o).getA();             }             if (o instanceof TestBCanEqualA) {                 return this.a == ((TestBCanEqualA) o).getB();             }             return false;         }         public int hashCode() {             return 1;         }          public int getA() {             return this.a;         }     }      public static class TestBCanEqualA {         private int b;          public TestBCanEqualA(int b) {             this.b = b;         }          public boolean equals(Object o) {             if (o == this) {                 return true;             }             if (o instanceof TestACanEqualB) {                 return this.b == ((TestACanEqualB) o).getA();             }             if (o instanceof TestBCanEqualA) {                 return this.b == ((TestBCanEqualA) o).getB();             }             return false;         }         public int hashCode() {             return 1;         }                  public int getB() {             return this.b;         }     }          /**      * Tests two instances of classes that can be equal and that are not "related". The two classes are not subclasses      * of each other and do not share a parent aside from Object.      * See http://issues.apache.org/bugzilla/show_bug.cgi?id=33069      */     @Test public void testUnrelatedClasses() {         Object[] x = new Object[]{new TestACanEqualB(1)};         Object[] y = new Object[]{new TestBCanEqualA(1)};          // sanity checks:         assertTrue(Arrays.equals(x, x));         assertTrue(Arrays.equals(y, y));         assertTrue(Arrays.equals(x, y));         assertTrue(Arrays.equals(y, x));         // real tests:         assertTrue(x[0].equals(x[0]));         assertTrue(y[0].equals(y[0]));         assertTrue(x[0].equals(y[0]));         assertTrue(y[0].equals(x[0]));         assertTrue(new EqualsBuilder().append(x, x).isEquals());         assertTrue(new EqualsBuilder().append(y, y).isEquals());         assertTrue(new EqualsBuilder().append(x, y).isEquals());         assertTrue(new EqualsBuilder().append(y, x).isEquals());     }          /**      * Test from http://issues.apache.org/bugzilla/show_bug.cgi?id=33067      */     @Test public void testNpeForNullElement() {         Object[] x1 = new Object[] { new Integer(1), null, new Integer(3) };         Object[] x2 = new Object[] { new Integer(1), new Integer(2), new Integer(3) };          // causes an NPE in 2.0 according to:         // http://issues.apache.org/bugzilla/show_bug.cgi?id=33067         new EqualsBuilder().append(x1, x2);     }      @Test public void testReflectionEqualsExcludeFields() throws Exception {         TestObjectWithMultipleFields x1 = new TestObjectWithMultipleFields(1, 2, 3);         TestObjectWithMultipleFields x2 = new TestObjectWithMultipleFields(1, 3, 4);          // not equal when including all fields         assertTrue(!EqualsBuilder.reflectionEquals(x1, x2));          // doesn't barf on null, empty array, or non-existent field, but still tests as not equal         assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, (String[]) null));         assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {}));         assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {"xxx"}));          // not equal if only one of the differing fields excluded         assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {"two"}));         assertTrue(!EqualsBuilder.reflectionEquals(x1, x2, new String[] {"three"}));          // equal if both differing fields excluded         assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {"two", "three"}));          // still equal as long as both differing fields are among excluded         assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {"one", "two", "three"}));         assertTrue(EqualsBuilder.reflectionEquals(x1, x2, new String[] {"one", "two", "three", "xxx"}));     }      @SuppressWarnings("unused")     static class TestObjectWithMultipleFields {         private TestObject one;         private TestObject two;         private TestObject three;          public TestObjectWithMultipleFields(int one, int two, int three) {             this.one = new TestObject(one);             this.two = new TestObject(two);             this.three = new TestObject(three);         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.progress;  import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.verification.VerificationModeFactory; import org.mockitoutil.TestBase;  public class AtLeastTest extends TestBase {      @Test     public void shouldNotAllowNegativeNumberOfMinimumInvocations() throws Exception {         try {             VerificationModeFactory.atLeast(-50);             fail();         } catch (MockitoException e) {             assertEquals("Negative value is not allowed here", e.getMessage());         }     }      @Test     public void shouldAllowZeroInvocations() throws Exception {         VerificationModeFactory.atLeast(0);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.progress;  import org.junit.Test;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNull;   public class HandyReturnValuesTest {      private HandyReturnValues h = new HandyReturnValues();      @Test     public void should_not_return_null_for_primitives_wrappers() throws Exception {         assertNotNull(h.returnFor(Boolean.class));         assertNotNull(h.returnFor(Character.class));         assertNotNull(h.returnFor(Byte.class));         assertNotNull(h.returnFor(Short.class));         assertNotNull(h.returnFor(Integer.class));         assertNotNull(h.returnFor(Long.class));         assertNotNull(h.returnFor(Float.class));         assertNotNull(h.returnFor(Double.class));     }      @Test     public void should_not_return_null_for_primitives() throws Exception {         assertNotNull(h.returnFor(boolean.class));         assertNotNull(h.returnFor(char.class));         assertNotNull(h.returnFor(byte.class));         assertNotNull(h.returnFor(short.class));         assertNotNull(h.returnFor(int.class));         assertNotNull(h.returnFor(long.class));         assertNotNull(h.returnFor(float.class));         assertNotNull(h.returnFor(double.class));     }      @Test public void should_default_values_for_primitive() {         assertThat(h.returnFor(boolean.class)).isFalse();         assertThat(h.returnFor(char.class)).isEqualTo('\u0000');         assertThat(h.returnFor(byte.class)).isEqualTo((byte) 0);         assertThat(h.returnFor(short.class)).isEqualTo((short) 0);         assertThat(h.returnFor(int.class)).isEqualTo(0);         assertThat(h.returnFor(long.class)).isEqualTo(0L);         assertThat(h.returnFor(float.class)).isEqualTo(0.0F);         assertThat(h.returnFor(double.class)).isEqualTo(0.0D);     }      @Test     public void should_return_null_for_everything_else() throws Exception {         assertNull(h.returnFor(Object.class));         assertNull(h.returnFor(String.class));         assertNull(h.returnFor(null));     }      @Test     public void should_return_handy_value_for_instances() throws Exception {         assertNull(h.returnFor(new Object()));         assertNull(h.returnFor((Object) null));                  assertNotNull(h.returnFor(10.0));         assertNotNull(h.returnFor(Boolean.FALSE));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.progress;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.listeners.MockingStartedListener; import org.mockito.internal.verification.VerificationModeFactory; import org.mockito.verification.VerificationMode; import org.mockitoutil.TestBase;  import java.util.List;  import static org.mockito.Matchers.eq; import static org.mockito.Matchers.notNull; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.verify;  public class MockingProgressImplTest extends TestBase {      private MockingProgress mockingProgress;      @Before     public void setup() {         mockingProgress = new MockingProgressImpl();     }          @Test     public void shouldStartVerificationAndPullVerificationMode() throws Exception {         assertNull(mockingProgress.pullVerificationMode());                  VerificationMode mode = VerificationModeFactory.times(19);                  mockingProgress.verificationStarted(mode);                  assertSame(mode, mockingProgress.pullVerificationMode());                  assertNull(mockingProgress.pullVerificationMode());     }          @Test     public void shouldCheckIfVerificationWasFinished() throws Exception {         mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());         try {             mockingProgress.verificationStarted(VerificationModeFactory.atLeastOnce());             fail();         } catch (MockitoException e) {}     }      @Test     public void shouldNotifyListenerWhenMockingStarted() throws Exception {         //given         MockingStartedListener listener = mock(MockingStartedListener.class);         mockingProgress.setListener(listener);          //when         mockingProgress.mockingStarted("foo", List.class);          //then         verify(listener).mockingStarted(eq("foo"), eq(List.class));     }      @Test     public void shouldNotifyListenerSafely() throws Exception {         //when         mockingProgress.setListener(null);          //then no exception is thrown:         mockingProgress.mockingStarted(null, null);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.progress;  import org.junit.After; import org.junit.Test; import org.mockito.internal.verification.DummyVerificationMode; import org.mockitoutil.TestBase;  import java.util.List;  import static org.mockito.Mockito.mock; import static org.mockito.Mockito.verify;  public class ThreadSafeMockingProgressTest extends TestBase {      @After     public void after() {         this.resetState();     }      @Test     public void shouldShareState() throws Exception {         //given         ThreadSafeMockingProgress p = new ThreadSafeMockingProgress();         p.verificationStarted(new DummyVerificationMode());          //then         p = new ThreadSafeMockingProgress();         assertNotNull(p.pullVerificationMode());     }      @Test     public void shouldKnowWhenVerificationHasStarted() throws Exception {         //given         verify(mock(List.class));         ThreadSafeMockingProgress p = new ThreadSafeMockingProgress();          //then         assertNotNull(p.pullVerificationMode());     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.progress;  import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.verification.VerificationModeFactory; import org.mockitoutil.TestBase;  public class TimesTest extends TestBase {      @Test     public void shouldNotAllowNegativeNumberOfInvocations() throws Exception {         try {             VerificationModeFactory.times(-50);             fail();         } catch (MockitoException e) {             assertEquals("Negative value is not allowed here", e.getMessage());         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.reporting;  import org.junit.Test; import org.mockitoutil.TestBase;  public class PluralizerTest extends TestBase {      @Test     public void shouldGetPluralizedNumber() {         new Pluralizer();         assertEquals("0 times", Pluralizer.pluralize(0));         assertEquals("1 time", Pluralizer.pluralize(1));         assertEquals("2 times", Pluralizer.pluralize(2));         assertEquals("20 times", Pluralizer.pluralize(20));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.runners;  import static org.hamcrest.CoreMatchers.*;  import org.junit.Test; import org.junit.runners.model.InitializationError; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.runners.util.RunnerProvider; import org.mockitoutil.TestBase;  import java.lang.reflect.InvocationTargetException;  public class RunnerFactoryTest extends TestBase {      static class ClassProviderStub extends RunnerProvider {         @Override         public boolean isJUnit45OrHigherAvailable() {             return super.isJUnit45OrHigherAvailable();         }     }      @Test     public void shouldCreateRunnerForJUnit44() {} // Defects4J: flaky method //     @Test //     public void shouldCreateRunnerForJUnit44() throws Exception { //         //given //         RunnerProvider provider = new RunnerProvider() { //             public boolean isJUnit45OrHigherAvailable() { //                 return false; //             } //         }; //         RunnerFactory factory = new RunnerFactory(provider); //          //         //when //         RunnerImpl runner = factory.create(RunnerFactoryTest.class); //          //         //then //         assertThat(runner, is(JUnit44RunnerImpl.class)); //     }          @Test     public void shouldCreateRunnerForJUnit45() {} // Defects4J: flaky method //     @Test //     public void shouldCreateRunnerForJUnit45()  throws Exception{ //         //given //         RunnerProvider provider = new RunnerProvider() { //             public boolean isJUnit45OrHigherAvailable() { //                 return true; //             } //         }; //         RunnerFactory factory = new RunnerFactory(provider); //          //         //when //         RunnerImpl runner = factory.create(RunnerFactoryTest.class); //          //         //then //         assertThat(runner, is(JUnit45AndHigherRunnerImpl.class)); //     }          @Test     public void     shouldThrowMeaningfulMockitoExceptionIfNoValidJUnitFound()  throws Exception{         //given         RunnerProvider provider = new RunnerProvider() {             public boolean isJUnit45OrHigherAvailable() {                 return false;             }             public RunnerImpl newInstance(String runnerClassName, Class<?> constructorParam) throws Exception {                 throw new InitializationError("Where is JUnit, dude?");             }         };         RunnerFactory factory = new RunnerFactory(provider);                  try {             //when             factory.create(RunnerFactoryTest.class);             fail();         } catch (MockitoException e) {             //then             assertContains("upgrade your JUnit version", e.getMessage());         }     }      static class NoTestMethods {}      @Test     public void shouldSaySomethingMeaningfulWhenNoTestMethods()  throws Exception{         //given         RunnerFactory factory = new RunnerFactory(new RunnerProvider());          //when         try {             factory.create(NoTestMethods.class);             fail();         }         //then         catch (MockitoException e) {             assertContains("No tests", e.getMessage());         }     }      @Test     public void shouldForwardInvocationTargetException()  throws Exception{         //given         RunnerFactory factory = new RunnerFactory(new RunnerProvider()         {             @Override             public RunnerImpl newInstance(String runnerClassName, Class<?> constructorParam) throws Exception {                 throw new InvocationTargetException(new RuntimeException());             }         });          //when         try {             factory.create(this.getClass());             fail();         }         //then         catch (InvocationTargetException e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.runners.util;  import org.junit.Test; import org.mockito.internal.runners.RunnerImpl; import org.mockitoutil.TestBase;   public class RunnerProviderTest extends TestBase {          @Test     public void shouldKnowAboutJUnit45() throws Exception {         //given         RunnerProvider provider = new RunnerProvider();         //then         assertTrue(provider.isJUnit45OrHigherAvailable());         //I cannot test the opposite condition :(     }          @Test     public void shouldCreateRunnerInstance() throws Throwable {         //given         RunnerProvider provider = new RunnerProvider();         //when         RunnerImpl runner = provider.newInstance("org.mockito.internal.runners.JUnit45AndHigherRunnerImpl", this.getClass());         //then         assertNotNull(runner);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.runners.util;  import org.junit.Test; import org.mockitoutil.TestBase;  public class TestMethodsFinderTest extends TestBase {      public static class HasTests {         @Test public void someTest() {}     }      static class DoesNotHaveTests {         public void someTest() {}     }      @Test     public void shouldKnowWhenClassHasTests() {         assertTrue(new TestMethodsFinder().hasTestMethods(HasTests.class));         assertFalse(new TestMethodsFinder().hasTestMethods(DoesNotHaveTests.class));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.stubbing;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.internal.progress.MockingProgress; import org.mockito.internal.progress.MockingProgressImpl; import org.mockito.internal.stubbing.answers.Returns; import org.mockito.internal.stubbing.answers.ThrowsException; import org.mockito.invocation.Invocation; import org.mockitoutil.TestBase;  public class InvocationContainerImplStubbingTest extends TestBase {      private InvocationContainerImpl invocationContainerImpl;     private InvocationContainerImpl invocationContainerImplStubOnly;     private MockingProgress state;     private Invocation simpleMethod;      @Before     public void setup() {         state = new MockingProgressImpl();          invocationContainerImpl = new InvocationContainerImpl(state, new MockSettingsImpl());         invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());          invocationContainerImplStubOnly =           new InvocationContainerImpl(state, new MockSettingsImpl().stubOnly());         invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());          simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();     }      @Test     public void should_finish_stubbing_when_wrong_throwable_is_set() throws Exception {         state.stubbingStarted();         try {             invocationContainerImpl.addAnswer(new ThrowsException(new Exception()));             fail();         } catch (MockitoException e) {             state.validateState();         }     }      @Test     public void should_finish_stubbing_on_adding_return_value() throws Exception {         state.stubbingStarted();         invocationContainerImpl.addAnswer(new Returns("test"));         state.validateState();     }      @Test     public void should_get_results_for_methods() throws Throwable {         invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));         invocationContainerImpl.addAnswer(new Returns("simpleMethod"));          Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();         invocationContainerImpl.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));         invocationContainerImpl.addAnswer(new ThrowsException(new MyException()));          assertEquals("simpleMethod", invocationContainerImpl.answerTo(simpleMethod));          try {             invocationContainerImpl.answerTo(differentMethod);             fail();         } catch (MyException e) {}     }      @Test     public void should_get_results_for_methods_stub_only() throws Throwable {         invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(simpleMethod));         invocationContainerImplStubOnly.addAnswer(new Returns("simpleMethod"));          Invocation differentMethod = new InvocationBuilder().differentMethod().toInvocation();         invocationContainerImplStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(differentMethod));         invocationContainerImplStubOnly.addAnswer(new ThrowsException(new MyException()));          assertEquals("simpleMethod", invocationContainerImplStubOnly.answerTo(simpleMethod));          try {             invocationContainerImplStubOnly.answerTo(differentMethod);             fail();         } catch (MyException e) {}     }      @Test     public void should_add_throwable_for_void_method() throws Throwable {         invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new MyException()));         invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));          try {             invocationContainerImpl.answerTo(simpleMethod);             fail();         } catch (MyException e) {}     }      @Test     public void should_validate_throwable_for_void_method() throws Throwable {         invocationContainerImpl.addAnswerForVoidMethod(new ThrowsException(new Exception()));          try {             invocationContainerImpl.setMethodForStubbing(new InvocationMatcher(simpleMethod));             fail();         } catch (MockitoException e) {}     }      @Test     public void should_validate_throwable() throws Throwable {         try {             invocationContainerImpl.addAnswer(new ThrowsException(null));             fail();         } catch (MockitoException e) {}     }      @SuppressWarnings("serial")     class MyException extends RuntimeException {}; }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.stubbing;  import org.junit.Test; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.internal.progress.ThreadSafeMockingProgress; import org.mockito.internal.stubbing.answers.Returns; import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues; import org.mockito.invocation.Invocation;  import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.mock.MockCreationSettings;  import java.util.LinkedList; import java.util.concurrent.CountDownLatch;  import static org.junit.Assert.*;  /**  * Author: Szczepan Faber  */ public class InvocationContainerImplTest {      InvocationContainerImpl container = new InvocationContainerImpl(new ThreadSafeMockingProgress(), new MockSettingsImpl());     InvocationContainerImpl containerStubOnly =       new InvocationContainerImpl(new ThreadSafeMockingProgress(), (MockCreationSettings) new MockSettingsImpl().stubOnly());     Invocation invocation = new InvocationBuilder().toInvocation();     LinkedList<Throwable> exceptions = new LinkedList<Throwable>();      @Test     public void should_be_thread_safe() throws Throwable {         doShouldBeThreadSafe(container);     }      @Test     public void should_be_thread_safe_stub_only() throws Throwable {         doShouldBeThreadSafe(containerStubOnly);     }      //works 50% of the time     private void doShouldBeThreadSafe(final InvocationContainerImpl c) throws Throwable {         //given         Thread[] t = new Thread[200];         final CountDownLatch starter = new CountDownLatch(200);         for (int i = 0; i < t.length; i++ ) {             t[i] = new Thread() {                 public void run() {                     try {                         starter.await(); //NOPMD                     } catch (InterruptedException e) {                         throw new RuntimeException(e);                     }                     c.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));                     c.addAnswer(new Returns("foo"));                     c.findAnswerFor(invocation);                 }             };             t[i].setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {                 public void uncaughtException(Thread t, Throwable e) {                     exceptions.add(e);                 }             });             t[i].start();              starter.countDown();         }          //when         for (Thread aT : t) {             aT.join();         }          //then         if (exceptions.size() != 0) {             throw exceptions.getFirst();         }     }      @Test     public void should_return_invoked_mock() throws Exception {         container.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));          assertEquals(invocation.getMock(), container.invokedMock());     }      @Test     public void should_return_invoked_mock_stub_only() throws Exception {         containerStubOnly.setInvocationForPotentialStubbing(new InvocationMatcher(invocation));          assertEquals(invocation.getMock(), containerStubOnly.invokedMock());     }      @Test     public void should_tell_if_has_invocation_for_potential_stubbing() throws Exception {         container.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());         assertTrue(container.hasInvocationForPotentialStubbing());          container.addAnswer(new ReturnsEmptyValues());         assertFalse(container.hasInvocationForPotentialStubbing());     }      @Test     public void should_tell_if_has_invocation_for_potential_stubbing_stub_only() throws Exception {         containerStubOnly.setInvocationForPotentialStubbing(new InvocationBuilder().toInvocationMatcher());         assertTrue(containerStubOnly.hasInvocationForPotentialStubbing());          containerStubOnly.addAnswer(new ReturnsEmptyValues());         assertFalse(containerStubOnly.hasInvocationForPotentialStubbing());     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.stubbing.answers;  import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.misusing.WrongTypeOfReturnValue; import org.mockito.internal.MockitoCore; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.invocation.Invocation;  import java.io.IOException; import java.nio.charset.CharacterCodingException; import java.util.ArrayList;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import static org.mockito.Mockito.mock;  @SuppressWarnings("unchecked") public class AnswersValidatorTest {      private AnswersValidator validator = new AnswersValidator();     private Invocation invocation = new InvocationBuilder().method("canThrowException").toInvocation();      @Test     public void should_validate_null_throwable() throws Throwable {         try {             validator.validate(new ThrowsException(null), new InvocationBuilder().toInvocation());             fail();         } catch (MockitoException expected) {}     }      @Test     public void should_pass_proper_checked_exception() throws Throwable {         validator.validate(new ThrowsException(new CharacterCodingException()), invocation);     }      @Test(expected = MockitoException.class)     public void should_fail_invalid_checked_exception() throws Throwable {         validator.validate(new ThrowsException(new IOException()), invocation);     }      @Test     public void should_pass_RuntimeExceptions() throws Throwable {         validator.validate(new ThrowsException(new Error()), invocation);         validator.validate(new ThrowsException(new RuntimeException()), invocation);     }      @Test(expected = MockitoException.class)     public void should_fail_when_return_Value_is_set_for_void_method() throws Throwable {         validator.validate(new Returns("one"), new InvocationBuilder().method("voidMethod").toInvocation());     }      @Test(expected = MockitoException.class)     public void should_fail_when_non_void_method_does_nothing() throws Throwable {         validator.validate(new DoesNothing(), new InvocationBuilder().simpleMethod().toInvocation());     }      @Test     public void should_allow_void_return_for_void_method() throws Throwable {         validator.validate(new DoesNothing(), new InvocationBuilder().method("voidMethod").toInvocation());     }      @Test     public void should_allow_correct_type_of_return_value() throws Throwable {         validator.validate(new Returns("one"), new InvocationBuilder().simpleMethod().toInvocation());         validator.validate(new Returns(false), new InvocationBuilder().method("booleanReturningMethod").toInvocation());         validator.validate(new Returns(Boolean.TRUE), new InvocationBuilder().method("booleanObjectReturningMethod").toInvocation());         validator.validate(new Returns(1), new InvocationBuilder().method("integerReturningMethod").toInvocation());         validator.validate(new Returns(1L), new InvocationBuilder().method("longReturningMethod").toInvocation());         validator.validate(new Returns(1L), new InvocationBuilder().method("longObjectReturningMethod").toInvocation());         validator.validate(new Returns(null), new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());         validator.validate(new Returns(1), new InvocationBuilder().method("objectReturningMethodNoArgs").toInvocation());     }      @Test(expected = MockitoException.class)     public void should_fail_on_return_type_mismatch() throws Throwable {         validator.validate(new Returns("String"), new InvocationBuilder().method("booleanReturningMethod").toInvocation());     }      @Test(expected = MockitoException.class)     public void should_fail_on_wrong_primitive() throws Throwable {         validator.validate(new Returns(1), new InvocationBuilder().method("doubleReturningMethod").toInvocation());     }      @Test(expected = MockitoException.class)     public void should_fail_on_null_with_primitive() throws Throwable {         validator.validate(new Returns(null), new InvocationBuilder().method("booleanReturningMethod").toInvocation());     }      @Test     public void should_fail_when_calling_real_method_on_interface() throws Throwable {         //given         Invocation invocationOnInterface = new InvocationBuilder().method("simpleMethod").toInvocation();         try {             //when             validator.validate(new CallsRealMethods(), invocationOnInterface);             //then             fail();         } catch (MockitoException expected) {}     }      @Test     public void should_be_OK_when_calling_real_method_on_concrete_class() throws Throwable {         //given         ArrayList mock = mock(ArrayList.class);         mock.clear();         Invocation invocationOnClass = new MockitoCore().getLastInvocation();         //when         validator.validate(new CallsRealMethods(), invocationOnClass);         //then no exception is thrown     }      @Test     public void should_allow_possible_argument_types() throws Exception {         validator.validate(                 new ReturnsArgumentAt(0),                 new InvocationBuilder().method("intArgumentReturningInt").argTypes(int.class).arg(1000).toInvocation()         );         validator.validate(                 new ReturnsArgumentAt(0),                 new InvocationBuilder().method("toString").argTypes(String.class).arg("whatever").toInvocation()         );         validator.validate(                 new ReturnsArgumentAt(2),                 new InvocationBuilder().method("varargsObject")                                        .argTypes(int.class, Object[].class)                                        .args(1000, "Object", "Object")                                        .toInvocation()         );         validator.validate(                 new ReturnsArgumentAt(1),                 new InvocationBuilder().method("threeArgumentMethod")                                        .argTypes(int.class, Object.class, String.class)                                        .args(1000, "Object", "String")                                        .toInvocation()         );     }      @Test     public void should_fail_if_index_is_not_in_range_for_one_arg_invocation() throws Throwable {         try {             validator.validate(new ReturnsArgumentAt(30), new InvocationBuilder().method("oneArg").arg("A").toInvocation());             fail();         } catch (MockitoException e) {             assertThat(e.getMessage())                     .containsIgnoringCase("invalid argument index")                     .containsIgnoringCase("iMethods.oneArg")                     .containsIgnoringCase("[0] String")                     .containsIgnoringCase("position")                     .contains("30");         }     }      @Test     public void should_fail_if_index_is_not_in_range_for_example_with_no_arg_invocation() throws Throwable {         try {             validator.validate(                     new ReturnsArgumentAt(ReturnsArgumentAt.LAST_ARGUMENT),                     new InvocationBuilder().simpleMethod().toInvocation()             );             fail();         } catch (MockitoException e) {             assertThat(e.getMessage())                     .containsIgnoringCase("invalid argument index")                     .containsIgnoringCase("iMethods.simpleMethod")                     .containsIgnoringCase("no arguments")                     .containsIgnoringCase("last parameter wanted");         }     }      @Test     public void should_fail_if_argument_type_of_signature_is_incompatible_with_return_type() throws Throwable {         try {             validator.validate(                     new ReturnsArgumentAt(2),                     new InvocationBuilder().method("varargsReturningString")                                            .argTypes(Object[].class)                                            .args("anyString", new Object(), "anyString")                                            .toInvocation()             );             fail();         } catch (WrongTypeOfReturnValue e) {             assertThat(e.getMessage())                     .containsIgnoringCase("argument of type")                     .containsIgnoringCase("Object")                     .containsIgnoringCase("varargsReturningString")                     .containsIgnoringCase("should return")                     .containsIgnoringCase("String")                     .containsIgnoringCase("possible argument indexes");         }     }      @Test     public void should_fail_if_returned_value_of_answer_is_incompatible_with_return_type() throws Throwable {         try {             validator.validateDefaultAnswerReturnedValue(                     new InvocationBuilder().method("toString").toInvocation(),                     AWrongType.WRONG_TYPE             );             fail();         } catch (WrongTypeOfReturnValue e) {             assertThat(e.getMessage())                     .containsIgnoringCase("Default answer returned a result with the wrong type")                     .containsIgnoringCase("AWrongType cannot be returned by toString()")                     .containsIgnoringCase("toString() should return String");         }     }      @Test     public void should_not_fail_if_returned_value_of_answer_is_null() throws Throwable {         validator.validateDefaultAnswerReturnedValue(                 new InvocationBuilder().method("toString").toInvocation(),                 null         );     }      private static class AWrongType {         public static final AWrongType WRONG_TYPE = new AWrongType();     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.stubbing.answers;  import org.junit.Test; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.invocation.Invocation;  import java.nio.charset.CharacterCodingException;  import static org.junit.Assert.*;  /**  * by Szczepan Faber, created at: 3/31/12  */ public class MethodInfoTest {      @Test     public void shouldKnowValidThrowables() throws Exception {         //when         Invocation invocation = new InvocationBuilder().method("canThrowException").toInvocation();         MethodInfo info = new MethodInfo(invocation);          //then         assertFalse(info.isValidException(new Exception()));         assertTrue(info.isValidException(new CharacterCodingException()));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.stubbing.answers;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import org.junit.Test; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.invocation.InvocationOnMock;  public class ReturnsArgumentAtTest {     @Test     public void should_be_able_to_return_the_first_parameter() throws Throwable {         assertThat(new ReturnsArgumentAt(0).answer(invocationWith("A", "B"))).isEqualTo("A");     }      @Test     public void should_be_able_to_return_the_second_parameter()             throws Throwable {         assertThat(new ReturnsArgumentAt(1).answer(invocationWith("A", "B", "C"))).isEqualTo("B");     }      @Test     public void should_be_able_to_return_the_last_parameter() throws Throwable {         assertThat(new ReturnsArgumentAt(-1).answer(invocationWith("A"))).isEqualTo("A");         assertThat(new ReturnsArgumentAt(-1).answer(invocationWith("A", "B"))).isEqualTo("B");     }      @Test     public void should_be_able_to_return_the_specified_parameter() throws Throwable {         assertThat(new ReturnsArgumentAt(0).answer(invocationWith("A", "B", "C"))).isEqualTo("A");         assertThat(new ReturnsArgumentAt(1).answer(invocationWith("A", "B", "C"))).isEqualTo("B");         assertThat(new ReturnsArgumentAt(2).answer(invocationWith("A", "B", "C"))).isEqualTo("C");     }      @Test     public void should_raise_an_exception_if_index_is_not_in_allowed_range_at_creation_time() throws Throwable {         try {             new ReturnsArgumentAt(-30);             fail();         } catch (Exception e) {             assertThat(e.getMessage())                     .containsIgnoringCase("argument index")                     .containsIgnoringCase("positive number")                     .contains("1")                     .containsIgnoringCase("last argument");         }     }      private static InvocationOnMock invocationWith(Object... parameters) {         return new InvocationBuilder().method("varargsReturningString").argTypes(Object[].class)              .args(parameters).toInvocation();     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.stubbing.defaultanswers;  import static org.mockito.Mockito.mock; import java.util.ArrayList; import java.util.Collection; import java.util.Date; import java.util.HashMap; import java.util.HashSet; import java.util.LinkedHashMap; import java.util.LinkedHashSet; import java.util.LinkedList; import java.util.List; import java.util.Map; import java.util.Set; import java.util.SortedMap; import java.util.SortedSet; import java.util.TreeMap; import java.util.TreeSet; import org.junit.Test; import org.mockito.invocation.Invocation; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class ReturnsEmptyValuesTest extends TestBase {      ReturnsEmptyValues values = new ReturnsEmptyValues();      @Test public void should_return_empty_collections_or_null_for_non_collections() {         assertTrue(((Collection) values.returnValueFor(Collection.class)).isEmpty());          assertTrue(((Set) values.returnValueFor(Set.class)).isEmpty());         assertTrue(((SortedSet) values.returnValueFor(SortedSet.class)).isEmpty());         assertTrue(((HashSet) values.returnValueFor(HashSet.class)).isEmpty());         assertTrue(((TreeSet) values.returnValueFor(TreeSet.class)).isEmpty());         assertTrue(((LinkedHashSet) values.returnValueFor(LinkedHashSet.class)).isEmpty());          assertTrue(((List) values.returnValueFor(List.class)).isEmpty());         assertTrue(((ArrayList) values.returnValueFor(ArrayList.class)).isEmpty());         assertTrue(((LinkedList) values.returnValueFor(LinkedList.class)).isEmpty());          assertTrue(((Map) values.returnValueFor(Map.class)).isEmpty());         assertTrue(((SortedMap) values.returnValueFor(SortedMap.class)).isEmpty());         assertTrue(((HashMap) values.returnValueFor(HashMap.class)).isEmpty());         assertTrue(((TreeMap) values.returnValueFor(TreeMap.class)).isEmpty());         assertTrue(((LinkedHashMap) values.returnValueFor(LinkedHashMap.class)).isEmpty());          assertNull(values.returnValueFor(String.class));     }      @Test     public void should_return_empty_iterable() throws Exception {         assertFalse(((Iterable) values.returnValueFor(Iterable.class)).iterator().hasNext());     }      @Test public void should_return_primitive() {         assertEquals(false, values.returnValueFor(Boolean.TYPE));         assertEquals((char) 0, values.returnValueFor(Character.TYPE));         assertEquals((byte) 0, values.returnValueFor(Byte.TYPE));         assertEquals((short) 0, values.returnValueFor(Short.TYPE));         assertEquals(0, values.returnValueFor(Integer.TYPE));         assertEquals(0L, values.returnValueFor(Long.TYPE));         assertEquals(0F, values.returnValueFor(Float.TYPE));         assertEquals(0D, values.returnValueFor(Double.TYPE));     }      @Test public void should_return_non_zero_for_compareTo_method() {         //given         Date d = mock(Date.class);         d.compareTo(new Date());         Invocation compareTo = this.getLastInvocation();          //when         Object result = values.answer(compareTo);                  //then         assertTrue(result != (Object) 0);     }      @Test public void should_return_zero_if_mock_is_compared_to_itself() {         //given         Date d = mock(Date.class);         d.compareTo(d);         Invocation compareTo = this.getLastInvocation();          //when         Object result = values.answer(compareTo);          //then         assertEquals(0, result);     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.stubbing.defaultanswers;  import org.junit.Test;  import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set;  import static org.fest.assertions.Assertions.assertThat; import static org.mockito.Mockito.RETURNS_DEEP_STUBS; import static org.mockito.Mockito.mock;  @SuppressWarnings("unused") public class ReturnsGenericDeepStubsTest {     interface ListOfInteger extends List<Integer> {}      interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {         Set<Number> remove(Object key); // override with fixed ParameterizedType         List<? super Number> returningWildcard();         Map<String, K> returningNonMockableNestedGeneric();         K returningK();         <O extends K> List<O> paramTypeWithTypeParams();         <S extends Appendable, T extends S> T twoTypeParams(S s);         <O extends K> O typeVarWithTypeParams();         Number returnsNormalType();     }      @Test     public void generic_deep_mock_frenzy__look_at_these_chained_calls() throws Exception {         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);          Set<? extends Map.Entry<? extends Cloneable, Set<Number>>> entries = mock.entrySet();         Iterator<? extends Map.Entry<? extends Cloneable,Set<Number>>> entriesIterator = mock.entrySet().iterator();         Map.Entry<? extends Cloneable, Set<Number>> nextEntry = mock.entrySet().iterator().next();          Cloneable cloneableKey = mock.entrySet().iterator().next().getKey();         Comparable<?> comparableKey = mock.entrySet().iterator().next().getKey();          Set<Number> value = mock.entrySet().iterator().next().getValue();         Iterator<Number> numbersIterator = mock.entrySet().iterator().next().getValue().iterator();         Number number = mock.entrySet().iterator().next().getValue().iterator().next();     }      @Test     public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_parameterizedtype_that_is_referencing_a_typevar_on_class() throws Exception {         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);          Cloneable cloneable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =                 mock.paramTypeWithTypeParams().get(0);         Comparable<?> comparable_bound_that_is_declared_on_typevar_K_in_the_class_which_is_referenced_by_typevar_O_declared_on_the_method =                 mock.paramTypeWithTypeParams().get(0);     }      @Test     public void can_create_mock_from_multiple_type_variable_bounds_when_method_return_type_is_referencing_a_typevar_on_class() throws Exception {         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);          Cloneable cloneable_bound_of_typevar_K = mock.returningK();         Comparable<?> comparable_bound_of_typevar_K = mock.returningK();     }      @Test     public void can_create_mock_from_multiple_type_variable_bounds_when_return_type_of_parameterized_method_is_a_typevar_that_is_referencing_a_typevar_on_class() throws Exception {         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);          Cloneable cloneable_bound_of_typevar_K_referenced_by_typevar_O = (Cloneable) mock.typeVarWithTypeParams();         Comparable<?> comparable_bound_of_typevar_K_referenced_by_typevar_O = (Comparable) mock.typeVarWithTypeParams();     }      @Test     public void can_create_mock_from_return_types_declared_with_a_bounded_wildcard() throws Exception {         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);          List<? super Integer> objects = mock.returningWildcard();         Number type_that_is_the_upper_bound_of_the_wildcard = (Number) mock.returningWildcard().get(45);         type_that_is_the_upper_bound_of_the_wildcard.floatValue();     }      @Test     public void can_still_work_with_raw_type_in_the_return_type() throws Exception {         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);          Number the_raw_type_that_should_be_returned = mock.returnsNormalType();         the_raw_type_that_should_be_returned.floatValue();     }      @Test     public void will_return_default_value_on_non_mockable_nested_generic() throws Exception {         GenericsNest<?> genericsNest = mock(GenericsNest.class, RETURNS_DEEP_STUBS);         ListOfInteger listOfInteger = mock(ListOfInteger.class, RETURNS_DEEP_STUBS);          assertThat(genericsNest.returningNonMockableNestedGeneric().keySet().iterator().next()).isNull();         assertThat(listOfInteger.get(25)).isEqualTo(0);     }      @Test(expected = ClassCastException.class)     public void as_expected_fail_with_a_CCE_on_callsite_when_erasure_takes_place_for_example___StringBuilder_is_subject_to_erasure() throws Exception {         GenericsNest<?> mock = mock(GenericsNest.class, RETURNS_DEEP_STUBS);          // following assignment needed to create a ClassCastException on the call site (i.e. : here)         StringBuilder stringBuilder_assignment_that_should_throw_a_CCE =                 mock.twoTypeParams(new StringBuilder()).append(2).append(3);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.stubbing.defaultanswers;  import org.junit.Test; import org.mockito.internal.util.MockUtil; import org.mockitoutil.TestBase;  public class ReturnsMocksTest extends TestBase {     private ReturnsMocks values = new ReturnsMocks();      interface FooInterface {     }      class BarClass {     }      final class Baz {     }      @Test     public void should_return_mock_value_for_interface() throws Exception {         Object interfaceMock = values.returnValueFor(FooInterface.class);         assertTrue(new MockUtil().isMock(interfaceMock));     }      @Test     public void should_return_mock_value_for_class() throws Exception {         Object classMock = values.returnValueFor(BarClass.class);         assertTrue(new MockUtil().isMock(classMock));     }      @Test     public void should_return_null_for_final_class() throws Exception {         assertNull(values.returnValueFor(Baz.class));     }      @Test     public void should_return_the_usual_default_values_for_primitives() throws Throwable {         ReturnsMocks answer = new ReturnsMocks();         assertEquals(false, answer.answer(invocationOf(HasPrimitiveMethods.class, "booleanMethod")));         assertEquals((char) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "charMethod")));         assertEquals((byte) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "byteMethod")));         assertEquals((short) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "shortMethod")));         assertEquals(0, answer.answer(invocationOf(HasPrimitiveMethods.class, "intMethod")));         assertEquals(0L, answer.answer(invocationOf(HasPrimitiveMethods.class, "longMethod")));         assertEquals(0f, answer.answer(invocationOf(HasPrimitiveMethods.class, "floatMethod")));         assertEquals(0d, answer.answer(invocationOf(HasPrimitiveMethods.class, "doubleMethod")));     }      @SuppressWarnings("unused")     interface StringMethods {         String stringMethod();         String[] stringArrayMethod();     }          @Test     public void should_return_empty_array() throws Throwable {         String[] ret = (String[]) values.answer(invocationOf(StringMethods.class, "stringArrayMethod"));                  assertTrue(ret.getClass().isArray());         assertTrue(ret.length == 0);     }          @Test     public void should_return_empty_string() throws Throwable {         assertEquals("", values.answer(invocationOf(StringMethods.class, "stringMethod")));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.stubbing.defaultanswers;  import org.junit.Test; import org.mockitoutil.TestBase;  public class ReturnsMoreEmptyValuesTest extends TestBase {      private ReturnsMoreEmptyValues rv = new ReturnsMoreEmptyValues();      @Test     public void shouldReturnEmptyArray() {         String[] ret = (String[]) rv.returnValueFor((new String[0]).getClass());         assertTrue(ret.getClass().isArray());         assertTrue(ret.length == 0);     }          @Test     public void shouldReturnEmptyString() {         assertEquals("", rv.returnValueFor(String.class));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.stubbing.defaultanswers;  import org.junit.Test; import org.mockito.exceptions.verification.SmartNullPointerException; import org.mockito.stubbing.Answer; import org.mockitoutil.TestBase;  public class ReturnsSmartNullsTest extends TestBase {      @Test     public void should_return_the_usual_default_values_for_primitives() throws Throwable {         Answer<Object> answer = new ReturnsSmartNulls();         assertEquals(false  ,   answer.answer(invocationOf(HasPrimitiveMethods.class, "booleanMethod")));         assertEquals((char) 0,  answer.answer(invocationOf(HasPrimitiveMethods.class, "charMethod")));         assertEquals((byte) 0,  answer.answer(invocationOf(HasPrimitiveMethods.class, "byteMethod")));         assertEquals((short) 0, answer.answer(invocationOf(HasPrimitiveMethods.class, "shortMethod")));         assertEquals(0,         answer.answer(invocationOf(HasPrimitiveMethods.class, "intMethod")));         assertEquals(0L,        answer.answer(invocationOf(HasPrimitiveMethods.class, "longMethod")));         assertEquals(0f,        answer.answer(invocationOf(HasPrimitiveMethods.class, "floatMethod")));         assertEquals(0d,        answer.answer(invocationOf(HasPrimitiveMethods.class, "doubleMethod")));     }      @SuppressWarnings("unused")     interface Foo {         Foo get();         Foo withArgs(String oneArg, String otherArg);     }      @Test     public void should_return_an_object_that_fails_on_any_method_invocation_for_non_primitives() throws Throwable {         Answer<Object> answer = new ReturnsSmartNulls();          Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "get"));          try {             smartNull.get();             fail();         } catch (SmartNullPointerException expected) {}     }      @Test     public void should_return_an_object_that_allows_object_methods() throws Throwable {         Answer<Object> answer = new ReturnsSmartNulls();          Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "get"));          assertContains("SmartNull returned by", smartNull + "");         assertContains("foo.get()", smartNull + "");     }      @Test     public void should_print_the_parameters_when_calling_a_method_with_args() throws Throwable {         Answer<Object> answer = new ReturnsSmartNulls();          Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "withArgs", "oompa", "lumpa"));          assertContains("foo.withArgs", smartNull + "");         assertContains("oompa", smartNull + "");         assertContains("lumpa", smartNull + "");     }      @Test     public void should_print_the_parameters_on_SmartNullPointerException_message() throws Throwable {         Answer<Object> answer = new ReturnsSmartNulls();          Foo smartNull = (Foo) answer.answer(invocationOf(Foo.class, "withArgs", "oompa", "lumpa"));          try {             smartNull.get();             fail();         } catch (SmartNullPointerException e) {             assertContains("oompa", e.getMessage());             assertContains("lumpa", e.getMessage());         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.util;  import static org.mockito.internal.util.Decamelizer.*;  import org.junit.Test; import org.mockitoutil.TestBase;  public class DecamelizerTest extends TestBase {          @Test     public void shouldProduceDecentDescription() throws Exception {         assertEquals("<Sentence with strong language>", decamelizeMatcher("SentenceWithStrongLanguage"));         assertEquals("<W e i r d o 1>", decamelizeMatcher("WEIRDO1"));         assertEquals("<_>", decamelizeMatcher("_"));         assertEquals("<Has exactly 3 elements>", decamelizeMatcher("HasExactly3Elements"));         assertEquals("<custom argument matcher>", decamelizeMatcher(""));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util;  import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockitousage.IMethods;  import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.Observer;  import static java.util.Arrays.asList; import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail;  @SuppressWarnings("unchecked") public class MockCreationValidatorTest {      final class FinalClass {}     MockCreationValidator validator = new MockCreationValidator();      @Test     public void should_not_allow_extra_interface_that_is_the_same_as_the_mocked_type() throws Exception {         try {             //when             validator.validateExtraInterfaces(IMethods.class, (Collection) asList(IMethods.class));             fail();         } catch (MockitoException e) {             //then             assertThat(e.getMessage()).contains("You mocked following type: IMethods");         }     }      @Test(expected = MockitoException.class)     public void should_not_allow_inconsistent_types() throws Exception {         //when         validator.validateMockedType(List.class, new ArrayList());         //then     }      @Test     public void should_allow_only_consistent_types() throws Exception {         //when         validator.validateMockedType(ArrayList.class, new ArrayList());         //then no exception is thrown     }      @Test     public void should_validation_be_safe_when_nulls_passed() throws Exception {         //when         validator.validateMockedType(null, new ArrayList());         //or         validator.validateMockedType(ArrayList.class, null);         //then no exception is thrown     }      @Test(expected = MockitoException.class)     public void should_not_allow_serializable_with_Object_that_dont_implement_Serializable() {         class NonSerializableInnerClassThatHaveAHiddenOneArgConstructor {}         boolean serializable = true;         validator.validateSerializable(NonSerializableInnerClassThatHaveAHiddenOneArgConstructor.class, serializable);     }      @Test     public void should_allow_serializable_with_interfaces_or_Serializable_objects() {         boolean serializable = true;         validator.validateSerializable(Observer.class, serializable);         validator.validateSerializable(Integer.class, serializable);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util;  import org.junit.Test; import org.mockitoutil.TestBase;  public class MockNameImplTest extends TestBase {      @Test     public void shouldProvideTheNameForClass() throws Exception {         //when         String name = new MockNameImpl(null, SomeClass.class).toString();         //then         assertEquals("someClass", name);     }      @Test     public void shouldProvideTheNameForAnonymousClass() throws Exception {         //given         SomeInterface anonymousInstance = new SomeInterface() {};         //when         String name = new MockNameImpl(null, anonymousInstance.getClass()).toString();         //then         assertEquals("someInterface", name);     }      @Test     public void shouldProvideTheGivenName() throws Exception {         //when         String name = new MockNameImpl("The Hulk", SomeClass.class).toString();         //then         assertEquals("The Hulk", name);     }      private class SomeClass {}     private class SomeInterface {} }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.util;  import static org.mockito.Mockito.withSettings; import java.util.ArrayList; import java.util.List; import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.Mockito; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.misusing.NotAMockException; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class MockUtilTest extends TestBase {      private MockUtil mockUtil = new MockUtil();      @Test     public void should_get_handler() {         List mock = Mockito.mock(List.class);         assertNotNull(mockUtil.getMockHandler(mock));     }      @Test (expected=NotAMockException.class)     public void should_scream_when_not_a_mock_passed() {         mockUtil.getMockHandler("");     }      @Test (expected=MockitoException.class)     public void should_scream_when_null_passed() {         mockUtil.getMockHandler(null);     }      @Test     public void should_get_mock_settings() {         List mock = Mockito.mock(List.class);         assertNotNull(mockUtil.getMockSettings(mock));     }      @Test     public void should_validate_mock() {         assertFalse(mockUtil.isMock("i mock a mock"));         assertTrue(mockUtil.isMock(Mockito.mock(List.class)));     }      @Test     public void should_validate_spy() {         assertFalse(mockUtil.isSpy("i mock a mock"));         assertFalse(mockUtil.isSpy(Mockito.mock(List.class)));         assertFalse(mockUtil.isSpy((Class) null));          assertTrue(mockUtil.isSpy(Mockito.spy(new ArrayList())));         assertTrue(mockUtil.isSpy(Mockito.spy(ArrayList.class)));         assertTrue(mockUtil.isSpy(Mockito.mock(ArrayList.class, withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))));     }      @Test     public void should_redefine_MockName_if_default() {         List mock = Mockito.mock(List.class);         mockUtil.maybeRedefineMockName(mock, "newName");          Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo("newName");     }      @Test     public void should_not_redefine_MockName_if_default() {         List mock = Mockito.mock(List.class, "original");         mockUtil.maybeRedefineMockName(mock, "newName");          Assertions.assertThat(mockUtil.getMockName(mock).toString()).isEqualTo("original");     }      final class FinalClass {}     class SomeClass {}     interface SomeInterface {}      @Test     public void should_konw_if_type_is_mockable() throws Exception {         assertFalse(mockUtil.isTypeMockable(FinalClass.class));         assertFalse(mockUtil.isTypeMockable(int.class));          assertTrue(mockUtil.isTypeMockable(SomeClass.class));         assertTrue(mockUtil.isTypeMockable(SomeInterface.class));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util;  import org.junit.Test; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import java.util.Date;  public class ObjectMethodsGuruTest extends TestBase {      ObjectMethodsGuru guru = new ObjectMethodsGuru();          @Test     public void shouldKnowToStringMethod() throws Exception {         assertFalse(guru.isToString(Object.class.getMethod("equals", Object.class)));         assertFalse(guru.isToString(IMethods.class.getMethod("toString", String.class)));         assertTrue(guru.isToString(IMethods.class.getMethod("toString")));     }      @Test     public void shouldKnowEqualsMethod() throws Exception {         assertFalse(guru.isEqualsMethod(IMethods.class.getMethod("equals", String.class)));         assertFalse(guru.isEqualsMethod(IMethods.class.getMethod("equals")));         assertFalse(guru.isEqualsMethod(Object.class.getMethod("toString")));         assertTrue(guru.isEqualsMethod(Object.class.getMethod("equals", Object.class)));     }      @Test     public void shouldKnowHashCodeMethod() throws Exception {         assertFalse(guru.isHashCodeMethod(IMethods.class.getMethod("toString")));         assertFalse(guru.isHashCodeMethod(IMethods.class.getMethod("hashCode", String.class)));         assertTrue(guru.isHashCodeMethod(Object.class.getDeclaredMethod("hashCode")));     }      interface HasCompareToButDoesNotImplementComparable {         public int compareTo(HasCompareToButDoesNotImplementComparable other);     }      interface HasCompare extends Comparable {         public int foo(HasCompare other);         public int compareTo(HasCompare other, String redHerring);         public int compareTo(String redHerring);         public int compareTo(HasCompare redHerring);     }      @Test     public void shouldKnowCompareToMethod() throws Exception {         assertFalse(guru.isCompareToMethod(Date.class.getMethod("toString")));         assertFalse(guru.isCompareToMethod(HasCompare.class.getMethod("foo", HasCompare.class)));         assertFalse(guru.isCompareToMethod(HasCompare.class.getMethod("compareTo", HasCompare.class, String.class)));         assertFalse(guru.isCompareToMethod(HasCompare.class.getMethod("compareTo", String.class)));         assertFalse(guru.isCompareToMethod(HasCompareToButDoesNotImplementComparable.class.getDeclaredMethod("compareTo", HasCompareToButDoesNotImplementComparable.class)));          assertTrue(guru.isCompareToMethod(HasCompare.class.getMethod("compareTo", HasCompare.class)));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util;  import org.junit.Test; import org.mockitoutil.TestBase;  public class SimpleMockitoLoggerTest extends TestBase {      @Test     public void shouldLog() throws Exception {         //given         SimpleMockitoLogger logger = new SimpleMockitoLogger();         //when         logger.log("foo");         //then         assertEquals("foo", logger.getLoggedInfo());     } }
package org.mockito.internal.util;  import org.junit.Assert; import org.junit.Test; import org.mockito.exceptions.misusing.FriendlyReminderException; import org.mockitoutil.TestBase;  import static org.hamcrest.CoreMatchers.is;  public class TimerTest extends TestBase {      @Test     public void should_return_true_if_task_is_in_acceptable_time_bounds() {} // Defects4J: flaky method //     @Test //     public void should_return_true_if_task_is_in_acceptable_time_bounds() { //         //given //         long duration = 10000L; //         Timer timer = new Timer(duration); //  //         //when //         timer.start(); //  //         //then //         assertThat(timer.isCounting(), is(true)); //     }      @Test     public void should_return_false_when_time_run_out() {} // Defects4J: flaky method //     @Test //     public void should_return_false_when_time_run_out() throws Exception { //         //given //         Timer timer = new Timer(0); //         timer.start(); //  //         //when //         oneMillisecondPasses(); //  //         //then //         assertThat(timer.isCounting(), is(false)); //     }      @Test     public void should_throw_friendly_reminder_exception_when_duration_is_negative() {         try {             new Timer(-1);             Assert.fail("It is forbidden to create timer with negative value of timer's duration.");         } catch (FriendlyReminderException e) {             Assert.assertTrue(true);         }     }      private void oneMillisecondPasses() throws InterruptedException {         Thread.sleep(1);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.collections;  import org.junit.Test;  import java.util.LinkedList; import java.util.List; import java.util.Observer;  import static org.fest.assertions.Assertions.assertThat; import static org.mockito.Mockito.mock;  public class HashCodeAndEqualsSafeSetTest {      @Test     public void can_add_mock_that_have_failing_hashCode_method() throws Exception {         new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));     }      @Test     public void mock_with_failing_hashCode_method_can_be_added() throws Exception {         new HashCodeAndEqualsSafeSet().add(mock(UnmockableHashCodeAndEquals.class));     }      @Test     public void mock_with_failing_equals_method_can_be_used() throws Exception {         HashCodeAndEqualsSafeSet mocks = new HashCodeAndEqualsSafeSet();         UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);         mocks.add(mock);          assertThat(mocks.contains(mock)).isTrue();         assertThat(mocks.contains(mock(UnmockableHashCodeAndEquals.class))).isFalse();     }      @Test     public void can_remove() throws Exception {         HashCodeAndEqualsSafeSet mocks = new HashCodeAndEqualsSafeSet();         UnmockableHashCodeAndEquals mock = mock(UnmockableHashCodeAndEquals.class);         mocks.add(mock);         mocks.remove(mock);          assertThat(mocks.isEmpty()).isTrue();     }       @Test     public void can_add_a_collection() throws Exception {         HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(                 mock(UnmockableHashCodeAndEquals.class),                 mock(Observer.class));          HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();          workingSet.addAll(mocks);          assertThat(workingSet.containsAll(mocks)).isTrue();     }      @Test     public void can_retain_a_collection() throws Exception {         HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(                 mock(UnmockableHashCodeAndEquals.class),                 mock(Observer.class));          HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();          workingSet.addAll(mocks);         workingSet.add(mock(List.class));          assertThat(workingSet.retainAll(mocks)).isTrue();         assertThat(workingSet.containsAll(mocks)).isTrue();     }      @Test     public void can_remove_a_collection() throws Exception {         HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(                 mock(UnmockableHashCodeAndEquals.class),                 mock(Observer.class));          HashCodeAndEqualsSafeSet workingSet = new HashCodeAndEqualsSafeSet();          workingSet.addAll(mocks);         workingSet.add(mock(List.class));          assertThat(workingSet.removeAll(mocks)).isTrue();         assertThat(workingSet.containsAll(mocks)).isFalse();     }      @Test     public void can_iterate() throws Exception {         HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(                 mock(UnmockableHashCodeAndEquals.class),                 mock(Observer.class));          LinkedList<Object> accumulator = new LinkedList<Object>();         for (Object mock : mocks) {             accumulator.add(mock);         }         assertThat(accumulator).isNotEmpty();     }      @Test     public void toArray_just_work() throws Exception {         UnmockableHashCodeAndEquals mock1 = mock(UnmockableHashCodeAndEquals.class);         HashCodeAndEqualsSafeSet mocks = HashCodeAndEqualsSafeSet.of(mock1);          assertThat(mocks.toArray()[0]).isSameAs(mock1);          assertThat(mocks.toArray(new UnmockableHashCodeAndEquals[0])[0]).isSameAs(mock1);     }      private static class UnmockableHashCodeAndEquals {         @Override public final int hashCode() {             throw new NullPointerException("I'm failing on hashCode and I don't care");         }          @Override public final boolean equals(Object obj) {             throw new NullPointerException("I'm failing on equals and I don't care");         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.collections;  import org.junit.Test;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertFalse; import static org.junit.Assert.assertTrue;   public class IdentitySetTest {          IdentitySet set = new IdentitySet();          @Test     public void shouldWork() throws Exception {         //when         Object o = new Object();         set.add(o);          //then         assertTrue(set.contains(o));         assertFalse(set.contains(new Object()));     }          class Fake {         @Override         public boolean equals(Object obj) {             return true;         }     }          @Test     public void shouldWorkEvenIfEqualsTheSame() throws Exception {         //given         assertEquals(new Fake(), new Fake());         Fake fake = new Fake();                  //when         set.add(fake);          //then         assertTrue(set.contains(fake));         assertFalse(set.contains(new Fake()));     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.util.collections;  import org.junit.Test; import org.mockito.internal.util.collections.ListUtil.Filter; import org.mockitoutil.TestBase;  import java.util.LinkedList; import java.util.List;  import static java.util.Arrays.asList; import static org.mockitoutil.ExtraMatchers.hasExactlyInOrder;  @SuppressWarnings("unchecked") public class ListUtilTest extends TestBase {      @Test     public void shouldFilterList() throws Exception {         List list = asList("one", "x", "two", "x", "three");         List filtered = ListUtil.filter(list, new Filter() {             public boolean isOut(Object object) {                 return object == "x";             }         });                  assertThat(filtered, hasExactlyInOrder("one", "two", "three"));     }          @Test     public void shouldReturnEmptyIfEmptyListGiven() throws Exception {         List list = new LinkedList();         List filtered = ListUtil.filter(list, null);         assertTrue(filtered.isEmpty());     } } 
package org.mockito.internal.util.io;  import org.junit.Rule; import org.junit.Test; import org.junit.rules.TemporaryFolder;  import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream;  import static java.util.Arrays.asList; import static org.junit.Assert.assertEquals;  public class IOUtilTest {      @Rule public TemporaryFolder tmp = new TemporaryFolder();      @Test     public void closes_streams() throws Exception {         IOUtil.closeQuietly(null);         IOUtil.closeQuietly(new ByteArrayOutputStream());          IOUtil.close(null);         IOUtil.close(new ByteArrayOutputStream());     }      @Test     public void writes_reads_files() throws Exception {         File file = tmp.newFile();         IOUtil.writeText("foo\n\nbar", file);         assertEquals(asList("foo", "", "bar"), IOUtil.readLines(new FileInputStream(file)));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.junit;  import org.fest.assertions.Assertions; import org.junit.Test; import org.junit.runner.Description; import org.junit.runner.notification.Failure; import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings; import org.mockitoutil.TestBase;  public class JUnitFailureHackerTest extends TestBase {          JUnitFailureHacker hacker = new JUnitFailureHacker();          @Test     public void shouldReplaceException() throws Exception {         //given         RuntimeException actualExc = new RuntimeException("foo");         Failure failure = new Failure(Description.EMPTY, actualExc);                  //when         hacker.appendWarnings(failure, "unused stubbing");                          //then         assertEquals(ExceptionIncludingMockitoWarnings.class, failure.getException().getClass());         assertEquals(actualExc, failure.getException().getCause());         Assertions.assertThat(actualExc.getStackTrace()).isEqualTo(failure.getException().getStackTrace());     }          @Test     public void shouldAppendWarning() throws Exception {         Failure failure = new Failure(Description.EMPTY, new RuntimeException("foo"));                  //when         hacker.appendWarnings(failure, "unused stubbing blah");                  //then         assertContains("unused stubbing blah", failure.getException().getMessage());             }             @Test     public void shouldNotAppendWhenNoWarnings() throws Exception {         RuntimeException ex = new RuntimeException("foo");         Failure failure = new Failure(Description.EMPTY, ex);                  //when         hacker.appendWarnings(failure, "");                  //then         assertEquals(ex, failure.getException());             }          @Test     public void shouldNotAppendWhenNullWarnings() throws Exception {         RuntimeException ex = new RuntimeException("foo");         Failure failure = new Failure(Description.EMPTY, ex);                  //when         hacker.appendWarnings(failure, null);                  //then         assertEquals(ex, failure.getException());             }          @Test     public void shouldPrintTheWarningSoICanSeeIt() throws Exception {         Failure failure = new Failure(Description.EMPTY, new RuntimeException("foo"));                  //when         hacker.appendWarnings(failure, "unused stubbing blah");                  //then         System.out.println(failure.getException());             } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.util.reflection;  import org.junit.Ignore; import org.junit.Test;  import java.lang.reflect.Field; import java.util.Observable;  public class AccessibilityChangerTest {      private Observable whatever;      @Test     public void should_enable_and_safely_disable() throws Exception {         AccessibilityChanger changer = new AccessibilityChanger();         changer.enableAccess(field("whatever"));         changer.safelyDisableAccess(field("whatever"));     }      @Test(expected = java.lang.AssertionError.class)     @Ignore("should be run only when -ea is passed to the VM")     public void safelyDisableAccess_should_fail_when_enableAccess_not_called() throws Exception {         new AccessibilityChanger().safelyDisableAccess(field("whatever"));     }      private Field field(String fieldName) throws NoSuchFieldException {         return this.getClass().getDeclaredField(fieldName);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.reflection;  import org.fest.assertions.Assertions; import org.junit.Test;  import java.io.File; import java.io.FileOutputStream; import java.lang.reflect.Field; import java.util.UUID;  import static org.junit.Assert.*;   public class BeanPropertySetterTest {      @Test     public void use_the_correct_setter_on_the_target() throws Exception {         // given         SomeBean someBean = new SomeBean();         Field theField = someBean.getClass().getDeclaredField("theField");         File valueToInject = new File("path");          // when         boolean injected = new BeanPropertySetter(someBean, theField, true).set(valueToInject);          // then         assertTrue(injected);         assertTrue(someBean.theFieldSetterWasUsed);         assertSame(valueToInject, someBean.getTheField());     }      @Test     public void use_the_setter_on_the_target_when_field_name_begins_by_at_least_2_caps() throws Exception {         // given         BeanWithWeirdFields someBean = new BeanWithWeirdFields();         Field theField = someBean.getClass().getDeclaredField("UUID");         UUID valueToInject = new UUID(0L, 0L);          // when         boolean injected = new BeanPropertySetter(someBean, theField, true).set(valueToInject);          // then         assertTrue(injected);         assertTrue(someBean.theFieldSetterWasUSed);         assertSame(valueToInject, someBean.UUID);     }      @Test     public void should_not_fail_if_bean_class_declares_only_the_setter_for_the_property() throws Exception {         // given         SomeBeanWithJustASetter someBean = new SomeBeanWithJustASetter();         Field theField = someBean.getClass().getDeclaredField("theField");         File valueToInject = new File("path");          // when         boolean injected = new BeanPropertySetter(someBean, theField, true).set(valueToInject);          // then         assertTrue(injected);         assertTrue(someBean.theFieldSetterWasUsed);     }      @Test     public void should_fail_if_matching_setter_cannot_be_found_and_if_report_failure_is_true() throws Exception {         // given         SomeBeanWithNoSetterMatchingFieldType bean = new SomeBeanWithNoSetterMatchingFieldType();         Field theField = bean.getClass().getDeclaredField("theField");         File valueToInject = new File("path");          try {             // when             new BeanPropertySetter(bean, theField, true).set(valueToInject);             fail();         } catch (Exception e) {             // then             Assertions.assertThat(e.getMessage()).contains("setter not found");         }     }      @Test     public void return_false_if_no_setter_was_found() throws Exception {         // given         SomeBeanWithJustAGetter bean = new SomeBeanWithJustAGetter();         Field theField = bean.getClass().getDeclaredField("theField");         File valueToInject = new File("path");          // when         boolean injected = new BeanPropertySetter(bean, theField).set(valueToInject);          // then         assertFalse(injected);     }      @Test     public void return_false_if_no_setter_was_found_and_if_reportNoSetterFound_is_false() throws Exception {         // given         SomeBeanWithNoSetterMatchingFieldType bean = new SomeBeanWithNoSetterMatchingFieldType();         Field theField = bean.getClass().getDeclaredField("theField");         File valueToInject = new File("path");          // when         boolean injected = new BeanPropertySetter(bean, theField, false).set(valueToInject);          // then         assertFalse(injected);     }      static class SomeBean {         private File theField;         boolean theFieldSetterWasUsed;          public void setTheField(final File theField) {             theFieldSetterWasUsed = true;             this.theField = theField;         }          public File getTheField() {             return theField;         }     }      static class SomeBeanWithJustASetter {         private File theField;         boolean theFieldSetterWasUsed;          public void setTheField(final File theField) {             theFieldSetterWasUsed = true;             this.theField = theField;         }     }     static class SomeBeanWithJustAGetter {         private File theField;          public File getTheField() {             return theField;         }     }      static class SomeBeanWithNoSetterMatchingFieldType {         private File theField;         boolean theFieldSetterWasUsed;          public void setTheField(final FileOutputStream somethingElse) {             theFieldSetterWasUsed = true;         }     }      static class BeanWithWeirdFields {         private UUID UUID;         boolean theFieldSetterWasUSed;          public void setUUID(UUID UUID) {             theFieldSetterWasUSed = true;             this.UUID = UUID;         }     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.reflection;  import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver;  import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException;  import static org.junit.Assert.*; import static org.mockito.BDDMockito.given; import static org.mockito.Matchers.any; import static org.mockito.Mockito.mock;    public class FieldInitializerTest {      private StaticClass alreadyInstantiated = new StaticClass();     private StaticClass noConstructor;     private StaticClassWithDefaultConstructor defaultConstructor;     private StaticClassWithPrivateDefaultConstructor privateDefaultConstructor;     private StaticClassWithoutDefaultConstructor noDefaultConstructor;     private StaticClassThrowingExceptionDefaultConstructor throwingExDefaultConstructor;     private AbstractStaticClass abstractType;     private Interface interfaceType;     private InnerClassType innerClassType;     private AbstractStaticClass instantiatedAbstractType = new ConcreteStaticClass();     private Interface instantiatedInterfaceType =  new ConcreteStaticClass();     private InnerClassType instantiatedInnerClassType = new InnerClassType();      @Test     public void should_keep_same_instance_if_field_initialized() throws Exception {         final StaticClass backupInstance = alreadyInstantiated;         FieldInitializer fieldInitializer = new FieldInitializer(this, field("alreadyInstantiated"));         FieldInitializationReport report = fieldInitializer.initialize();          assertSame(backupInstance, report.fieldInstance());         assertFalse(report.fieldWasInitialized());         assertFalse(report.fieldWasInitializedUsingContructorArgs());     }      @Test     public void should_instantiate_field_when_type_has_no_constructor() throws Exception {         FieldInitializer fieldInitializer = new FieldInitializer(this, field("noConstructor"));         FieldInitializationReport report = fieldInitializer.initialize();          assertNotNull(report.fieldInstance());         assertTrue(report.fieldWasInitialized());         assertFalse(report.fieldWasInitializedUsingContructorArgs());     }      @Test     public void should_instantiate_field_with_default_constructor() throws Exception {         FieldInitializer fieldInitializer = new FieldInitializer(this, field("defaultConstructor"));         FieldInitializationReport report = fieldInitializer.initialize();          assertNotNull(report.fieldInstance());         assertTrue(report.fieldWasInitialized());         assertFalse(report.fieldWasInitializedUsingContructorArgs());     }      @Test     public void should_instantiate_field_with_private_default_constructor() throws Exception {         FieldInitializer fieldInitializer = new FieldInitializer(this, field("privateDefaultConstructor"));         FieldInitializationReport report = fieldInitializer.initialize();          assertNotNull(report.fieldInstance());         assertTrue(report.fieldWasInitialized());         assertFalse(report.fieldWasInitializedUsingContructorArgs());     }      @Test(expected = MockitoException.class)     public void should_fail_to_instantiate_field_if_no_default_constructor() throws Exception {         FieldInitializer fieldInitializer = new FieldInitializer(this, field("noDefaultConstructor"));         fieldInitializer.initialize();     }      @Test     public void should_fail_to_instantiate_field_if_default_constructor_throws_exception() throws Exception {         FieldInitializer fieldInitializer = new FieldInitializer(this, field("throwingExDefaultConstructor"));         try {             fieldInitializer.initialize();             fail();         } catch (MockitoException e) {             InvocationTargetException ite = (InvocationTargetException) e.getCause();             assertTrue(ite.getTargetException() instanceof NullPointerException);             assertEquals("business logic failed", ite.getTargetException().getMessage());         }     }      @Test(expected = MockitoException.class)     public void should_fail_for_abstract_field() throws Exception {         new FieldInitializer(this, field("abstractType"));     }      @Test     public void should_not_fail_if_abstract_field_is_instantiated() throws Exception {         new FieldInitializer(this, field("instantiatedAbstractType"));     }      @Test(expected = MockitoException.class)     public void should_fail_for_interface_field() throws Exception {         new FieldInitializer(this, field("interfaceType"));     }      @Test     public void should_not_fail_if_interface_field_is_instantiated() throws Exception {         new FieldInitializer(this, field("instantiatedInterfaceType"));     }      @Test(expected = MockitoException.class)     public void should_fail_for_local_type_field() throws Exception {         // when         class LocalType { }          class TheTestWithLocalType {             @InjectMocks LocalType field;         }          TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();          // when         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));     }      @Test     public void should_not_fail_if_local_type_field_is_instantiated() throws Exception {         // when         class LocalType { }          class TheTestWithLocalType {             @InjectMocks LocalType field = new LocalType();         }          TheTestWithLocalType testWithLocalType = new TheTestWithLocalType();          // when         new FieldInitializer(testWithLocalType, testWithLocalType.getClass().getDeclaredField("field"));     }      @Test(expected = MockitoException.class)     public void should_fail_for_inner_class_field() throws Exception {         new FieldInitializer(this, field("innerClassType"));     }      @Test     public void should_not_fail_if_inner_class_field_is_instantiated() throws Exception {         new FieldInitializer(this, field("instantiatedInnerClassType"));     }      @Test     public void can_instantiate_class_with_parameterized_constructor() throws Exception {         ConstructorArgumentResolver resolver = given(mock(ConstructorArgumentResolver.class).resolveTypeInstances(any(Class[].class)))                         .willReturn(new Object[]{null}).getMock();          new FieldInitializer(this, field("noDefaultConstructor"), resolver).initialize();          assertNotNull(noDefaultConstructor);     }      private Field field(String fieldName) throws NoSuchFieldException {         return this.getClass().getDeclaredField(fieldName);     }      static class StaticClass {     }      static class StaticClassWithDefaultConstructor {         StaticClassWithDefaultConstructor() { }     }      static class StaticClassWithPrivateDefaultConstructor {         private StaticClassWithPrivateDefaultConstructor() { }     }      static class StaticClassWithoutDefaultConstructor {         private StaticClassWithoutDefaultConstructor(String param) { }     }      static class StaticClassThrowingExceptionDefaultConstructor {         StaticClassThrowingExceptionDefaultConstructor() throws Exception {             throw new NullPointerException("business logic failed");         }     }          static abstract class AbstractStaticClass {         public AbstractStaticClass() {}     }      interface Interface {      }      static class ConcreteStaticClass extends AbstractStaticClass implements Interface {     }      class InnerClassType {         InnerClassType() { }     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.reflection;  import org.junit.Test; import org.mockitoutil.TestBase;  @SuppressWarnings("unused") public class FieldReaderTest extends TestBase {      class Foo {                 private final String isNull = null;                 private final String notNull = "";             }          @Test     public void shouldKnowWhenNull() throws Exception {         //when         FieldReader reader = new FieldReader(new Foo(), Foo.class.getDeclaredField("isNull"));         //then         assertTrue(reader.isNull());     }          @Test     public void shouldKnowWhenNotNull() throws Exception {         //when         FieldReader reader = new FieldReader(new Foo(), Foo.class.getDeclaredField("notNull"));         //then         assertFalse(reader.isNull());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.reflection;  import org.junit.Test;  import java.lang.reflect.Field;  import static org.fest.assertions.Assertions.assertThat;  public class FieldsTest {      @Test     public void fields_should_return_all_declared_fields_in_hierarchy() throws Exception {         assertThat(Fields.allDeclaredFieldsOf(new HierarchyOfClasses()).names())                 .containsOnly("a", "b", "static_a", "static_b");     }      @Test     public void fields_should_return_declared_fields() throws Exception {         assertThat(Fields.declaredFieldsOf(new HierarchyOfClasses()).names())                 .containsOnly("b", "static_b");     }      @Test     public void can_filter_not_null_fields() throws Exception {         assertThat(Fields.declaredFieldsOf(new NullOrNotNullFields()).notNull().names())                 .containsOnly("c");     }      @Test     public void can_get_values_of_instance_fields() throws Exception {         assertThat(Fields.declaredFieldsOf(new ValuedFields()).assignedValues())                 .containsOnly("a", "b");     }       @Test     public void can_get_list_of_InstanceField() throws Exception {         ValuedFields instance = new ValuedFields();          assertThat(Fields.declaredFieldsOf(instance).instanceFields())                 .containsOnly(new InstanceField(field("a", instance), instance),                               new InstanceField(field("b", instance), instance)                 );     }      private Field field(String name, Object instance) throws NoSuchFieldException {         return instance.getClass().getDeclaredField(name);     }       interface AnInterface {         int someStaticInInterface = 0;      }     public static class ParentClass implements AnInterface {         static int static_a;         int a;      }     public static class HierarchyOfClasses extends ParentClass {         static int static_b;         int b = 1;      }     public static class NullOrNotNullFields {         static Object static_b;         Object b;         Object c = new Object();     }      public static class ValuedFields {         String a = "a";         String b = "b";     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.reflection;  import org.junit.Test;  import java.lang.reflect.Field; import java.lang.reflect.Type; import java.util.*;  import static org.junit.Assert.assertEquals;  public class GenericMasterTest {          GenericMaster m = new GenericMaster();          List<String> one;     Set<Integer> two;     Map<Double, String> map;     String nonGeneric;     List<Set<String>> nested;     List<Set<Collection<String>>> multiNested;      public interface ListSet extends List<Set> {}     public interface MapNumberString extends Map<Number, String> {}     public class HashMapNumberString<K extends Number> extends HashMap<K, String> {}      public List<Number> numberList() { return null; }     public Comparable<Number> numberComparable() { return null; }     public List rawList() { return null; }     public List<? extends Type> typeList() { return null; }        @Test     public void should_find_generic_class() throws Exception {         assertEquals(String.class, m.getGenericType(field("one")));         assertEquals(Integer.class, m.getGenericType(field("two")));         assertEquals(Double.class, m.getGenericType(field("map")));     }          @Test     public void should_get_object_for_non_generic() throws Exception {         assertEquals(Object.class, m.getGenericType(field("nonGeneric")));     }          @Test     public void should_deal_with_nested_generics() throws Exception {         assertEquals(Set.class, m.getGenericType(field("nested")));         assertEquals(Set.class, m.getGenericType(field("multiNested")));     }      private Field field(String fieldName) throws SecurityException, NoSuchFieldException {         return this.getClass().getDeclaredField(fieldName);     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.reflection;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import static org.mockito.internal.util.reflection.GenericMetadataSupport.inferFrom;  import java.io.Serializable; import java.lang.reflect.Method; import java.lang.reflect.Type; import java.lang.reflect.TypeVariable; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set;  import org.junit.Test;  public class GenericMetadataSupportTest {        interface GenericsSelfReference<T extends GenericsSelfReference<T>> {         T self();     }     interface UpperBoundedTypeWithClass<E extends Number & Comparable<E>> {         E get();     }     interface UpperBoundedTypeWithInterfaces<E extends Comparable<E> & Cloneable> {         E get();     }     interface ListOfNumbers extends List<Number> {}     interface ListOfAnyNumbers<N extends Number & Cloneable> extends List<N> {}      interface GenericsNest<K extends Comparable<K> & Cloneable> extends Map<K, Set<Number>> {         Set<Number> remove(Object key); // override with fixed ParameterizedType         List<? super Integer> returning_wildcard_with_class_lower_bound();         List<? super K> returning_wildcard_with_typeVar_lower_bound();         List<? extends K> returning_wildcard_with_typeVar_upper_bound();         K returningK();         <O extends K> List<O> paramType_with_type_params();         <S, T extends S> T two_type_params();         <O extends K> O typeVar_with_type_params();     }      static class StringList extends ArrayList<String> { }      @Test     public void typeVariable_of_self_type() {         GenericMetadataSupport genericMetadata = inferFrom(GenericsSelfReference.class).resolveGenericReturnType(firstNamedMethod("self", GenericsSelfReference.class));          assertThat(genericMetadata.rawType()).isEqualTo(GenericsSelfReference.class);     }      @Test     public void can_get_raw_type_from_Class() throws Exception {         assertThat(inferFrom(ListOfAnyNumbers.class).rawType()).isEqualTo(ListOfAnyNumbers.class);         assertThat(inferFrom(ListOfNumbers.class).rawType()).isEqualTo(ListOfNumbers.class);         assertThat(inferFrom(GenericsNest.class).rawType()).isEqualTo(GenericsNest.class);         assertThat(inferFrom(StringList.class).rawType()).isEqualTo(StringList.class);     }      @Test     public void can_get_raw_type_from_ParameterizedType() throws Exception {         assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);         assertThat(inferFrom(ListOfNumbers.class.getGenericInterfaces()[0]).rawType()).isEqualTo(List.class);         assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).rawType()).isEqualTo(Map.class);         assertThat(inferFrom(StringList.class.getGenericSuperclass()).rawType()).isEqualTo(ArrayList.class);     }      @Test     public void can_get_type_variables_from_Class() throws Exception {         assertThat(inferFrom(GenericsNest.class).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("K");         assertThat(inferFrom(ListOfNumbers.class).actualTypeArguments().keySet()).isEmpty();         assertThat(inferFrom(ListOfAnyNumbers.class).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("N");         assertThat(inferFrom(Map.class).actualTypeArguments().keySet()).hasSize(2).onProperty("name").contains("K", "V");         assertThat(inferFrom(Serializable.class).actualTypeArguments().keySet()).isEmpty();         assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();     }      @Test     public void can_get_type_variables_from_ParameterizedType() throws Exception {         assertThat(inferFrom(GenericsNest.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(2).onProperty("name").contains("K", "V");         assertThat(inferFrom(ListOfAnyNumbers.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("E");         assertThat(inferFrom(Integer.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).hasSize(1).onProperty("name").contains("T");         assertThat(inferFrom(StringBuilder.class.getGenericInterfaces()[0]).actualTypeArguments().keySet()).isEmpty();         assertThat(inferFrom(StringList.class).actualTypeArguments().keySet()).isEmpty();     }      @Test     public void typeVariable_return_type_of____iterator____resolved_to_Iterator_and_type_argument_to_String() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(StringList.class).resolveGenericReturnType(firstNamedMethod("iterator", StringList.class));          assertThat(genericMetadata.rawType()).isEqualTo(Iterator.class);         assertThat(genericMetadata.actualTypeArguments().values()).contains(String.class);     }      @Test     public void typeVariable_return_type_of____get____resolved_to_Set_and_type_argument_to_Number() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("get", GenericsNest.class));          assertThat(genericMetadata.rawType()).isEqualTo(Set.class);         assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);     }      @Test     public void bounded_typeVariable_return_type_of____returningK____resolved_to_Comparable_and_with_BoundedType() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returningK", GenericsNest.class));          assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);         GenericMetadataSupport extraInterface_0 = inferFrom(genericMetadata.extraInterfaces().get(0));         assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);     }      @Test     public void fixed_ParamType_return_type_of____remove____resolved_to_Set_and_type_argument_to_Number() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("remove", GenericsNest.class));          assertThat(genericMetadata.rawType()).isEqualTo(Set.class);         assertThat(genericMetadata.actualTypeArguments().values()).contains(Number.class);     }      @Test     public void paramType_return_type_of____values____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("values", GenericsNest.class));          assertThat(genericMetadata.rawType()).isEqualTo(Collection.class);         GenericMetadataSupport fromTypeVariableE = inferFrom(typeVariableValue(genericMetadata.actualTypeArguments(), "E"));         assertThat(fromTypeVariableE.rawType()).isEqualTo(Set.class);         assertThat(fromTypeVariableE.actualTypeArguments().values()).contains(Number.class);     }      @Test     public void paramType_with_type_parameters_return_type_of____paramType_with_type_params____resolved_to_Collection_and_type_argument_to_Parameterized_Set() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("paramType_with_type_params", GenericsNest.class));          assertThat(genericMetadata.rawType()).isEqualTo(List.class);         Type firstBoundOfE = ((GenericMetadataSupport.TypeVarBoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E")).firstBound();         assertThat(inferFrom(firstBoundOfE).rawType()).isEqualTo(Comparable.class);     }      @Test     public void typeVariable_with_type_parameters_return_type_of____typeVar_with_type_params____resolved_K_hence_to_Comparable_and_with_BoundedType() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("typeVar_with_type_params", GenericsNest.class));          assertThat(genericMetadata.rawType()).isEqualTo(Comparable.class);         GenericMetadataSupport extraInterface_0 = inferFrom(genericMetadata.extraInterfaces().get(0));         assertThat(extraInterface_0.rawType()).isEqualTo(Cloneable.class);     }      @Test     public void class_return_type_of____append____resolved_to_StringBuilder_and_type_arguments() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(StringBuilder.class).resolveGenericReturnType(firstNamedMethod("append", StringBuilder.class));          assertThat(genericMetadata.rawType()).isEqualTo(StringBuilder.class);         assertThat(genericMetadata.actualTypeArguments()).isEmpty();     }        @Test     public void paramType_with_wildcard_return_type_of____returning_wildcard_with_class_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_class_lower_bound", GenericsNest.class));          assertThat(genericMetadata.rawType()).isEqualTo(List.class);         GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");         assertThat(boundedType.firstBound()).isEqualTo(Integer.class);         assertThat(boundedType.interfaceBounds()).isEmpty();     }      @Test     public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_lower_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_typeVar_lower_bound", GenericsNest.class));          assertThat(genericMetadata.rawType()).isEqualTo(List.class);         GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");          assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);         assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);    }      @Test     public void paramType_with_wildcard_return_type_of____returning_wildcard_with_typeVar_upper_bound____resolved_to_List_and_type_argument_to_Integer() throws Exception {         GenericMetadataSupport genericMetadata = inferFrom(GenericsNest.class).resolveGenericReturnType(firstNamedMethod("returning_wildcard_with_typeVar_upper_bound", GenericsNest.class));          assertThat(genericMetadata.rawType()).isEqualTo(List.class);         GenericMetadataSupport.BoundedType boundedType = (GenericMetadataSupport.BoundedType) typeVariableValue(genericMetadata.actualTypeArguments(), "E");          assertThat(inferFrom(boundedType.firstBound()).rawType()).isEqualTo(Comparable.class);         assertThat(boundedType.interfaceBounds()).contains(Cloneable.class);     }        private Type typeVariableValue(Map<TypeVariable, Type> typeVariables, String typeVariableName) {         for (Map.Entry<TypeVariable, Type> typeVariableTypeEntry : typeVariables.entrySet()) {             if (typeVariableTypeEntry.getKey().getName().equals(typeVariableName)) {                 return typeVariableTypeEntry.getValue();             }         }          fail("'" + typeVariableName + "' was not found in " + typeVariables);         return null; // unreachable     }      private Method firstNamedMethod(String methodName, Class<?> clazz) {         for (Method method : clazz.getMethods()) {             boolean protect_against_different_jdk_ordering_avoiding_bridge_methods = !method.isBridge();             if (method.getName().contains(methodName) && protect_against_different_jdk_ordering_avoiding_bridge_methods) {                 return method;             }         }         throw new IllegalStateException("The method : '" + methodName + "' do not exist in '" + clazz.getSimpleName() + "'");     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.reflection;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.lang.reflect.Field; import java.util.LinkedList;  import org.junit.Test; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class LenientCopyToolTest extends TestBase {      private LenientCopyTool tool = new LenientCopyTool();      static class InheritMe {         protected String protectedInherited = "protected";         private String privateInherited = "private";     }          public static class SomeObject extends InheritMe {         @SuppressWarnings("unused")         // required because static fields needs to be excluded from copying         private static int staticField = -100;         private int privateField = -100;         private transient int privateTransientField = -100;         String defaultField = "-100";         protected Object protectedField = new Object();         public SomeOtherObject instancePublicField = new SomeOtherObject();         final int finalField;          public SomeObject(int finalField) {             this.finalField = finalField;         }     }      public static class SomeOtherObject {     }      private SomeObject from = new SomeObject(100);     private SomeObject to = mock(SomeObject.class);      @Test     public void shouldShallowCopyBasicFinalField() throws Exception {         // given         assertEquals(100, from.finalField);         assertNotEquals(100, to.finalField);          // when         tool.copyToMock(from, to);          // then         assertEquals(100, to.finalField);     }      @Test     public void shouldShallowCopyTransientPrivateFields() throws Exception {         // given         from.privateTransientField = 1000;         assertNotEquals(1000, to.privateTransientField);          // when         tool.copyToMock(from, to);          // then         assertEquals(1000, to.privateTransientField);     }      @Test     public void shouldShallowCopyLinkedListIntoMock() throws Exception {         // given         LinkedList fromList = new LinkedList();         LinkedList toList = mock(LinkedList.class);          // when         tool.copyToMock(fromList, toList);          // then no exception is thrown     }      @Test     public void shouldShallowCopyFieldValuesIntoMock() throws Exception {         // given         from.defaultField = "foo";         from.instancePublicField = new SomeOtherObject();         from.privateField = 1;         from.privateTransientField = 2;         from.protectedField = 3;                  assertNotEquals(from.defaultField, to.defaultField);         assertNotEquals(from.instancePublicField, to.instancePublicField);         assertNotEquals(from.privateField, to.privateField);         assertNotEquals(from.privateTransientField, to.privateTransientField);         assertNotEquals(from.protectedField, to.protectedField);          // when         tool.copyToMock(from, to);          // then         assertEquals(from.defaultField, to.defaultField);         assertEquals(from.instancePublicField, to.instancePublicField);         assertEquals(from.privateField, to.privateField);         assertEquals(from.privateTransientField, to.privateTransientField);         assertEquals(from.protectedField, to.protectedField);     }          @Test     public void shouldCopyValuesOfInheritedFields() throws Exception {         //given         ((InheritMe) from).privateInherited = "foo";         ((InheritMe) from).protectedInherited = "bar";              assertNotEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);         assertNotEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);                  //when         tool.copyToMock(from, to);                  //then         assertEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);         assertEquals(((InheritMe) from).privateInherited, ((InheritMe) to).privateInherited);     }          @Test     public void shouldEnableAndThenDisableAccessibility() throws Exception {         //given         Field privateField = SomeObject.class.getDeclaredField("privateField");         assertFalse(privateField.isAccessible());                  //when         tool.copyToMock(from, to);                  //then         privateField = SomeObject.class.getDeclaredField("privateField");         assertFalse(privateField.isAccessible());     }          @Test     public void shouldContinueEvenIfThereAreProblemsCopyingSingleFieldValue() throws Exception {         //given         tool.fieldCopier = mock(FieldCopier.class);                  doNothing().         doThrow(new IllegalAccessException()).         doNothing().         when(tool.fieldCopier).         copyValue(anyObject(), anyObject(), any(Field.class));                  //when         tool.copyToMock(from, to);                  //then         verify(tool.fieldCopier, atLeast(3)).copyValue(any(), any(), any(Field.class));     }          @Test     public void shouldBeAbleToCopyFromRealObjectToRealObject() throws Exception {                  // given         from.defaultField = "defaultField";         from.instancePublicField = new SomeOtherObject();         from.privateField = 1;         from.privateTransientField = 2;         from.protectedField = "protectedField";         from.protectedInherited = "protectedInherited";         to = new SomeObject(0);                  // when         tool.copyToRealObject(from, to);                  // then         assertEquals(from.defaultField, to.defaultField);         assertEquals(from.instancePublicField, to.instancePublicField);         assertEquals(from.privateField, to.privateField);         assertEquals(from.privateTransientField, to.privateTransientField);         assertEquals(from.protectedField, to.protectedField);         assertEquals(from.protectedInherited, to.protectedInherited);              } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.util.reflection;   import org.junit.After; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Matchers; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.reflection.FieldInitializer.ConstructorArgumentResolver; import org.mockito.internal.util.reflection.FieldInitializer.ParameterizedConstructorInstantiator; import org.mockito.runners.MockitoJUnitRunner;  import java.io.IOException; import java.lang.reflect.Field; import java.util.Map; import java.util.Observer; import java.util.Set;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.assertNotNull; import static org.junit.Assert.fail; import static org.mockito.BDDMockito.given; import static org.mockito.Mockito.mock;   @SuppressWarnings("unchecked") @RunWith(MockitoJUnitRunner.class) public class ParameterizedConstructorInstantiatorTest {      private Set whateverForNow;     private OneConstructor withOneConstructor;     private MultipleConstructor withMultipleConstructor;     private NoArgConstructor withNoArgConstructor;     private ThrowingConstructor withThrowingConstructor;     private VarargConstructor withVarargConstructor;      @After     public void ensure_instances_to_create_are_null() {         withMultipleConstructor = null;         withOneConstructor = null;         withNoArgConstructor = null;         withThrowingConstructor = null;         withVarargConstructor = null;     }      @Mock private ConstructorArgumentResolver resolver;      @Test     public void should_be_created_with_an_argument_resolver() throws Exception {         new ParameterizedConstructorInstantiator(this, field("whateverForNow"), resolver);     }      @Test     public void should_fail_if_no_parameterized_constructor_found___excluding_inner_and_others_kind_of_types() throws Exception {         try {             new ParameterizedConstructorInstantiator(this, field("withNoArgConstructor"), resolver).instantiate();             fail();         } catch (MockitoException me) {             assertThat(me.getMessage()).contains("no parameterized constructor").contains("withNoArgConstructor").contains("NoArgConstructor");         }     }      @Test     public void should_instantiate_type_if_resolver_provide_matching_types() throws Exception {         Observer observer = mock(Observer.class);         Map map = mock(Map.class);         given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, map });          new ParameterizedConstructorInstantiator(this, field("withMultipleConstructor"), resolver).instantiate();          assertNotNull(withMultipleConstructor);         assertNotNull(withMultipleConstructor.observer);         assertNotNull(withMultipleConstructor.map);     }      @Test     public void should_fail_if_an_argument_instance_type_do_not_match_wanted_type() throws Exception {         Observer observer = mock(Observer.class);         Set wrongArg = mock(Set.class);         given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ observer, wrongArg });          try {             new ParameterizedConstructorInstantiator(this, field("withMultipleConstructor"), resolver).instantiate();             fail();         } catch (MockitoException e) {             assertThat(e.getMessage()).contains("argResolver").contains("incorrect types");         }     }      @Test     public void should_report_failure_if_constructor_throws_exception() throws Exception {         given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ null });          try {             new ParameterizedConstructorInstantiator(this, field("withThrowingConstructor"), resolver).instantiate();             fail();         } catch (MockitoException e) {             assertThat(e.getMessage()).contains("constructor").contains("raised an exception");         }     }      @Test     public void should_instantiate_type_with_vararg_constructor() throws Exception {         Observer[] vararg = new Observer[] {  };         given(resolver.resolveTypeInstances(Matchers.<Class<?>[]>anyVararg())).willReturn(new Object[]{ "", vararg});          new ParameterizedConstructorInstantiator(this, field("withVarargConstructor"), resolver).instantiate();          assertNotNull(withVarargConstructor);     }      private Field field(String fieldName) throws NoSuchFieldException {         Field field = this.getClass().getDeclaredField(fieldName);         field.setAccessible(true);         return field;     }      private static class NoArgConstructor {         NoArgConstructor() { }     }      private static class OneConstructor {         public OneConstructor(Observer observer) { }     }      private static class ThrowingConstructor {         public ThrowingConstructor(Observer observer) throws IOException { throw new IOException(); }     }      private static class MultipleConstructor extends OneConstructor {         Observer observer;         Map map;          public MultipleConstructor(Observer observer) { this(observer, null); }         public MultipleConstructor(Observer observer, Map map) {             super(observer);             this.observer = observer;             this.map = map;         }     }      private static class VarargConstructor {         VarargConstructor(String whatever, Observer... observers) { }     } } 
package org.mockito.internal.util.reflection;  import org.fest.assertions.Condition; import org.junit.Test; import org.mockito.internal.util.reflection.SuperTypesLastSorter;  import java.lang.reflect.Field; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.HashSet; import java.util.List; import java.util.Set;  import static org.fest.assertions.Assertions.assertThat;  @SuppressWarnings("unused") public class SuperTypesLastSorterTest {     /**      * A Comparator that behaves like the old one, so the existing tests      * continue to work.      */     private static Comparator<Field> cmp = new Comparator<Field>()     {         public int compare(Field o1, Field o2)         {             if (o1.equals(o2)) {                 return 0;             }              List<Field> l = new SuperTypesLastSorter().sort(Arrays.asList(o1, o2));              if (l.get(0) == o1) {                 return -1;             } else {                 return 1;             }         }     };      private Object objectA;     private Object objectB;      private Number numberA;     private Number numberB;      private Integer integerA;     private Integer integerB;      private Iterable<?> iterableA;      private Number xNumber;     private Iterable<?> yIterable;     private Integer zInteger;       @Test     public void when_same_type_the_order_is_based_on_field_name() throws Exception {         assertThat(cmp.compare(field("objectA"), field("objectB"))).isEqualTo(-1);         assertThat(cmp.compare(field("objectB"), field("objectA"))).isEqualTo(1);         assertThat(cmp.compare(field("objectB"), field("objectB"))).isEqualTo(0);     }      @Test     public void when_type_is_different_the_supertype_comes_last() throws Exception {         assertThat(cmp.compare(field("numberA"), field("objectB"))).isEqualTo(-1);         assertThat(cmp.compare(field("objectB"), field("numberA"))).isEqualTo(1);     }      @Test     public void using_Collections_dot_sort() throws Exception {         List<Field> unsortedFields = Arrays.asList(                 field("objectB"),                 field("integerB"),                 field("numberA"),                 field("numberB"),                 field("objectA"),                 field("integerA")         );          List<Field> sortedFields = new SuperTypesLastSorter().sort(unsortedFields);          assertThat(sortedFields).containsSequence(                 field("integerA"),                 field("integerB"),                 field("numberA"),                 field("numberB"),                 field("objectA"),                 field("objectB")         );     }       @Test     public void issue_352_order_was_different_between_JDK6_and_JDK7() throws Exception {         List<Field> unsortedFields = Arrays.asList(                 field("objectB"),                 field("objectA")         );          Collections.sort(unsortedFields, cmp);          assertThat(unsortedFields).containsSequence(                 field("objectA"),                 field("objectB")         );     }      @Test     public void fields_sort_consistently_when_interfaces_are_included() throws NoSuchFieldException     {         assertSortConsistently(field("iterableA"), field("numberA"), field("integerA"));     }      @Test     public void fields_sort_consistently_when_names_and_type_indicate_different_order() throws NoSuchFieldException     {         assertSortConsistently(field("xNumber"), field("yIterable"), field("zInteger"));     }      /**      * Assert that these fields sort in the same order no matter which order      * they start in.      */     private static void assertSortConsistently(Field a, Field b, Field c)     {         Field[][] initialOrderings = {                 {a, b, c},                 {a, c, b},                 {b, a, c},                 {b, c, a},                 {c, a, b},                 {c, b, a}         };          Set<List<Field>> results = new HashSet<List<Field>>();          for (Field[] o : initialOrderings) {             results.add(new SuperTypesLastSorter().sort(Arrays.asList(o)));         }          assertThat(results).hasSize(1);     }      private Field field(String field) throws NoSuchFieldException {         return getClass().getDeclaredField(field);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.util.reflection;  import org.junit.Test; import org.mockitoutil.TestBase;  public class WhiteboxTest extends TestBase {      @Test     public void shouldSetInternalStateOnHierarchy() {         //given         DummyClassForTests dummy = new DummyClassForTests();         //when         Whitebox.setInternalState(dummy, "somePrivateField", "cool!");         //then         Object internalState = org.powermock.reflect.Whitebox.getInternalState(dummy, "somePrivateField");         assertEquals("cool!", internalState);     }      @Test     public void shouldGetInternalStateFromHierarchy() {         //given         DummyClassForTests dummy = new DummyClassForTests();         org.powermock.reflect.Whitebox.setInternalState(dummy, "somePrivateField", "boo!");         //when         Object internalState = Whitebox.getInternalState(dummy, "somePrivateField");         //then         assertEquals("boo!", internalState);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.verification;  import org.junit.Before; import org.junit.Test; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.invocation.Invocation; import org.mockitoutil.TestBase;  public class DefaultRegisteredInvocationsTest extends TestBase {          private DefaultRegisteredInvocations invocations;          @Before     public void setup() {         invocations = new DefaultRegisteredInvocations();     }          @Test     public void should_not_return_to_string_method() throws Exception {         Invocation toString = new InvocationBuilder().method("toString").toInvocation();         Invocation simpleMethod = new InvocationBuilder().simpleMethod().toInvocation();                  invocations.add(toString);         invocations.add(simpleMethod);                  assertTrue(invocations.getAll().contains(simpleMethod));         assertFalse(invocations.getAll().contains(toString));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.verification;  import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.internal.creation.MockSettingsImpl; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.internal.progress.ThreadSafeMockingProgress; import org.mockito.internal.stubbing.InvocationContainerImpl; import org.mockito.internal.verification.api.VerificationDataInOrderImpl; import org.mockito.invocation.Invocation; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static java.util.Arrays.asList; import static org.mockito.Mockito.mock;  public class NoMoreInteractionsTest extends TestBase {      InOrderContextImpl context = new InOrderContextImpl();      @Test     public void shouldVerifyInOrder() {         //given         NoMoreInteractions n = new NoMoreInteractions();         Invocation i = new InvocationBuilder().toInvocation();         assertFalse(context.isVerified(i));          try {             //when             n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));             //then             fail();         } catch(VerificationInOrderFailure e) {}     }      @Test     public void shouldVerifyInOrderAndPass() {         //given         NoMoreInteractions n = new NoMoreInteractions();         Invocation i = new InvocationBuilder().toInvocation();         context.markVerified(i);         assertTrue(context.isVerified(i));          //when         n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));         //then no exception is thrown     }      @Test     public void shouldVerifyInOrderMultipleInvoctions() {         //given         NoMoreInteractions n = new NoMoreInteractions();         Invocation i = new InvocationBuilder().seq(1).toInvocation();         Invocation i2 = new InvocationBuilder().seq(2).toInvocation();          //when         context.markVerified(i2);          //then no exception is thrown         n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i, i2), null));     }      @Test     public void shouldVerifyInOrderMultipleInvoctionsAndThrow() {         //given         NoMoreInteractions n = new NoMoreInteractions();         Invocation i = new InvocationBuilder().seq(1).toInvocation();         Invocation i2 = new InvocationBuilder().seq(2).toInvocation();          try {             //when             n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i, i2), null));             fail();         } catch (VerificationInOrderFailure e) {}     }      @Test     public void noMoreInteractionsExceptionMessageShouldDescribeMock() {         //given         NoMoreInteractions n = new NoMoreInteractions();         IMethods mock = mock(IMethods.class, "a mock");         InvocationMatcher i = new InvocationBuilder().mock(mock).toInvocationMatcher();          InvocationContainerImpl invocations =             new InvocationContainerImpl(new ThreadSafeMockingProgress(), new MockSettingsImpl());         invocations.setInvocationForPotentialStubbing(i);          try {             //when             n.verify(new VerificationDataImpl(invocations, null));             //then             fail();         } catch (NoInteractionsWanted e) {             Assertions.assertThat(e.toString()).contains(mock.toString());         }     }      @Test     public void noMoreInteractionsInOrderExceptionMessageShouldDescribeMock() {         //given         NoMoreInteractions n = new NoMoreInteractions();         IMethods mock = mock(IMethods.class, "a mock");         Invocation i = new InvocationBuilder().mock(mock).toInvocation();          try {             //when             n.verifyInOrder(new VerificationDataInOrderImpl(context, asList(i), null));             //then             fail();         } catch (VerificationInOrderFailure e) {             Assertions.assertThat(e.toString()).contains(mock.toString());         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.verification;  import static org.junit.Assert.*;  import java.util.Arrays; import java.util.List;  import org.junit.Test; import org.mockito.exceptions.base.MockitoAssertionError; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.internal.verification.api.VerificationData; import org.mockito.invocation.Invocation;  public class OnlyTest {      Only only = new Only();          public class VerificationDataStub implements VerificationData {         private final Invocation invocation;         private final InvocationMatcher wanted;          public VerificationDataStub(InvocationMatcher wanted, Invocation invocation) {             this.invocation = invocation;             this.wanted = wanted;         }          public List<Invocation> getAllInvocations() {             return Arrays.asList(invocation);         }          public InvocationMatcher getWanted() {             return wanted;         }     }      @Test     public void shouldMarkAsVerified() {         //given         Invocation invocation = new InvocationBuilder().toInvocation();         assertFalse(invocation.isVerified());                  //when         only.verify(new VerificationDataStub(new InvocationMatcher(invocation), invocation));                  //then         assertTrue(invocation.isVerified());     }          @Test     public void shouldNotMarkAsVerifiedWhenAssertionFailed() {         //given         Invocation invocation = new InvocationBuilder().toInvocation();         assertFalse(invocation.isVerified());                  //when         try {             only.verify(new VerificationDataStub(new InvocationBuilder().toInvocationMatcher(), invocation));             fail();         } catch (MockitoAssertionError e) {}                  //then         assertFalse(invocation.isVerified());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.verification;  import org.junit.Before; import org.junit.Test; import org.mockito.Mock; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.internal.reporting.SmartPrinter; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class SmartPrinterTest extends TestBase {      private InvocationMatcher multi;     private InvocationMatcher shortie;     @Mock private IMethods mock;      @Before     public void setup() throws Exception {         mock.varargs("first very long argument", "second very long argument", "another very long argument");         multi = new InvocationMatcher(getLastInvocation());          mock.varargs("short arg");         shortie = new InvocationMatcher(getLastInvocation());     }      @Test     public void shouldPrintBothInMultilinesWhenFirstIsMulti() {         //when         SmartPrinter printer = new SmartPrinter(multi, shortie.getInvocation());                  //then         assertContains("\n", printer.getWanted().toString());         assertContains("\n", printer.getActual().toString());     }      @Test     public void shouldPrintBothInMultilinesWhenSecondIsMulti() {         //when         SmartPrinter printer = new SmartPrinter(shortie, multi.getInvocation());                  //then         assertContains("\n", printer.getWanted().toString());         assertContains("\n", printer.getActual().toString());     }      @Test     public void shouldPrintBothInMultilinesWhenBothAreMulti() {         //when         SmartPrinter printer = new SmartPrinter(multi, multi.getInvocation());                  //then         assertContains("\n", printer.getWanted().toString());         assertContains("\n", printer.getActual().toString());     }      @Test     public void shouldPrintBothInSingleLineWhenBothAreShort() {         //when         SmartPrinter printer = new SmartPrinter(shortie, shortie.getInvocation());                  //then         assertNotContains("\n", printer.getWanted().toString());         assertNotContains("\n", printer.getActual().toString());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.verification;  import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockitoutil.TestBase;  public class VerificationDataImplTest extends TestBase {      @Test     public void shouldToStringBeNotVerifiable() throws Exception {         InvocationMatcher toString = new InvocationBuilder().method("toString").toInvocationMatcher();         try {             new VerificationDataImpl(null, toString);             fail();         } catch (MockitoException e) {}     } } 
package org.mockito.internal.verification;  import org.junit.Before; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoAssertionError; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockito.verification.VerificationMode;  import static org.hamcrest.CoreMatchers.is; import static org.mockito.Mockito.doThrow; import static org.mockito.Mockito.verify; import static org.mockito.MockitoAnnotations.initMocks;  public class VerificationOverTimeImplTest {     @Mock     private VerificationMode delegate;     private VerificationOverTimeImpl impl;      @Rule     public ExpectedException exception = ExpectedException.none();      @Before     public void setUp() {         initMocks(this);         impl = new VerificationOverTimeImpl(10, 1000, delegate, true);     }      @Test     public void should_return_on_success() {         impl.verify(null);         verify(delegate).verify(null);     }      @Test     public void should_throw_mockito_assertion_error() {} // Defects4J: flaky method //     @Test //     public void should_throw_mockito_assertion_error() { //         MockitoAssertionError toBeThrown = new MockitoAssertionError("message"); //         exception.expect(is(toBeThrown)); //  //         doThrow(toBeThrown).when(delegate).verify(null); //         impl.verify(null); //     }      @Test     public void should_deal_with_junit_assertion_error() {} // Defects4J: flaky method //     @Test //     public void should_deal_with_junit_assertion_error() { //         ArgumentsAreDifferent toBeThrown = new ArgumentsAreDifferent("message", "wanted", "actual"); //         exception.expect(is(toBeThrown)); //         exception.expectMessage("message"); //  //         doThrow(toBeThrown).when(delegate).verify(null); //         impl.verify(null); //     }      @Test     public void should_not_wrap_other_exceptions() {} // Defects4J: flaky method //     @Test //     public void should_not_wrap_other_exceptions() { //         RuntimeException toBeThrown = new RuntimeException(); //         exception.expect(is(toBeThrown)); //  //         doThrow(toBeThrown).when(delegate).verify(null); //         impl.verify(null); //     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.verification.argumentmatching;  import java.util.Arrays; import java.util.List;  import org.hamcrest.BaseMatcher; import org.hamcrest.Description; import org.hamcrest.Matcher; import org.junit.Test; import org.mockito.internal.matchers.Equals; import org.mockitoutil.TestBase;  @SuppressWarnings({"unchecked","serial"}) public class ArgumentMatchingToolTest extends TestBase {      private ArgumentMatchingTool tool = new ArgumentMatchingTool();      @Test     public void shouldNotFindAnySuspiciousMatchersWhenNumberOfArgumentsDoesntMatch() {         //given         List<Matcher> matchers = (List) Arrays.asList(new Equals(1));          //when         Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, 20});                  //then         assertEquals(0, suspicious.length);     }      @Test     public void shouldNotFindAnySuspiciousMatchersWhenArgumentsMatch() {         //given         List<Matcher> matchers = (List) Arrays.asList(new Equals(10), new Equals(20));                  //when         Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, 20});                  //then         assertEquals(0, suspicious.length);     }          @Test     public void shouldFindSuspiciousMatchers() {         //given         Equals matcherInt20 = new Equals(20);         Long longPretendingAnInt = new Long(20);                  //when         List<Matcher> matchers = (List) Arrays.asList(new Equals(10), matcherInt20);         Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10, longPretendingAnInt});                  //then         assertEquals(1, suspicious.length);         assertEquals(new Integer(1), suspicious[0]);     }          @Test     public void shouldNotFindSuspiciousMatchersWhenTypesAreTheSame() {         //given         Equals matcherWithBadDescription = new Equals(20) {             public void describeTo(Description desc) {                 //let's pretend we have the same description as the toString() of the argument                 desc.appendText("10");             }         };         Integer argument = 10;                  //when         Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(matcherWithBadDescription), new Object[] {argument});                  //then         assertEquals(0, suspicious.length);     }          @Test     public void shouldWorkFineWhenGivenArgIsNull() {         //when         Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes((List) Arrays.asList(new Equals(20)), new Object[] {null});                  //then         assertEquals(0, suspicious.length);     }          @Test     public void shouldUseMatchersSafely() {         //given         List<Matcher> matchers = (List) Arrays.asList(new BaseMatcher() {             public boolean matches(Object item) {                 throw new ClassCastException("nasty matcher");             }              public void describeTo(Description description) {             }});                  //when         Integer[] suspicious = tool.getSuspiciouslyNotMatchingArgsIndexes(matchers, new Object[] {10});                  //then         assertEquals(0, suspicious.length);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.internal.verification.checkers;  import static java.util.Arrays.asList; import static org.mockito.Matchers.any; import static org.mockito.Matchers.eq;  import org.junit.Test; import org.mockito.Mockito; import org.mockito.internal.invocation.*; import org.mockito.invocation.Invocation; import org.mockitoutil.TestBase;  public class AtLeastXNumberOfInvocationsCheckerTest extends TestBase {      @Test     public void shouldMarkActualInvocationsAsVerified() {         //given         AtLeastXNumberOfInvocationsChecker c = new AtLeastXNumberOfInvocationsChecker();         c.invocationMarker = Mockito.mock(InvocationMarker.class);         Invocation invocation = new InvocationBuilder().simpleMethod().toInvocation();         Invocation invocationTwo = new InvocationBuilder().differentMethod().toInvocation();          //when         c.check(asList(invocation, invocationTwo), new InvocationMatcher(invocation), 1);          //then         Mockito.verify(c.invocationMarker).markVerified(eq(asList(invocation)), any(CapturesArgumensFromInvocation.class));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.verification.checkers;  import static java.util.Arrays.*;  import java.util.List;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.Reporter; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.invocation.DescribedInvocation; import org.mockito.invocation.Invocation; import org.mockito.invocation.Location; import org.mockitoutil.TestBase;  public class MissingInvocationCheckerTest extends TestBase {      private MissingInvocationChecker checker;          private InvocationsFinderStub finderStub;     private ReporterStub reporterStub;          private InvocationMatcher wanted;     private List<Invocation> invocations;      @Before     public void setup() {         reporterStub = new ReporterStub();         finderStub = new InvocationsFinderStub();         checker = new MissingInvocationChecker(finderStub, reporterStub);                  wanted = new InvocationBuilder().toInvocationMatcher();         invocations = asList(new InvocationBuilder().toInvocation());     }          @Test     public void shouldAskFinderForActualInvocations() {         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());         checker.check(invocations, wanted);                  assertSame(invocations, finderStub.invocations);     }          @Test     public void shouldPassBecauseActualInvocationFound() {         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());         checker.check(invocations, wanted);     }          @Test     public void shouldAskAnalyzerForSimilarInvocation() {         checker.check(invocations, wanted);                  assertSame(invocations, finderStub.invocations);     }          @Test     public void shouldReportWantedButNotInvoked() {         //given                   assertTrue(finderStub.actualToReturn.isEmpty());         finderStub.similarToReturn = null;                  //when         checker.check(invocations, wanted);                  //then         assertEquals(wanted, reporterStub.wanted);         assertNull(reporterStub.actualLocation);     }          @Test     public void shouldReportWantedInvocationDiffersFromActual() {         assertTrue(finderStub.actualToReturn.isEmpty());         Invocation actualInvocation = new InvocationBuilder().toInvocation();         finderStub.similarToReturn = actualInvocation;                  checker.check(invocations, wanted);                  assertNotNull(reporterStub.wanted);         assertNotNull(reporterStub.actual);                  assertSame(actualInvocation.getLocation(), reporterStub.actualLocation);     }          class ReporterStub extends Reporter {         private Object wanted;         private String actual;         private Location actualLocation;                  @Override         public void wantedButNotInvoked(DescribedInvocation wanted, List<? extends DescribedInvocation> invocations) {             this.wanted = wanted;         }                  @Override public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {                     this.wanted = wanted;                     this.actual = actual;                     this.actualLocation = actualLocation;         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.verification.checkers;  import static java.util.Arrays.*;  import java.util.LinkedList;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.Reporter; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.internal.progress.VerificationModeBuilder; import org.mockito.internal.reporting.SmartPrinter; import org.mockito.internal.verification.InOrderContextImpl; import org.mockito.internal.verification.api.InOrderContext; import org.mockito.invocation.DescribedInvocation; import org.mockito.invocation.Invocation; import org.mockito.invocation.Location; import org.mockitoutil.TestBase;  public class MissingInvocationInOrderCheckerTest extends TestBase {      private MissingInvocationInOrderChecker checker;     private ReporterStub reporterStub;     private InvocationMatcher wanted;     private LinkedList<Invocation> invocations;     private InvocationsFinderStub finderStub;     private InOrderContext context = new InOrderContextImpl();          @Before     public void setup() {         reporterStub = new ReporterStub();         finderStub = new InvocationsFinderStub();         checker = new MissingInvocationInOrderChecker(finderStub, reporterStub);                  wanted = new InvocationBuilder().toInvocationMatcher();         invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));     }                                                                          @Test     public void shouldPassWhenMatchingInteractionFound() throws Exception {         Invocation actual = new InvocationBuilder().toInvocation();         finderStub.allMatchingUnverifiedChunksToReturn.add(actual);                  checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);     }          @Test     public void shouldReportWantedButNotInvoked() throws Exception {         assertTrue(finderStub.allMatchingUnverifiedChunksToReturn.isEmpty());         checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);                  assertEquals(wanted, reporterStub.wanted);     }      @Test     public void shouldReportArgumentsAreDifferent() throws Exception {         assertTrue(finderStub.findInvocations(invocations, wanted).isEmpty());         finderStub.similarToReturn = new InvocationBuilder().toInvocation();         checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);         SmartPrinter printer = new SmartPrinter(wanted, finderStub.similarToReturn, 0);         assertEquals(printer.getWanted(), reporterStub.wantedString);         assertEquals(printer.getActual(), reporterStub.actual);         assertEquals(finderStub.similarToReturn.getLocation(), reporterStub.actualLocation);      }          @Test     public void shouldReportWantedDiffersFromActual() throws Exception {         Invocation previous = new InvocationBuilder().toInvocation();         finderStub.previousInOrderToReturn = previous;                  checker.check(invocations, wanted, new VerificationModeBuilder().inOrder(), context);                  assertEquals(wanted, reporterStub.wanted);         assertEquals(previous, reporterStub.previous);     }          class ReporterStub extends Reporter {         private DescribedInvocation wanted;         private DescribedInvocation previous;         private String wantedString;         private String actual;         private Location actualLocation;                  @Override public void wantedButNotInvokedInOrder(DescribedInvocation wanted, DescribedInvocation previous) {             this.wanted = wanted;             this.previous = previous;         }                  @Override public void wantedButNotInvoked(DescribedInvocation wanted) {             this.wanted = wanted;         }          @Override public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {             this.wantedString = wanted;             this.actual = actual;             this.actualLocation = actualLocation;         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.verification.checkers;  import static java.util.Arrays.*;  import java.util.LinkedList;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.Reporter; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.invocation.DescribedInvocation; import org.mockito.invocation.Invocation; import org.mockito.invocation.Location; import org.mockitoutil.TestBase;  public class NumberOfInvocationsCheckerTest extends TestBase {      private NumberOfInvocationsChecker checker;     private ReporterStub reporterStub;     private InvocationMatcher wanted;     private LinkedList<Invocation> invocations;     private InvocationsFinderStub finderStub;          @Before     public void setup() {         reporterStub = new ReporterStub();         finderStub = new InvocationsFinderStub();         checker = new NumberOfInvocationsChecker(reporterStub, finderStub);                  wanted = new InvocationBuilder().toInvocationMatcher();         invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));     }      @Test     public void shouldReportTooLittleActual() throws Exception {         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());                  checker.check(invocations, wanted, 100);                  assertEquals(1, reporterStub.actualCount);         assertEquals(100, reporterStub.wantedCount);         assertEquals(wanted, reporterStub.wanted);     }      @Test     public void shouldReportWithLastInvocationStackTrace() throws Exception {         Invocation first = new InvocationBuilder().toInvocation();         Invocation second = new InvocationBuilder().toInvocation();                  finderStub.actualToReturn.addAll(asList(first, second));                  checker.check(invocations, wanted, 100);                  assertSame(second.getLocation(), reporterStub.location);     }          @Test     public void shouldNotReportWithLastInvocationStackTraceIfNoInvocationsFound() throws Exception {         assertTrue(finderStub.actualToReturn.isEmpty());                  checker.check(invocations, wanted, 100);                  assertNull(reporterStub.location);     }          @Test     public void shouldReportWithFirstUndesiredInvocationStackTrace() throws Exception {         Invocation first = new InvocationBuilder().toInvocation();         Invocation second = new InvocationBuilder().toInvocation();         Invocation third = new InvocationBuilder().toInvocation();                  finderStub.actualToReturn.addAll(asList(first, second, third));                  checker.check(invocations, wanted, 2);                  assertSame(third.getLocation(), reporterStub.location);     }          @Test     public void shouldReportTooManyActual() throws Exception {         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());         finderStub.actualToReturn.add(new InvocationBuilder().toInvocation());                  checker.check(invocations, wanted, 1);                  assertEquals(2, reporterStub.actualCount);         assertEquals(1, reporterStub.wantedCount);         assertEquals(wanted, reporterStub.wanted);     }          @Test     public void shouldReportNeverWantedButInvoked() throws Exception {         Invocation invocation = new InvocationBuilder().toInvocation();         finderStub.actualToReturn.add(invocation);                  checker.check(invocations, wanted, 0);                  assertEquals(wanted, reporterStub.wanted);         assertEquals(invocation.getLocation(), reporterStub.location);     }          @Test     public void shouldMarkInvocationsAsVerified() throws Exception {         Invocation invocation = new InvocationBuilder().toInvocation();         finderStub.actualToReturn.add(invocation);         assertFalse(invocation.isVerified());                  checker.check(invocations, wanted, 1);                  assertTrue(invocation.isVerified());     }          class ReporterStub extends Reporter {         private int wantedCount;         private int actualCount;         private DescribedInvocation wanted;         private Location location;         @Override public void tooLittleActualInvocations(org.mockito.internal.reporting.Discrepancy discrepancy, DescribedInvocation wanted, Location lastActualLocation) {                     this.wantedCount = discrepancy.getWantedCount();                     this.actualCount = discrepancy.getActualCount();                     this.wanted = wanted;                     this.location = lastActualLocation;         }                  @Override public void tooManyActualInvocations(int wantedCount, int actualCount, DescribedInvocation wanted, Location firstUndesired) {                     this.wantedCount = wantedCount;                     this.actualCount = actualCount;                     this.wanted = wanted;                     this.location = firstUndesired;         }                  @Override         public void neverWantedButInvoked(DescribedInvocation wanted, Location firstUndesired) {             this.wanted = wanted;             this.location = firstUndesired;         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockito.internal.verification.checkers;  import static java.util.Arrays.*;  import java.util.LinkedList;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.Reporter; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.internal.invocation.InvocationImpl; import org.mockito.internal.invocation.InvocationBuilder; import org.mockito.internal.invocation.InvocationMatcher; import org.mockito.internal.verification.InOrderContextImpl; import org.mockito.internal.verification.api.InOrderContext; import org.mockito.invocation.Invocation; import org.mockitoutil.TestBase;  public class NumberOfInvocationsInOrderCheckerTest extends TestBase {      private NumberOfInvocationsInOrderChecker checker;     private Reporter reporter;     private InvocationMatcher wanted;     private LinkedList<Invocation> invocations;     private InvocationsFinderStub finderStub;     private InOrderContext context = new InOrderContextImpl();          @Before     public void setup() {         reporter = new Reporter();         finderStub = new InvocationsFinderStub();         checker = new NumberOfInvocationsInOrderChecker(finderStub, reporter);                  wanted = new InvocationBuilder().toInvocationMatcher();         invocations = new LinkedList<Invocation>(asList(new InvocationBuilder().toInvocation()));     }          @Test     public void shouldPassIfWantedIsZeroAndMatchingChunkIsEmpty() throws Exception {                 assertTrue(finderStub.validMatchingChunkToReturn.isEmpty());         checker.check(invocations, wanted, 0, context);     }          @Test     public void shouldPassIfChunkMatches() throws Exception {         finderStub.validMatchingChunkToReturn.add(wanted.getInvocation());                  checker.check(invocations, wanted, 1, context);     }          @Test     public void shouldReportTooLittleInvocations() throws Exception {         Invocation first = new InvocationBuilder().toInvocation();         Invocation second = new InvocationBuilder().toInvocation();         finderStub.validMatchingChunkToReturn.addAll(asList(first, second));                   try {             checker.check(invocations, wanted, 4, context);             fail();         } catch (VerificationInOrderFailure e) {             assertContains("Wanted 4 times", e.getMessage());             assertContains("But was 2 times", e.getMessage());         }     }          @Test     public void shouldReportTooManyInvocations() throws Exception {         Invocation first = new InvocationBuilder().toInvocation();         Invocation second = new InvocationBuilder().toInvocation();         finderStub.validMatchingChunkToReturn.addAll(asList(first, second));                   try {             checker.check(invocations, wanted, 1, context);             fail();         } catch (VerificationInOrderFailure e) {             assertContains("Wanted 1 time", e.getMessage());             assertContains("But was 2 times", e.getMessage());         }     }          @Test     public void shouldMarkAsVerifiedInOrder() throws Exception {         Invocation invocation = new InvocationBuilder().toInvocation();         assertFalse(context.isVerified(invocation));         finderStub.validMatchingChunkToReturn.addAll(asList(invocation));                   checker.check(invocations, wanted, 1, context);                  assertTrue(context.isVerified(invocation));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.runners;  import org.junit.Before; import org.junit.Test; import org.junit.runner.Description; import org.junit.runner.manipulation.Filter; import org.junit.runner.manipulation.NoTestsRemainException; import org.junit.runner.notification.RunNotifier; import org.junit.runners.model.InitializationError; import org.mockito.internal.runners.RunnerImpl; import org.mockito.internal.util.ConsoleMockitoLogger; import org.mockitoutil.TestBase;  public class ConsoleSpammingMockitoJUnitRunnerTest extends TestBase {          private ConsoleSpammingMockitoJUnitRunner runner;     private MockitoLoggerStub loggerStub;     private RunNotifier notifier;      @Before     public void setup() throws InitializationError {         loggerStub = new MockitoLoggerStub();         notifier = new RunNotifier();     }      //TODO add sensible tests             @Test     public void shouldDelegateToGetDescription() throws Exception {         //given         final Description expectedDescription = Description.createSuiteDescription(this.getClass());         runner = new ConsoleSpammingMockitoJUnitRunner(loggerStub, new RunnerImplStub() {             public Description getDescription() {                 return expectedDescription;             }         });                  //when         Description description = runner.getDescription();                  //then         assertEquals(expectedDescription, description);     }      public class MockitoLoggerStub extends ConsoleMockitoLogger {                  StringBuilder loggedInfo = new StringBuilder();                  public void log(Object what) {             super.log(what);             loggedInfo.append(what);         }          public String getLoggedInfo() {             return loggedInfo.toString();         }     }          static class RunnerImplStub implements RunnerImpl {          public Description getDescription() {             return null;         }          public void run(RunNotifier notifier) {}          public void filter(Filter filter) throws NoTestsRemainException {}      } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.runners;  import static org.mockitoutil.ExtraMatchers.*;  import java.util.LinkedList; import java.util.List;  import org.junit.Test; import org.junit.runner.Runner; import org.junit.runner.notification.RunListener; import org.junit.runner.notification.RunNotifier; import org.mockito.internal.runners.util.FrameworkUsageValidator; import org.mockitoutil.TestBase;  @SuppressWarnings({"unchecked", "deprecation"}) public class RunnersValidateFrameworkUsageTest extends TestBase {          private Runner runner;     private RunNotifierStub notifier = new RunNotifierStub();          public static class DummyTest extends TestBase {         @Test public void dummy() throws Exception {}     }      public class RunNotifierStub extends RunNotifier {          private List<RunListener> addedListeners = new LinkedList<RunListener>();          @Override         public void addListener(RunListener listener) {             addedListeners.add(listener);         }     }      @Test     public void shouldValidateWithDefaultRunner() throws Exception {         //given         runner = new MockitoJUnitRunner(DummyTest.class);          //when         runner.run(notifier);                  //then         assertThat(notifier.addedListeners, contains(clazz(FrameworkUsageValidator.class)));     }          @Test     public void shouldValidateWithD44Runner() throws Exception {         //given         runner = new MockitoJUnit44Runner(DummyTest.class);          //when         runner.run(notifier);                  //then         assertThat(notifier.addedListeners, contains(clazz(FrameworkUsageValidator.class)));     }          @Test     public void shouldValidateWithVerboseRunner() throws Exception {         //given         runner = new ConsoleSpammingMockitoJUnitRunner(DummyTest.class);                  //when         runner.run(notifier);                  //then         assertEquals(2, notifier.addedListeners.size());         assertThat(notifier.addedListeners, contains(clazz(FrameworkUsageValidator.class)));     } }
package org.mockito.verification;  import org.junit.Assert; import org.junit.Test; import org.mockito.Mockito; import org.mockito.exceptions.misusing.FriendlyReminderException;  public class NegativeDurationTest {      @Test     public void should_throw_exception_when_duration_is_negative_for_timeout_method() {         try {             Mockito.timeout(-1);             Assert.fail("It is forbidden to invoke Mockito.timeout() with negative value.");         } catch (FriendlyReminderException e) {             Assert.assertTrue(true);         }     }      @Test     public void should_throw_exception_when_duration_is_negative_for_after_method() {         try {             Mockito.after(-1);             Assert.fail("It is forbidden to invoke Mockito.after() with negative value.");         } catch (FriendlyReminderException e) {             Assert.assertTrue(true);         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockito.verification;  import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoAssertionError; import org.mockito.internal.util.Timer; import org.mockito.internal.verification.VerificationDataImpl; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  public class TimeoutTest extends TestBase {          @Mock VerificationMode mode;     @Mock VerificationDataImpl data;     @Mock     Timer timer;     MockitoAssertionError error = new MockitoAssertionError("");       @Test     public void should_pass_when_verification_passes() {         Timeout t = new Timeout(1, mode, timer);          when(timer.isCounting()).thenReturn(true);         doNothing().when(mode).verify(data);          t.verify(data);          InOrder inOrder = inOrder(timer);         inOrder.verify(timer).start();         inOrder.verify(timer).isCounting();     }      @Test     public void should_fail_because_verification_fails() {         Timeout t = new Timeout(1, mode, timer);          when(timer.isCounting()).thenReturn(true, true, true, false);         doThrow(error).         doThrow(error).         doThrow(error).         when(mode).verify(data);                  try {             t.verify(data);             fail();         } catch (MockitoAssertionError e) {}          verify(timer, times(4)).isCounting();     }          @Test     public void should_pass_even_if_first_verification_fails() {         Timeout t = new Timeout(1, mode, timer);          when(timer.isCounting()).thenReturn(true, true, true, false);         doThrow(error).         doThrow(error).         doNothing().         when(mode).verify(data);                  t.verify(data);         verify(timer, times(3)).isCounting();     }      @Test     public void should_try_to_verify_correct_number_of_times() {} // Defects4J: flaky method //     @Test //     public void should_try_to_verify_correct_number_of_times() { //         Timeout t = new Timeout(10, mode, timer); //          //         doThrow(error).when(mode).verify(data); //         when(timer.isCounting()).thenReturn(true, true, true, true, true, false); //  //         try { //             t.verify(data); //             fail(); //         } catch (MockitoAssertionError e) {} //  //         verify(mode, times(5)).verify(data); //     }  }
package org.mockitointegration;  import java.util.Set; import org.hamcrest.Matcher; import org.junit.Assume; import org.junit.Test; import org.mockito.Mockito; import org.mockito.internal.configuration.plugins.Plugins; import org.mockitoutil.ClassLoaders; import org.objenesis.Objenesis; import net.bytebuddy.ByteBuddy;  public class NoJUnitDependenciesTest {      @Test     public void pure_mockito_should_not_depend_JUnit___ByteBuddy() throws Exception {         Assume.assumeTrue("ByteBuddyMockMaker".equals(Plugins.getMockMaker().getClass().getSimpleName()));          ClassLoader classLoader_without_JUnit = ClassLoaders.excludingClassLoader()                 .withCodeSourceUrlOf(                         Mockito.class,                         Matcher.class,                         ByteBuddy.class,                         Objenesis.class                 )                 .without("junit", "org.junit")                 .build();          Set<String> pureMockitoAPIClasses = ClassLoaders.in(classLoader_without_JUnit).omit("runners", "junit", "JUnit").listOwnedClasses();          for (String pureMockitoAPIClass : pureMockitoAPIClasses) {             checkDependency(classLoader_without_JUnit, pureMockitoAPIClass);         }     }      private void checkDependency(ClassLoader classLoader_without_JUnit, String pureMockitoAPIClass) throws ClassNotFoundException {         try {             Class.forName(pureMockitoAPIClass, true, classLoader_without_JUnit);         } catch (Throwable e) {             throw new AssertionError(String.format("'%s' has some dependency to JUnit", pureMockitoAPIClass), e);         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage;  import static org.mockito.Mockito.*;  import org.junit.Ignore; import org.junit.Test; import org.mockito.Mock; import org.mockitoutil.TestBase;  public class PlaygroundTest extends TestBase {     static class Foo {                  int doSomeThing() {             return 0;         }          protected String getStuff() {             return "foo";         }     }          class Boo {         final public Object withLong(long y) {                          return "";         }          public Object foo() {                    return "";         }     }      Foo mock;     @Mock IMethods mockTwo;          @Test     public void spyInAction() {      }          @Test     public void partialMockInAction() { //        mock = mock(Foo.class, withSettings()  //            .defaultBehavior(CALLS_REAL_METHODS);  //        mock = mock(Foo.class, withSettings()  //            .defaultMockAnswer(CALLS_REAL_METHODS);  //        mock = mock(Foo.class, withSettings()  //            .defaultAnswer(CALLS_REAL_METHODS);  //        mock = mock(Foo.class, CALLS_REAL_METHODS);  //        mock = mock(Foo.class, withSettings()  //            .defaultBehavior(CALLS_REAL_METHODS) //            .createUsingDefaultConstructor(); //         //        mock = mock(Foo.class, withSettings()  //            .defaultBehavior(CALLS_REAL_METHODS) //            .createPassingArguments("some arg", 1); // //        spy = spy(Foo.class, "some arg", 1); //         //            .withName("foo") //            .withDefaultBehavior(RETURNS_SMART_NULLS) //            .withInterfaces(Bar.class); //         //        mock = mock(Foo.class) //            .name("foo") //            .defaultBehavior(RETURNS_SMART_NULLS) //            .interfaces(Bar.class); //         //        mock = mock(Foo.class) //            .named("foo") //            .byDefault(RETURNS_SMART_NULLS) //            .alsoImplements(Bar.class, Bar2.class); //         //        mock = mock(Foo.class) //            hasName("foo");          //        when(mock.getStuff()).thenReturn("aha!"); //        when(mock.doSomeThing()).thenCallRealMethod(); //          //        mock.doSomeThing();     }      //    interface Colored { //         //    } //     //    interface Bar { //        <T extends Foo & Colored> T getColoredPoint(); //    } //     //    @Test //    public void testname() throws Exception { //        when(mock.get()).then(returnArgument()); //         //        Bar mock = mock(Bar.class); //        when(mock.getColoredPoint()).thenReturn(new Foo()); //    } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage;  import static org.mockito.BDDMockito.given; import static org.mockito.BDDMockito.willAnswer; import static org.mockito.Matchers.any; import static org.mockito.Mockito.verify;  import java.util.Date; import java.util.GregorianCalendar;  import org.junit.Before; import org.junit.Test; import org.mockito.Mockito; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class PlaygroundWithDemoOfUnclonedParametersProblemTest extends TestBase {      ImportManager importManager;     ImportLogDao importLogDao;     IImportHandler importHandler;      @Before     public void setUp() throws Exception {         importLogDao = Mockito.mock(ImportLogDao.class);         importHandler = Mockito.mock(IImportHandler.class);         importManager = new ImportManager(importLogDao);     }      @Test     public void shouldIncludeInitialLog() {         //given         int importType = 0;         Date currentDate = new GregorianCalendar(2009, 10, 12).getTime();          ImportLogBean initialLog = new ImportLogBean(currentDate, importType);         initialLog.setStatus(1);          given(importLogDao.anyImportRunningOrRunnedToday(importType, currentDate)).willReturn(false);         willAnswer(byCheckingLogEquals(initialLog)).given(importLogDao).include(any(ImportLogBean.class));          //when         importManager.startImportProcess(importType, currentDate);          //then         verify(importLogDao).include(any(ImportLogBean.class));     }      @Test     public void shouldAlterFinalLog() {         //given         int importType = 0;         Date currentDate = new GregorianCalendar(2009, 10, 12).getTime();          ImportLogBean finalLog = new ImportLogBean(currentDate, importType);         finalLog.setStatus(9);          given(importLogDao.anyImportRunningOrRunnedToday(importType, currentDate)).willReturn(false);         willAnswer(byCheckingLogEquals(finalLog)).given(importLogDao).alter(any(ImportLogBean.class));          //when         importManager.startImportProcess(importType, currentDate);          //then         verify(importLogDao).alter(any(ImportLogBean.class));     }      private Answer byCheckingLogEquals(final ImportLogBean status) {         return new Answer() {             public Object answer(InvocationOnMock invocation) throws Throwable {                 ImportLogBean bean = (ImportLogBean) invocation.getArguments()[0];                 assertEquals(status, bean);                 return null;             }         };     }      public class ImportManager {          public ImportManager(ImportLogDao pImportLogDao) {             super();             importLogDao = pImportLogDao;         }          private ImportLogDao importLogDao = null;          public void startImportProcess(int importType, Date date) {             ImportLogBean importLogBean = null;              try {                 importLogBean = createResume(importType, date);                 if (isOkToImport(importType, date)) {                     // get the right handler                     //importLogBean = ImportHandlerFactory.singleton().getImportHandler(importType).processImport(importLogBean);                     // 2 = ok                     importLogBean.setStatus(2);                 } else {                     // 5 = failed - is there a running process                     importLogBean.setStatus(9);                 }             } catch (Exception e) {                 // 9 = failed - exception                 if (importLogBean != null)                     importLogBean.setStatus(9);             } finally {                 if (importLogBean != null)                     finalizeResume(importLogBean);             }         }          private boolean isOkToImport(int importType, Date date) {             return importLogDao.anyImportRunningOrRunnedToday(importType, date);         }          private ImportLogBean createResume(int importType, Date date) {             ImportLogBean importLogBean = new ImportLogBean(date,                     importType);             // 1 = running             importLogBean.setStatus(1);             importLogDao.include(importLogBean);             return importLogBean;         }          private void finalizeResume(ImportLogBean importLogBean) {             importLogDao.alter(importLogBean);         }     }      private interface ImportLogDao {         public boolean anyImportRunningOrRunnedToday(int importType, Date currentDate);          void include(ImportLogBean importLogBean);          void alter(ImportLogBean importLogBean);     }      private class IImportHandler {     }      private class ImportLogBean {         private Date currentDate;         private int importType;         private int status;          public ImportLogBean(Date currentDate, int importType) {             this.currentDate = currentDate;             this.importType = importType;         }          public void setStatus(int status) {             this.status = status;         }          @Override         public boolean equals(Object o) {             if (this == o) return true;             if (!(o instanceof ImportLogBean)) return false;              ImportLogBean that = (ImportLogBean) o;              if (importType != that.importType) return false;             if (status != that.status) return false;             if (currentDate != null ? !currentDate.equals(that.currentDate) : that.currentDate != null) return false;              return true;         }          @Override         public int hashCode() {             int result = currentDate != null ? currentDate.hashCode() : 0;             result = 31 * result + importType;             result = 31 * result + status;             return result;         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.annotation;  import static org.mockito.Mockito.*;  import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set;  import org.junit.Before; import org.junit.Test; import org.mockito.Answers; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.exceptions.base.MockitoException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class AnnotationsTest extends TestBase {      @Retention(RetentionPolicy.RUNTIME)     public @interface NotAMock {}      @Mock List list;     @Mock final Map map = new HashMap();              @NotAMock Set notAMock;      @SuppressWarnings("deprecation")     @MockitoAnnotations.Mock List listTwo;      @Before     public void setup() {         MockitoAnnotations.initMocks(this);     }      @Test     public void shouldInitMocks() throws Exception {         list.clear();         map.clear();         listTwo.clear();          verify(list).clear();         verify(map).clear();         verify(listTwo).clear();     }      @Test     public void shouldScreamWhenInitializingMocksForNullClass() throws Exception {         try {             MockitoAnnotations.initMocks(null);             fail();         } catch (MockitoException e) {             assertEquals("testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class",                     e.getMessage());         }     }      @Test     public void shouldLookForAnnotatedMocksInSuperClasses() throws Exception {         Sub sub = new Sub();         MockitoAnnotations.initMocks(sub);          assertNotNull(sub.getMock());         assertNotNull(sub.getBaseMock());         assertNotNull(sub.getSuperBaseMock());     }          @Mock(answer = Answers.RETURNS_MOCKS, name = "i have a name") IMethods namedAndReturningMocks;     @Mock(answer = Answers.RETURNS_DEFAULTS) IMethods returningDefaults;     @Mock(extraInterfaces = {List.class}) IMethods hasExtraInterfaces;     @Mock() IMethods noExtraConfig;      @Test     public void shouldInitMocksWithGivenSettings() throws Exception {         assertEquals("i have a name", namedAndReturningMocks.toString());         assertNotNull(namedAndReturningMocks.iMethodsReturningMethod());                 assertEquals("returningDefaults", returningDefaults.toString());         assertEquals(0, returningDefaults.intReturningMethod());                   assertTrue(hasExtraInterfaces instanceof List);                  assertEquals(0, noExtraConfig.intReturningMethod());             }      class SuperBase {         @Mock private IMethods mock;          public IMethods getSuperBaseMock() {             return mock;         }     }      class Base extends SuperBase {         @Mock private IMethods mock;          public IMethods getBaseMock() {             return mock;         }     }      class Sub extends Base {         @Mock private IMethods mock;          public IMethods getMock() {             return mock;         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.annotation;  import static org.mockito.Mockito.*;  import java.util.LinkedList; import java.util.List;  import org.junit.Test; import org.mockito.ArgumentCaptor; import org.mockito.Captor; import org.mockito.Mock; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class CaptorAnnotationBasicTest extends TestBase {      public class Person {         private final String name;         private final String surname;          public Person(String name, String surname) {             this.name = name;             this.surname = surname;         }          public String getName() {             return name;         }                  public String getSurname() {             return surname;         }     }      public interface PeopleRepository {         public void save(Person capture);     }          @Mock PeopleRepository peopleRepository;                     private void createPerson(String name, String surname) {         peopleRepository.save(new Person(name, surname));     }                @Test     public void shouldUseCaptorInOrdinaryWay() {         //when         createPerson("Wes", "Williams");                  //then         ArgumentCaptor<Person> captor = ArgumentCaptor.forClass(Person.class);         verify(peopleRepository).save(captor.capture());         assertEquals("Wes", captor.getValue().getName());         assertEquals("Williams", captor.getValue().getSurname());     }          @Captor ArgumentCaptor<Person> captor;          @Test     public void shouldUseAnnotatedCaptor() {         //when         createPerson("Wes", "Williams");                  //then         verify(peopleRepository).save(captor.capture());         assertEquals("Wes", captor.getValue().getName());         assertEquals("Williams", captor.getValue().getSurname());     }              @Captor ArgumentCaptor genericLessCaptor;          @Test     public void shouldUseGenericlessAnnotatedCaptor() {         //when         createPerson("Wes", "Williams");                  //then         verify(peopleRepository).save((Person) genericLessCaptor.capture());         assertEquals("Wes", ((Person) genericLessCaptor.getValue()).getName());         assertEquals("Williams", ((Person) genericLessCaptor.getValue()).getSurname());     }            @Captor ArgumentCaptor<List<String>> genericListCaptor;     @Mock IMethods mock;          @Test     public void shouldCaptureGenericList() {         //given         List<String> list = new LinkedList<String>();         mock.listArgMethod(list);                          //when         verify(mock).listArgMethod(genericListCaptor.capture());                  //then         assertSame(list, genericListCaptor.getValue());     }  }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.annotation;  import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.util.ArrayList; import java.util.List; import java.util.Set;  import org.junit.Test; import org.mockito.ArgumentCaptor; import org.mockito.Captor; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.MockitoAnnotations; import org.mockito.exceptions.base.MockitoException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class CaptorAnnotationTest extends TestBase {      @Retention(RetentionPolicy.RUNTIME)     public @interface NotAMock {     }      @Captor     final ArgumentCaptor<String> finalCaptor = ArgumentCaptor.forClass(String.class);      @Captor     ArgumentCaptor<List<List<String>>> genericsCaptor;      @Captor     ArgumentCaptor nonGenericCaptorIsAllowed;      @Mock     MockInterface mockInterface;      @NotAMock     Set notAMock;      public interface MockInterface {         void testMe(String simple, List<List<String>> genericList);     }      @Test     public void testNormalUsage() {          MockitoAnnotations.initMocks(this);          // check if assigned correctly         assertNotNull(finalCaptor);         assertNotNull(genericsCaptor);         assertNotNull(nonGenericCaptorIsAllowed);         assertNull(notAMock);          // use captors in the field to be sure they are cool         String argForFinalCaptor = "Hello";         ArrayList<List<String>> argForGenericsCaptor = new ArrayList<List<String>>();          mockInterface.testMe(argForFinalCaptor, argForGenericsCaptor);          Mockito.verify(mockInterface).testMe(finalCaptor.capture(), genericsCaptor.capture());          assertEquals(argForFinalCaptor, finalCaptor.getValue());         assertEquals(argForGenericsCaptor, genericsCaptor.getValue());      }      public static class WrongType {         @Captor         List wrongType;     }      @Test     public void shouldScreamWhenWrongTypeForCaptor() {         try {             MockitoAnnotations.initMocks(new WrongType());             fail();         } catch (MockitoException e) {}     }      public static class ToManyAnnotations {         @Captor         @Mock         ArgumentCaptor<List> missingGenericsField;     }      @Test     public void shouldScreamWhenMoreThanOneMockitoAnnotaton() {         try {             MockitoAnnotations.initMocks(new ToManyAnnotations());             fail();         } catch (MockitoException e) {             assertContains("missingGenericsField", e.getMessage());             assertContains("multiple Mockito annotations", e.getMessage());                     }     }      @Test     public void shouldScreamWhenInitializingCaptorsForNullClass() throws Exception {         try {             MockitoAnnotations.initMocks(null);             fail();         } catch (MockitoException e) {         }     }      @Test     public void shouldLookForAnnotatedCaptorsInSuperClasses() throws Exception {         Sub sub = new Sub();         MockitoAnnotations.initMocks(sub);          assertNotNull(sub.getCaptor());         assertNotNull(sub.getBaseCaptor());         assertNotNull(sub.getSuperBaseCaptor());     }      class SuperBase {         @Captor         private ArgumentCaptor<IMethods> mock;          public ArgumentCaptor<IMethods> getSuperBaseCaptor() {             return mock;         }     }      class Base extends SuperBase {         @Captor         private ArgumentCaptor<IMethods> mock;          public ArgumentCaptor<IMethods> getBaseCaptor() {             return mock;         }     }      class Sub extends Base {         @Captor         private ArgumentCaptor<IMethods> mock;          public ArgumentCaptor<IMethods> getCaptor() {             return mock;         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.annotation;  import java.util.List;  import org.junit.Before; import org.junit.Test; import org.mockito.Captor; import org.mockito.MockitoAnnotations; import org.mockito.exceptions.base.MockitoException; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class CaptorAnnotationUnhappyPathTest extends TestBase {          @Captor List notACaptorField;      @Before     @Override     public void init() {         //we need to get rid of parent implementation this time     }          @Test     public void shouldFailIfCaptorHasWrongType() throws Exception {         try {             //when             MockitoAnnotations.initMocks(this);             fail();         } catch (MockitoException e) {             //then             assertContains("notACaptorField", e.getMessage());             assertContains("wrong type", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.annotation;  import org.junit.After; import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.configuration.AnnotationEngine; import org.mockito.configuration.DefaultMockitoConfiguration; import org.mockito.internal.configuration.ConfigurationAccess; import org.mockito.internal.configuration.DefaultAnnotationEngine; import org.mockitoutil.TestBase;  public class DeprecatedAnnotationEngineApiTest extends TestBase {      @After     public void goBackToDefaultConfiguration() {         ConfigurationAccess.getConfig().overrideAnnotationEngine(null);     }          class SimpleTestCase {         @InjectMocks Tested tested = new Tested();         @Mock Dependency mock;     }          class Tested {                 Dependency dependency;         public void setDependency(Dependency dependency) {             this.dependency = dependency;         }             }          class Dependency {}          @Test     public void shouldInjectMocksIfThereIsNoUserDefinedEngine() throws Exception {         //given         AnnotationEngine defaultEngine = new DefaultMockitoConfiguration().getAnnotationEngine();         ConfigurationAccess.getConfig().overrideAnnotationEngine(defaultEngine);         SimpleTestCase test = new SimpleTestCase();                  //when         MockitoAnnotations.initMocks(test);                  //then            assertNotNull(test.mock);         assertNotNull(test.tested.dependency);         assertSame(test.mock, test.tested.dependency);     }          @Test     public void shouldRespectUsersEngine() throws Exception {         //given         AnnotationEngine customizedEngine = new DefaultAnnotationEngine() { /**/ };         ConfigurationAccess.getConfig().overrideAnnotationEngine(customizedEngine);         SimpleTestCase test = new SimpleTestCase();                  //when         MockitoAnnotations.initMocks(test);                  //then            assertNotNull(test.mock);         assertNull(test.tested.dependency);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.annotation;   import org.junit.Before; import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.MockitoAnnotations;  import java.awt.*;  import static org.junit.Assert.assertNotNull;  public class DeprecatedMockAnnotationTest {      @MockitoAnnotations.Mock private List deprecatedMock;      @InjectMocks private AnInjectedObject anInjectedObject;      @Before     public void initMocks() throws Exception {         MockitoAnnotations.initMocks(this);     }      @Test     public void shouldCreateMockForDeprecatedMockAnnotation() throws Exception {         assertNotNull(deprecatedMock);     }      @Test     public void shouldInjectDeprecatedMockAnnotation() throws Exception {         assertNotNull(anInjectedObject.aFieldAwaitingInjection);     }      private static class AnInjectedObject {         List aFieldAwaitingInjection;     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.annotation;  import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.runners.MockitoJUnitRunner;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertSame; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.spy;  @RunWith(MockitoJUnitRunner.class) public class InjectionOfInlinedMockDeclarationTest {      @InjectMocks private Receiver receiver;     @InjectMocks private Receiver spiedReceiver = spy(new Receiver());      private Antenna oldAntenna = mock(Antenna.class);     private Antenna satelliteAntenna = mock(Antenna.class);     private Antenna antenna = mock(Antenna.class, "dvbtAntenna");     private Tuner tuner = spy(new Tuner());      @Test     public void mock_declared_fields_shall_be_injected_too() throws Exception {         assertNotNull(receiver.oldAntenna);         assertNotNull(receiver.satelliteAntenna);         assertNotNull(receiver.dvbtAntenna);         assertNotNull(receiver.tuner);     }      @Test     public void unnamed_mocks_should_be_resolved_withe_their_field_names() throws Exception {         assertSame(oldAntenna, receiver.oldAntenna);         assertSame(satelliteAntenna, receiver.satelliteAntenna);     }      @Test     public void named_mocks_should_be_resolved_with_their_name() throws Exception {         assertSame(antenna, receiver.dvbtAntenna);     }       @Test     public void inject_mocks_even_in_declared_spy() throws Exception {         assertNotNull(spiedReceiver.oldAntenna);         assertNotNull(spiedReceiver.tuner);     }      // note that static class is not private !!     static class Receiver {         Antenna oldAntenna;         Antenna satelliteAntenna;         Antenna dvbtAntenna;         Tuner tuner;          public boolean tune() { return true; }     }      private static class Antenna { }     private static class Tuner { }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.annotation;  import static org.fest.assertions.Assertions.*;  import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.internal.util.MockUtil; import org.mockito.runners.MockitoJUnitRunner; import org.mockitousage.examples.use.ArticleCalculator;  @RunWith(MockitoJUnitRunner.class) public class MockInjectionUsingConstructorIssue421Test {      @Mock private ArticleCalculator calculator;      @InjectMocks private Issue421 issue421;      @Test     public void mockJustWorks() {         issue421.checkIfMockIsInjected();     }      static class Issue421 {          private ArticleCalculator calculator;          public Issue421(int a) {         }          public Issue421(ArticleCalculator calculator) {             this.calculator = calculator;         }          public void checkIfMockIsInjected(){             assertThat(new MockUtil().isMock(calculator)).isTrue();         }     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.annotation;  import org.junit.Ignore; import org.junit.Test; import org.junit.internal.TextListener; import org.junit.runner.JUnitCore; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.Spy; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.MockUtil; import org.mockito.runners.MockitoJUnitRunner; import org.mockitousage.examples.use.ArticleCalculator; import org.mockitousage.examples.use.ArticleDatabase; import org.mockitousage.examples.use.ArticleManager;  import java.util.List; import java.util.Set;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.*; import static org.mockito.Mockito.when;  @RunWith(MockitoJUnitRunner.class) public class MockInjectionUsingConstructorTest {     private MockUtil mockUtil = new MockUtil();      @Mock private ArticleCalculator calculator;     @Mock private ArticleDatabase database;      @InjectMocks private ArticleManager articleManager;     @Spy @InjectMocks private ArticleManager spiedArticleManager;   //    @InjectMocks private ArticleVisitor should_be_initialized_3_times;      @Test     public void shouldNotFailWhenNotInitialized() {         assertNotNull(articleManager);     }      @Test(expected = IllegalArgumentException.class)     public void innerMockShouldRaiseAnExceptionThatChangesOuterMockBehavior() {         when(calculator.countArticles("new")).thenThrow(new IllegalArgumentException());          articleManager.updateArticleCounters("new");     }      @Test     public void mockJustWorks() {         articleManager.updateArticleCounters("new");     }      @Test     public void constructor_is_called_for_each_test_in_test_class() throws Exception {         // given         JUnitCore jUnitCore = new JUnitCore();         jUnitCore.addListener(new TextListener(System.out));          // when         jUnitCore.run(junit_test_with_3_tests_methods.class);          // then         assertThat(junit_test_with_3_tests_methods.constructor_instantiation).isEqualTo(3);     }      @Test     public void objects_created_with_constructor_initialization_can_be_spied() throws Exception {         assertFalse(mockUtil.isMock(articleManager));         assertTrue(mockUtil.isMock(spiedArticleManager));     }      @Test     public void should_report_failure_only_when_object_initialization_throws_exception() throws Exception {          try {             MockitoAnnotations.initMocks(new ATest());             fail();         } catch (MockitoException e) {             assertThat(e.getMessage()).contains("failingConstructor").contains("constructor").contains("threw an exception");             assertThat(e.getCause()).isInstanceOf(IllegalStateException.class);         }     }       @RunWith(MockitoJUnitRunner.class)     public static class junit_test_with_3_tests_methods {         private static int constructor_instantiation = 0;          @Mock List some_collaborator;         @InjectMocks some_class_with_parametered_constructor should_be_initialized_3_times;          @Test public void test_1() { }         @Test public void test_2() { }         @Test public void test_3() { }          private static class some_class_with_parametered_constructor {             public some_class_with_parametered_constructor(List collaborator) {                 constructor_instantiation++;             }         }     }      private static class FailingConstructor {         FailingConstructor(Set set) {             throw new IllegalStateException("always fail");         }     }      @Ignore("don't run this code in the test runner")     private static class ATest {         @Mock Set set;         @InjectMocks FailingConstructor failingConstructor;     }   } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.annotation;  import org.fest.assertions.Assertions; import org.junit.Before; import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.Spy; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.util.MockUtil; import org.mockitoutil.TestBase;  import java.util.List; import java.util.Map; import java.util.Set; import java.util.TreeSet;  @SuppressWarnings({"unchecked", "unused"}) public class MockInjectionUsingSetterOrPropertyTest extends TestBase {      private SuperUnderTesting superUnderTestWithoutInjection = new SuperUnderTesting();     @InjectMocks private SuperUnderTesting superUnderTest = new SuperUnderTesting();     @InjectMocks private BaseUnderTesting baseUnderTest = new BaseUnderTesting();     @InjectMocks private SubUnderTesting subUnderTest = new SubUnderTesting();     @InjectMocks private OtherBaseUnderTesting otherBaseUnderTest = new OtherBaseUnderTesting();      private BaseUnderTesting baseUnderTestingInstance = new BaseUnderTesting();     @InjectMocks private BaseUnderTesting initializedBase = baseUnderTestingInstance;     @InjectMocks private BaseUnderTesting notInitializedBase;      @Spy @InjectMocks private SuperUnderTesting initializedSpy = new SuperUnderTesting();     @Spy @InjectMocks private SuperUnderTesting notInitializedSpy;      @Mock private Map map;     @Mock private List list;     @Mock private Set histogram1;     @Mock private Set histogram2;     @Spy private TreeSet searchTree = new TreeSet();     private MockUtil mockUtil = new MockUtil();      @Before     public void init() {         // initMocks called in TestBase Before method, so instances ar not the same         MockitoAnnotations.initMocks(this);     }      @Test     public void shouldKeepSameInstanceIfFieldInitialized() {         assertSame(baseUnderTestingInstance, initializedBase);     }      @Test     public void shouldInitializeAnnotatedFieldIfNull() {         assertNotNull(notInitializedBase);     }                                                @Test     public void shouldIInjectMocksInSpy() {         assertNotNull(initializedSpy.getAList());         assertTrue(mockUtil.isMock(initializedSpy));     }     @Test     public void shouldInitializeSpyIfNullAndInjectMocks() {         assertNotNull(notInitializedSpy);         assertNotNull(notInitializedSpy.getAList());         assertTrue(mockUtil.isMock(notInitializedSpy));     }      @Test     public void shouldInjectMocksIfAnnotated() {         MockitoAnnotations.initMocks(this);         assertSame(list, superUnderTest.getAList());     }      @Test     public void shouldNotInjectIfNotAnnotated() {         MockitoAnnotations.initMocks(this);         assertNull(superUnderTestWithoutInjection.getAList());     }      @Test     public void shouldInjectMocksForClassHierarchyIfAnnotated() {         MockitoAnnotations.initMocks(this);         assertSame(list, baseUnderTest.getAList());         assertSame(map, baseUnderTest.getAMap());     }      @Test     public void shouldInjectMocksByName() {         MockitoAnnotations.initMocks(this);         assertSame(histogram1, subUnderTest.getHistogram1());         assertSame(histogram2, subUnderTest.getHistogram2());     }      @Test     public void shouldInjectSpies() {         MockitoAnnotations.initMocks(this);         assertSame(searchTree, otherBaseUnderTest.getSearchTree());     }          @Test     public void shouldInstantiateInjectMockFieldIfPossible() throws Exception {         assertNotNull(notInitializedBase);     }      @Test     public void shouldKeepInstanceOnInjectMockFieldIfPresent() throws Exception {         assertSame(baseUnderTestingInstance, initializedBase);     }      @Test     public void shouldReportNicely() throws Exception {         Object failing = new Object() {             @InjectMocks ThrowingConstructor failingConstructor;         };         try {             MockitoAnnotations.initMocks(failing);             fail();         } catch (MockitoException e) {             Assertions.assertThat(e.getMessage()).contains("failingConstructor").contains("constructor").contains("threw an exception");             Assertions.assertThat(e.getCause()).isInstanceOf(RuntimeException.class);         }     }      static class ThrowingConstructor {         ThrowingConstructor() { throw new RuntimeException("aha"); };     }      static class SuperUnderTesting {          private List aList;          public List getAList() {             return aList;         }     }      static class BaseUnderTesting extends SuperUnderTesting {         private Map aMap;          public Map getAMap() {             return aMap;         }     }      static class OtherBaseUnderTesting extends SuperUnderTesting {         private TreeSet searchTree;          public TreeSet getSearchTree() {             return searchTree;         }     }      static class SubUnderTesting extends BaseUnderTesting {         private Set histogram1;         private Set histogram2;          public Set getHistogram1() {             return histogram1;         }          public Set getHistogram2() {             return histogram2;         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.annotation;  import java.util.LinkedList; import java.util.List;  import org.junit.Before; import org.junit.Test; import org.mockito.MockitoAnnotations; import org.mockito.Spy; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class SpyAnnotationInitializedInBaseClassTest extends TestBase {          class BaseClass {         @Spy List list = new LinkedList();     }          class SubClass extends BaseClass {}          @Test     public void shouldInitSpiesInBaseClass() throws Exception {         //given         SubClass subClass = new SubClass();         //when         MockitoAnnotations.initMocks(subClass);         //then         assertTrue(isMock(subClass.list));     }          @Before     @Override     public void init() {         //we need to get rid of parent implementation this time     }              @Before     public void before() {         MockitoAnnotations.initMocks(this);     }          @Spy List spyInBaseclass = new LinkedList();          public static class SubTest extends SpyAnnotationInitializedInBaseClassTest {                  @Spy List spyInSubclass = new LinkedList();                  @Test         public void shouldInitSpiesInHierarchy() throws Exception {             assertTrue(isMock(spyInSubclass));             assertTrue(isMock(spyInBaseclass));                     }        }        } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.annotation;  import static org.mockito.Mockito.doReturn; import static org.mockito.Mockito.never; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; import java.util.AbstractList; import java.util.ArrayList; import java.util.Arrays; import java.util.LinkedList; import java.util.List; import org.fest.assertions.Assertions; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.Spy; import org.mockito.exceptions.base.MockitoException; import org.mockitoutil.TestBase;  @SuppressWarnings({"unchecked", "unused"}) public class SpyAnnotationTest extends TestBase {      @Spy final List spiedList = new ArrayList();      @Spy NestedClassWithNoArgConstructor staticTypeWithNoArgConstructor;      @Spy     NestedClassWithoutDefinedConstructor staticTypeWithoutDefinedConstructor;        @Rule public final ExpectedException shouldThrow = ExpectedException.none();      @Test     public void should_init_spy_by_instance() throws Exception {         doReturn("foo").when(spiedList).get(10);         assertEquals("foo", spiedList.get(10));         assertTrue(spiedList.isEmpty());     }      @Test     public void should_init_spy_and_automatically_create_instance() throws Exception {         when(staticTypeWithNoArgConstructor.toString()).thenReturn("x");         when(staticTypeWithoutDefinedConstructor.toString()).thenReturn("y");         assertEquals("x", staticTypeWithNoArgConstructor.toString());         assertEquals("y", staticTypeWithoutDefinedConstructor.toString());     }      @Test     public void should_prevent_spying_on_interfaces() throws Exception {         class WithSpy {             @Spy List<String> list;         }          WithSpy withSpy = new WithSpy();         try {             MockitoAnnotations.initMocks(withSpy);             fail();         } catch (MockitoException e) {             Assertions.assertThat(e.getMessage()).contains("is an interface and it cannot be spied on");         }     }      @Test     public void should_allow_spying_on_interfaces_when_instance_is_concrete() throws Exception {         class WithSpy {             @Spy List<String> list = new LinkedList<String>();         }          WithSpy withSpy = new WithSpy();         //when         MockitoAnnotations.initMocks(withSpy);          //then         verify(withSpy.list, never()).clear();     }      @Test     public void should_report_when_no_arg_less_constructor() throws Exception {         class FailingSpy {             @Spy             NoValidConstructor noValidConstructor;         }          try {             MockitoAnnotations.initMocks(new FailingSpy());             fail();         } catch (MockitoException e) {             Assertions.assertThat(e.getMessage()).contains("0-arg constructor");         }     }          @Test     public void should_report_when_constructor_is_explosive() throws Exception {         class FailingSpy {             @Spy             ThrowingConstructor throwingConstructor;         }          try {             MockitoAnnotations.initMocks(new FailingSpy());             fail();         } catch (MockitoException e) {             Assertions.assertThat(e.getMessage()).contains("Unable to create mock instance");         }     }      @Test     public void should_spy_abstract_class() throws Exception {         class SpyAbstractClass {             @Spy AbstractList<String> list;                          List<String> asSingletonList(String s) {                 when(list.size()).thenReturn(1);                 when(list.get(0)).thenReturn(s);                 return list;             }         }         SpyAbstractClass withSpy = new SpyAbstractClass();         MockitoAnnotations.initMocks(withSpy);         assertEquals(Arrays.asList("a"), withSpy.asSingletonList("a"));     }      @Test     public void should_spy_inner_class() throws Exception {                class WithMockAndSpy {             @Spy private InnerStrength strength;             @Mock private List<String> list;              abstract class InnerStrength {                 private final String name;                  InnerStrength() {                     // Make sure that @Mock fields are always injected before @Spy fields.                     assertNotNull(list);                     // Make sure constructor is indeed called.                     this.name = "inner";                 }                                  abstract String strength();                                  String fullStrength() {                     return name + " " + strength();                 }             }         }         WithMockAndSpy outer = new WithMockAndSpy();         MockitoAnnotations.initMocks(outer);         when(outer.strength.strength()).thenReturn("strength");         assertEquals("inner strength", outer.strength.fullStrength());     }      @Test(expected = IndexOutOfBoundsException.class)     public void should_reset_spy() throws Exception {         spiedList.get(10); // see shouldInitSpy     }      @Test     public void should_report_when_encosing_instance_is_needed() throws Exception {         class Outer {             class Inner {}         }         class WithSpy {             @Spy private Outer.Inner inner;         }         try {             MockitoAnnotations.initMocks(new WithSpy());             fail();         } catch (MockitoException e) {             assertContains("@Spy annotation can only initialize inner classes", e.getMessage());         }     }      static class NestedClassWithoutDefinedConstructor { }      static class NestedClassWithNoArgConstructor {         NestedClassWithNoArgConstructor() { }         NestedClassWithNoArgConstructor(String f) { }     }      static class NoValidConstructor {         NoValidConstructor(String f) { }     }      static class ThrowingConstructor {         ThrowingConstructor() { throw new RuntimeException("boo!"); }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.annotation;  import java.util.LinkedList; import java.util.List;  import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.Spy; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class SpyInjectionTest extends TestBase {      @Spy List spy = new LinkedList();     @InjectMocks HasSpy hasSpy = new HasSpy();          static class HasSpy {         private List spy;         public void setSpy(List spy) {             this.spy = spy;         }             }          @Test     public void shouldDoStuff() throws Exception {         isMock(hasSpy.spy);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.annotation;  import java.util.List; import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.ArgumentCaptor; import org.mockito.Captor; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.Spy; import org.mockito.exceptions.base.MockitoException; import org.mockitoutil.TestBase;  @SuppressWarnings({"unchecked", "unused"}) public class WrongSetOfAnnotationsTest extends TestBase {      @Test(expected=MockitoException.class)     public void should_not_allow_Mock_and_Spy() throws Exception {         MockitoAnnotations.initMocks(new Object() {             @Mock @Spy List mock;         });     }      @Test     public void should_not_allow_Spy_and_or_InjectMocks_on_interfaces() throws Exception {         try {             MockitoAnnotations.initMocks(new Object() { @InjectMocks @Spy List mock; });             fail();         } catch (MockitoException me) {             Assertions.assertThat(me.getMessage()).contains("'List' is an interface");         }         try {             MockitoAnnotations.initMocks(new Object() { @Spy List mock; });             fail();         } catch (MockitoException me) {             Assertions.assertThat(me.getMessage()).contains("'List' is an interface");         }     }  //    @Test //    public void should_allow_Spy_and_InjectMocks() throws Exception { //        MockitoAnnotations.initMocks(new Object() { //            @InjectMocks //            @Spy //            WithDependency mock; //        }); //    } //    static class WithDependency { List list; }      @Test(expected=MockitoException.class)     public void should_not_allow_Mock_and_InjectMocks() throws Exception {         MockitoAnnotations.initMocks(new Object() {             @InjectMocks @Mock List mock;         });     }      @Test(expected=MockitoException.class)     public void should_not_allow_Captor_and_Mock() throws Exception {         MockitoAnnotations.initMocks(new Object() {             @Mock @Captor ArgumentCaptor captor;         });     }      @Test(expected=MockitoException.class)     public void should_not_allow_Captor_and_Spy() throws Exception {         MockitoAnnotations.initMocks(new Object() {             @Spy @Captor ArgumentCaptor captor;         });     }      @Test(expected=MockitoException.class)     public void should_not_allow_Captor_and_InjectMocks() throws Exception {         MockitoAnnotations.initMocks(new Object() {             @InjectMocks @Captor ArgumentCaptor captor;         });     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.basicapi;   import org.junit.Test;  import java.util.Set;  import static org.junit.Assert.assertEquals; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when;  public class MockAccessTest {      @Test     public void shouldAllowStubbedMockReferenceAccess() throws Exception {         Set expectedMock = mock(Set.class);          Set returnedMock = when(expectedMock.isEmpty()).thenReturn(false).getMock();          assertEquals(expectedMock, returnedMock);     }      @Test     public void stubbedMockShouldWorkAsUsual() throws Exception {         Set returnedMock = when(mock(Set.class).isEmpty()).thenReturn(false, true).getMock();          assertEquals(false, returnedMock.isEmpty());         assertEquals(true, returnedMock.isEmpty());     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.basicapi;  import org.junit.Test; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.Spy; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  public class MockingDetailsTest extends TestBase {          static class TestClass {}      @Mock TestClass annotatedMock;     @Spy TestClass annotatedSpy;      @Test     public void should_know_spy(){         assertTrue(mockingDetails(annotatedSpy).isMock());         assertTrue(mockingDetails(spy( new TestClass())).isMock());         assertTrue(mockingDetails(spy(TestClass.class)).isMock());         assertTrue(mockingDetails(mock(TestClass.class, withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))).isMock());          assertTrue(mockingDetails(annotatedSpy).isSpy());         assertTrue(mockingDetails(spy( new TestClass())).isSpy());         assertTrue(mockingDetails(spy(TestClass.class)).isSpy());         assertTrue(mockingDetails(mock(TestClass.class, withSettings().defaultAnswer(Mockito.CALLS_REAL_METHODS))).isSpy());     }      @Test     public void should_know_mock(){         assertTrue(mockingDetails(annotatedMock).isMock());         assertTrue(mockingDetails(mock(TestClass.class)).isMock());          assertFalse(mockingDetails(annotatedMock).isSpy());         assertFalse(mockingDetails(mock(TestClass.class)).isSpy());     }      @Test     public void should_handle_non_mocks() {         assertFalse(mockingDetails("non mock").isSpy());         assertFalse(mockingDetails("non mock").isMock());          assertFalse(mockingDetails(null).isSpy());         assertFalse(mockingDetails(null).isMock());     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.basicapi;  import static org.fest.assertions.Assertions.assertThat; import static org.fest.assertions.Fail.fail; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.withSettings; import static org.mockitoutil.ClassLoaders.inMemoryClassLoader; import static org.mockitoutil.SimpleClassGenerator.makeMarkerInterface; import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockitousage.IMethods;  // See issue 453 public class MockingMultipleInterfacesTest {      class Foo {}     interface IFoo {}     interface IBar {}          @Test     public void should_allow_multiple_interfaces() {         //when         Foo mock = mock(Foo.class, withSettings().extraInterfaces(IFoo.class, IBar.class));                  //then         assertThat(mock).isInstanceOf(IFoo.class);         assertThat(mock).isInstanceOf(IBar.class);     }          @Test     public void should_scream_when_null_passed_instead_of_an_interface() {         try {             //when             mock(Foo.class, withSettings().extraInterfaces(IFoo.class, null));             fail();         } catch (MockitoException e) {             //then             assertThat(e.getMessage()).contains("extraInterfaces() does not accept null parameters");         }     }          @Test     public void should_scream_when_no_args_passed() {         try {             //when             mock(Foo.class, withSettings().extraInterfaces());             fail();         } catch (MockitoException e) {             //then             assertThat(e.getMessage()).contains("extraInterfaces() requires at least one interface");         }     }          @Test     public void should_scream_when_null_passed_instead_of_an_array() {         try {             //when             mock(Foo.class, withSettings().extraInterfaces((Class[]) null));             fail();         } catch (MockitoException e) {             //then             assertThat(e.getMessage()).contains("extraInterfaces() requires at least one interface");         }     }          @Test     public void should_scream_when_non_interface_passed() {         try {             //when             mock(Foo.class, withSettings().extraInterfaces(Foo.class));             fail();         } catch (MockitoException e) {             //then             assertThat(e.getMessage()).contains("Foo which is not an interface");         }     }          @Test     public void should_scream_when_the_same_interfaces_passed() {         try {             //when             mock(IMethods.class, withSettings().extraInterfaces(IMethods.class));             fail();         } catch (MockitoException e) {             //then             assertThat(e.getMessage()).contains("You mocked following type: IMethods");         }     }       @Test     public void should_mock_class_with_interfaces_of_different_class_loader_AND_different_classpaths() throws ClassNotFoundException {         // Note : if classes are in the same classpath, SearchingClassLoader can find the class/classes and load them in the first matching classloader         Class<?> interface1 = inMemoryClassLoader()                 .withClassDefinition("test.Interface1", makeMarkerInterface("test.Interface1"))                 .build()                 .loadClass("test.Interface1");         Class<?> interface2 = inMemoryClassLoader()                 .withClassDefinition("test.Interface2", makeMarkerInterface("test.Interface2"))                 .build()                 .loadClass("test.Interface2");          Object mocked = mock(interface1, withSettings().extraInterfaces(interface2));         assertThat(interface2.isInstance(mocked)).describedAs("mock should be assignable from interface2 type").isTrue();     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.basicapi;  import org.junit.Test; import org.mockito.Mockito; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.SmartNullPointerException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import java.util.LinkedList; import java.util.List; import java.util.Set;  import static org.hamcrest.CoreMatchers.is; import static org.mockito.Mockito.*;  @SuppressWarnings("unchecked") public class MocksCreationTest extends TestBase {      private class HasPrivateConstructor {};          @Test     public void shouldCreateMockWhenConstructorIsPrivate() {         assertNotNull(Mockito.mock(HasPrivateConstructor.class));     }          @Test     public void shouldCombineMockNameAndSmartNulls() {         //given         IMethods mock = mock(IMethods.class, withSettings()             .defaultAnswer(RETURNS_SMART_NULLS)             .name("great mockie"));                      //when         IMethods smartNull = mock.iMethodsReturningMethod();         String name = mock.toString();                  //then         assertContains("great mockie", name);         //and         try {             smartNull.simpleMethod();             fail();         } catch(SmartNullPointerException e) {}     }          @Test     public void shouldCombineMockNameAndExtraInterfaces() {} // Defects4J: flaky method //     @Test //     public void shouldCombineMockNameAndExtraInterfaces() { //         //given //         IMethods mock = mock(IMethods.class, withSettings() //                 .extraInterfaces(List.class) //                 .name("great mockie")); //          //         //when //         String name = mock.toString(); //          //         //then //         assertContains("great mockie", name); //         //and //         assertThat(mock, is(List.class)); //     }          @Test     public void shouldSpecifyMockNameViaSettings() {         //given         IMethods mock = mock(IMethods.class, withSettings().name("great mockie"));          //when         String name = mock.toString();                  //then         assertContains("great mockie", name);     }          @Test     public void shouldScreamWhenSpyCreatedWithWrongType() {         //given         List list = new LinkedList();         try {             //when             mock(List.class, withSettings().spiedInstance(list));             fail();             //then         } catch (MockitoException e) {}     }      @Test     public void shouldAllowCreatingSpiesWithCorrectType() {         List list = new LinkedList();         mock(LinkedList.class, withSettings().spiedInstance(list));     }      @Test     public void shouldAllowInlineMockCreation() throws Exception {         when(mock(Set.class).isEmpty()).thenReturn(false);     }  }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.basicapi;  import static org.mockito.Matchers.anyObject; import static org.mockito.Matchers.anyString; import static org.mockito.Mockito.CALLS_REAL_METHODS; import static org.mockito.Mockito.inOrder; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.never; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; import static org.mockito.Mockito.withSettings; import static org.mockitoutil.SimpleSerializationUtil.deserializeMock; import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack; import static org.mockitoutil.SimpleSerializationUtil.serializeMock; import java.io.ByteArrayOutputStream; import java.io.Serializable; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Observable; import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.MockitoAnnotations; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.matchers.Any; import org.mockito.internal.stubbing.answers.ThrowsException; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings({"unchecked", "serial"}) public class MocksSerializationForAnnotationTest extends TestBase implements Serializable {      private static final long serialVersionUID = 6160482220413048624L;      @Mock Any any;     @Mock(serializable=true) Bar barMock;     @Mock(serializable=true) IMethods imethodsMock;     @Mock(serializable=true) IMethods imethodsMock2;     @Mock(serializable=true) Any anyMock;     @Mock(serializable=true) AlreadySerializable alreadySerializableMock;     @Mock(extraInterfaces={List.class},serializable=true) IMethods imethodsWithExtraInterfacesMock;          @Test     public void should_allow_throws_exception_to_be_serializable() throws Exception {         // given         when(barMock.doSomething()).thenAnswer(new ThrowsException(new RuntimeException()));          //when-serialize then-deserialize         serializeAndBack(barMock);     }          @Test     public void should_allow_mock_to_be_serializable() throws Exception {         // when-serialize then-deserialize         serializeAndBack(imethodsMock);     }      @Test     public void should_allow_mock_and_boolean_value_to_serializable() throws Exception {         // given         when(imethodsMock.booleanReturningMethod()).thenReturn(true);          // when         ByteArrayOutputStream serialized = serializeMock(imethodsMock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertTrue(readObject.booleanReturningMethod());     }      @Test     public void should_allow_mock_and_string_value_to_be_serializable() throws Exception {         // given         String value = "value";         when(imethodsMock.stringReturningMethod()).thenReturn(value);          // when         ByteArrayOutputStream serialized = serializeMock(imethodsMock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(value, readObject.stringReturningMethod());     }      @Test     public void should_all_mock_and_serializable_value_to_be_serialized() throws Exception {         // given         List<?> value = Collections.emptyList();         when(imethodsMock.objectReturningMethodNoArgs()).thenReturn(value);          // when         ByteArrayOutputStream serialized = serializeMock(imethodsMock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(value, readObject.objectReturningMethodNoArgs());     }      @Test     public void should_serialize_method_call_with_parameters_that_are_serializable() throws Exception {         List<?> value = Collections.emptyList();         when(imethodsMock.objectArgMethod(value)).thenReturn(value);          // when         ByteArrayOutputStream serialized = serializeMock(imethodsMock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(value, readObject.objectArgMethod(value));     }      @Test     public void should_serialize_method_calls_using_any_string_matcher() throws Exception {         List<?> value = Collections.emptyList();         when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);          // when         ByteArrayOutputStream serialized = serializeMock(imethodsMock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(value, readObject.objectArgMethod(""));     }      @Test     public void should_verify_called_n_times_for_serialized_mock() throws Exception {         List<?> value = Collections.emptyList();         when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);         imethodsMock.objectArgMethod("");          // when         ByteArrayOutputStream serialized = serializeMock(imethodsMock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         verify(readObject, times(1)).objectArgMethod("");     }      @Test     public void should_verify_even_if_some_methods_called_after_serialization() throws Exception {          // when         imethodsMock.simpleMethod(1);         ByteArrayOutputStream serialized = serializeMock(imethodsMock);         IMethods readObject = deserializeMock(serialized, IMethods.class);         readObject.simpleMethod(1);          // then         verify(readObject, times(2)).simpleMethod(1);          //this test is working because it seems that java serialization mechanism replaces all instances         //of serialized object in the object graph (if there are any)     }      class Bar implements Serializable {         Foo foo;          public Foo doSomething() {             return foo;         }     }      class Foo implements Serializable {         Bar bar;         Foo() {             bar = new Bar();             bar.foo = this;         }     }      @Test     public void should_serialization_work() {} // Defects4J: flaky method //     @Test //     public void should_serialization_work() throws Exception { //         //given //         Foo foo = new Foo(); //         //when //         foo = serializeAndBack(foo); //         //then //         assertSame(foo, foo.bar.foo); //     }      @Test     public void should_stub_even_if_some_methods_called_after_serialization() throws Exception {         //given         // when         when(imethodsMock.simpleMethod(1)).thenReturn("foo");         ByteArrayOutputStream serialized = serializeMock(imethodsMock);         IMethods readObject = deserializeMock(serialized, IMethods.class);         when(readObject.simpleMethod(2)).thenReturn("bar");          // then         assertEquals("foo", readObject.simpleMethod(1));         assertEquals("bar", readObject.simpleMethod(2));     }      @Test     public void should_verify_call_order_for_serialized_mock() throws Exception {         imethodsMock.arrayReturningMethod();         imethodsMock2.arrayReturningMethod();          // when         ByteArrayOutputStream serialized = serializeMock(imethodsMock);         ByteArrayOutputStream serialized2 = serializeMock(imethodsMock2);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         IMethods readObject2 = deserializeMock(serialized2, IMethods.class);         InOrder inOrder = inOrder(readObject, readObject2);         inOrder.verify(readObject).arrayReturningMethod();         inOrder.verify(readObject2).arrayReturningMethod();     }      @Test     public void should_remember_interactions_for_serialized_mock() throws Exception {         List<?> value = Collections.emptyList();         when(imethodsMock.objectArgMethod(anyString())).thenReturn(value);         imethodsMock.objectArgMethod("happened");          // when         ByteArrayOutputStream serialized = serializeMock(imethodsMock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         verify(readObject, never()).objectArgMethod("never happened");     }      @Test     public void should_serialize_with_stubbing_callback() throws Exception {          // given         CustomAnswersMustImplementSerializableForSerializationToWork answer =              new CustomAnswersMustImplementSerializableForSerializationToWork();         answer.string = "return value";         when(imethodsMock.objectArgMethod(anyString())).thenAnswer(answer);          // when         ByteArrayOutputStream serialized = serializeMock(imethodsMock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(answer.string, readObject.objectArgMethod(""));     }      static class CustomAnswersMustImplementSerializableForSerializationToWork         implements Answer<Object>, Serializable {         private String string;         public Object answer(InvocationOnMock invocation) throws Throwable {             invocation.getArguments();             invocation.getMock();             return string;         }     }      @Test     public void should_serialize_with_real_object_spy() throws Exception {         // given         List<Object> list = new ArrayList<Object>();         List<Object> spy = mock(ArrayList.class, withSettings()                         .spiedInstance(list)                         .defaultAnswer(CALLS_REAL_METHODS)                         .serializable());         when(spy.size()).thenReturn(100);          // when         ByteArrayOutputStream serialized = serializeMock(spy);          // then         List<?> readObject = deserializeMock(serialized, List.class);         assertEquals(100, readObject.size());     }      @Test     public void should_serialize_object_mock() {} // Defects4J: flaky method //     @Test //     public void should_serialize_object_mock() throws Exception { //         // when //         ByteArrayOutputStream serialized = serializeMock(any); //  //         // then //         deserializeMock(serialized, Any.class); //     }          @Test     public void should_serialize_real_partial_mock() {} // Defects4J: flaky method //     @Test //     public void should_serialize_real_partial_mock() throws Exception { //         // given //         when(anyMock.matches(anyObject())).thenCallRealMethod(); //  //         // when //         ByteArrayOutputStream serialized = serializeMock(anyMock); //  //         // then //         Any readObject = deserializeMock(serialized, Any.class); //         readObject.matches(""); //     }      class AlreadySerializable implements Serializable {}      @Test     public void should_serialize_already_serializable_class() throws Exception {         // given         when(alreadySerializableMock.toString()).thenReturn("foo");          // when         alreadySerializableMock = serializeAndBack(alreadySerializableMock);          // then         assertEquals("foo", alreadySerializableMock.toString());     }          @Test     public void should_be_serialize_and_have_extra_interfaces() throws Exception {         //then         Assertions.assertThat((Object) serializeAndBack((List) imethodsWithExtraInterfacesMock))                 .isInstanceOf(List.class)                 .isInstanceOf(IMethods.class);     }        static class NotSerializableAndNoDefaultConstructor {         NotSerializableAndNoDefaultConstructor(Observable o) { super(); }     }          public static class FailTestClass {         @Mock(serializable=true)         NotSerializableAndNoDefaultConstructor notSerializableAndNoDefaultConstructor;     }          @Test     public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor() throws Exception {         try {             FailTestClass testClass = new FailTestClass();             MockitoAnnotations.initMocks(testClass);             serializeAndBack(testClass.notSerializableAndNoDefaultConstructor);             fail("should have thrown an exception to say the object is not serializable");         } catch (MockitoException e) {             Assertions.assertThat(e.getMessage())                     .contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName())                     .contains("serializable()")                     .contains("implement Serializable")                     .contains("no-arg constructor");         }     }        static class SerializableAndNoDefaultConstructor implements Serializable {         SerializableAndNoDefaultConstructor(Observable o) { super(); }     }      public static class TestClassThatHoldValidField {         @Mock(serializable=true)         SerializableAndNoDefaultConstructor serializableAndNoDefaultConstructor;     }      @Test     public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor() throws Exception {         TestClassThatHoldValidField testClass = new TestClassThatHoldValidField();         MockitoAnnotations.initMocks(testClass);          serializeAndBack(testClass.serializableAndNoDefaultConstructor);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.basicapi;  import static org.mockito.Matchers.anyString; import static org.mockito.Mockito.CALLS_REAL_METHODS; import static org.mockito.Mockito.RETURNS_DEEP_STUBS; import static org.mockito.Mockito.anyObject; import static org.mockito.Mockito.inOrder; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.never; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; import static org.mockito.Mockito.withSettings; import static org.mockitoutil.SimpleSerializationUtil.deserializeMock; import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack; import static org.mockitoutil.SimpleSerializationUtil.serializeMock; import java.io.ByteArrayOutputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.util.ArrayList; import java.util.Collections; import java.util.List; import java.util.Observable; import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mockito; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.matchers.Any; import org.mockito.internal.stubbing.answers.ThrowsException; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import org.mockitousage.IMethods; import org.mockitoutil.SimpleSerializationUtil; import org.mockitoutil.TestBase;  @SuppressWarnings({"unchecked", "serial"}) public class MocksSerializationTest extends TestBase implements Serializable {      private static final long serialVersionUID = 6160482220413048624L;      @Test     public void should_allow_throws_exception_to_be_serializable() throws Exception {         // given         Bar mock = mock(Bar.class, new ThrowsException(new RuntimeException()));         // when-serialize then-deserialize         serializeAndBack(mock);     }      @Test     public void should_allow_method_delegation() throws Exception {         // given         Bar barMock = mock(Bar.class, withSettings().serializable());         Foo fooMock = mock(Foo.class);         when(barMock.doSomething()).thenAnswer(new ThrowsException(new RuntimeException()));          //when-serialize then-deserialize         serializeAndBack(barMock);     }      @Test     public void should_allow_mock_to_be_serializable() throws Exception {         // given         IMethods mock = mock(IMethods.class, withSettings().serializable());          // when-serialize then-deserialize         serializeAndBack(mock);     }      @Test     public void should_allow_mock_and_boolean_value_to_serializable() throws Exception {         // given         IMethods mock = mock(IMethods.class, withSettings().serializable());         when(mock.booleanReturningMethod()).thenReturn(true);          // when         ByteArrayOutputStream serialized = serializeMock(mock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertTrue(readObject.booleanReturningMethod());     }      @Test     public void should_allow_mock_and_string_value_to_be_serializable() throws Exception {         // given         IMethods mock = mock(IMethods.class, withSettings().serializable());         String value = "value";         when(mock.stringReturningMethod()).thenReturn(value);          // when         ByteArrayOutputStream serialized = serializeMock(mock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(value, readObject.stringReturningMethod());     }      @Test     public void should_all_mock_and_serializable_value_to_be_serialized() throws Exception {         // given         IMethods mock = mock(IMethods.class, withSettings().serializable());         List<?> value = Collections.emptyList();         when(mock.objectReturningMethodNoArgs()).thenReturn(value);          // when         ByteArrayOutputStream serialized = serializeMock(mock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(value, readObject.objectReturningMethodNoArgs());     }      @Test     public void should_serialize_method_call_with_parameters_that_are_serializable() throws Exception {         IMethods mock = mock(IMethods.class, withSettings().serializable());         List<?> value = Collections.emptyList();         when(mock.objectArgMethod(value)).thenReturn(value);          // when         ByteArrayOutputStream serialized = serializeMock(mock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(value, readObject.objectArgMethod(value));     }      @Test     public void should_serialize_method_calls_using_any_string_matcher() throws Exception {         IMethods mock = mock(IMethods.class, withSettings().serializable());         List<?> value = Collections.emptyList();         when(mock.objectArgMethod(anyString())).thenReturn(value);          // when         ByteArrayOutputStream serialized = serializeMock(mock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(value, readObject.objectArgMethod(""));     }      @Test     public void should_verify_called_n_times_for_serialized_mock() throws Exception {         IMethods mock = mock(IMethods.class, withSettings().serializable());         List<?> value = Collections.emptyList();         when(mock.objectArgMethod(anyString())).thenReturn(value);         mock.objectArgMethod("");          // when         ByteArrayOutputStream serialized = serializeMock(mock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         verify(readObject, times(1)).objectArgMethod("");     }      @Test     public void should_verify_even_if_some_methods_called_after_serialization() throws Exception {         //given         IMethods mock = mock(IMethods.class, withSettings().serializable());          // when         mock.simpleMethod(1);         ByteArrayOutputStream serialized = serializeMock(mock);         IMethods readObject = deserializeMock(serialized, IMethods.class);         readObject.simpleMethod(1);          // then         verify(readObject, times(2)).simpleMethod(1);          //this test is working because it seems that java serialization mechanism replaces all instances         //of serialized object in the object graph (if there are any)     }      class Bar implements Serializable {         Foo foo;          public Foo doSomething() {             return foo;         }     }      class Foo implements Serializable {         Bar bar;         Foo() {             bar = new Bar();             bar.foo = this;         }     }      @Test     public void should_serialization_work() throws Exception {         //given         Foo foo = new Foo();         //when         foo = serializeAndBack(foo);         //then         assertSame(foo, foo.bar.foo);     }      @Test     public void should_stub_even_if_some_methods_called_after_serialization() throws Exception {         //given         IMethods mock = mock(IMethods.class, withSettings().serializable());          // when         when(mock.simpleMethod(1)).thenReturn("foo");         ByteArrayOutputStream serialized = serializeMock(mock);         IMethods readObject = deserializeMock(serialized, IMethods.class);         when(readObject.simpleMethod(2)).thenReturn("bar");          // then         assertEquals("foo", readObject.simpleMethod(1));         assertEquals("bar", readObject.simpleMethod(2));     }      @Test     public void should_verify_call_order_for_serialized_mock() throws Exception {         IMethods mock = mock(IMethods.class, withSettings().serializable());         IMethods mock2 = mock(IMethods.class, withSettings().serializable());         mock.arrayReturningMethod();         mock2.arrayReturningMethod();          // when         ByteArrayOutputStream serialized = serializeMock(mock);         ByteArrayOutputStream serialized2 = serializeMock(mock2);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         IMethods readObject2 = deserializeMock(serialized2, IMethods.class);         InOrder inOrder = inOrder(readObject, readObject2);         inOrder.verify(readObject).arrayReturningMethod();         inOrder.verify(readObject2).arrayReturningMethod();     }      @Test     public void should_remember_interactions_for_serialized_mock() throws Exception {         IMethods mock = mock(IMethods.class, withSettings().serializable());         List<?> value = Collections.emptyList();         when(mock.objectArgMethod(anyString())).thenReturn(value);         mock.objectArgMethod("happened");          // when         ByteArrayOutputStream serialized = serializeMock(mock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         verify(readObject, never()).objectArgMethod("never happened");     }      @Test     public void should_serialize_with_stubbing_callback() throws Exception {          // given         IMethods mock = mock(IMethods.class, withSettings().serializable());         CustomAnswersMustImplementSerializableForSerializationToWork answer =                 new CustomAnswersMustImplementSerializableForSerializationToWork();         answer.string = "return value";         when(mock.objectArgMethod(anyString())).thenAnswer(answer);          // when         ByteArrayOutputStream serialized = serializeMock(mock);          // then         IMethods readObject = deserializeMock(serialized, IMethods.class);         assertEquals(answer.string, readObject.objectArgMethod(""));     }      class CustomAnswersMustImplementSerializableForSerializationToWork             implements Answer<Object>, Serializable {         private String string;         public Object answer(InvocationOnMock invocation) throws Throwable {             invocation.getArguments();             invocation.getMock();             return string;         }     }      @Test     public void should_serialize_with_real_object_spy() throws Exception {         // given         List<Object> list = new ArrayList<Object>();         List<Object> spy = mock(ArrayList.class, withSettings()                 .spiedInstance(list)                 .defaultAnswer(CALLS_REAL_METHODS)                 .serializable());         when(spy.size()).thenReturn(100);          // when         ByteArrayOutputStream serialized = serializeMock(spy);          // then         List<?> readObject = deserializeMock(serialized, List.class);         assertEquals(100, readObject.size());     }      @Test     public void should_serialize_object_mock() {} // Defects4J: flaky method //     @Test //     public void should_serialize_object_mock() throws Exception { //         // given //         Any mock = mock(Any.class); //  //         // when //         ByteArrayOutputStream serialized = serializeMock(mock); //  //         // then //         deserializeMock(serialized, Any.class); //     }      @Test     public void should_serialize_real_partial_mock() {} // Defects4J: flaky method //     @Test //     public void should_serialize_real_partial_mock() throws Exception { //         // given //         Any mock = mock(Any.class, withSettings().serializable()); //         when(mock.matches(anyObject())).thenCallRealMethod(); //  //         // when //         ByteArrayOutputStream serialized = serializeMock(mock); //  //         // then //         Any readObject = deserializeMock(serialized, Any.class); //         readObject.matches(""); //     }      class AlreadySerializable implements Serializable {}      @Test     public void should_serialize_already_serializable_class() throws Exception {         // given         AlreadySerializable mock = mock(AlreadySerializable.class, withSettings().serializable());         when(mock.toString()).thenReturn("foo");          // when         mock = serializeAndBack(mock);          // then         assertEquals("foo", mock.toString());     }      @Test     public void should_be_serialize_and_have_extra_interfaces() throws Exception {         //when         IMethods mock = mock(IMethods.class, withSettings().serializable().extraInterfaces(List.class));         IMethods mockTwo = mock(IMethods.class, withSettings().extraInterfaces(List.class).serializable());          //then         Assertions.assertThat((Object) serializeAndBack((List) mock))                 .isInstanceOf(List.class)                 .isInstanceOf(IMethods.class);         Assertions.assertThat((Object) serializeAndBack((List) mockTwo))                 .isInstanceOf(List.class)                 .isInstanceOf(IMethods.class);     }        static class NotSerializableAndNoDefaultConstructor {         NotSerializableAndNoDefaultConstructor(Observable o) { super(); }     }      @Test     public void should_fail_when_serializable_used_with_type_that_dont_implements_Serializable_and_dont_declare_a_no_arg_constructor() throws Exception {         try {             serializeAndBack(mock(NotSerializableAndNoDefaultConstructor.class, withSettings().serializable()));             fail("should have thrown an exception to say the object is not serializable");         } catch (MockitoException e) {             Assertions.assertThat(e.getMessage())                     .contains(NotSerializableAndNoDefaultConstructor.class.getSimpleName())                     .contains("serializable()")                     .contains("implement Serializable")                     .contains("no-arg constructor");         }     }        static class SerializableAndNoDefaultConstructor implements Serializable {         SerializableAndNoDefaultConstructor(Observable o) { super(); }     }      @Test     public void should_be_able_to_serialize_type_that_implements_Serializable_but_but_dont_declare_a_no_arg_constructor() throws Exception {         serializeAndBack(mock(SerializableAndNoDefaultConstructor.class));     }        public static class AClassWithPrivateNoArgConstructor {         private AClassWithPrivateNoArgConstructor() {}         List returningSomething() { return Collections.emptyList(); }     }      @Test     public void private_constructor_currently_not_supported_at_the_moment_at_deserialization_time() throws Exception {         // given         AClassWithPrivateNoArgConstructor mockWithPrivateConstructor = Mockito.mock(                 AClassWithPrivateNoArgConstructor.class,                 Mockito.withSettings().serializable()         );          try {             // when             SimpleSerializationUtil.serializeAndBack(mockWithPrivateConstructor);             fail("should have thrown an ObjectStreamException or a subclass of it");         } catch (ObjectStreamException e) {             // then             Assertions.assertThat(e.toString()).contains("no valid constructor");         }     }       @Test     public void BUG_ISSUE_399_try_some_mocks_with_current_answers() throws Exception {         IMethods iMethods = mock(IMethods.class, withSettings().serializable().defaultAnswer(RETURNS_DEEP_STUBS));          when(iMethods.iMethodsReturningMethod().linkedListReturningMethod().contains(anyString())).thenReturn(false);          serializeAndBack(iMethods);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.basicapi;  import org.junit.Test; import org.mockitoutil.TestBase;  import java.io.Serializable;  import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;  @SuppressWarnings("serial") public class ObjectsSerializationTest extends TestBase implements Serializable {      //Ok, this test has nothing to do with mocks but it shows fundamental feature of java serialization that     //plays important role in mocking:     //Serialization/deserialization actually replaces all instances of serialized object in the object graph (if there are any)     //thanks to that mechanizm, stubbing & verification can correctly match method invocations because     //one of the parts of invocation matching is checking if mock object is the same      class Bar implements Serializable {         Foo foo;     }      class Foo implements Serializable {         Bar bar;         Foo() {             bar = new Bar();             bar.foo = this;         }     }      @Test     public void shouldSerializationWork() throws Exception {         //given         Foo foo = new Foo();         //when         foo = serializeAndBack(foo);         //then         assertSame(foo, foo.bar.foo);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.basicapi;  import static org.hamcrest.CoreMatchers.*;  import org.junit.Test; import org.mockito.Mockito; import org.mockitoutil.TestBase;  public class ReplacingObjectMethodsTest extends TestBase {      private interface DummyInterface {}     private class DummyClass {}          @Test     public void shouldProvideMockyImplementationOfToString() {         DummyClass dummyClass = Mockito.mock(DummyClass.class);         assertEquals("Mock for DummyClass, hashCode: " + dummyClass.hashCode(), dummyClass.toString());         DummyInterface dummyInterface = Mockito.mock(DummyInterface.class);         assertEquals("Mock for DummyInterface, hashCode: " + dummyInterface.hashCode(), dummyInterface.toString());     }          @Test     public void shouldReplaceObjectMethods() {} // Defects4J: flaky method //     @Test  //     public void shouldReplaceObjectMethods() { //         Object mock = Mockito.mock(ObjectMethodsOverridden.class); //         Object otherMock = Mockito.mock(ObjectMethodsOverridden.class); //          //         assertThat(mock, equalTo(mock)); //         assertThat(mock, not(equalTo(otherMock))); //          //         assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode()))); //          //         assertContains("Mock for ObjectMethodsOverridden", mock.toString()); //     }          @Test     public void shouldReplaceObjectMethodsWhenOverridden() {} // Defects4J: flaky method //     @Test  //     public void shouldReplaceObjectMethodsWhenOverridden() { //         Object mock = Mockito.mock(ObjectMethodsOverriddenSubclass.class); //         Object otherMock = Mockito.mock(ObjectMethodsOverriddenSubclass.class); //          //         assertThat(mock, equalTo(mock)); //         assertThat(mock, not(equalTo(otherMock))); //          //         assertThat(mock.hashCode(), not(equalTo(otherMock.hashCode()))); //          //         assertContains("Mock for ObjectMethodsOverriddenSubclass", mock.toString()); //     }          public static class ObjectMethodsOverridden {         public boolean equals(Object o) {             throw new RuntimeException("Should not be called. MethodInterceptorFilter provides implementation");         }         public int hashCode() {             throw new RuntimeException("Should not be called. MethodInterceptorFilter provides implementation");         }         public String toString() {             throw new RuntimeException("Should not be called. MethodInterceptorFilter provides implementation");         }     }          public static class ObjectMethodsOverriddenSubclass extends ObjectMethodsOverridden {     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.basicapi;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.misusing.MissingMethodInvocationException; import org.mockito.exceptions.misusing.NotAMockException; import org.mockito.exceptions.misusing.UnfinishedVerificationException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class ResetTest extends TestBase {      @Mock private IMethods mock;     @Mock private IMethods mockTwo;          @Test     public void shouldResetOngoingStubbingSoThatMoreMeaningfulExceptionsAreRaised() {         mock(IMethods.class);         mock.booleanReturningMethod();         reset(mock);         try {             when(null).thenReturn("anything");             fail();         } catch (MissingMethodInvocationException e) {         }     }      @Test(expected = NotAMockException.class)     public void resettingNonMockIsSafe() {         reset("");     }      @Test(expected = NotAMockException.class)     public void resettingNullIsSafe() {         reset(new Object[] {null});     }      @Test     public void shouldRemoveAllStubbing() throws Exception {         when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);         when(mock.objectReturningMethod(200)).thenReturn(200);         reset(mock);         assertNull(mock.objectReturningMethod(200));         assertEquals("default behavior should return null", null, mock.objectReturningMethod("blah"));     }      @Test     public void shouldRemoveAllInteractions() throws Exception {         mock.simpleMethod(1);         reset(mock);         verifyZeroInteractions(mock);     }      @Test     public void shouldRemoveStubbingToString() throws Exception {         IMethods mockTwo = mock(IMethods.class);         when(mockTwo.toString()).thenReturn("test");         reset(mockTwo);         assertContains("Mock for IMethods", mockTwo.toString());     }      @Test     public void shouldStubbingNotBeTreatedAsInteraction() {         when(mock.simpleMethod("one")).thenThrow(new RuntimeException());         doThrow(new RuntimeException()).when(mock).simpleMethod("two");         reset(mock);         verifyZeroInteractions(mock);     }      @Test     public void shouldNotAffectMockName() {         IMethods mock = mock(IMethods.class, "mockie");         IMethods mockTwo = mock(IMethods.class);         reset(mock);         assertContains("Mock for IMethods", "" + mockTwo);         assertEquals("mockie", "" + mock);     }          @Test     public void shouldResetMultipleMocks() {         mock.simpleMethod();         mockTwo.simpleMethod();         reset(mock, mockTwo);         verifyNoMoreInteractions(mock, mockTwo);     }          @Test     public void shouldValidateStateWhenResetting() {         //invalid verify:         verify(mock);                  try {             reset(mockTwo);             fail();         } catch (UnfinishedVerificationException e) {}     }          @Test     public void shouldMaintainPreviousDefaultAnswer() {         //given         mock = mock(IMethods.class, RETURNS_MOCKS);         //when         reset(mock);         //then         assertNotNull(mock.iMethodsReturningMethod());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.basicapi;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.util.ArrayList;  import org.junit.Test; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitoutil.TestBase;  public class UsingVarargsTest extends TestBase {      private interface IVarArgs {         void withStringVarargs(int value, String... s);         String withStringVarargsReturningString(int value, String... s);         void withObjectVarargs(int value, Object... o);         boolean withBooleanVarargs(int value, boolean... b);         int foo(Object ... objects);     }          @Mock IVarArgs mock;      @SuppressWarnings("deprecation")     @Test     public void shouldStubStringVarargs() {         when(mock.withStringVarargsReturningString(1)).thenReturn("1");         when(mock.withStringVarargsReturningString(2, "1", "2", "3")).thenReturn("2");                  RuntimeException expected = new RuntimeException();         stubVoid(mock).toThrow(expected).on().withStringVarargs(3, "1", "2", "3", "4");          assertEquals("1", mock.withStringVarargsReturningString(1));         assertEquals(null, mock.withStringVarargsReturningString(2));                  assertEquals("2", mock.withStringVarargsReturningString(2, "1", "2", "3"));         assertEquals(null, mock.withStringVarargsReturningString(2, "1", "2"));         assertEquals(null, mock.withStringVarargsReturningString(2, "1", "2", "3", "4"));         assertEquals(null, mock.withStringVarargsReturningString(2, "1", "2", "9999"));                  mock.withStringVarargs(3, "1", "2", "3", "9999");         mock.withStringVarargs(9999, "1", "2", "3", "4");                  try {             mock.withStringVarargs(3, "1", "2", "3", "4");             fail();         } catch (Exception e) {             assertEquals(expected, e);         }     }          @Test     public void shouldStubBooleanVarargs() {         when(mock.withBooleanVarargs(1)).thenReturn(true);         when(mock.withBooleanVarargs(1, true, false)).thenReturn(true);                  assertEquals(true, mock.withBooleanVarargs(1));         assertEquals(false, mock.withBooleanVarargs(9999));                  assertEquals(true, mock.withBooleanVarargs(1, true, false));         assertEquals(false, mock.withBooleanVarargs(1, true, false, true));         assertEquals(false, mock.withBooleanVarargs(2, true, false));         assertEquals(false, mock.withBooleanVarargs(1, true));         assertEquals(false, mock.withBooleanVarargs(1, false, false));     }          @Test     public void shouldVerifyStringVarargs() {         mock.withStringVarargs(1);         mock.withStringVarargs(2, "1", "2", "3");         mock.withStringVarargs(3, "1", "2", "3", "4");          verify(mock).withStringVarargs(1);         verify(mock).withStringVarargs(2, "1", "2", "3");         try {             verify(mock).withStringVarargs(2, "1", "2", "79", "4");             fail();         } catch (ArgumentsAreDifferent e) {}     }      @Test     public void shouldVerifyObjectVarargs() {         mock.withObjectVarargs(1);         mock.withObjectVarargs(2, "1", new ArrayList<Object>(), new Integer(1));         mock.withObjectVarargs(3, new Integer(1));          verify(mock).withObjectVarargs(1);         verify(mock).withObjectVarargs(2, "1", new ArrayList<Object>(), new Integer(1));         try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {}     }      @Test     public void shouldVerifyBooleanVarargs() {         mock.withBooleanVarargs(1);         mock.withBooleanVarargs(2, true, false, true);         mock.withBooleanVarargs(3, true, true, true);          verify(mock).withBooleanVarargs(1);         verify(mock).withBooleanVarargs(2, true, false, true);         try {             verify(mock).withBooleanVarargs(3, true, true, true, true);             fail();         } catch (ArgumentsAreDifferent e) {}     }          @Test     public void shouldVerifyWithAnyObject() {         Foo foo = Mockito.mock(Foo.class);         foo.varArgs("");                 Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());         Mockito.verify(foo).varArgs((String) Mockito.anyObject());     }             @Test     public void shouldVerifyWithNullVarArgArray() {         Foo foo = Mockito.mock(Foo.class);         foo.varArgs((String[]) null);             Mockito.verify(foo).varArgs((String[]) Mockito.anyObject());         Mockito.verify(foo).varArgs((String[]) null);     }            public class Foo {               public void varArgs(String... args) {}            }          interface MixedVarargs {         String doSomething(String one, String... varargs);         String doSomething(String one, String two, String... varargs);     }      @SuppressWarnings("all")     @Test     //See bug #31     public void shouldStubCorrectlyWhenMixedVarargsUsed() {         MixedVarargs mixedVarargs = mock(MixedVarargs.class);         when(mixedVarargs.doSomething("hello", (String[])null)).thenReturn("hello");         when(mixedVarargs.doSomething("goodbye", (String[])null)).thenReturn("goodbye");          String result = mixedVarargs.doSomething("hello",(String[]) null);         assertEquals("hello", result);                  verify(mixedVarargs).doSomething("hello", (String[])null);     }          @SuppressWarnings("all")     @Test     public void shouldStubCorrectlyWhenDoubleStringAndMixedVarargsUsed() {         MixedVarargs mixedVarargs = mock(MixedVarargs.class);         when(mixedVarargs.doSomething("one", "two", (String[])null)).thenReturn("hello");         when(mixedVarargs.doSomething("1", "2", (String[])null)).thenReturn("goodbye");          String result = mixedVarargs.doSomething("one", "two", (String[])null);         assertEquals("hello", result);     }          @Test     //See bug #157     public void shouldMatchEasilyEmptyVararg() throws Exception {         //when         when(mock.foo(anyVararg())).thenReturn(-1);          //then         assertEquals(-1, mock.foo());     }  }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import static org.mockito.Matchers.anyInt; import static org.mockito.Matchers.anyString; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockitoutil.TestBase;  //see bug 116 public class AIOOBExceptionWithAtLeastTest extends TestBase {      interface IProgressMonitor {         void beginTask(String s, int i);         void worked(int i);         void done();     }      @Test     public void testCompleteProgress() throws Exception {         IProgressMonitor progressMonitor = mock(IProgressMonitor.class);          progressMonitor.beginTask("foo", 12);         progressMonitor.worked(10);         progressMonitor.done();          verify(progressMonitor).beginTask(anyString(), anyInt());         verify(progressMonitor, atLeastOnce()).worked(anyInt());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockitoutil.TestBase;  public class ActualInvocationHasNullArgumentNPEBugTest extends TestBase {          public interface Fun {         String doFun(String something);     }      @Test     public void shouldAllowPassingNullArgument() {         //given         Fun mockFun = mock(Fun.class);         when(mockFun.doFun((String) anyObject())).thenReturn("value");          //when         mockFun.doFun(null);          //then         try {             verify(mockFun).doFun("hello");             fail();         } catch(AssertionError r) {             //it's ok, we just want to reproduce the bug         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.junit.Before; import org.junit.Test; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.MockitoAnnotations; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  //see issue 101 public class BridgeMethodsHitAgainTest extends TestBase {       public interface Factory {}   public interface ExtendedFactory extends Factory {}    public interface SomeInterface {     Factory factory();   }    public interface SomeSubInterface extends SomeInterface {     ExtendedFactory factory();   }    @Mock SomeSubInterface someSubInterface;   @Mock ExtendedFactory extendedFactory;    @Test   public void basicCheck() {     Mockito.when((someSubInterface).factory()).thenReturn(extendedFactory);     SomeInterface si = someSubInterface;     assertTrue(si.factory() != null);   }    @Test   public void checkWithExtraCast() {     Mockito.when(((SomeInterface) someSubInterface).factory()).thenReturn(extendedFactory);     SomeInterface si = someSubInterface;     assertTrue(si.factory() != null);   } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.ArgumentCaptor; import org.mockito.Captor; import org.mockito.Mock; import org.mockitoutil.TestBase;  //see issue 188 public class CaptorAnnotationAutoboxingTest extends TestBase {          interface Fun {         void doFun(double prmitive);         void moreFun(int howMuch);     }          @Mock Fun fun;     @Captor ArgumentCaptor<Double> captor;      @Test     public void shouldAutoboxSafely() {         //given         fun.doFun(1.0);                  //then         verify(fun).doFun(captor.capture());         assertEquals((Double) 1.0, captor.getValue());     }      @Captor ArgumentCaptor<Integer> intCaptor;          @Test     public void shouldAutoboxAllPrimitives() {         verify(fun, never()).moreFun(intCaptor.capture());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.runners.MockitoJUnitRunner;  import static org.junit.Assert.assertNotNull;  // issue 289 @RunWith(MockitoJUnitRunner.class) public class ChildWithSameParentFieldInjectionTest {     @InjectMocks     private System system;      @Mock     private SomeService someService;      @Test     public void parent_field_is_not_null() {         assertNotNull(((AbstractSystem) system).someService);     }      @Test     public void child_field_is_not_null() {         assertNotNull(system.someService);     }      public static class System extends AbstractSystem {         private SomeService someService;          public void doSomethingElse() {             someService.doSomething();         }     }      public static class AbstractSystem {         private SomeService someService;          public void doSomething() {             someService.doSomething();         }     }      public static class SomeService {         public void doSomething() {         }     } }
package org.mockitousage.bugs;  import org.junit.Test; import org.mockito.exceptions.misusing.WrongTypeOfReturnValue; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer;  import static org.mockito.Mockito.mock; import static org.mockito.Mockito.verifyZeroInteractions;  public class ClassCastExOnVerifyZeroInteractionsTest {     public interface TestMock {         boolean m1();     }      @Test(expected = NoInteractionsWanted.class)     public void should_not_throw_ClassCastException_when_mock_verification_fails() {         TestMock test = mock(TestMock.class, new Answer() {             public Object answer(InvocationOnMock invocation) throws Throwable {                 return false;             }         });         test.m1();         verifyZeroInteractions(test);     }      @Test(expected = WrongTypeOfReturnValue.class)     public void should_report_bogus_default_answer() throws Exception {         TestMock test = mock(TestMock.class, new Answer() {             public Object answer(InvocationOnMock invocation) throws Throwable {                 return false;             }         });          test.toString();     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import static org.mockito.Mockito.reset; import static org.mockito.Mockito.timeout; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.verifyNoMoreInteractions; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import org.junit.Before; import org.junit.Test; import org.mockito.Mockito;  // issue 322 // the only evidence of this failing test was shown on a RHEL with IBM J9 JVM 64bits // // details // java.fullversion=JRE 1.6.0 IBM J9 2.6 Linux amd64-64 20111113_94967  (JIT enabled, AOT enabled) // Linux2.6.32-220.4.2.el6.x86_64 #1SMP Mon Feb 6 16:39:28EST 2012x86_64 x86_64 x86_64 GNU/Linux public class ConcurrentModificationExceptionOnMultiThreadedVerificationTest {      int nThreads = 1;          static final int TIMES = 100;     static final int INTERVAL_MILLIS = 10;      ITarget target = Mockito.mock(ITarget.class);     ExecutorService fixedThreadPool;          @Before     public void setUp() {         target = Mockito.mock(ITarget.class);         fixedThreadPool = Executors.newFixedThreadPool(nThreads);     }      @Test     public void shouldSuccessfullyVerifyConcurrentInvocationsWithTimeout() throws Exception {         int potentialOverhead = 1000; // Leave 1000ms extra before timing out as leeway for test overheads         int expectedMaxTestLength = TIMES * INTERVAL_MILLIS + potentialOverhead;          reset(target);         startInvocations();                  verify(target, timeout(expectedMaxTestLength).times(TIMES * nThreads)).targetMethod("arg");         verifyNoMoreInteractions(target);     }      private void startInvocations() throws InterruptedException,             ExecutionException {                  for(int i=0; i<nThreads; i++) {             fixedThreadPool.submit(new TargetInvoker(i));         }      }          public class TargetInvoker implements Callable<Object> {         private final int seq;          TargetInvoker(int seq) {             this.seq = seq;         }                  public Object call() throws Exception {             System.err.println("started " + seq);             for (int i = 0; i < TIMES; i++) {                 Thread.yield();                 target.targetMethod("arg");                 Thread.sleep((long) INTERVAL_MILLIS);             }             System.err.println("finished" + seq);             return seq;         }              }          public interface ITarget {         public String targetMethod(String arg);     }      } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.junit.Test; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  //see issue 101 public class CovariantOverrideTest extends TestBase {         public interface ReturnsObject {         Object callMe();     }      public interface ReturnsString extends ReturnsObject {         // Java 5 covariant override of method from parent interface         String callMe();     }      @Test      public void returnFoo1() {         ReturnsObject mock = mock(ReturnsObject.class);         when(mock.callMe()).thenReturn("foo");         assertEquals("foo", mock.callMe()); // Passes     }      @Test      public void returnFoo2() {         ReturnsString mock = mock(ReturnsString.class);         when(mock.callMe()).thenReturn("foo");         assertEquals("foo", mock.callMe()); // Passes     }      @Test      public void returnFoo3() {         ReturnsObject mock = mock(ReturnsString.class);         when(mock.callMe()).thenReturn("foo");         assertEquals("foo", mock.callMe()); // Passes     }      @Test      public void returnFoo4() {         ReturnsString mock = mock(ReturnsString.class);         mock.callMe(); // covariant override not generated         ReturnsObject mock2 = mock; // Switch to base type to call covariant override         verify(mock2).callMe(); // Fails: java.lang.AssertionError: expected:<foo> but was:<null>     } }
package org.mockitousage.bugs;  import org.junit.Test;  import static org.fest.assertions.Assertions.assertThat; import static org.mockito.Mockito.RETURNS_DEEP_STUBS; import static org.mockito.Mockito.mock;  /**  * In GH issue 99 : https://github.com/mockito/mockito/issues/99  */ public class DeepStubsWronglyReportsSerializationProblemsTest {      @Test     public void should_not_raise_a_mockito_exception_about_serialization_when_accessing_deep_stub() {         NotSerializableShouldBeMocked the_deep_stub = mock(ToBeDeepStubbed.class, RETURNS_DEEP_STUBS).getSomething();         assertThat(the_deep_stub).isNotNull();     }      public static class ToBeDeepStubbed {         public ToBeDeepStubbed() { }          public NotSerializableShouldBeMocked getSomething() {             return null;         }     }      public static class NotSerializableShouldBeMocked {         NotSerializableShouldBeMocked(String mandatory_param) { }     }  } 
package org.mockitousage.bugs;  import org.hamcrest.Matcher; import org.junit.Test; import org.mockito.internal.matchers.EqualsWithDelta;  import static org.fest.assertions.Assertions.assertThat;  public class EqualsWithDeltaTest {      @Test     public void testEqualsWithDelta_NullExpected() throws Exception {         Matcher<Number> matcher = equalsWithDelta(null);         assertThat(matcher.matches(1.0)).isFalse();     }      @Test     public void testEqualsWithDelta_NullActual() throws Exception {         Matcher<Number> matcher = equalsWithDelta(1.0);         assertThat(matcher.matches(null)).isFalse();     }      @Test     public void testEqualsWithDelta_NullActualAndExpected() throws Exception {         Matcher<Number> matcher = equalsWithDelta(null);         assertThat(matcher.matches(null)).isTrue();     }      @Test     public void testEqualsWithDelta_WhenActualAndExpectedAreTheSameObject() throws Exception {         Double expected = 1.0;         Double actual = expected;         Matcher<Number> matcher = equalsWithDelta(expected);         assertThat(matcher.matches(actual)).isTrue();     }      public Matcher<Number> equalsWithDelta(final Double expected) {         return new EqualsWithDelta(expected, .000001);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations;  import java.nio.charset.Charset;  // issue 327 public class FinalHashCodeAndEqualsRaiseNPEInInitMocksTest {     @Mock private Charset charset;     @InjectMocks private FieldCharsetHolder fieldCharsetHolder;     @InjectMocks private ConstructorCharsetHolder constructorCharsetHolder;      @Test     public void dont_raise_NullPointerException() throws Exception {         MockitoAnnotations.initMocks(this);     }      private static class FieldCharsetHolder {         private Charset charset;     }      private static class ConstructorCharsetHolder {         public ConstructorCharsetHolder(Charset charset) {         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.stubbing.OngoingStubbing;  import java.util.Map;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import static org.mockito.Matchers.anyString; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when;  public class IOOBExceptionShouldNotBeThrownWhenNotCodingFluentlyTest {      @Test     public void second_stubbing_throws_IndexOutOfBoundsException() throws Exception {         Map<String, String> map = mock(Map.class);          OngoingStubbing<String> mapOngoingStubbing = when(map.get(anyString()));          mapOngoingStubbing.thenReturn("first stubbing");          try {             mapOngoingStubbing.thenReturn("second stubbing");             fail();         } catch (MockitoException e) {             assertThat(e.getMessage())                     .contains("Incorrect use of API detected here")                     .contains(this.getClass().getSimpleName());         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import static org.mockito.Mockito.*;  import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.Iterator; import java.util.LinkedList; import java.util.List;  import org.junit.Assert; import org.junit.Test; import org.mockito.Mockito; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") //see issue 200 public class InheritedGenericsPolimorphicCallTest extends TestBase {      protected interface MyIterable<T> extends Iterable<T> {         public MyIterator<T> iterator();     }      protected interface MyIterator<T> extends Iterator<T> {         // adds nothing here     }      MyIterator<String> myIterator = Mockito.mock(MyIterator.class);     MyIterable<String> iterable = Mockito.mock(MyIterable.class);      @Test     public void shouldStubbingWork() {         Mockito.when(iterable.iterator()).thenReturn(myIterator);         Assert.assertNotNull(((Iterable) iterable).iterator());         Assert.assertNotNull(iterable.iterator());     }          @Test     public void shouldVerificationWorks() {         iterable.iterator();                  verify(iterable).iterator();         verify((Iterable) iterable).iterator();     }          @Test     public void shouldWorkExactlyAsJavaProxyWould() {         //given         final List<Method> methods = new LinkedList<Method>();         InvocationHandler handler = new InvocationHandler() {         public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {             methods.add(method);             return null;         }};                      iterable = (MyIterable) Proxy.newProxyInstance(                 this.getClass().getClassLoader(),                 new Class[] { MyIterable.class },                 handler);          //when         iterable.iterator();         ((Iterable) iterable).iterator();                  //then         assertEquals(2, methods.size());         assertEquals(methods.get(0), methods.get(1));     }   }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.runners.MockitoJUnitRunner;  import java.util.List;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertTrue;  /**  * Issue 211 : @InjectMocks should carry out their work by the method (and not by field) if available   */ @RunWith(MockitoJUnitRunner.class) public class InjectMocksShouldTryPropertySettersFirstBeforeFieldAccessTest {     @Mock List<?> fieldAccess;     @Mock List<?> propertySetterAccess;     @InjectMocks BeanAwaitingInjection awaitingInjection;      @Test     public void shouldInjectUsingPropertySetterIfAvailable() {         assertTrue(awaitingInjection.propertySetterUsed);     }      @Test     public void shouldInjectFieldIfNoSetter() {         assertEquals(fieldAccess, awaitingInjection.fieldAccess);     }      static class BeanAwaitingInjection {         List<?> fieldAccess;         List<?> propertySetterAccess;         boolean propertySetterUsed;          public void setPropertySetterAccess(List<?> propertySetterAccess) {             // don't care if field is set, the setter can do whatever it want.             propertySetterUsed = true;         }     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.runners.MockitoJUnitRunner;  import java.lang.reflect.Field;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNull; import static org.junit.Assert.assertSame;  @RunWith(MockitoJUnitRunner.class) public class InjectionByTypeShouldFirstLookForExactTypeThenAncestorTest {      private static final Object REFERENCE = new Object();      @Mock private Bean mockedBean;      @InjectMocks private Service illegalInjectionExample = new Service();     @InjectMocks private ServiceWithReversedOrder reversedOrderService = new ServiceWithReversedOrder();     @InjectMocks private WithNullObjectField withNullObjectField = new WithNullObjectField();      @Test     public void just_for_information_fields_are_read_in_declaration_order_see_Service() {         Field[] declaredFields = Service.class.getDeclaredFields();          assertEquals("mockShouldNotGoInHere", declaredFields[0].getName());         assertEquals("mockShouldGoInHere", declaredFields[1].getName());     }      @Test     public void mock_should_be_injected_once_and_in_the_best_matching_type() {         assertSame(REFERENCE, illegalInjectionExample.mockShouldNotGoInHere);         assertSame(mockedBean, illegalInjectionExample.mockShouldGoInHere);     }      @Test     public void should_match_be_consistent_regardless_of_order() {         assertSame(REFERENCE, reversedOrderService.mockShouldNotGoInHere);         assertSame(mockedBean, reversedOrderService.mockShouldGoInHere);     }      @Test     public void should_inject_the_mock_only_once_and_in_the_correct_type() {         assertNull(withNullObjectField.keepMeNull);         assertSame(mockedBean, withNullObjectField.injectMePlease);     }      public static class Bean {}      public static class Service {         public final Object mockShouldNotGoInHere = REFERENCE;         public Bean mockShouldGoInHere;     }      public static class ServiceWithReversedOrder {         public Bean mockShouldGoInHere;         public final Object mockShouldNotGoInHere = REFERENCE;     }      class WithNullObjectField{         Bean injectMePlease;         Object keepMeNull = null;     } }
package org.mockitousage.bugs;   import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.runners.MockitoJUnitRunner;  import java.util.HashMap; import java.util.Map;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.assertSame;  @RunWith(MockitoJUnitRunner.class) public class Issue353InjectionMightNotHappenInCertainConfigurationTest {     @Mock Map<String, String> stringString_that_matches_field;     @Mock Map<String, Integer> mockStringInteger_was_not_injected;     @InjectMocks FooService fooService;      @Test     public void when_identical_types_and_the_correct_mock_name_is_greater_than_the_non_matching_name_then_injection_occurs_only_on_the_named_one() {         assertThat("stringString_that_matches_field".compareTo("mockStringInteger_was_not_injected")).isGreaterThanOrEqualTo(1);          assertSame(stringString_that_matches_field, fooService.stringString_that_matches_field);         assertSame(mockStringInteger_was_not_injected, fooService.stringInteger_field);     }      public static class FooService {         Map<String, Integer> stringInteger_field = new HashMap<String, Integer>();         Map<String, String> stringString_that_matches_field = new HashMap<String, String>();     }  }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;   import org.junit.Test; import org.mockito.listeners.InvocationListener; import org.mockito.listeners.MethodInvocationReport;  import java.util.List;  import static org.mockito.Mockito.*;  public class ListenersLostOnResetMockTest {      @Test     public void listener() throws Exception {         InvocationListener invocationListener = mock(InvocationListener.class);          List mockedList = mock(List.class, withSettings().invocationListeners(invocationListener));         reset(mockedList);          mockedList.clear();          verify(invocationListener).reportInvocation(any(MethodInvocationReport.class));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.junit.Test; import org.junit.internal.TextListener; import org.junit.runner.JUnitCore; import org.junit.runner.Result; import org.junit.runner.RunWith; import org.mockito.runners.MockitoJUnitRunner; import org.mockitoutil.TestBase;   // @Ignore("for demo only. this test cannot be enabled as it fails :)") public class MockitoRunnerBreaksWhenNoTestMethodsTest extends TestBase {      @Test     public void ensure_the_test_runner_breaks() throws Exception {         JUnitCore runner = new JUnitCore();         runner.addListener(new TextListener(System.out));          Result result = runner.run(TestClassWithoutTestMethod.class);          assertEquals(1, result.getFailureCount());         assertFalse(result.wasSuccessful());     }      @RunWith(MockitoJUnitRunner.class)     static class TestClassWithoutTestMethod { // package visibility is important         public void notATestMethod() { }     }  }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import static org.junit.Assert.*; import static org.mockito.Mockito.*;  import java.util.List;  import org.junit.Test; import org.mockito.InOrder;  @SuppressWarnings("unchecked") public class MultipleInOrdersTest {          @Test     public void inOrderTest(){         List list= mock(List.class);                  list.add("a");         list.add("x");         list.add("b");         list.add("y");                  InOrder inOrder = inOrder(list);         InOrder inAnotherOrder = inOrder(list);         assertNotSame(inOrder, inAnotherOrder);                  inOrder.verify(list).add("a");         inOrder.verify(list).add("b");                  inAnotherOrder.verify(list).add("x");         inAnotherOrder.verify(list).add("y");     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import static java.util.Collections.*; import static org.junit.Assert.*; import static org.mockito.Mockito.*;  import java.util.LinkedList; import java.util.List; import java.util.concurrent.Executor; import java.util.concurrent.Executors; import java.util.concurrent.RejectedExecutionException;  import org.junit.Before; import org.junit.Ignore; import org.junit.Test;  @Ignore public class MultithreadedStubbingHalfManualTest {      /**      * Class with two methods, one of them is repeatedly mocked while another is repeatedly called.      */     public interface ToMock {         public Integer getValue(Integer param);          public List<Integer> getValues(Integer param);     }      /**      * Thread pool for concurrent invocations.      */     private Executor executor;      private List exceptions = synchronizedList(new LinkedList());      @Before     public void setUp() {         this.executor = Executors.newSingleThreadExecutor();     }      /**      * The returned runnable simply calls ToMock.getValues(int).      *      * @param toMock The mocked object      * @return The runnable.      */     private Runnable getConflictingRunnable(final ToMock toMock) {         return new Runnable() {             public void run() {                 while (true) {                     try {                         Thread.sleep((long) (Math.random() * 10));                     } catch (InterruptedException e) {                     }                     if (!toMock.getValues(0).isEmpty()) {                         fail("Shouldn't happen, were just making sure it wasn't optimized away...");                     }                 }             }         };     }      @Test     //this problem shows at 4 out of 5 executions     //it is not strictly a bug because Mockito does not support simultanous stubbing (see FAQ)     //however I decided to synchronize some calls in order to make the exceptions nicer      public void tryToRevealTheProblem() {         ToMock toMock = mock(ToMock.class);         for (int i = 0; i < 100; i++) {             int j = i % 11;              // Repeated mocking             when(toMock.getValue(i)).thenReturn(j);             //TODO make it also showing errors for doReturn() //            doReturn(j).when(toMock).getValue(i);              while (true) {                 try {                     // Scheduling invocation                     this.executor.execute(getConflictingRunnable(toMock));                     break;                 } catch (RejectedExecutionException ex) {                     fail();                 }             }              try {                 Thread.sleep(10 / ((i % 10) + 1)); //NOPMD             } catch (InterruptedException e) {             }         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.junit.Test; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  //see issue 221 public class NPEOnAnyClassMatcherAutounboxTest extends TestBase {      interface Foo {         void bar(long id);     }      @Test     public void shouldNotThrowNPE() {         Foo f = mock(Foo.class);         f.bar(1);         verify(f).bar(any(Long.class));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class NPEWhenMockingThrowablesTest extends TestBase {      @Mock IMethods mock;     @Mock DummyException mock2;          class DummyException extends RuntimeException {         private static final long serialVersionUID = 1L;     }      //issue 70     @Test     public void shouldNotThrowNPE() {         when(mock.simpleMethod()).thenThrow(mock2);         try {             mock.simpleMethod();             fail();         } catch(DummyException e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import org.junit.After; import org.junit.Test; import org.mockito.Mock; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.never; import static org.mockito.Mockito.verify;  public class NPEWithCertainMatchersTest extends TestBase {      @Mock IMethods mock;          @After     public void clearState() {         this.resetState();     }      @Test     public void shouldNotThrowNPEWhenIntegerPassed() {         mock.intArgumentMethod(100);          verify(mock).intArgumentMethod(isA(Integer.class));     }      @Test     public void shouldNotThrowNPEWhenIntPassed() {         mock.intArgumentMethod(100);                  verify(mock).intArgumentMethod(isA(Integer.class));     }          @Test     public void shouldNotThrowNPEWhenIntegerPassedToEq() {         mock.intArgumentMethod(100);                  verify(mock).intArgumentMethod(eq(new Integer(100)));     }      @Test     public void shouldNotThrowNPEWhenIntegerPassedToSame() {         mock.intArgumentMethod(100);          verify(mock, never()).intArgumentMethod(same(new Integer(100)));     }      @Test(expected = AssertionError.class)     public void shouldNotThrowNPEWhenNullPassedToEq() {         mock.objectArgMethod("not null");          verify(mock).objectArgMethod(eq(null));     }      @Test(expected = AssertionError.class)     public void shouldNotThrowNPEWhenNullPassedToSame() {         mock.objectArgMethod("not null");          verify(mock).objectArgMethod(same(null));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import static org.mockito.Matchers.anyObject; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; import java.util.List; import org.fest.assertions.Assertions; import org.junit.Assume; import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.misusing.CannotStubVoidMethodWithReturnValue; import org.mockito.exceptions.misusing.InvalidUseOfMatchersException; import org.mockito.exceptions.misusing.MissingMethodInvocationException; import org.mockito.exceptions.misusing.UnfinishedVerificationException; import org.mockito.internal.configuration.plugins.Plugins; import org.mockito.internal.exceptions.MockitoLimitations; import org.mockitoutil.TestBase;  /**  * See bug 212  *  * Mocking methods that are declared on a non-public parent is not supported.  * We cannot really fail fast during mock creation because one might mock a method that is not declared on a parent - this would be valid.  */ public class ParentClassNotPublicTest extends TestBase {      class SuperClass {         public boolean isValid() {           return false;         }         public int arg(Object o) { return 0; }       }      public class ClassForMocking extends SuperClass {     }      @Before     public void only_if_CglibMockMaker() {         // CGLIB issue ; not reproducible with ByteBuddy         Assume.assumeTrue("CglibMockMaker".equals(Plugins.getMockMaker().getClass().getSimpleName()));     }      @Test     public void hints_that_parent_not_public_during_stubbing() throws Exception {         ClassForMocking clazzMock = mock(ClassForMocking.class);         try {             when(clazzMock.isValid()).thenReturn(true);             fail();         } catch (MissingMethodInvocationException e) {             Assertions.assertThat(e.getMessage())                     .contains(MockitoLimitations.NON_PUBLIC_PARENT);         }     }      @Test     public void hints_that_parent_not_public_during_stubbing_start() throws Exception {         ClassForMocking clazzMock = mock(ClassForMocking.class);         mock(List.class).clear();         try {             //Mockito thinks that we're stubbing void 'clear' method here and reports that boolean value cannot stub void method             when(clazzMock.isValid()).thenReturn(true);             fail();         } catch (CannotStubVoidMethodWithReturnValue e) {             Assertions.assertThat(e.getMessage())                     .contains(MockitoLimitations.NON_PUBLIC_PARENT);         }     }      @Test     public void hints_that_parent_not_public_during_verify() throws Exception {         ClassForMocking clazzMock = mock(ClassForMocking.class);         verify(clazzMock).isValid();         try {             //Since Mockito did not see 'isValid()' method, we will report unfinished verification             verify(clazzMock);             fail();         } catch (UnfinishedVerificationException e) {             Assertions.assertThat(e.getMessage())                     .contains(MockitoLimitations.NON_PUBLIC_PARENT);         }     }      @Test     public void hints_that_parent_not_public_when_misplaced_matchers_detected() throws Exception {         ClassForMocking clazzMock = mock(ClassForMocking.class);         try {             //Mockito does not see 'arg()' method so the anyObject() matcher is reported as misplaced             when(clazzMock.arg(anyObject())).thenReturn(0);             fail();         } catch (InvalidUseOfMatchersException e) {             Assertions.assertThat(e.getMessage())                     .contains(MockitoLimitations.NON_PUBLIC_PARENT);         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import org.junit.Before; import org.junit.Ignore; import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.MockitoAnnotations;  import static org.junit.Assert.assertNotNull;  // issue 229 : @Mock fields in super test class are not injected on @InjectMocks fields public class ParentTestMockInjectionTest {      @Test     public void injectMocksShouldInjectMocksFromTestSuperClasses() {         ImplicitTest it = new ImplicitTest();         MockitoAnnotations.initMocks(it);          assertNotNull(it.daoFromParent);         assertNotNull(it.daoFromSub);         assertNotNull(it.sut.daoFromParent);         assertNotNull(it.sut.daoFromSub);     }      @Ignore     public static abstract class BaseTest {         @Mock protected DaoA daoFromParent;     }      @Ignore("JUnit test under test : don't test this!")     public static class ImplicitTest extends BaseTest {         @InjectMocks private TestedSystem sut = new TestedSystem();          @Mock private DaoB daoFromSub;          @Before         public void setup() {             MockitoAnnotations.initMocks(this);         }          @Test         public void noNullPointerException() {             sut.businessMethod();         }     }      public static class TestedSystem {         private DaoA daoFromParent;         private DaoB daoFromSub;          public void businessMethod() {             daoFromParent.doQuery();             daoFromSub.doQuery();         }     }       public static class DaoA {         public void doQuery() { }     }      public static class DaoB {         public void doQuery() { }     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.Mock; import org.mockito.Spy; import org.mockitoutil.TestBase;  import java.util.LinkedList; import java.util.List; import java.util.Set;  import static org.mockito.Mockito.*;  //see issue 191 public class ShouldAllowInlineMockCreationTest extends TestBase {      @Mock List list;      @Test     public void shouldAllowInlineMockCreation() {         when(list.get(0)).thenReturn(mock(Set.class));         assertTrue(list.get(0) instanceof Set);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.junit.Test; import org.mockito.Mock; import org.mockitoutil.TestBase;  import java.util.Date; import java.util.List; import java.util.Set; import java.util.TreeSet;  import static org.mockito.Mockito.*;  //see issue 184 public class ShouldMocksCompareToBeConsistentWithEqualsTest extends TestBase {      @Test     public void should_compare_to_be_consistent_with_equals() {         //given         Date today    = mock(Date.class);         Date tomorrow = mock(Date.class);          //when         Set<Date> set = new TreeSet<Date>();         set.add(today);         set.add(tomorrow);          //then         assertEquals(2, set.size());     }      @Test     public void should_compare_to_be_consistent_with_equals_when_comparing_the_same_reference() {         //given         Date today    = mock(Date.class);          //when         Set<Date> set = new TreeSet<Date>();         set.add(today);         set.add(today);          //then         assertEquals(1, set.size());     }      @Test     public void should_allow_stubbing_and_verifying_compare_to() {         //given         Date mock    = mock(Date.class);         when(mock.compareTo(any(Date.class))).thenReturn(10);          //when         mock.compareTo(new Date());          //then         assertEquals(10, mock.compareTo(new Date()));         verify(mock, atLeastOnce()).compareTo(any(Date.class));     }      @Test     public void should_reset_not_remove_default_stubbing() {         //given         Date mock    = mock(Date.class);         reset(mock);          //then         assertEquals(1, mock.compareTo(new Date()));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.bugs;  import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger;  import org.junit.Assert; import org.junit.Test; import org.mockito.Mockito; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer;  //see bug 190 public class ShouldNotDeadlockAnswerExecutionTest {      @Test     public void failIfMockIsSharedBetweenThreads() throws Exception {         Service service = Mockito.mock(Service.class);         ExecutorService threads = Executors.newCachedThreadPool();         AtomicInteger counter = new AtomicInteger(2);          // registed answer on verySlowMethod          Mockito.when(service.verySlowMethod()).thenAnswer(new LockingAnswer(counter));          // execute verySlowMethod twice in separate threads          threads.execute(new ServiceRunner(service));         threads.execute(new ServiceRunner(service));          // waiting for threads to finish          threads.shutdown();          if (!threads.awaitTermination(1000, TimeUnit.MILLISECONDS)) {             // threads were timed-out             Assert.fail();         }     }      @Test     public void successIfEveryThreadHasItsOwnMock() {} // Defects4J: flaky method //     @Test //     public void successIfEveryThreadHasItsOwnMock() throws Exception { //         Service service1 = Mockito.mock(Service.class); //         Service service2 = Mockito.mock(Service.class); //         ExecutorService threads = Executors.newCachedThreadPool(); //         AtomicInteger counter = new AtomicInteger(2); //  //         // registed answer on verySlowMethod //  //         Mockito.when(service1.verySlowMethod()).thenAnswer(new LockingAnswer(counter)); //         Mockito.when(service2.verySlowMethod()).thenAnswer(new LockingAnswer(counter)); //  //         // execute verySlowMethod twice in separate threads //  //         threads.execute(new ServiceRunner(service1)); //         threads.execute(new ServiceRunner(service2)); //  //         // waiting for threads to finish //  //         threads.shutdown(); //  //         if (!threads.awaitTermination(500, TimeUnit.MILLISECONDS)) { //             // threads were timed-out //             Assert.fail(); //         } //     }      static class LockingAnswer implements Answer<String> {          private AtomicInteger counter;          public LockingAnswer(AtomicInteger counter) {             this.counter = counter;         }          /**          * Decrement counter and wait until counter has value 0          */         public String answer(InvocationOnMock invocation) throws Throwable {             counter.decrementAndGet();              while (counter.get() != 0) {                 Thread.sleep(10);             }              return null;         }      }      static class ServiceRunner implements Runnable {          private Service service;          public ServiceRunner(Service service) {             this.service = service;         }          public void run() {             service.verySlowMethod();         }      }      interface Service {          String verySlowMethod();      }  }  
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.Spy; import org.mockito.runners.MockitoJUnitRunner;  import java.util.*;  import static org.junit.Assert.assertNotNull; import static org.junit.Assert.assertNotSame; import static org.junit.Assert.assertThat; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when;  // issue 262 @RunWith(MockitoJUnitRunner.class) public class ShouldNotTryToInjectInFinalOrStaticFieldsTest {      public static class ExampleService {         public static final List<String> CONSTANTS = Arrays.asList("c1", "c1");         public final Set<String> aSet = new HashSet<String>();     }      @Spy private List<String> unrelatedList = new ArrayList<String>();     @Mock private Set<String> unrelatedSet;      @InjectMocks private ExampleService exampleService = new ExampleService();      @Test     public void dont_fail_with_CONSTANTS() throws Exception {     }      @Test     public void dont_inject_in_final() {         assertNotSame(unrelatedSet, exampleService.aSet);     }  }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.ArgumentCaptor; import org.mockito.Mock; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  //bug 197 public class ShouldOnlyModeAllowCapturingArgumentsTest extends TestBase {          @Mock IMethods mock;          @Test     public void shouldAllowCapturingArguments() {         //given         mock.simpleMethod("o");         ArgumentCaptor<String> arg = ArgumentCaptor.forClass(String.class);                  //when         verify(mock, only()).simpleMethod(arg.capture());          //then         assertEquals("o", arg.getValue());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.Spy; import org.mockitoutil.TestBase;  import java.util.LinkedList; import java.util.List;  import static org.mockito.Mockito.verify;  //see issue 216 public class SpyShouldHaveNiceNameTest extends TestBase {      @Spy List veryCoolSpy = new LinkedList();      @Test     public void shouldPrintNiceName() {         //when         veryCoolSpy.add(1);          try {             verify(veryCoolSpy).add(2);             fail();         } catch(AssertionError e) {             Assertions.assertThat(e.getMessage()).contains("veryCoolSpy");         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.junit.Test; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  //issue 151 public class StubbingMocksThatAreConfiguredToReturnMocksTest extends TestBase {      @Test     public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKS() {         IMethods mock = mock(IMethods.class, RETURNS_MOCKS);         when(mock.objectReturningMethodNoArgs()).thenReturn(null);     }      @Test     public void shouldAllowStubbingMocksConfiguredWithRETURNS_MOCKSWithDoApi() {         IMethods mock = mock(IMethods.class, RETURNS_MOCKS);         doReturn(null).when(mock).objectReturningMethodNoArgs();     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.misusing.FriendlyReminderException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  //see issue 235 @SuppressWarnings("deprecation") public class TimeoutWithAtMostOrNeverShouldBeDisabledTest extends TestBase {      @Mock IMethods mock;      @Test     public void shouldDisableTimeoutForAtMost() {         try {             verify(mock, timeout(30000).atMost(1)).simpleMethod();             fail();         } catch (FriendlyReminderException e) {}     }      @Test     public void shouldDisableTimeoutForNever() {         try {             verify(mock, timeout(30000).never()).simpleMethod();             fail();         } catch (FriendlyReminderException e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import org.junit.Test; import static org.mockito.Mockito.*; import org.mockitoutil.TestBase;  public class VarargsErrorWhenCallingRealMethodTest extends TestBase {      class Foo {         int blah(String a, String b, Object ... c) {             return 1;         }     }      @Test     public void shouldNotThrowAnyException() throws Exception {         Foo foo = mock(Foo.class);          when(foo.blah(anyString(), anyString())).thenCallRealMethod();          assertEquals(1, foo.blah("foo", "bar"));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.verification.NeverWantedButInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  //see bug 138 public class VerifyingWithAnExtraCallToADifferentMockTest extends TestBase {         @Mock IMethods mock;     @Mock IMethods mockTwo;          @Test      public void shouldAllowVerifyingWhenOtherMockCallIsInTheSameLine() {         //given         when(mock.otherMethod()).thenReturn("foo");                  //when         mockTwo.simpleMethod("foo");                  //then         verify(mockTwo).simpleMethod(mock.otherMethod());         try {             verify(mockTwo, never()).simpleMethod(mock.otherMethod());             fail();         } catch (NeverWantedButInvoked e) {}     } }
package org.mockitousage.bugs.deepstubs;  import org.junit.Test;  import static org.mockito.Mockito.RETURNS_DEEP_STUBS; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when;  public class DeepStubFailingWhenGenericNestedAsRawTypeTest {    interface MyClass1<MC2 extends MyClass2> {     MC2 getNested();   }    interface MyClass2<MC3 extends MyClass3> {     MC3 getNested();   }    interface MyClass3 {     String returnSomething();   }    @Test   public void discoverDeepMockingOfGenerics() {     MyClass1 myMock1 = mock(MyClass1.class, RETURNS_DEEP_STUBS);     when(myMock1.getNested().getNested().returnSomething()).thenReturn("Hello World.");   } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs.varargs;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockitoutil.TestBase;  public class VarargsAndAnyObjectPicksUpExtraInvocationsTest extends TestBase {     public interface TableBuilder {         void newRow(String trAttributes, String... cells);     }      @Mock     TableBuilder table;      @Test     public void shouldVerifyCorrectlyWithAnyVarargs() {         //when         table.newRow("qux", "foo", "bar", "baz");         table.newRow("abc", "def");                  //then         verify(table, times(2)).newRow(anyString(), (String[]) anyVararg());     }      @Test     public void shouldVerifyCorrectlyNumberOfInvocationsUsingAnyVarargAndEqualArgument() {         //when         table.newRow("x", "foo", "bar", "baz");         table.newRow("x", "def");          //then         verify(table, times(2)).newRow(eq("x"), (String[]) anyVararg());     }      @Test     public void shouldVerifyCorrectlyNumberOfInvocationsWithVarargs() {} // Defects4J: flaky method //     @Test //     public void shouldVerifyCorrectlyNumberOfInvocationsWithVarargs() { //         //when //         table.newRow("qux", "foo", "bar", "baz"); //         table.newRow("abc", "def"); //          //         //then //         verify(table).newRow(anyString(), eq("foo"), anyString(), anyString()); //         verify(table).newRow(anyString(), anyString()); //     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.bugs.varargs;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockitoutil.TestBase;  //see issue 62 public class VarargsNotPlayingWithAnyObjectTest extends TestBase {      interface VarargMethod {         Object run(String... args);     }          @Mock VarargMethod mock;      @Test     public void shouldMatchAnyVararg() {} // Defects4J: flaky method //     @Test //     public void shouldMatchAnyVararg() { //         mock.run("a", "b"); //  //         verify(mock).run(anyString(), anyString()); //         verify(mock).run((String) anyObject(), (String) anyObject()); //  //         verify(mock).run((String[]) anyVararg()); //          //         verify(mock, never()).run(); //         verify(mock, never()).run(anyString(), eq("f")); //     }      //we cannot use anyObject() for entire varargs because it makes the verification pick up extra invocations     //see other tests in this package     @Test     public void shouldNotAllowUsingAnyObjectForVarArgs() {         mock.run("a", "b");          try {             verify(mock).run((String[]) anyObject());             fail();         } catch (AssertionError e) {}     }      @Test     public void shouldStubUsingAnyVarargs() {         when(mock.run((String[]) anyVararg())).thenReturn("foo");                  assertEquals("foo", mock.run("a", "b"));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.configuration;   import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import static org.mockito.Mockito.mock; import java.util.concurrent.Callable; import org.fest.assertions.Condition; import org.junit.Assume; import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.internal.configuration.ConfigurationAccess; import org.mockito.internal.configuration.plugins.Plugins; import org.mockitoutil.SimplePerRealmReloadingClassLoader;  @SuppressWarnings("unchecked") public class ClassCacheVersusClassReloadingTest {     // TODO refactor to use ClassLoaders      private SimplePerRealmReloadingClassLoader testMethodClassLoaderRealm = new SimplePerRealmReloadingClassLoader(reloadMockito());      @Test     public void should_throw_ClassCastException_on_second_call() throws Exception {         Assume.assumeTrue("CglibMockMaker".equals(Plugins.getMockMaker().getClass().getSimpleName()));          doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");          try {             doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking");             fail("should have raised a ClassCastException when Objenesis Cache is enabled");         } catch (MockitoException e) {             assertThat(e.getMessage())                     .containsIgnoringCase("classloading")                     .containsIgnoringCase("objenesis")                     .containsIgnoringCase("MockitoConfiguration");             assertThat(e.getCause())                     .satisfies(thatCceIsThrownFrom("java.lang.Class.cast"))                     .satisfies(thatCceIsThrownFrom("org.mockito.internal.creation.cglib.ClassImposterizer.imposterise"));         }     }      @Test     public void should_not_throw_ClassCastException_when_objenesis_cache_disabled() {} // Defects4J: flaky method //     @Test //     public void should_not_throw_ClassCastException_when_objenesis_cache_disabled() throws Exception { //         prepareMockitoAndDisableObjenesisCache(); //  //         doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking"); //         doInNewChildRealm(testMethodClassLoaderRealm, "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking"); //     }      private Condition<Throwable> thatCceIsThrownFrom(final String stacktraceElementDescription) {         return new Condition<Throwable>() {             @Override             public boolean matches(Throwable throwable) {                 StackTraceElement[] stackTrace = throwable.getStackTrace();                 for (StackTraceElement stackTraceElement : stackTrace) {                     if (stackTraceElement.toString().contains(stacktraceElementDescription)) {                         return true;                     }                 }                  return false;             }         };     }      public static class DoTheMocking implements Callable {         public Object call() throws Exception {             Class clazz = this.getClass().getClassLoader().loadClass("org.mockitousage.configuration.ClassToBeMocked");             return mock(clazz);         }     }       private static void doInNewChildRealm(ClassLoader parentRealm, String callableCalledInClassLoaderRealm) throws Exception {         new SimplePerRealmReloadingClassLoader(parentRealm, reloadScope()).doInRealm(callableCalledInClassLoaderRealm);     }      private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadScope() {         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {             public boolean acceptReloadOf(String qualifiedName) {                 return "org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$DoTheMocking".equals(qualifiedName)                     || "org.mockitousage.configuration.ClassToBeMocked".equals(qualifiedName);             }         };     }      private void prepareMockitoAndDisableObjenesisCache() throws Exception {         testMethodClassLoaderRealm.doInRealm("org.mockitousage.configuration.ClassCacheVersusClassReloadingTest$PrepareMockito");     }      public static class PrepareMockito implements Callable {         public Object call() throws Exception {             Class.forName("org.mockito.Mockito");             ConfigurationAccess.getConfig().overrideEnableClassCache(false);             return Boolean.TRUE;         }     }      private static SimplePerRealmReloadingClassLoader.ReloadClassPredicate reloadMockito() {         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {             public boolean acceptReloadOf(String qualifiedName) {                 return (!qualifiedName.contains("net.bytebuddy") && qualifiedName.contains("org.mockito"));             }         };     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.configuration;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class CustomizedAnnotationForSmartMockTest extends TestBase {          @SmartMock IMethods smartMock;      @Test     public void shouldUseCustomAnnotation() {         assertEquals("SmartMock should return empty String by default", "", smartMock.simpleMethod(1));         verify(smartMock).simpleMethod(1);     } }
package org.mockitousage.constructor;  import static org.mockito.Mockito.CALLS_REAL_METHODS; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.spy; import static org.mockito.Mockito.when; import static org.mockito.Mockito.withSettings; import java.util.List; import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.mock.SerializableMode; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class CreatingMocksWithConstructorTest extends TestBase {      static abstract class AbstractMessage {         private final String message;         AbstractMessage() {             this.message = "hey!";         }         String getMessage() {             return message;         }     }      static class Message extends AbstractMessage {}     class InnerClass extends AbstractMessage {}      @Test     public void can_create_mock_with_constructor() {         Message mock = mock(Message.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));         //the message is a part of state of the mocked type that gets initialized in constructor         assertEquals("hey!", mock.getMessage());     }      @Test     public void can_mock_abstract_classes() {         AbstractMessage mock = mock(AbstractMessage.class, withSettings().useConstructor().defaultAnswer(CALLS_REAL_METHODS));         assertEquals("hey!", mock.getMessage());     }      @Test     public void can_spy_abstract_classes() {         AbstractMessage mock = spy(AbstractMessage.class);         assertEquals("hey!", mock.getMessage());     }      @Test     public void can_mock_inner_classes() {         InnerClass mock = mock(InnerClass.class, withSettings().useConstructor().outerInstance(this).defaultAnswer(CALLS_REAL_METHODS));         assertEquals("hey!", mock.getMessage());     }      static class HasConstructor {         HasConstructor(String x) {}     }      @Test     public void exception_message_when_constructor_not_found() {         try {             //when             spy(HasConstructor.class);             //then             fail();         } catch (MockitoException e) {             assertEquals("Unable to create mock instance of type 'HasConstructor'", e.getMessage());             assertContains("0-arg constructor", e.getCause().getMessage());         }     }      @Test     public void mocking_inner_classes_with_wrong_outer_instance() {         try {             //when             mock(InnerClass.class, withSettings().useConstructor().outerInstance("foo").defaultAnswer(CALLS_REAL_METHODS));             //then             fail();         } catch (MockitoException e) {             assertEquals("Unable to create mock instance of type 'InnerClass'", e.getMessage());             assertContains("Please ensure that the outer instance has correct type and that the target class has 0-arg constructor.", e.getCause().getMessage());         }     }      @Test     public void mocking_interfaces_with_constructor() {         //at the moment this is allowed however we can be more strict if needed         //there is not much sense in creating a spy of an interface         mock(IMethods.class, withSettings().useConstructor());         spy(IMethods.class);     }      @Test     public void prevents_across_jvm_serialization_with_constructor() {         try {             //when             mock(AbstractMessage.class, withSettings().useConstructor().serializable(SerializableMode.ACROSS_CLASSLOADERS));             //then             fail();         } catch (MockitoException e) {             assertEquals("Mocks instantiated with constructor cannot be combined with " + SerializableMode.ACROSS_CLASSLOADERS + " serialization mode.", e.getMessage());         }     }      static abstract class AbstractThing {         abstract String name();         String fullName() {             return "abstract " + name();         }     }      @Test     public void abstract_method_returns_default() {         AbstractThing thing = spy(AbstractThing.class);         assertEquals("abstract null", thing.fullName());     }      @Test     public void abstract_method_stubbed() {         AbstractThing thing = spy(AbstractThing.class);         when(thing.name()).thenReturn("me");         assertEquals("abstract me", thing.fullName());     }      @Test     public void calls_real_interface_method() {         List list = mock(List.class, withSettings().defaultAnswer(CALLS_REAL_METHODS));         assertNull(list.get(1));     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.customization;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.misusing.NotAMockException; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import org.mockitousage.IMethods; import org.mockitousage.MethodsImpl; import org.mockitoutil.TestBase;  import java.util.Set;  import static org.mockito.BDDMockito.*;  public class BDDMockitoTest extends TestBase {      @Mock IMethods mock;      @Test     public void shouldStub() throws Exception {         given(mock.simpleMethod("foo")).willReturn("bar");          assertEquals("bar", mock.simpleMethod("foo"));         assertEquals(null, mock.simpleMethod("whatever"));     }      @Test     public void shouldStubWithThrowable() throws Exception {         given(mock.simpleMethod("foo")).willThrow(new RuntimeException());          try {             assertEquals("foo", mock.simpleMethod("foo"));             fail();         } catch(RuntimeException e) {}     }      @Test     public void shouldStubWithThrowableClass() throws Exception {         given(mock.simpleMethod("foo")).willThrow(RuntimeException.class);          try {             assertEquals("foo", mock.simpleMethod("foo"));             fail();         } catch(RuntimeException e) {}     }      @Test     public void shouldStubWithAnswer() throws Exception {         given(mock.simpleMethod(anyString())).willAnswer(new Answer<String>() {             public String answer(InvocationOnMock invocation) throws Throwable {                 return (String) invocation.getArguments()[0];             }});          assertEquals("foo", mock.simpleMethod("foo"));     }      @Test     public void shouldStubWithWillAnswerAlias() throws Exception {         given(mock.simpleMethod(anyString())).will(new Answer<String>() {             public String answer(InvocationOnMock invocation) throws Throwable {                 return (String) invocation.getArguments()[0];             }});          assertEquals("foo", mock.simpleMethod("foo"));     }      @Test     public void shouldStubConsecutively() throws Exception {        given(mock.simpleMethod(anyString()))            .willReturn("foo")            .willReturn("bar");         assertEquals("foo", mock.simpleMethod("whatever"));        assertEquals("bar", mock.simpleMethod("whatever"));     }      @Test     public void shouldStubConsecutivelyWithCallRealMethod() throws Exception {         MethodsImpl mock = mock(MethodsImpl.class);         willReturn("foo").willCallRealMethod()                 .given(mock).simpleMethod();         assertEquals("foo", mock.simpleMethod());        assertEquals(null, mock.simpleMethod());     }      @Test     public void shouldStubVoid() throws Exception {         willThrow(new RuntimeException()).given(mock).voidMethod();          try {             mock.voidMethod();             fail();         } catch(RuntimeException e) {}     }      @Test     public void shouldStubVoidWithExceptionClass() throws Exception {         willThrow(RuntimeException.class).given(mock).voidMethod();          try {             mock.voidMethod();             fail();         } catch(RuntimeException e) {}     }      @Test     public void shouldStubVoidConsecutively() throws Exception {         willDoNothing()         .willThrow(new RuntimeException())         .given(mock).voidMethod();          mock.voidMethod();         try {             mock.voidMethod();             fail();         } catch(RuntimeException e) {}     }      @Test     public void shouldStubVoidConsecutivelyWithExceptionClass() throws Exception {         willDoNothing()         .willThrow(IllegalArgumentException.class)         .given(mock).voidMethod();          mock.voidMethod();         try {             mock.voidMethod();             fail();         } catch(IllegalArgumentException e) {}     }      @Test     public void shouldStubUsingDoReturnStyle() throws Exception {         willReturn("foo").given(mock).simpleMethod("bar");          assertEquals(null, mock.simpleMethod("boooo"));         assertEquals("foo", mock.simpleMethod("bar"));     }      @Test     public void shouldStubUsingDoAnswerStyle() throws Exception {         willAnswer(new Answer<String>() {             public String answer(InvocationOnMock invocation) throws Throwable {                 return (String) invocation.getArguments()[0];             }})         .given(mock).simpleMethod(anyString());          assertEquals("foo", mock.simpleMethod("foo"));     }      class Dog {         public String bark() {             return "woof";         }     }      @Test     public void shouldStubByDelegatingToRealMethod() throws Exception {         //given         Dog dog = mock(Dog.class);         //when         willCallRealMethod().given(dog).bark();         //then         assertEquals("woof", dog.bark());     }      @Test     public void shouldStubByDelegatingToRealMethodUsingTypicalStubbingSyntax() throws Exception {         //given         Dog dog = mock(Dog.class);         //when         given(dog.bark()).willCallRealMethod();         //then         assertEquals("woof", dog.bark());     }      @Test     public void shouldAllStubbedMockReferenceAccess() throws Exception {         Set expectedMock = mock(Set.class);          Set returnedMock = given(expectedMock.isEmpty()).willReturn(false).getMock();          assertEquals(expectedMock, returnedMock);     }      @Test(expected = NotAMockException.class)     public void shouldValidateMockWhenVerifying() {          then("notMock").should();     }      @Test(expected = NotAMockException.class)     public void shouldValidateMockWhenVerifyingWithExpectedNumberOfInvocations() {          then("notMock").should(times(19));     }      @Test(expected = NotAMockException.class)     public void shouldValidateMockWhenVerifyingNoMoreInteractions() {          then("notMock").should();     }      @Test(expected = WantedButNotInvoked.class)     public void shouldFailForExpectedBehaviorThatDidNotHappen() {          then(mock).should().booleanObjectReturningMethod();     }      @Test     public void shouldPassForExpectedBehaviorThatHappened() {          mock.booleanObjectReturningMethod();          then(mock).should().booleanObjectReturningMethod();     }      @Test     public void shouldPassFluentBddScenario() {          Bike bike = new Bike();         Person person = mock(Person.class);          person.ride(bike);         person.ride(bike);          then(person).should(times(2)).ride(bike);     }      static class Person {          void ride(Bike bike) {}     }      static class Bike {      } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.debugging;  import org.junit.Test; import org.mockito.InOrder; import org.mockito.invocation.DescribedInvocation; import org.mockito.listeners.InvocationListener; import org.mockito.listeners.MethodInvocationReport;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import static org.mockito.BDDMockito.given; import static org.mockito.BDDMockito.willReturn; import static org.mockito.Mockito.*;   /**  * Ensures that custom listeners can be registered and will be called every time  * a method on a mock is invoked.  */ public class InvocationListenerCallbackTest {      // Cannot use a mockito-mock here: during stubbing, the listener1 will be called     // and mockito will confuse the mocks.     private RememberingListener listener1 = new RememberingListener();     private RememberingListener listener2 = new RememberingListener();      @Test     public void should_call_single_listener_when_mock_return_normally() throws Exception {         // given         Foo foo = mock(Foo.class, withSettings().invocationListeners(listener1));         willReturn("basil").given(foo).giveMeSomeString("herb");          // when         foo.giveMeSomeString("herb");          // then         assertThatHasBeenNotified(listener1, "basil", getClass().getSimpleName());     }      @Test     public void should_call_all_listener_when_mock_return_normally() throws Exception {         // given         Foo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));         given(foo.giveMeSomeString("herb")).willReturn("rosemary");          // when         foo.giveMeSomeString("herb");          // then         assertThatHasBeenNotified(listener1, "rosemary", getClass().getSimpleName());         assertThatHasBeenNotified(listener2, "rosemary", getClass().getSimpleName());     }       @Test     public void should_call_all_listener_when_mock_throws_exception() throws Exception {         // given         InvocationListener listener1 = mock(InvocationListener.class, "listener1");         InvocationListener listener2 = mock(InvocationListener.class, "listener2");         Foo foo = mock(Foo.class, withSettings().invocationListeners(listener1, listener2));         doThrow(new OvenNotWorking()).when(foo).doSomething("cook");          // when         try {             foo.doSomething("cook");             fail("Exception expected.");         } catch (OvenNotWorking actualException) {             // then             InOrder orderedVerify = inOrder(listener1, listener2);             orderedVerify.verify(listener1).reportInvocation(any(MethodInvocationReport.class));             orderedVerify.verify(listener2).reportInvocation(any(MethodInvocationReport.class));         }     }      static class OvenNotWorking extends RuntimeException { }      private void assertThatHasBeenNotified(RememberingListener listener, Object returned, String location) {         assertThat(listener.returnValue).isEqualTo(returned);         assertThat(listener.invocation).isNotNull();         assertThat(listener.locationOfStubbing).contains(getClass().getSimpleName());     }      private static class RememberingListener implements InvocationListener {         DescribedInvocation invocation;         Object returnValue;         String locationOfStubbing;          public void reportInvocation(MethodInvocationReport mcr) {             this.invocation = mcr.getInvocation();             this.returnValue = mcr.getReturnedValue();             this.locationOfStubbing = mcr.getLocationOfStubbing();         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.debugging;  import static org.mockito.BDDMockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockitoutil.TestBase;  public class PrintingInvocationsDetectsUnusedStubTest extends TestBase {      @Mock Foo mock;     @Mock Foo mockTwo;      @Test     public void shouldDetectUnusedStubbingWhenPrinting() throws Exception {         //given         given(mock.giveMeSomeString("different arg")).willReturn("foo");         mock.giveMeSomeString("arg");          //when         String log = NewMockito.debug().printInvocations(mock, mockTwo);          //then         assertContainsIgnoringCase("unused", log);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.debugging;  import static org.mockito.BDDMockito.*;  import org.junit.After; import org.junit.Test; import org.mockito.Mock; import org.mockitoutil.TestBase;  public class PrintingInvocationsWhenEverythingOkTest extends TestBase {      @Mock Foo mock;     @Mock Foo mockTwo;      @Test     public void shouldPrintInvocationsWhenStubbingNotUsed() throws Exception {         //given         performStubbing();         //when         businessLogicWithAsking("arg");         //then         verify(mockTwo).doSomething("foo");     }      private void performStubbing() {         given(mock.giveMeSomeString("arg")).willReturn("foo");     }      private void businessLogicWithAsking(String name) {         String out = mock.giveMeSomeString(name);         businessLogicWithTelling(out);     }      private void businessLogicWithTelling(String out) {         mockTwo.doSomething(out);     }      @After     public void printInvocations() {         String log = NewMockito.debug().printInvocations(mock, mockTwo);         //asking         assertContains("giveMeSomeString(\"arg\")", log);         assertContains(".businessLogicWithAsking(", log);         //telling         assertContains("doSomething(\"foo\")", log);         assertContains(".businessLogicWithTelling(", log);         //stubbing         assertContains("giveMeSomeString(\"arg\")", log);         assertContains(".performStubbing(", log);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.debugging;  import org.junit.After; import org.junit.Test; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitoutil.TestBase;  import static org.mockito.BDDMockito.*;  public class PrintingInvocationsWhenStubNotUsedTest extends TestBase {      Foo mock = mock(Foo.class);     Foo mockTwo = mock(Foo.class);      @Test(expected = ArgumentsAreDifferent.class)     public void shouldPrintInvocationsWhenStubbingNotUsed() throws Exception {         //given         performStubbing();         //when         businessLogicWithAsking("arg");         //then         verify(mockTwo).doSomething("foo");     }      private void performStubbing() {         given(mock.giveMeSomeString("different arg")).willReturn("foo");     }      private void businessLogicWithAsking(String name) {         String out = mock.giveMeSomeString(name);         businessLogicWithTelling(out);     }      private void businessLogicWithTelling(String out) {         mockTwo.doSomething(out);     }      @After     public void printInvocations() {         String log = NewMockito.debug().printInvocations(mock, mockTwo);         //asking         assertContains("giveMeSomeString(\"arg\")", log);         assertContains(".businessLogicWithAsking(", log);         //telling         assertContains("doSomething(null)", log);         assertContains(".businessLogicWithTelling(", log);         //stubbing         assertContains("giveMeSomeString(\"different arg\")", log);         assertContains(".performStubbing(", log);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.debugging;  import static org.junit.Assert.fail; import static org.mockito.BDDMockito.given; import static org.mockito.Mockito.doCallRealMethod; import static org.mockito.Mockito.doThrow; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.withSettings; import java.io.ByteArrayOutputStream; import java.io.PrintStream; import org.fest.assertions.Assertions; import org.junit.After; import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.internal.util.MockUtil; import org.mockito.runners.MockitoJUnitRunner;  /**  * Tests the verbose logging of invocation on mock methods.  *   * BEWARE: These tests rely on mocking the standard output. While in a  * single-threaded environment the Before/After-contract ensures, that the  * original output stream is restored, there is no guarantee for this  * in the parallel setting.  * Maybe, the test class should be @Ignore'd by default ...  */ @RunWith(MockitoJUnitRunner.class) public class VerboseLoggingOfInvocationsOnMockTest {      private ByteArrayOutputStream output;     private PrintStream original;      @Mock UnrelatedClass unrelatedMock;      @Before     public void setUp() {         original = System.out;         output = new ByteArrayOutputStream();         System.setOut(new PrintStream(output));     }      @After     public void tearDown() {         System.setOut(original);     }      @Test     public void shouldNotPrintInvocationOnMockWithoutSetting() {         // given         Foo foo = mock(Foo.class, withSettings().verboseLogging());          // when         foo.giveMeSomeString("Klipsch");         unrelatedMock.unrelatedMethod("Apple");          // then         Assertions.assertThat(printed())                 .doesNotContain(mockName(unrelatedMock))                 .doesNotContain("unrelatedMethod")                 .doesNotContain("Apple");     }      @Test     public void shouldPrintUnstubbedInvocationOnMockToStdOut() {         // given         Foo foo = mock(Foo.class, withSettings().verboseLogging());          // when         foo.doSomething("Klipsch");          // then         Assertions.assertThat(printed())                 .contains(getClass().getName())                 .contains(mockName(foo))                 .contains("doSomething")                 .contains("Klipsch");     }      @Test     public void shouldPrintStubbedInvocationOnMockToStdOut() {         // given         Foo foo = mock(Foo.class, withSettings().verboseLogging());         given(foo.giveMeSomeString("Klipsch")).willReturn("earbuds");          // when         foo.giveMeSomeString("Klipsch");          // then         Assertions.assertThat(printed())                 .contains(getClass().getName())                 .contains(mockName(foo))                 .contains("giveMeSomeString")                 .contains("Klipsch")                 .contains("earbuds");     }      @Test     public void shouldPrintThrowingInvocationOnMockToStdOut() {         // given         Foo foo = mock(Foo.class, withSettings().verboseLogging());         doThrow(new ThirdPartyException()).when(foo).doSomething("Klipsch");          try {             // when             foo.doSomething("Klipsch");             fail("Exception excepted.");         } catch (ThirdPartyException e) {             // then             Assertions.assertThat(printed())                     .contains(getClass().getName())                     .contains(mockName(foo))                     .contains("doSomething")                     .contains("Klipsch")                     .contains(ThirdPartyException.class.getName());         }     }      @Test     public void shouldPrintRealInvocationOnSpyToStdOut() {         // given         FooImpl fooSpy = mock(FooImpl.class,                 withSettings().spiedInstance(new FooImpl()).verboseLogging());         doCallRealMethod().when(fooSpy).doSomething("Klipsch");                  // when         fooSpy.doSomething("Klipsch");                  // then         Assertions.assertThat(printed())                 .contains(getClass().getName())                 .contains(mockName(fooSpy))                 .contains("doSomething")                 .contains("Klipsch");     }      @Test     public void usage() {         // given         Foo foo = mock(Foo.class, withSettings().verboseLogging());         given(foo.giveMeSomeString("Apple")).willReturn(                 "earbuds");          // when         foo.giveMeSomeString("Shure");         foo.giveMeSomeString("Apple");         foo.doSomething("Klipsch");     }      private String printed() {         return output.toString();     }      private String mockName(Object mock) {         return new MockUtil().getMockName(mock).toString();     }      private static class UnrelatedClass {         void unrelatedMethod(String anotherStringValue) {         }     }      /**      * An exception that isn't defined by Mockito or the JDK and therefore does      * not appear in the logging result by chance alone.      */     static class ThirdPartyException extends RuntimeException {         private static final long serialVersionUID = 2160445705646210847L;     }      static class FooImpl implements Foo {         public String giveMeSomeString(String param) {             return null;         }          public void doSomething(String param) {         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.examples.use; import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.util.Arrays;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.runners.MockitoJUnitRunner; import org.mockitoutil.TestBase;  @RunWith(MockitoJUnitRunner.class) public class ExampleTest extends TestBase {          @Mock private ArticleCalculator mockCalculator;     @Mock private ArticleDatabase mockDatabase;          private ArticleManager articleManager;          @Before     public void setup() {         articleManager = new ArticleManager(mockCalculator, mockDatabase);     }      @Test     public void managerCountsArticlesAndSavesThemInTheDatabase() {         when(mockCalculator.countArticles("Guardian")).thenReturn(12);         when(mockCalculator.countArticlesInPolish(anyString())).thenReturn(5);          articleManager.updateArticleCounters("Guardian");                  verify(mockDatabase).updateNumberOfArticles("Guardian", 12);         verify(mockDatabase).updateNumberOfPolishArticles("Guardian", 5);         verify(mockDatabase).updateNumberOfEnglishArticles("Guardian", 7);     }          @Test     public void managerCountsArticlesUsingCalculator() {         articleManager.updateArticleCounters("Guardian");          verify(mockCalculator).countArticles("Guardian");         verify(mockCalculator).countArticlesInPolish("Guardian");     }          @Test     public void managerSavesArticlesInTheDatabase() {         articleManager.updateArticleCounters("Guardian");          verify(mockDatabase).updateNumberOfArticles("Guardian", 0);         verify(mockDatabase).updateNumberOfPolishArticles("Guardian", 0);         verify(mockDatabase).updateNumberOfEnglishArticles("Guardian", 0);     }          @Test     public void managerUpdatesNumberOfRelatedArticles() {         Article articleOne = new Article();         Article articleTwo = new Article();         Article articleThree = new Article();                  when(mockCalculator.countNumberOfRelatedArticles(articleOne)).thenReturn(1);         when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);         when(mockCalculator.countNumberOfRelatedArticles(articleThree)).thenReturn(0);                  when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo, articleThree));                   articleManager.updateRelatedArticlesCounters("Guardian");          verify(mockDatabase).save(articleOne);         verify(mockDatabase).save(articleTwo);         verify(mockDatabase).save(articleThree);     }          @Test     public void shouldPersistRecalculatedArticle() {         Article articleOne = new Article();         Article articleTwo = new Article();                  when(mockCalculator.countNumberOfRelatedArticles(articleOne)).thenReturn(1);         when(mockCalculator.countNumberOfRelatedArticles(articleTwo)).thenReturn(12);                  when(mockDatabase.getArticlesFor("Guardian")).thenReturn(Arrays.asList(articleOne, articleTwo));                   articleManager.updateRelatedArticlesCounters("Guardian");          InOrder inOrder = inOrder(mockDatabase, mockCalculator);                  inOrder.verify(mockCalculator).countNumberOfRelatedArticles((Article) anyObject());         inOrder.verify(mockDatabase, atLeastOnce()).save((Article) anyObject());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.internal.debugging;  import org.junit.Test; import org.mockito.internal.debugging.LocationImpl; import org.mockito.internal.exceptions.stacktrace.StackTraceFilter; import org.mockitoutil.TestBase;  @SuppressWarnings("serial") public class LocationImplTest extends TestBase {      @Test     public void shouldLocationNotContainGetStackTraceMethod() {         assertContains("shouldLocationNotContainGetStackTraceMethod", new LocationImpl().toString());     }      @Test     public void shouldBeSafeInCaseForSomeReasonFilteredStackTraceIsEmpty() {         //given         StackTraceFilter filterReturningEmptyArray = new StackTraceFilter() {             @Override             public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {                 return new StackTraceElement[0];             }         };          //when         String loc = new LocationImpl(filterReturningEmptyArray).toString();          //then         assertEquals("-> at <<unknown line>>", loc);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.internal.invocation.realmethod;  import static org.mockitoutil.ExtraMatchers.*;  import org.junit.Before; import org.junit.Test; import org.mockito.internal.invocation.realmethod.CleanTraceRealMethod; import org.mockito.internal.invocation.realmethod.RealMethod; import org.mockitoutil.TestBase;  public class CleanTraceRealMethodTest extends TestBase {      @Before     public void keepStackTracesClean() {         makeStackTracesClean();     }          class Foo {         public String throwSomething() {             throw new RuntimeException();         }     }          @Test     public void shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows() throws Throwable {         //given         CleanTraceRealMethod realMethod = new CleanTraceRealMethod(new RealMethod() {             public Object invoke(Object target, Object[] arguments) throws Throwable {                 return new Foo().throwSomething();             }});                  //when         try {             realMethod.invoke(null, null);             fail();         //then         } catch (Exception e) {             assertThat(e, hasMethodInStackTraceAt(0, "throwSomething"));             assertThat(e, hasMethodInStackTraceAt(1, "invoke"));             assertThat(e, hasMethodInStackTraceAt(2, "shouldRemoveMockitoInternalsFromStackTraceWhenRealMethodThrows"));         }     } }
package org.mockitousage.junitrule;  import org.junit.Rule; import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.MockitoJUnitRule;  import static org.junit.Assert.assertNotNull; import static org.mockitousage.junitrule.MockitoJUnitRuleTest.InjectInto; import static org.mockitousage.junitrule.MockitoJUnitRuleTest.Injected;  public class InvalidTargetMockitoJUnitRuleTest {      @Rule     public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule("asdf");      @Mock     private Injected injected;      @InjectMocks     private InjectInto injectInto;      @Test     public void shouldInjectWithInvalidReference() throws Exception {         assertNotNull("Mock created", injected);         assertNotNull("Test object created", injectInto);     } } 
package org.mockitousage.junitrule;  import org.junit.Rule; import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.MockitoJUnit; import org.mockito.junit.MockitoRule;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull;  public class MockitoJUnitRuleTest {      @Rule     public MockitoRule mockitoRule = MockitoJUnit.rule();      @Mock     private Injected injected;      @InjectMocks     private InjectInto injectInto;      @Test     public void testInjectMocks() throws Exception {         assertNotNull("Mock created", injected);         assertNotNull("Object created", injectInto);         assertEquals("A injected into B", injected, injectInto.getInjected());     }      public static class Injected {     }      public static class InjectInto {          private Injected injected;          public Injected getInjected() {             return injected;         }     } }
package org.mockitousage.junitrule;  import org.junit.Rule; import org.junit.Test; import org.junit.rules.MethodRule; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.MockitoJUnit; import org.mockito.junit.MockitoRule;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull;  public class RuleTestWithFactoryMethodTest {      @Rule     public MockitoRule mockitoRule = MockitoJUnit.rule();      @Mock     private Injected injected;      @InjectMocks     private InjectInto injectInto;      @Test     public void testInjectMocks() throws Exception {         assertNotNull("Mock created", injected);         assertNotNull("Object created", injectInto);         assertEquals("A injected into B", injected, injectInto.getInjected());      }      public static class Injected {     }      public static class InjectInto {          private Injected injected;          public Injected getInjected() {             return injected;         }     } }
package org.mockitousage.junitrule;  import org.junit.Rule; import org.junit.Test; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.junit.MockitoJUnitRule;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull;  public class RuleTestWithParameterConstructorTest {      @Rule     public MockitoJUnitRule mockitoJUnitRule = new MockitoJUnitRule(this);      @Mock     private Injected injected;      @InjectMocks     private InjectInto injectInto;      @Test     public void testInjectMocks() throws Exception {         assertNotNull("Mock created", injected);         assertNotNull("Object created", injectInto);         assertEquals("A injected into B", injected, injectInto.getInjected());      }      public static class Injected {     }      public static class InjectInto {          private Injected injected;          public Injected getInjected() {             return injected;         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.junitrunner;  import static org.junit.Assert.*; import static org.mockito.Mockito.*; import static org.mockitousage.junitrunner.Filters.*;  import java.util.List;  import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.runners.MockitoJUnit44Runner;  @RunWith(MockitoJUnit44Runner.class) @SuppressWarnings( { "unchecked", "deprecation" }) public class JUnit44RunnerTest {      @InjectMocks     private ListDependent listDependent = new ListDependent();      @Mock     private List list;      @Test     public void shouldInitMocksUsingRunner() {         list.add("test");         verify(list).add("test");     }     @Test     public void shouldInjectMocksUsingRunner() {         assertSame(list, listDependent.getList());     }      @Test     public void shouldFilterTestMethodsCorrectly() throws Exception{         MockitoJUnit44Runner runner = new MockitoJUnit44Runner(this.getClass());          runner.filter(methodNameContains("shouldInitMocksUsingRunner"));          assertEquals(1, runner.testCount());     }      class ListDependent {         private List list;          public List getList() {             return list;         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.junitrunner;  import static org.junit.Assert.*; import static org.mockito.Mockito.*; import static org.mockitousage.junitrunner.Filters.*;  import java.util.List;  import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InjectMocks; import org.mockito.Mock; import org.mockito.runners.MockitoJUnitRunner;  @RunWith(MockitoJUnitRunner.class) @SuppressWarnings("unchecked") public class JUnit45RunnerTest {      @InjectMocks private ListDependent listDependent = new ListDependent();     @Mock private List list;      @Test     public void shouldInitMocksUsingRunner() {         list.add("test");         verify(list).add("test");     }      @Test     public void shouldInjectMocksUsingRunner() {         assertNotNull(list);         assertSame(list, listDependent.getList());     }      @Test     public void shouldFilterTestMethodsCorrectly() throws Exception{         MockitoJUnitRunner runner = new MockitoJUnitRunner(this.getClass());          runner.filter(methodNameContains("shouldInitMocksUsingRunner"));          assertEquals(1, runner.testCount());     }      class ListDependent {         private List list;          public List getList() {             return list;         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.junitrunner;  import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Ignore; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.runners.VerboseMockitoJUnitRunner; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  //@RunWith(ConsoleSpammingMockitoJUnitRunner.class) @RunWith(VerboseMockitoJUnitRunner.class) @Ignore public class ModellingVerboseMockitoTest extends TestBase {          @Mock private IMethods mock;               @Before     public void cleanStackTraces() {         super.makeStackTracesClean();     }          @Test     public void shouldLogUnusedStubbingWarningWhenTestFails() throws Exception {         when(mock.simpleMethod(1)).thenReturn("foo");         when(mock.otherMethod()).thenReturn("foo");         when(mock.booleanObjectReturningMethod()).thenReturn(false);          //TODO: stubbed with those args here -> stubbed with certain args here          String ret = mock.simpleMethod(2);          assertEquals("foo", ret);         //TODO: should show message from actual failure not at the bottom but at least below 'the actual failure is ...'     }              @Test     public void shouldNotLogAnythingWhenNoWarnings() throws Exception {         //stub         when(mock.simpleMethod()).thenReturn("foo");         //use stub:         mock.simpleMethod();         //verify:         verify(mock).simpleMethod();         //should be no warnings:         fail();     }  //    @After //    public void checkStubs() { ////        stubsUsedIn(mock); //    } // //    private void stubsUsed(Object ... mocks) { // //    } // //    private void stubsUsed(Object testCaseOrMock) { // //    } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.junitrunner;  import junit.framework.TestCase; import org.junit.Ignore; import org.junit.Test; import org.junit.runner.JUnitCore; import org.junit.runner.Result; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.internal.exceptions.ExceptionIncludingMockitoWarnings; import org.mockito.runners.VerboseMockitoJUnitRunner; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  //@RunWith(ConsoleSpammingMockitoJUnitRunner.class) @RunWith(VerboseMockitoJUnitRunner.class) //TODO public class VerboseMockitoRunnerTest extends TestBase {          @Mock private IMethods mock;          public static class NoWarnings {                  @Test         @Ignore         public void test() {             IMethods mock = mock(IMethods.class);             mock.simpleMethod(1);             mock.otherMethod();                          verify(mock).simpleMethod(1);             throw new RuntimeException("boo");         }     }      public static class ContainsWarnings extends TestCase {                  public ContainsWarnings() {             super("test");         }          public void testIgnored() {}          public void _test() {             IMethods mock = mock(IMethods.class);                          //some stubbing             when(mock.simpleMethod(1)).thenReturn("foo");             when(mock.otherMethod()).thenReturn("foo");             when(mock.booleanObjectReturningMethod()).thenReturn(false);              //stub called with different args:             String ret = mock.simpleMethod(2);              //assertion fails due to stub called with different args             assertEquals("foo", ret);         }     }              public void cleanStackTraces() {         super.makeStackTracesClean();     }          @Test     @Ignore     public void shouldContainWarnings() throws Exception {         //when         Result result = new JUnitCore().run(new ContainsWarnings());         //then         assertEquals(1, result.getFailures().size());         Throwable exception = result.getFailures().get(0).getException();         assertTrue(exception instanceof ExceptionIncludingMockitoWarnings);             }      @Test     @Ignore     public void shouldNotContainWarnings() throws Exception {         Result result = new JUnitCore().run(NoWarnings.class);         assertEquals(1, result.getFailures().size());         assertEquals("boo", result.getFailures().get(0).getException().getMessage());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.matchers;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.Mockito; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class AnyXMatchersAcceptNullsTest extends TestBase {          private IMethods mock;      @Before     public void setUp() {         mock = Mockito.mock(IMethods.class);     }      @Test     public void shouldAcceptNullsInAnyMatcher() {         when(mock.oneArg(any())).thenReturn("matched");          assertEquals(null, mock.forObject(null));     }      @Test     public void shouldAcceptNullsInAnyObjectMatcher() {         when(mock.oneArg(anyObject())).thenReturn("matched");          assertEquals(null, mock.forObject(null));     }      @Test     public void shouldNotAcceptNullInAnyXMatchers() {         when(mock.oneArg(anyString())).thenReturn("0");         when(mock.forList(anyList())).thenReturn("1");         when(mock.forMap(anyMap())).thenReturn("2");         when(mock.forCollection(anyCollection())).thenReturn("3");         when(mock.forSet(anySet())).thenReturn("4");                  assertEquals(null, mock.oneArg((Object) null));         assertEquals(null, mock.oneArg((String) null));         assertEquals(null, mock.forList(null));         assertEquals(null, mock.forMap(null));         assertEquals(null, mock.forCollection(null));         assertEquals(null, mock.forSet(null));     }          @Test     public void shouldNotAcceptNullInAllAnyPrimitiveWrapperMatchers() {         when(mock.forInteger(anyInt())).thenReturn("0");         when(mock.forCharacter(anyChar())).thenReturn("1");         when(mock.forShort(anyShort())).thenReturn("2");         when(mock.forByte(anyByte())).thenReturn("3");         when(mock.forBoolean(anyBoolean())).thenReturn("4");         when(mock.forLong(anyLong())).thenReturn("5");         when(mock.forFloat(anyFloat())).thenReturn("6");         when(mock.forDouble(anyDouble())).thenReturn("7");                  assertEquals(null, mock.forInteger(null));         assertEquals(null, mock.forCharacter(null));         assertEquals(null, mock.forShort(null));         assertEquals(null, mock.forByte(null));         assertEquals(null, mock.forBoolean(null));         assertEquals(null, mock.forLong(null));         assertEquals(null, mock.forFloat(null));         assertEquals(null, mock.forDouble(null));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import org.junit.Assert; import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.ArgumentCaptor; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import java.util.ArrayList; import java.util.List;  import static org.mockito.Matchers.any; import static org.mockito.Matchers.eq; import static org.mockito.Mockito.*;  public class CapturingArgumentsTest extends TestBase {      class Person {          private final Integer age;          public Person(Integer age) {             this.age = age;         }          public int getAge() {             return age;         }     }      class BulkEmailService {          private EmailService service;          public BulkEmailService(EmailService service) {             this.service = service;         }          public void email(Integer ... personId) {             for (Integer i : personId) {                 Person person = new Person(i);                 service.sendEmailTo(person);             }         }     }      interface EmailService {         boolean sendEmailTo(Person person);     }      EmailService emailService = mock(EmailService.class);     BulkEmailService bulkEmailService = new BulkEmailService(emailService);     IMethods mock = mock(IMethods.class);      @SuppressWarnings("deprecation")     @Test     public void should_allow_assertions_on_captured_argument() {         //given         ArgumentCaptor<Person> argument = new ArgumentCaptor<Person>();          //when         bulkEmailService.email(12);          //then         verify(emailService).sendEmailTo(argument.capture());         assertEquals(12, argument.getValue().getAge());     }          @Test     public void should_allow_assertions_on_all_captured_arguments() {         //given         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);          //when         bulkEmailService.email(11, 12);          //then         verify(emailService, times(2)).sendEmailTo(argument.capture());         assertEquals(11, argument.getAllValues().get(0).getAge());         assertEquals(12, argument.getAllValues().get(1).getAge());     }          @Test     public void should_allow_assertions_on_last_argument() {         //given         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);          //when         bulkEmailService.email(11, 12, 13);          //then         verify(emailService, times(3)).sendEmailTo(argument.capture());         assertEquals(13, argument.getValue().getAge());     }          @Test     public void should_print_captor_matcher() {         //given         ArgumentCaptor<Person> person = ArgumentCaptor.forClass(Person.class);                  try {             //when             verify(emailService).sendEmailTo(person.capture());             fail();         } catch(WantedButNotInvoked e) {             //then             assertContains("<Capturing argument>", e.getMessage());         }     }          @Test     public void should_allow_assertions_on_captured_null() {         //given         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);          //when         emailService.sendEmailTo(null);          //then         verify(emailService).sendEmailTo(argument.capture());         assertEquals(null, argument.getValue());     }      @Test     public void should_allow_construction_of_captor_for_parameterized_type_in_a_convenient_way()  {         //the test passes if this expression compiles         ArgumentCaptor<List<Person>> argument = ArgumentCaptor.forClass(List.class);         assertNotNull(argument);     }      @Test     public void should_allow_construction_of_captor_for_a_more_specific_type()  {         //the test passes if this expression compiles         ArgumentCaptor<List> argument = ArgumentCaptor.forClass(ArrayList.class);         assertNotNull(argument);     }          @Test     public void should_allow_capturing_for_stubbing() {         //given         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);         when(emailService.sendEmailTo(argument.capture())).thenReturn(false);                  //when         emailService.sendEmailTo(new Person(10));                  //then         assertEquals(10, argument.getValue().getAge());     }          @Test     public void should_capture_when_stubbing_only_when_entire_invocation_matches() {         //given         ArgumentCaptor<String> argument = ArgumentCaptor.forClass(String.class);         when(mock.simpleMethod(argument.capture(), eq(2))).thenReturn("blah");                  //when         mock.simpleMethod("foo", 200);         mock.simpleMethod("bar", 2);                  //then         Assertions.assertThat(argument.getAllValues()).containsOnly("bar");     }          @Test     public void should_say_something_smart_when_misused() {         ArgumentCaptor<Person> argument = ArgumentCaptor.forClass(Person.class);         try {             argument.getValue();             fail();         } catch (MockitoException e) {             Assert.assertTrue(true);         }     }          @Test     public void should_capture_when_full_arg_list_matches() throws Exception {         //given         ArgumentCaptor<String> captor = ArgumentCaptor.forClass(String.class);          //when         mock.simpleMethod("foo", 1);         mock.simpleMethod("bar", 2);          //then         verify(mock).simpleMethod(captor.capture(), eq(1));         assertEquals(1, captor.getAllValues().size());         assertEquals("foo", captor.getValue());     }          @Test     public void should_capture_int_by_creating_captor_with_primitive_wrapper() {         //given         ArgumentCaptor<Integer> argument = ArgumentCaptor.forClass(Integer.class);          //when         mock.intArgumentMethod(10);                  //then         verify(mock).intArgumentMethod(argument.capture());         assertEquals(10, (int) argument.getValue());     }      @Test     public void should_capture_int_by_creating_captor_with_primitive() throws Exception {         //given         ArgumentCaptor<Integer> argument = ArgumentCaptor.forClass(int.class);                  //when         mock.intArgumentMethod(10);                  //then         verify(mock).intArgumentMethod(argument.capture());         assertEquals(10, (int) argument.getValue());     }      @Test     public void should_capture_byte_vararg_by_creating_captor_with_primitive() {} // Defects4J: flaky method //     @Test //     public void should_capture_byte_vararg_by_creating_captor_with_primitive() throws Exception { //         // given //         ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(byte.class); //  //         // when //         mock.varargsbyte((byte) 1, (byte) 2); //  //         // then //         verify(mock).varargsbyte(argumentCaptor.capture()); //         assertEquals((byte) 2, (byte) argumentCaptor.getValue()); //         Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1, (byte) 2); //     }      @Test     public void should_capture_byte_vararg_by_creating_captor_with_primitive_wrapper() {} // Defects4J: flaky method //     @Test //     public void should_capture_byte_vararg_by_creating_captor_with_primitive_wrapper() throws Exception { //         // given //         ArgumentCaptor<Byte> argumentCaptor = ArgumentCaptor.forClass(Byte.class); //  //         // when //         mock.varargsbyte((byte) 1, (byte) 2); //  //         // then //         verify(mock).varargsbyte(argumentCaptor.capture()); //         assertEquals((byte) 2, (byte) argumentCaptor.getValue()); //         Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly((byte) 1, (byte) 2); //     }      @Test     public void should_capture_vararg() {} // Defects4J: flaky method //     @Test //     public void should_capture_vararg() throws Exception { //         // given //         ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class); //  //         // when //         mock.mixedVarargs(42, "a", "b", "c"); //  //         // then //         verify(mock).mixedVarargs(any(), argumentCaptor.capture()); //         Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a", "b", "c"); //     }      @Test     public void should_capture_all_vararg() {} // Defects4J: flaky method //     @Test //     public void should_capture_all_vararg() throws Exception { //         // given //         ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class); //  //         // when //         mock.mixedVarargs(42, "a", "b", "c"); //         mock.mixedVarargs(42, "again ?!"); //  //         // then //         verify(mock, times(2)).mixedVarargs(any(), argumentCaptor.capture()); //  //         Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a", "b", "c", "again ?!"); //     }      @Test     public void should_capture_one_arg_even_when_using_vararg_captor_on_nonvararg_method() throws Exception {         // given         ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class);          // when         mock.simpleMethod("a", 2);          // then         verify(mock).simpleMethod(argumentCaptor.capture(), eq(2));         Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a");     }      @Test     public void captures_correctly_when_captor_used_multiple_times() {} // Defects4J: flaky method //     @Test //     public void captures_correctly_when_captor_used_multiple_times() throws Exception { //         // given //         ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class); //  //         // when //         mock.mixedVarargs(42, "a", "b", "c"); //  //         // then //         // this is only for backwards compatibility. It does not make sense in real to do so. //         verify(mock).mixedVarargs(any(), argumentCaptor.capture(), argumentCaptor.capture(), argumentCaptor.capture()); //         Assertions.assertThat(argumentCaptor.getAllValues()).containsExactly("a", "b", "c"); //     }      @Test     public void captures_correctly_when_captor_used_on_pure_vararg_method() {} // Defects4J: flaky method //     @Test //     public void captures_correctly_when_captor_used_on_pure_vararg_method() throws Exception { //         // given //         ArgumentCaptor<String> argumentCaptor = ArgumentCaptor.forClass(String.class); //  //         // when //         mock.varargs(42, "capturedValue"); //  //         // then //         verify(mock).varargs(eq(42), argumentCaptor.capture()); //         Assertions.assertThat(argumentCaptor.getValue()).contains("capturedValue"); //     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.matchers;  import static org.mockito.Matchers.argThat; import static org.mockito.Mockito.verify;  import org.junit.Test; import org.mockito.ArgumentMatcher; import org.mockito.Mock; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class CustomMatcherDoesYieldCCETest extends TestBase {      @Mock private IMethods mock;      @Test     public void shouldNotThrowCCE() {         mock.simpleMethod(new Object());          try {             // calling overloaded method so that matcher will be called with             // different type             verify(mock).simpleMethod(argThat(isStringWithTextFoo()));             fail();         } catch (ArgumentsAreDifferent e) {}     }      private ArgumentMatcher<String> isStringWithTextFoo() {         return new ArgumentMatcher<String>() {             @Override             public boolean matches(Object argument) {                 // casting that should not be thrown:                 String str = (String) argument;                 return str.equals("foo");             }         };     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.ArgumentMatcher; import org.mockito.Mockito; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class CustomMatchersTest extends TestBase {          private final class ContainsFoo extends ArgumentMatcher<String> {         public boolean matches(Object arg) {             return ((String) arg).contains("foo");         }     }      private final class IsAnyBoolean extends ArgumentMatcher<Boolean> {         public boolean matches(Object arg) {             return true;         }     }          private final class IsSorZ extends ArgumentMatcher<Character> {         public boolean matches(Object arg) {             Character character = (Character) arg;             return character.equals('s') || character.equals('z');         }     }      private final class IsZeroOrOne<T extends Number> extends ArgumentMatcher<T> {         public boolean matches(Object arg) {             Number number = (Number) arg;             if (number.intValue() == 0 || number.intValue() == 1) {                 return true;             }             return false;         }     }      private IMethods mock;      @Before     public void setUp() {         mock = Mockito.mock(IMethods.class);     }      @Test     public void shouldUseCustomBooleanMatcher() {         when(mock.oneArg(booleanThat(new IsAnyBoolean()))).thenReturn("foo");                  assertEquals("foo", mock.oneArg(true));         assertEquals("foo", mock.oneArg(false));                  assertEquals(null, mock.oneArg("x"));     }          @Test     public void shouldUseCustomCharMatcher() {         when(mock.oneArg(charThat(new IsSorZ()))).thenReturn("foo");                assertEquals("foo", mock.oneArg('s'));         assertEquals("foo", mock.oneArg('z'));         assertEquals(null, mock.oneArg('x'));     }          class Article {                  private int pageNumber;         private String headline;                  public Article(int pageNumber, String headline) {             super();             this.pageNumber = pageNumber;             this.headline = headline;         }          public int getPageNumber() {             return pageNumber;         }          public String getHeadline() {             return headline;         }     }          @Test     public void shouldUseCustomPrimitiveNumberMatchers() {         when(mock.oneArg(byteThat(new IsZeroOrOne<Byte>()))).thenReturn("byte");         when(mock.oneArg(shortThat(new IsZeroOrOne<Short>()))).thenReturn("short");         when(mock.oneArg(intThat(new IsZeroOrOne<Integer>()))).thenReturn("int");         when(mock.oneArg(longThat(new IsZeroOrOne<Long>()))).thenReturn("long");         when(mock.oneArg(floatThat(new IsZeroOrOne<Float>()))).thenReturn("float");         when(mock.oneArg(doubleThat(new IsZeroOrOne<Double>()))).thenReturn("double");                  assertEquals("byte", mock.oneArg((byte) 0));         assertEquals("short", mock.oneArg((short) 1));         assertEquals("int", mock.oneArg(0));         assertEquals("long", mock.oneArg(1L));         assertEquals("float", mock.oneArg(0F));         assertEquals("double", mock.oneArg(1.0));                  assertEquals(null, mock.oneArg(2));         assertEquals(null, mock.oneArg("foo"));     }               @Test     public void shouldUseCustomObjectMatcher() {         when(mock.oneArg(argThat(new ContainsFoo()))).thenReturn("foo");                  assertEquals("foo", mock.oneArg("foo"));         assertEquals(null, mock.oneArg("bar"));     }          @Test     public void shouldCustomMatcherPrintDescriptionBasedOnName() {         mock.simpleMethod("foo");          try {             verify(mock).simpleMethod(containsTest());             fail();         } catch (AssertionError e) {             assertContains("<String that contains xxx>", e.getMessage());         }     }      private String containsTest() {         return argThat(new StringThatContainsXxx());     }          private final class StringThatContainsXxx extends ArgumentMatcher<String> {         public boolean matches(Object argument) {             String arg = (String) argument;             return arg.contains("xxx");         }     }          @Test     public void shouldAnonymousCustomMatcherPrintDefaultDescription() {         mock.simpleMethod("foo");          try {             verify(mock).simpleMethod((String) argThat(new ArgumentMatcher<Object>() {                 @Override public boolean matches(Object argument) {                     return false;                 }}));             fail();         } catch (AssertionError e) {             assertContains("<custom argument matcher>", e.getMessage());             assertContains("foo", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.util.Date; import java.util.List;  import org.junit.Test; import org.mockito.Mock; import org.mockitoutil.TestBase;  public class GenericMatchersTest extends TestBase {          private interface Foo {         List<String> sort(List<String> otherList);         String convertDate(Date date);     }          @Mock Foo sorter;      @SuppressWarnings("unchecked")     @Test     public void shouldCompile() {         when(sorter.convertDate(new Date())).thenReturn("one");         when(sorter.convertDate((Date) anyObject())).thenReturn("two");          //following requires warning suppression but allows setting anyList()         when(sorter.sort(anyList())).thenReturn(null);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.hamcrest.BaseMatcher; import org.hamcrest.Description; import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class HamcrestMatchersTest extends TestBase {          private final class ContainsX extends BaseMatcher<String> {         public boolean matches(Object o) {             return ((String) o).contains("X");         }          public void describeTo(Description d) {             d.appendText("contains 'X'");         }     }      @Mock private IMethods mock;      @Test     public void shouldAcceptHamcrestMatcher() {         when(mock.simpleMethod(argThat(new ContainsX()))).thenReturn("X");         assertNull(mock.simpleMethod("blah"));         assertEquals("X", mock.simpleMethod("blah X blah"));     }          @Test     public void shouldVerifyUsingHamcrestMatcher() {         mock.simpleMethod("blah");                  try {             verify(mock).simpleMethod(argThat(new ContainsX()));             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("contains 'X'", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.AdditionalMatchers; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.exceptions.misusing.InvalidUseOfMatchersException; import org.mockito.runners.MockitoJUnitRunner; import org.mockitousage.IMethods;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import static org.mockito.Matchers.eq; import static org.mockito.Mockito.when;  @RunWith(MockitoJUnitRunner.class) public class InvalidUseOfMatchersTest {      @Mock private IMethods mock;      @Test     public void should_detect_wrong_number_of_matchers_when_stubbing() {         when(mock.threeArgumentMethod(1, "2", "3")).thenReturn(null);         try {             when(mock.threeArgumentMethod(1, eq("2"), "3")).thenReturn(null);             fail();         } catch (InvalidUseOfMatchersException e) {             assertThat(e.getMessage())                       .contains("3 matchers expected")                       .contains("1 recorded");         }     }      @Test     public void should_detect_stupid_use_of_matchers_when_verifying() {         mock.oneArg(true);         eq("that's the stupid way");         eq("of using matchers");         try {             Mockito.verify(mock).oneArg(true);             fail();         } catch (InvalidUseOfMatchersException e) {             assertThat(e.getMessage())                       .contains("Misplaced argument matcher detected here");             e.printStackTrace();         }     }      @Test     public void should_not_scream_on_correct_usage() throws Exception {         mock.simpleMethod(AdditionalMatchers.not(eq("asd")));         mock.simpleMethod(AdditionalMatchers.or(eq("jkl"), eq("asd")));     }      @Test     public void should_scream_when_no_matchers_inside_not() {         try {             mock.simpleMethod(AdditionalMatchers.not("jkl"));             fail();         } catch (InvalidUseOfMatchersException e) {             assertThat(e.getMessage())                     .contains("No matchers found for")                     .containsIgnoringCase("Not(?)");         }     }      @Test     public void should_scream_when_not_enough_matchers_inside_or_AddtionalMatcher() {         try {             mock.simpleMethod(AdditionalMatchers.or(eq("jkl"), "asd"));             fail();         } catch (InvalidUseOfMatchersException e) {             assertThat(e.getMessage())                     .containsIgnoringCase("inside additional matcher Or(?)")                     .contains("2 sub matchers expected")                     .contains("1 recorded");         }     }      @Test     public void should_scream_when_Matchers_count_dont_match_parameter_count() {         try {             mock.threeArgumentMethod(1, "asd", eq("asd"));             fail();         } catch (InvalidUseOfMatchersException e) {             assertThat(e.getMessage())                       .contains("3 matchers expected")                       .contains("1 recorded");         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Ignore; import org.junit.Test; import org.mockito.Mock; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class MatchersMixedWithRawArgumentsTest extends TestBase {          @Mock private IMethods mock;        //description of an idea:     //types of arguments and descriptor value that identifies matcher:     //Object: objenesis instance to check for identity     //boolean: false     //byte: max-1     //short: max-1     //int: max-1     //long: max-1     //char: 'x'     //double: max-1     //float: max-1          //1. how objenesis deal with primitive arrays (like byte[])?     //2. Analisys of all matchers used by R2 project finished before anyObject() and so far proves it's a good idea.      @Ignore("prototyping new feature that allows to avoid eq() matchers when raw args passed")     @Test     public void shouldAllowMixingRawArgumentsWithMatchers() {         mock.varargs("1", "2", "3");         verify(mock).varargs("1", anyString(), "3");                  verify(mock).varargs(anyBoolean(), false);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import static org.mockito.AdditionalMatchers.*; import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.math.BigDecimal; import java.util.HashMap; import java.util.List;  import org.junit.Before; import org.junit.Test; import org.mockito.Matchers; import org.mockito.Mockito; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;   @SuppressWarnings("unchecked") public class MatchersTest extends TestBase {     private IMethods mock;      @Before     public void setUp() {         mock = Mockito.mock(IMethods.class);     }      @Test     public void andOverloaded() {         when(mock.oneArg(and(eq(false), eq(false)))).thenReturn("0");         when(mock.oneArg(and(eq((byte) 1), eq((byte) 1)))).thenReturn("1");         when(mock.oneArg(and(eq('a'), eq('a')))).thenReturn("2");         when(mock.oneArg(and(eq((double) 1), eq((double) 1)))).thenReturn("3");         when(mock.oneArg(and(eq((float) 1), eq((float) 1)))).thenReturn("4");         when(mock.oneArg(and(eq((int) 1), eq((int) 1)))).thenReturn("5");         when(mock.oneArg(and(eq((long) 1), eq((long) 1)))).thenReturn("6");         when(mock.oneArg(and(eq((short) 1), eq((short) 1)))).thenReturn("7");         when(mock.oneArg(and(Matchers.contains("a"), Matchers.contains("d")))).thenReturn("8");         when(mock.oneArg(and(isA(Class.class), eq(Object.class)))).thenReturn("9");          assertEquals("0", mock.oneArg(false));         assertEquals(null, mock.oneArg(true));          assertEquals("1", mock.oneArg((byte) 1));         assertEquals("2", mock.oneArg('a'));         assertEquals("3", mock.oneArg((double) 1));         assertEquals("4", mock.oneArg((float) 1));         assertEquals("5", mock.oneArg((int) 1));         assertEquals("6", mock.oneArg((long) 1));         assertEquals("7", mock.oneArg((short) 1));          assertEquals("8", mock.oneArg("abcde"));         assertEquals(null, mock.oneArg("aaaaa"));          assertEquals("9", mock.oneArg(Object.class));     }          @Test     public void orOverloaded() {         when(mock.oneArg(or(eq(false), eq(true)))).thenReturn("0");         when(mock.oneArg(or(eq((byte) 1), eq((byte) 2)))).thenReturn("1");         when(mock.oneArg(or(eq((char) 1), eq((char) 2)))).thenReturn("2");         when(mock.oneArg(or(eq((double) 1), eq((double) 2)))).thenReturn("3");         when(mock.oneArg(or(eq((float) 1), eq((float) 2)))).thenReturn("4");         when(mock.oneArg(or(eq((int) 1), eq((int) 2)))).thenReturn("5");         when(mock.oneArg(or(eq((long) 1), eq((long) 2)))).thenReturn("6");         when(mock.oneArg(or(eq((short) 1), eq((short) 2)))).thenReturn("7");         when(mock.oneArg(or(eq("asd"), eq("jkl")))).thenReturn("8");         when(mock.oneArg(or(eq(this.getClass()), eq(Object.class)))).thenReturn("9");          assertEquals("0", mock.oneArg(true));         assertEquals("0", mock.oneArg(false));          assertEquals("1", mock.oneArg((byte) 2));         assertEquals("2", mock.oneArg((char) 1));         assertEquals("3", mock.oneArg((double) 2));         assertEquals("4", mock.oneArg((float) 1));         assertEquals("5", mock.oneArg((int) 2));         assertEquals("6", mock.oneArg((long) 1));         assertEquals("7", mock.oneArg((short) 1));          assertEquals("8", mock.oneArg("jkl"));         assertEquals("8", mock.oneArg("asd"));         assertEquals(null, mock.oneArg("asdjkl"));          assertEquals("9", mock.oneArg(Object.class));         assertEquals(null, mock.oneArg(String.class));     }      @Test     public void notOverloaded() {         when(mock.oneArg(not(eq(false)))).thenReturn("0");         when(mock.oneArg(not(eq((byte) 1)))).thenReturn("1");         when(mock.oneArg(not(eq('a')))).thenReturn("2");         when(mock.oneArg(not(eq((double) 1)))).thenReturn("3");         when(mock.oneArg(not(eq((float) 1)))).thenReturn("4");         when(mock.oneArg(not(eq((int) 1)))).thenReturn("5");         when(mock.oneArg(not(eq((long) 1)))).thenReturn("6");         when(mock.oneArg(not(eq((short) 1)))).thenReturn("7");         when(mock.oneArg(not(Matchers.contains("a")))).thenReturn("8");         when(mock.oneArg(not(isA(Class.class)))).thenReturn("9");          assertEquals("0", mock.oneArg(true));         assertEquals(null, mock.oneArg(false));          assertEquals("1", mock.oneArg((byte) 2));         assertEquals("2", mock.oneArg('b'));         assertEquals("3", mock.oneArg((double) 2));         assertEquals("4", mock.oneArg((float) 2));         assertEquals("5", mock.oneArg((int) 2));         assertEquals("6", mock.oneArg((long) 2));         assertEquals("7", mock.oneArg((short) 2));         assertEquals("8", mock.oneArg("bcde"));          assertEquals("9", mock.oneArg(new Object()));         assertEquals(null, mock.oneArg(Class.class));     }      @Test     public void lessOrEqualOverloaded() {         when(mock.oneArg(leq((byte) 1))).thenReturn("1");         when(mock.oneArg(leq((double) 1))).thenReturn("3");         when(mock.oneArg(leq((float) 1))).thenReturn("4");         when(mock.oneArg(leq((int) 1))).thenReturn("5");         when(mock.oneArg(leq((long) 1))).thenReturn("6");         when(mock.oneArg(leq((short) 1))).thenReturn("7");         when(mock.oneArg(leq(new BigDecimal("1")))).thenReturn("8");          assertEquals("1", mock.oneArg((byte) 1));         assertEquals(null, mock.oneArg((byte) 2));          assertEquals("3", mock.oneArg((double) 1));         assertEquals("7", mock.oneArg((short) 0));         assertEquals("4", mock.oneArg((float) -5));         assertEquals("5", mock.oneArg((int) -2));         assertEquals("6", mock.oneArg((long) -3));          assertEquals("8", mock.oneArg(new BigDecimal("0.5")));         assertEquals(null, mock.oneArg(new BigDecimal("1.1")));     }      @Test     public void lessThanOverloaded() {         when(mock.oneArg(lt((byte) 1))).thenReturn("1");         when(mock.oneArg(lt((double) 1))).thenReturn("3");         when(mock.oneArg(lt((float) 1))).thenReturn("4");         when(mock.oneArg(lt((int) 1))).thenReturn("5");         when(mock.oneArg(lt((long) 1))).thenReturn("6");         when(mock.oneArg(lt((short) 1))).thenReturn("7");         when(mock.oneArg(lt(new BigDecimal("1")))).thenReturn("8");          assertEquals("1", mock.oneArg((byte) 0));         assertEquals(null, mock.oneArg((byte) 1));          assertEquals("3", mock.oneArg((double) 0));         assertEquals("7", mock.oneArg((short) 0));         assertEquals("4", mock.oneArg((float) -4));         assertEquals("5", mock.oneArg((int) -34));         assertEquals("6", mock.oneArg((long) -6));          assertEquals("8", mock.oneArg(new BigDecimal("0.5")));         assertEquals(null, mock.oneArg(new BigDecimal("23")));     }      @Test     public void greaterOrEqualMatcherOverloaded() {         when(mock.oneArg(geq((byte) 1))).thenReturn("1");         when(mock.oneArg(geq((double) 1))).thenReturn("3");         when(mock.oneArg(geq((float) 1))).thenReturn("4");         when(mock.oneArg(geq((int) 1))).thenReturn("5");         when(mock.oneArg(geq((long) 1))).thenReturn("6");         when(mock.oneArg(geq((short) 1))).thenReturn("7");         when(mock.oneArg(geq(new BigDecimal("1")))).thenReturn("8");          assertEquals("1", mock.oneArg((byte) 2));         assertEquals(null, mock.oneArg((byte) 0));          assertEquals("3", mock.oneArg((double) 1));         assertEquals("7", mock.oneArg((short) 2));         assertEquals("4", mock.oneArg((float) 3));         assertEquals("5", mock.oneArg((int) 4));         assertEquals("6", mock.oneArg((long) 5));          assertEquals("8", mock.oneArg(new BigDecimal("1.00")));         assertEquals(null, mock.oneArg(new BigDecimal("0.9")));     }      @Test     public void greaterThanMatcherOverloaded() {         when(mock.oneArg(gt((byte) 1))).thenReturn("1");         when(mock.oneArg(gt((double) 1))).thenReturn("3");         when(mock.oneArg(gt((float) 1))).thenReturn("4");         when(mock.oneArg(gt((int) 1))).thenReturn("5");         when(mock.oneArg(gt((long) 1))).thenReturn("6");         when(mock.oneArg(gt((short) 1))).thenReturn("7");         when(mock.oneArg(gt(new BigDecimal("1")))).thenReturn("8");          assertEquals("1", mock.oneArg((byte) 2));         assertEquals(null, mock.oneArg((byte) 1));          assertEquals("3", mock.oneArg((double) 2));         assertEquals("7", mock.oneArg((short) 2));         assertEquals("4", mock.oneArg((float) 3));         assertEquals("5", mock.oneArg((int) 2));         assertEquals("6", mock.oneArg((long) 5));          assertEquals("8", mock.oneArg(new BigDecimal("1.5")));         assertEquals(null, mock.oneArg(new BigDecimal("0.9")));     }      @Test     public void compareToMatcher() {         when(mock.oneArg(cmpEq(new BigDecimal("1.5")))).thenReturn("0");          assertEquals("0", mock.oneArg(new BigDecimal("1.50")));         assertEquals(null, mock.oneArg(new BigDecimal("1.51")));     }          @Test     public void anyStringMatcher() {         when(mock.oneArg(anyString())).thenReturn("matched");                  assertEquals("matched", mock.oneArg(""));         assertEquals("matched", mock.oneArg("any string"));         assertEquals(null, mock.oneArg((String) null));     }      @Test     public void anyMatcher() {         when(mock.forObject(any())).thenReturn("matched");          assertEquals("matched", mock.forObject(123));         assertEquals("matched", mock.forObject("any string"));         assertEquals("matched", mock.forObject("any string"));         assertEquals("matched", mock.forObject((Object) null));     }      @Test     public void anyXMatcher() {         when(mock.oneArg(anyBoolean())).thenReturn("0");         when(mock.oneArg(anyByte())).thenReturn("1");         when(mock.oneArg(anyChar())).thenReturn("2");         when(mock.oneArg(anyDouble())).thenReturn("3");         when(mock.oneArg(anyFloat())).thenReturn("4");         when(mock.oneArg(anyInt())).thenReturn("5");         when(mock.oneArg(anyLong())).thenReturn("6");         when(mock.oneArg(anyShort())).thenReturn("7");         when(mock.oneArg((String) anyObject())).thenReturn("8");         when(mock.oneArg(anyObject())).thenReturn("9");                  assertEquals("0", mock.oneArg(true));         assertEquals("0", mock.oneArg(false));          assertEquals("1", mock.oneArg((byte) 1));         assertEquals("2", mock.oneArg((char) 1));         assertEquals("3", mock.oneArg((double) 1));         assertEquals("4", mock.oneArg((float) 889));         assertEquals("5", mock.oneArg((int) 1));         assertEquals("6", mock.oneArg((long) 1));         assertEquals("7", mock.oneArg((short) 1));         assertEquals("8", mock.oneArg("Test"));          assertEquals("9", mock.oneArg(new Object()));         assertEquals("9", mock.oneArg(new HashMap()));     }      @Test     public void shouldArrayEqualsDealWithNullArray() throws Exception {         Object[] nullArray = null;         when(mock.oneArray(aryEq(nullArray))).thenReturn("null");          assertEquals("null", mock.oneArray(nullArray));          mock = mock(IMethods.class);          try {             verify(mock).oneArray(aryEq(nullArray));             fail();         } catch (WantedButNotInvoked e) {             assertContains("oneArray(null)", e.getMessage());         }     }      @Test     public void shouldUseSmartEqualsForArrays() throws Exception {         //issue 143         mock.arrayMethod(new String[] {"one"});         verify(mock).arrayMethod(eq(new String[] {"one"}));         verify(mock).arrayMethod(new String[] {"one"});     }      @Test     public void shouldUseSmartEqualsForPrimitiveArrays() throws Exception {         //issue 143         mock.objectArgMethod(new int[] {1, 2});         verify(mock).objectArgMethod(eq(new int[] {1, 2}));         verify(mock).objectArgMethod(new int[] {1, 2});     }          @Test(expected=ArgumentsAreDifferent.class)     public void arrayEqualsShouldThrowArgumentsAreDifferentExceptionForNonMatchingArguments() {                 List list = Mockito.mock(List.class);                  list.add("test"); // testing fix for issue 20         list.contains(new Object[] {"1"});                  Mockito.verify(list).contains(new Object[] {"1", "2", "3"});         }      @Test     public void arrayEqualsMatcher() {         when(mock.oneArray(aryEq(new boolean[] { true, false, false }))).thenReturn("0");         when(mock.oneArray(aryEq(new byte[] { 1 }))).thenReturn("1");         when(mock.oneArray(aryEq(new char[] { 1 }))).thenReturn("2");         when(mock.oneArray(aryEq(new double[] { 1 }))).thenReturn("3");         when(mock.oneArray(aryEq(new float[] { 1 }))).thenReturn("4");         when(mock.oneArray(aryEq(new int[] { 1 }))).thenReturn("5");         when(mock.oneArray(aryEq(new long[] { 1 }))).thenReturn("6");         when(mock.oneArray(aryEq(new short[] { 1 }))).thenReturn("7");         when(mock.oneArray(aryEq(new String[] { "Test" }))).thenReturn("8");         when(mock.oneArray(aryEq(new Object[] { "Test", new Integer(4) }))).thenReturn("9");          assertEquals("0", mock.oneArray(new boolean[] { true, false, false }));         assertEquals("1", mock.oneArray(new byte[] { 1 }));         assertEquals("2", mock.oneArray(new char[] { 1 }));         assertEquals("3", mock.oneArray(new double[] { 1 }));         assertEquals("4", mock.oneArray(new float[] { 1 }));         assertEquals("5", mock.oneArray(new int[] { 1 }));         assertEquals("6", mock.oneArray(new long[] { 1 }));         assertEquals("7", mock.oneArray(new short[] { 1 }));         assertEquals("8", mock.oneArray(new String[] { "Test" }));         assertEquals("9", mock.oneArray(new Object[] { "Test", new Integer(4) }));          assertEquals(null, mock.oneArray(new Object[] { "Test", new Integer(999) }));         assertEquals(null, mock.oneArray(new Object[] { "Test", new Integer(4), "x" }));          assertEquals(null, mock.oneArray(new boolean[] { true, false }));         assertEquals(null, mock.oneArray(new boolean[] { true, true, false }));     }      @Test     public void greaterOrEqualMatcher() {         when(mock.oneArg(geq(7))).thenReturn(">= 7");         when(mock.oneArg(lt(7))).thenReturn("< 7");          assertEquals(">= 7", mock.oneArg(7));         assertEquals(">= 7", mock.oneArg(8));         assertEquals(">= 7", mock.oneArg(9));          assertEquals("< 7", mock.oneArg(6));         assertEquals("< 7", mock.oneArg(6));     }      @Test     public void greaterThanMatcher() {         when(mock.oneArg(gt(7))).thenReturn("> 7");         when(mock.oneArg(leq(7))).thenReturn("<= 7");          assertEquals("> 7", mock.oneArg(8));         assertEquals("> 7", mock.oneArg(9));         assertEquals("> 7", mock.oneArg(10));          assertEquals("<= 7", mock.oneArg(7));         assertEquals("<= 7", mock.oneArg(6));     }      @Test     public void lessOrEqualMatcher() {         when(mock.oneArg(leq(7))).thenReturn("<= 7");         when(mock.oneArg(gt(7))).thenReturn("> 7");          assertEquals("<= 7", mock.oneArg(7));         assertEquals("<= 7", mock.oneArg(6));         assertEquals("<= 7", mock.oneArg(5));          assertEquals("> 7", mock.oneArg(8));         assertEquals("> 7", mock.oneArg(9));     }      @Test     public void lessThanMatcher() {         when(mock.oneArg(lt(7))).thenReturn("< 7");         when(mock.oneArg(geq(7))).thenReturn(">= 7");          assertEquals("< 7", mock.oneArg(5));         assertEquals("< 7", mock.oneArg(6));         assertEquals("< 7", mock.oneArg(4));          assertEquals(">= 7", mock.oneArg(7));         assertEquals(">= 7", mock.oneArg(8));     }      @Test     public void orMatcher() {         when(mock.oneArg(anyInt())).thenReturn("other");         when(mock.oneArg(or(eq(7), eq(9)))).thenReturn("7 or 9");          assertEquals("other", mock.oneArg(10));         assertEquals("7 or 9", mock.oneArg(7));         assertEquals("7 or 9", mock.oneArg(9));     }      @Test     public void nullMatcher() {         when(mock.threeArgumentMethod(eq(1), isNull(), eq(""))).thenReturn("1");         when(mock.threeArgumentMethod(eq(1), not(isNull()), eq(""))).thenReturn("2");          assertEquals("1", mock.threeArgumentMethod(1, null, ""));         assertEquals("2", mock.threeArgumentMethod(1, new Object(), ""));     }      @Test     public void notNullMatcher() {         when(mock.threeArgumentMethod(eq(1), notNull(), eq(""))).thenReturn("1");         when(mock.threeArgumentMethod(eq(1), not(isNotNull()), eq(""))).thenReturn("2");          assertEquals("1", mock.threeArgumentMethod(1, new Object(), ""));         assertEquals("2", mock.threeArgumentMethod(1, null, ""));     }      @Test     public void findMatcher() {         when(mock.oneArg(find("([a-z]+)\\d"))).thenReturn("1");          assertEquals("1", mock.oneArg("ab12"));         assertEquals(null, mock.oneArg("12345"));         assertEquals(null, mock.oneArg((Object) null));     }      @Test     public void matchesMatcher() {         when(mock.oneArg(matches("[a-z]+\\d\\d"))).thenReturn("1");         when(mock.oneArg(matches("\\d\\d\\d"))).thenReturn("2");          assertEquals("1", mock.oneArg("a12"));         assertEquals("2", mock.oneArg("131"));         assertEquals(null, mock.oneArg("blah"));     }      @Test     public void containsMatcher() {         when(mock.oneArg(Matchers.contains("ell"))).thenReturn("1");         when(mock.oneArg(Matchers.contains("ld"))).thenReturn("2");          assertEquals("1", mock.oneArg("hello"));         assertEquals("2", mock.oneArg("world"));         assertEquals(null, mock.oneArg("xlx"));     }      @Test     public void startsWithMatcher() {         when(mock.oneArg(startsWith("ab"))).thenReturn("1");         when(mock.oneArg(startsWith("bc"))).thenReturn("2");          assertEquals("1", mock.oneArg("ab quake"));         assertEquals("2", mock.oneArg("bc quake"));         assertEquals(null, mock.oneArg("ba quake"));     }      @Test     public void endsWithMatcher() {         when(mock.oneArg(Matchers.endsWith("ab"))).thenReturn("1");         when(mock.oneArg(Matchers.endsWith("bc"))).thenReturn("2");          assertEquals("1", mock.oneArg("xab"));         assertEquals("2", mock.oneArg("xbc"));         assertEquals(null, mock.oneArg("ac"));     }      @Test     public void deltaMatcher() {         when(mock.oneArg(eq(1.0D, 0.1D))).thenReturn("1");         when(mock.oneArg(eq(2.0D, 0.1D))).thenReturn("2");         when(mock.oneArg(eq(1.0F, 0.1F))).thenReturn("3");         when(mock.oneArg(eq(2.0F, 0.1F))).thenReturn("4");         when(mock.oneArg(eq(2.0F, 0.1F))).thenReturn("4");          assertEquals("1", mock.oneArg(1.0));         assertEquals("1", mock.oneArg(0.91));         assertEquals("1", mock.oneArg(1.09));         assertEquals("2", mock.oneArg(2.0));          assertEquals("3", mock.oneArg(1.0F));         assertEquals("3", mock.oneArg(0.91F));         assertEquals("3", mock.oneArg(1.09F));         assertEquals("4", mock.oneArg(2.1F));          assertEquals(null, mock.oneArg(2.2F));     }          @Test     public void deltaMatcherPrintsItself() {         try {             verify(mock).oneArg(eq(1.0D, 0.1D));             fail();         } catch (WantedButNotInvoked e) {             assertContains("eq(1.0, 0.1)", e.getMessage());         }     }          @Test     public void sameMatcher() {         Object one = new String("1243");         Object two = new String("1243");         Object three = new String("1243");          assertNotSame(one, two);         assertEquals(one, two);         assertEquals(two, three);          when(mock.oneArg(same(one))).thenReturn("1");         when(mock.oneArg(same(two))).thenReturn("2");          assertEquals("1", mock.oneArg(one));         assertEquals("2", mock.oneArg(two));         assertEquals(null, mock.oneArg(three));     }      @Test     public void eqMatcherAndNulls() {         mock.simpleMethod((Object) null);          verify(mock).simpleMethod((Object) eq(null));     }      @Test     public void sameMatcherAndNulls() {         mock.simpleMethod((Object) null);          verify(mock).simpleMethod(same(null));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import org.junit.Test; import org.mockito.Mock; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import java.util.*;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when;  public class MoreMatchersTest extends TestBase {      @Mock private IMethods mock;      @Test     public void shouldHelpOutWithUnnecessaryCasting() {         when(mock.objectArgMethod(any(String.class))).thenReturn("string");          assertEquals("string", mock.objectArgMethod("foo"));     }      @Test     public void shouldAnyBeActualAliasToAnyObject() {         mock.simpleMethod((Object) null);          verify(mock).simpleMethod(anyObject());         verify(mock).simpleMethod(any(Object.class));     }      @Test     public void shouldHelpOutWithUnnecessaryCastingOfLists() {         //Below yields compiler warning:         //when(mock.listArgMethod(anyList())).thenReturn("list");         when(mock.listArgMethod(anyListOf(String.class))).thenReturn("list");          assertEquals("list", mock.listArgMethod(new LinkedList<String>()));         assertEquals("list", mock.listArgMethod(Collections.<String>emptyList()));     }      @Test     public void shouldHelpOutWithUnnecessaryCastingOfSets() {         //Below yields compiler warning:         //when(mock.setArgMethod(anySet())).thenReturn("set");         when(mock.setArgMethod(anySetOf(String.class))).thenReturn("set");          assertEquals("set", mock.setArgMethod(new HashSet<String>()));         assertEquals("set", mock.setArgMethod(Collections.<String>emptySet()));     }      @Test     public void shouldHelpOutWithUnnecessaryCastingOfMaps() {         //Below yields compiler warning:         //when(mock.setArgMethod(anySet())).thenReturn("set");         when(mock.forMap(anyMapOf(String.class, String.class))).thenReturn("map");          assertEquals("map", mock.forMap(new HashMap<String, String>()));         assertEquals("map", mock.forMap(Collections.<String, String>emptyMap()));     }      @Test     public void shouldHelpOutWithUnnecessaryCastingOfCollections() {         //Below yields compiler warning:         //when(mock.setArgMethod(anySet())).thenReturn("set");         when(mock.collectionArgMethod(anyCollectionOf(String.class))).thenReturn("col");          assertEquals("col", mock.collectionArgMethod(new ArrayList<String>()));         assertEquals("col", mock.collectionArgMethod(Collections.<String>emptyList()));     }      @Test     public void shouldHelpOutWithUnnecessaryCastingOfNullityChecks() {         when(mock.objectArgMethod(isNull(LinkedList.class))).thenReturn("string");         when(mock.objectArgMethod(notNull(LinkedList.class))).thenReturn("string");         when(mock.objectArgMethod(isNotNull(LinkedList.class))).thenReturn("string");          assertEquals("string", mock.objectArgMethod(null));         assertEquals("string", mock.objectArgMethod("foo"));         assertEquals("string", mock.objectArgMethod("foo"));     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.matchers;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.util.Arrays; import java.util.HashMap; import java.util.HashSet;  import org.junit.Before; import org.junit.Test; import org.mockito.Mockito; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class NewMatchersTest extends TestBase {          private IMethods mock;      @Before     public void setUp() {         mock = Mockito.mock(IMethods.class);     }      @Test     public void shouldAllowAnyList() {         when(mock.forList(anyList())).thenReturn("matched");                  assertEquals("matched", mock.forList(Arrays.asList("x", "y")));         assertEquals(null, mock.forList(null));          verify(mock, times(1)).forList(anyList());     }          @Test     public void shouldAllowAnyCollection() {         when(mock.forCollection(anyCollection())).thenReturn("matched");                  assertEquals("matched", mock.forCollection(Arrays.asList("x", "y")));         assertEquals(null, mock.forCollection(null));          verify(mock, times(1)).forCollection(anyCollection());     }          @Test     public void shouldAllowAnyMap() {         when(mock.forMap(anyMap())).thenReturn("matched");                  assertEquals("matched", mock.forMap(new HashMap<String, String>()));         assertEquals(null, mock.forMap(null));          verify(mock, times(1)).forMap(anyMap());     }          @Test     public void shouldAllowAnySet() {         when(mock.forSet(anySet())).thenReturn("matched");                  assertEquals("matched", mock.forSet(new HashSet<String>()));         assertEquals(null, mock.forSet(null));          verify(mock, times(1)).forSet(anySet());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitoutil.TestBase;  @SuppressWarnings("all") public class ReflectionMatchersTest extends TestBase {      class Parent {         private int parentField;         protected String protectedParentField;         public Parent(int parentField, String protectedParentField) {             this.parentField = parentField;             this.protectedParentField = protectedParentField;         }     }          class Child extends Parent {         private int childFieldOne;         private Object childFieldTwo;         public Child(int parentField, String protectedParentField, int childFieldOne, Object childFieldTwo) {             super(parentField, protectedParentField);             this.childFieldOne = childFieldOne;             this.childFieldTwo = childFieldTwo;         }      }          interface MockMe {         void run(Child child);     }          MockMe mock;          @Before     public void setup() {         mock = mock(MockMe.class);                  Child actual = new Child(1, "foo", 2, "bar");         mock.run(actual);     }          @Test     public void shouldMatchWhenFieldValuesEqual() throws Exception {         Child wanted = new Child(1, "foo", 2, "bar");         verify(mock).run(refEq(wanted));     }          @Test(expected=ArgumentsAreDifferent.class)     public void shouldNotMatchWhenFieldValuesDiffer() throws Exception {         Child wanted = new Child(1, "foo", 2, "bar XXX");         verify(mock).run(refEq(wanted));     }          @Test(expected=ArgumentsAreDifferent.class)     public void shouldNotMatchAgain() throws Exception {         Child wanted = new Child(1, "foo", 999, "bar");         verify(mock).run(refEq(wanted));     }          @Test(expected=ArgumentsAreDifferent.class)     public void shouldNotMatchYetAgain() throws Exception {         Child wanted = new Child(1, "XXXXX", 2, "bar");         verify(mock).run(refEq(wanted));     }          @Test(expected=ArgumentsAreDifferent.class)     public void shouldNotMatch() throws Exception {         Child wanted = new Child(234234, "foo", 2, "bar");         verify(mock).run(refEq(wanted));     }      @Test     public void shouldMatchWhenFieldValuesEqualWithOneFieldExcluded() throws Exception {         Child wanted = new Child(1, "foo", 2, "excluded");         verify(mock).run(refEq(wanted, "childFieldTwo"));     }      @Test     public void shouldMatchWhenFieldValuesEqualWithTwoFieldsExcluded() throws Exception {         Child wanted = new Child(234234, "foo", 2, "excluded");         verify(mock).run(refEq(wanted, "childFieldTwo", "parentField"));         verify(mock).run(refEq(wanted, "parentField", "childFieldTwo"));     }          @Test(expected=ArgumentsAreDifferent.class)     public void shouldNotMatchWithFieldsExclusion() throws Exception {         Child wanted = new Child(234234, "foo", 2, "excluded");         verify(mock).run(refEq(wanted, "childFieldTwo"));     }     }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.matchers;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class VerificationAndStubbingUsingMatchersTest extends TestBase {     private IMethods one;     private IMethods two;     private IMethods three;      @Before     public void setUp() {         one = mock(IMethods.class);         two = mock(IMethods.class);         three = mock(IMethods.class);     }          @Test     public void shouldStubUsingMatchers() {         when(one.simpleMethod(2)).thenReturn("2");         when(two.simpleMethod(anyString())).thenReturn("any");         when(three.simpleMethod(startsWith("test"))).thenThrow(new RuntimeException());          assertEquals(null, one.simpleMethod(1));         assertEquals("2", one.simpleMethod(2));                  assertEquals("any", two.simpleMethod("two"));         assertEquals("any", two.simpleMethod("two again"));                  assertEquals(null, three.simpleMethod("three"));         assertEquals(null, three.simpleMethod("three again"));                 try {             three.simpleMethod("test three again");             fail();         } catch (RuntimeException e) {}     }          @SuppressWarnings("deprecation")     @Test     public void shouldVerifyUsingMatchers() {         stubVoid(one).toThrow(new RuntimeException()).on().oneArg(true);         when(three.varargsObject(5, "first arg", "second arg")).thenReturn("stubbed");          try {             one.oneArg(true);             fail();         } catch (RuntimeException e) {}          one.simpleMethod(100);         two.simpleMethod("test Mockito");         three.varargsObject(10, "first arg", "second arg");                  assertEquals("stubbed", three.varargsObject(5, "first arg", "second arg"));          verify(one).oneArg(eq(true));         verify(one).simpleMethod(anyInt());         verify(two).simpleMethod(startsWith("test"));         verify(three).varargsObject(5, "first arg", "second arg");         verify(three).varargsObject(eq(10), eq("first arg"), startsWith("second"));                  verifyNoMoreInteractions(one, two, three);                  try {             verify(three).varargsObject(eq(10), eq("first arg"), startsWith("third"));             fail();         } catch (WantedButNotInvoked e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.misuse;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.misusing.MissingMethodInvocationException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class CleaningUpPotentialStubbingTest extends TestBase {      @Mock private IMethods mock;          @Test     public void shouldResetOngoingStubbingOnVerify() {         // first test         mock.booleanReturningMethod();         verify(mock).booleanReturningMethod();                  // second test         assertOngoingStubbingIsReset();     }      @Test     public void shouldResetOngoingStubbingOnInOrder() {         mock.booleanReturningMethod();         InOrder inOrder = inOrder(mock);         inOrder.verify(mock).booleanReturningMethod();         assertOngoingStubbingIsReset();     }          @Test     public void shouldResetOngoingStubbingOnDoReturn() {         mock.booleanReturningMethod();         doReturn(false).when(mock).booleanReturningMethod();         assertOngoingStubbingIsReset();     }      private void assertOngoingStubbingIsReset() {         try {             //In real, there might be a call to real object or a final method call             //I'm modelling it with null             when(null).thenReturn("anything");             fail();         } catch (MissingMethodInvocationException e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.misuse;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.misusing.NotAMockException; import org.mockito.exceptions.misusing.NullInsteadOfMockException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class DescriptiveMessagesOnMisuseTest extends TestBase {          @Mock private IMethods mock;          class Foo {         public final String finalMethod() {             return null;         }     }      @SuppressWarnings("all")     @Test     public void tryDescriptiveMessagesOnMisuse() {         Foo foo = mock(Foo.class);          //        when(foo.finalMethod()).thenReturn("foo"); //        doReturn("foo").when(foo).finalMethod(); //        verify(foo).finalMethod();          //        doReturn("foo"); //        doReturn("bar");          //        verifyNoMoreInteractions(); //        verifyNoMoreInteractions(null); //        verifyNoMoreInteractions(""); //        verifyZeroInteractions(); //        verifyZeroInteractions(null); //        verifyZeroInteractions(""); // //        inOrder(); //        inOrder(null); //        inOrder("test"); //        InOrder inOrder = inOrder(mock(List.class)); //        inOrder.verify(mock).simpleMethod();  //        verify(null); //        verify(mock.booleanReturningMethod());  //        verify(mock).varargs("test", anyString());  //        when("x").thenReturn("x");  //        when(mock.simpleMethod()); //        when(mock.differentMethod()).thenReturn("");     }           @Test(expected=NotAMockException.class)     public void shouldScreamWhenWholeMethodPassedToVerify() {         verify(mock.booleanReturningMethod());     }             @Test(expected=NotAMockException.class)     public void shouldScreamWhenWholeMethodPassedToVerifyNoMoreInteractions() {         verifyNoMoreInteractions(mock.byteReturningMethod());     }          @Test(expected=NotAMockException.class)     public void shouldScreamWhenInOrderCreatedWithDodgyMock() {         inOrder("not a mock");     }          @Test(expected=NullInsteadOfMockException.class)     public void shouldScreamWhenInOrderCreatedWithNulls() {         inOrder(mock, null);     }          @Test(expected=NullInsteadOfMockException.class)     public void shouldScreamNullPassedToVerify() {         verify(null);     }            @Test(expected=NullInsteadOfMockException.class)     public void shouldScreamWhenNotMockPassedToVerifyNoMoreInteractions() {         verifyNoMoreInteractions(null, "blah");     }           @SuppressWarnings("all")     @Test(expected=MockitoException.class)     public void shouldScreamWhenNullPassedToVerifyNoMoreInteractions() {         verifyNoMoreInteractions((Object[])null);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.misuse; import org.junit.Ignore; import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.misusing.MissingMethodInvocationException; import org.mockito.exceptions.misusing.UnfinishedVerificationException; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  public class DetectingFinalMethodsTest extends TestBase {          class WithFinal {         final int foo() {             return 0;         }     }          @Mock private WithFinal withFinal;      @Test     public void shouldFailWithUnfinishedVerification() {         withFinal = mock(WithFinal.class);         verify(withFinal).foo();         try {             verify(withFinal).foo();             fail();         } catch (UnfinishedVerificationException e) {}     }      @Test     @Ignore("Failed on check out")     public void shouldFailWithUnfinishedStubbing() {         withFinal = mock(WithFinal.class);         try {             when(withFinal.foo()).thenReturn(null);             fail();         } catch (MissingMethodInvocationException e) {}     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.misuse;  import static org.mockito.Matchers.anyBoolean; import static org.mockito.Matchers.anyInt; import static org.mockito.Matchers.anyObject; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.validateMockitoUsage; import static org.mockito.Mockito.verify; import java.util.Observer; import org.junit.After; import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.misusing.InvalidUseOfMatchersException; import org.mockito.exceptions.misusing.UnfinishedVerificationException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class DetectingMisusedMatchersTest extends TestBase {      class WithFinal {         final Object finalMethod(Object object) {             return null;         }     }      @Mock private WithFinal withFinal;          @After     public void resetState() {         super.resetState();     }      private void misplaced_anyObject_argument_matcher() {         anyObject();     }          private void misplaced_anyInt_argument_matcher() {         anyInt();     }          private void misplaced_anyBoolean_argument_matcher() {         anyBoolean();     }      @Test     public void should_fail_fast_when_argument_matchers_are_abused() {         misplaced_anyObject_argument_matcher();         try {             mock(IMethods.class);             fail();         } catch (InvalidUseOfMatchersException e) {             assertContains("Misplaced argument matcher", e.getMessage());         }     }          @Test     public void should_report_argument_locations_when_argument_matchers_misused() {         try {             Observer observer = mock(Observer.class);                          misplaced_anyInt_argument_matcher();             misplaced_anyObject_argument_matcher();             misplaced_anyBoolean_argument_matcher();                          observer.update(null, null);                          validateMockitoUsage();             fail();         } catch (InvalidUseOfMatchersException e) {             assertContains("DetectingMisusedMatchersTest.misplaced_anyInt_argument_matcher", e.getMessage());             assertContains("DetectingMisusedMatchersTest.misplaced_anyObject_argument_matcher", e.getMessage());             assertContains("DetectingMisusedMatchersTest.misplaced_anyBoolean_argument_matcher", e.getMessage());         }     }              @Test     public void shouldSayUnfinishedVerificationButNotInvalidUseOfMatchers() {         verify(withFinal).finalMethod(anyObject());         try {             verify(withFinal);             fail();         } catch (UnfinishedVerificationException e) {}     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.misuse;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.exceptions.misusing.InvalidUseOfMatchersException; import org.mockito.exceptions.misusing.UnfinishedStubbingException; import org.mockito.exceptions.misusing.UnfinishedVerificationException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class ExplicitFrameworkValidationTest extends TestBase {      @Mock IMethods mock;          @Test     public void shouldValidateExplicitly() {         verify(mock);         try {             Mockito.validateMockitoUsage();             fail();         } catch (UnfinishedVerificationException e) {}     }          @Test     public void shouldDetectUnfinishedStubbing() {         when(mock.simpleMethod());         try {             Mockito.validateMockitoUsage();             fail();         } catch (UnfinishedStubbingException e) {}     }          @Test     public void shouldDetectMisplacedArgumentMatcher() {         anyObject();         try {             Mockito.validateMockitoUsage();             fail();         } catch (InvalidUseOfMatchersException e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.misuse;  import org.junit.After; import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.misusing.MissingMethodInvocationException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  public class InvalidUsageTest extends TestBase {      @Mock private IMethods mock;     @Mock private IMethods mockTwo;      @After     public void resetState() {         super.resetState();     }          @Test(expected=MockitoException.class)     public void shouldRequireArgumentsWhenVerifyingNoMoreInteractions() {         verifyNoMoreInteractions();     }          @Test(expected=MockitoException.class)     public void shouldRequireArgumentsWhenVerifyingZeroInteractions() {         verifyZeroInteractions();     }          @Test(expected=MockitoException.class)     public void shouldNotCreateInOrderObjectWithoutMocks() {         inOrder();     }          @Test(expected=MockitoException.class)     public void shouldNotAllowVerifyingInOrderUnfamilarMocks() {         InOrder inOrder = inOrder(mock);         inOrder.verify(mockTwo).simpleMethod();     }          @Test(expected=MissingMethodInvocationException.class)     public void shouldReportMissingMethodInvocationWhenStubbing() {         when(mock.simpleMethod()).thenReturn("this stubbing is required to make sure Stubbable is pulled");         when("".toString()).thenReturn("x");     }          @Test(expected=MockitoException.class)     public void shouldNotAllowSettingInvalidCheckedException() throws Exception {         when(mock.simpleMethod()).thenThrow(new Exception());     }          @Test(expected=MockitoException.class)     public void shouldNotAllowSettingNullThrowable() throws Exception {         when(mock.simpleMethod()).thenThrow(new Throwable[] {null});     }          @SuppressWarnings("all")     @Test(expected=MockitoException.class)     public void shouldNotAllowSettingNullThrowableVararg() throws Exception {         when(mock.simpleMethod()).thenThrow((Throwable) null);     }          @Test(expected=MockitoException.class)     public void shouldNotAllowSettingNullConsecutiveThrowable() throws Exception {         when(mock.simpleMethod()).thenThrow(new RuntimeException(), null);     }              final class FinalClass {}          @Test(expected=MockitoException.class)     public void shouldNotAllowMockingFinalClasses() throws Exception {         mock(FinalClass.class);      }          @Test(expected=MockitoException.class)     public void shouldNotAllowMockingPrimitves() throws Exception {         mock(Integer.TYPE);      }          interface ObjectLikeInterface {         boolean equals(Object o);         String toString();         int hashCode();     }          @Test     public void shouldNotMockObjectMethodsOnInterface() throws Exception {         ObjectLikeInterface inter = mock(ObjectLikeInterface.class);                  inter.equals(null);         inter.toString();         inter.hashCode();                  verifyZeroInteractions(inter);     }          public void shouldNotMockObjectMethodsOnClass() throws Exception {         Object clazz = mock(ObjectLikeInterface.class);                  clazz.equals(null);         clazz.toString();         clazz.hashCode();                  verifyZeroInteractions(clazz);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.misuse;  import static org.mockito.Mockito.*;  import java.util.List;  import org.junit.After; import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class RestrictedObjectMethodsTest extends TestBase {      @Mock List mock;      @After     public void after() {         this.resetState();     }      @Test     public void shouldScreamWhenVerifyToString() {         try {             verify(mock).toString();             fail();         } catch (MockitoException e) {             assertContains("cannot verify", e.getMessage());         }     }      @Test     public void shouldBeSilentWhenVerifyHashCode() {         //because it leads to really wierd behavior sometimes         //it's because cglib & my code can occasionelly call those methods         // and when user has verification started at that time there will be a mess         verify(mock).hashCode();     }      @Test     public void shouldBeSilentWhenVerifyEquals() {         //because it leads to really wierd behavior sometimes         //it's because cglib & my code can occasionelly call those methods         // and when user has verification started at that time there will be a mess         verify(mock).equals(null);     }      @Test     public void shouldBeSilentWhenVerifyEqualsInOrder() {         //because it leads to really wierd behavior sometimes         //it's because cglib & my code can occasionelly call those methods         // and when user has verification started at that time there will be a mess         InOrder inOrder = inOrder(mock);         inOrder.verify(mock).equals(null);     }        }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.misuse;  import org.junit.Test; import org.mockito.exceptions.misusing.WrongTypeOfReturnValue;  import static org.junit.Assert.fail; import static org.fest.assertions.Assertions.assertThat; import static org.mockito.Mockito.*;  public class SpyStubbingMisuseTest {      @Test     public void nestedWhenTest() {         Strategy mfoo = mock(Strategy.class);         Sampler mpoo = mock(Sampler.class);         Producer out = spy(new Producer(mfoo));          try {             when(out.produce()).thenReturn(mpoo);             fail();         } catch (WrongTypeOfReturnValue e) {             assertThat(e.getMessage()).contains("spy").contains("syntax").contains("doReturn|Throw");         }     }      public class Sample { }      public class Strategy {         Sample getSample() {             return new Sample();         }     }      public class Sampler {         Sample sample;         Sampler(Strategy f) {             sample = f.getSample();         }     }      public class Producer {         Strategy strategy;         Producer(Strategy f) {             strategy = f;         }         Sampler produce() {             return new Sampler(strategy);         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.packageprotected;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockitoutil.TestBase;  public class MockingPackageProtectedTest extends TestBase {      static class Foo {};          class Bar {};          @Test     public void shouldMockPackageProtectedClasses() {         mock(PackageProtected.class);         mock(Foo.class);         mock(Bar.class);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.performance;  import static org.mockito.Mockito.*;  import java.util.LinkedList; import java.util.List;  import org.junit.Ignore; import org.junit.Test; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class LoadsOfMocksTest extends TestBase {      @Ignore("Use it for performance checks")     @Test     public void testSomething() {         List mocks = new LinkedList();         for (int i = 0; i < 50000; i++) {             System.out.println("Mock no: " + i);             IMethods mock = mock(IMethods.class);             mocks.add(mock);                          when(mock.simpleMethod(1)).thenReturn("one");             when(mock.simpleMethod(2)).thenReturn("two");                          assertEquals("one", mock.simpleMethod(1));             assertEquals("two", mock.simpleMethod(2));                          verify(mock).simpleMethod(1);             verify(mock).simpleMethod(2);         }     } }
package org.mockitousage.performance;  import org.junit.Ignore; import org.junit.Test;  import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; import static org.mockito.Mockito.withSettings;  public class StubOnlyAvoidMemoryConsumptionTest {      @Test     public void using_stub_only_wont_thrown_an_OutOfMemoryError() {         Object obj = mock(Object.class, withSettings().stubOnly());         when(obj.toString()).thenReturn("asdf");          for (int i = 0; i < 1000000; i++) {             obj.toString();         }     }      @Test     @Ignore("ignored because it will detonate our test suite with an OOM for real")     public void without_stub_only_mocks_will_store_invocations_leading_to_an_OutOfMemoryError() {         Object obj = mock(Object.class, withSettings());         when(obj.toString()).thenReturn("asdf");          for (int i = 0; i < 1000000; i++) {             obj.toString();         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.puzzlers;  import static org.mockito.Mockito.*; import static org.mockitoutil.ExtraMatchers.*;  import org.junit.Test; import org.mockitoutil.TestBase;  /**  * Bridge method is generated by compiler when erasure in parent class is  * different. When is different then it means that in runtime we will have  * overloading rather than overridding Therefore the compiler generates bridge  * method in Subclass so that erasures are the same, signatures of methods match  * and overridding is ON.  */ @SuppressWarnings("unchecked") public class BridgeMethodPuzzleTest extends TestBase {          private class Super<T> {         public String say(T t) {             return "Super says: " + t;         }     }          private class Sub extends Super<String> {         @Override         public String say(String t)  {             return "Dummy says: " + t;         }     }      Super mock;          private void setMockWithDownCast(Super mock) {         this.mock = mock;     }          private void say(String string) {         mock.say(string);     }          @Test     public void shouldHaveBridgeMethod() throws Exception {         Super s = new Sub();                  assertEquals("Dummy says: Hello", s.say("Hello"));                  assertThat(Sub.class, hasBridgeMethod("say"));         assertThat(s, hasBridgeMethod("say"));     }          @Test     public void shouldVerifyCorrectlyWhenBridgeMethodCalled() throws Exception {         //Super has following erasure: say(Object) which differs from Dummy.say(String)         //mock has to detect it and do the super.say()         Sub s = mock(Sub.class);         setMockWithDownCast(s);         say("Hello");                  verify(s).say("Hello");     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.puzzlers;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitoutil.TestBase;  public class OverloadingPuzzleTest extends TestBase {      private Super mock;      private void setMockWithDowncast(Super mock) {         this.mock = mock;     }      private interface Super {         void say(Object message);     }      private interface Sub extends Super {         void say(String message);     }      private void say(Object message) {         mock.say(message);     }      @Test     public void shouldUseArgumentTypeWhenOverloadingPuzzleDetected() throws Exception {         Sub sub = mock(Sub.class);         setMockWithDowncast(sub);         say("Hello");         try {             verify(sub).say("Hello");             fail();         } catch (WantedButNotInvoked e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.serialization;  import java.io.ByteArrayInputStream; import java.util.Collections; import java.util.List; import java.util.concurrent.Callable; import org.junit.Before; import org.junit.Test; import org.mockito.Mockito; import org.mockito.mock.SerializableMode; import org.mockitousage.IMethods; import org.mockitoutil.SimplePerRealmReloadingClassLoader; import org.mockitoutil.SimpleSerializationUtil;   public class AcrossClassLoaderSerializationTest {      public IMethods mock;      @Before     public void reproduce_CCE_by_creating_a_mock_with_IMethods_before() throws Exception {         mock = Mockito.mock(IMethods.class);     }      @Test     public void check_that_mock_can_be_serialized_in_a_classloader_and_deserialized_in_another() throws Exception {         byte[] bytes = create_mock_and_serialize_it_in_class_loader_A();          Object the_deserialized_mock = read_stream_and_deserialize_it_in_class_loader_B(bytes);     }      private Object read_stream_and_deserialize_it_in_class_loader_B(byte[] bytes) throws Exception {         return new SimplePerRealmReloadingClassLoader(this.getClass().getClassLoader(), isolating_test_classes())                 .doInRealm(                         "org.mockitousage.serialization.AcrossClassLoaderSerializationTest$ReadStreamAndDeserializeIt",                         new Class[]{ byte[].class },                         new Object[]{ bytes }                 );     }      private byte[] create_mock_and_serialize_it_in_class_loader_A() throws Exception {         return (byte[]) new SimplePerRealmReloadingClassLoader(this.getClass().getClassLoader(), isolating_test_classes())                 .doInRealm("org.mockitousage.serialization.AcrossClassLoaderSerializationTest$CreateMockAndSerializeIt");     }       private SimplePerRealmReloadingClassLoader.ReloadClassPredicate isolating_test_classes() {         return new SimplePerRealmReloadingClassLoader.ReloadClassPredicate() {             public boolean acceptReloadOf(String qualifiedName) {                 return qualifiedName.contains("org.mockitousage")                         || qualifiedName.contains("org.mockitoutil")                         ;             }         };     }       // see create_mock_and_serialize_it_in_class_loader_A     public static class CreateMockAndSerializeIt implements Callable<byte[]> {         public byte[] call() throws Exception {             AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito.mock(                     AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class,                     Mockito.withSettings().serializable(SerializableMode.ACROSS_CLASSLOADERS)             );             // use MethodProxy before             mock.returningSomething();              return SimpleSerializationUtil.serializeMock(mock).toByteArray();         }     }      // see read_stream_and_deserialize_it_in_class_loader_B     public static class ReadStreamAndDeserializeIt implements Callable<Object> {         private byte[] bytes;          public ReadStreamAndDeserializeIt(byte[] bytes) {             this.bytes = bytes;         }          public Object call() throws Exception {             ByteArrayInputStream to_unserialize = new ByteArrayInputStream(bytes);             return SimpleSerializationUtil.deserializeMock(                     to_unserialize,                     AClassToBeMockedInThisTestOnlyAndInCallablesOnly.class             );         }     }       public static class AClassToBeMockedInThisTestOnlyAndInCallablesOnly {         List returningSomething() { return Collections.emptyList(); }     } } 
package org.mockitousage.serialization;  import static org.fest.assertions.Assertions.assertThat; import static org.mockito.Mockito.RETURNS_DEEP_STUBS; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.when; import static org.mockito.Mockito.withSettings; import static org.mockitoutil.SimpleSerializationUtil.serializeAndBack;  import java.io.Serializable; import java.util.Iterator; import java.util.List; import org.junit.Test;  public class DeepStubsSerializableTest {      @Test     public void should_serialize_and_deserialize_mock_created_with_deep_stubs() throws Exception {         // given         SampleClass sampleClass = mock(SampleClass.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());         when(sampleClass.getSample().isFalse()).thenReturn(true);         when(sampleClass.getSample().number()).thenReturn(999);          // when         SampleClass deserializedSample = serializeAndBack(sampleClass);          // then         assertThat(deserializedSample.getSample().isFalse()).isEqualTo(true);         assertThat(deserializedSample.getSample().number()).isEqualTo(999);     }      @Test     public void should_serialize_and_deserialize_parameterized_class_mocked_with_deep_stubs() throws Exception {         // given         ListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());         when(deep_stubbed.iterator().next().add("yes")).thenReturn(true);          // when         ListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);                  // then         assertThat(deserialized_deep_stub.iterator().next().add("not stubbed but mock already previously resolved")).isEqualTo(false);         assertThat(deserialized_deep_stub.iterator().next().add("yes")).isEqualTo(true);     }      @Test(expected = ClassCastException.class)     public void should_discard_generics_metadata_when_serialized_then_disabling_deep_stubs_with_generics() throws Exception {         // given         ListContainer deep_stubbed = mock(ListContainer.class, withSettings().defaultAnswer(RETURNS_DEEP_STUBS).serializable());         when(deep_stubbed.iterator().hasNext()).thenReturn(true);          ListContainer deserialized_deep_stub = serializeAndBack(deep_stubbed);          // when stubbing on a deserialized mock         when(deserialized_deep_stub.iterator().next().get(42)).thenReturn("no");          // then revert to the default RETURNS_DEEP_STUBS and the code will raise a ClassCastException     }       static class SampleClass implements Serializable {         SampleClass2 getSample() { return new SampleClass2(); }     }      static class SampleClass2 implements Serializable {         boolean isFalse() { return false; }         int number() { return 100; }     }      static class Container<E> implements Iterable<E>, Serializable {         private E e;         public Container(E e) { this.e = e; }         public E get() { return e; }          public Iterator<E> iterator() {             return new Iterator<E>() {                 public boolean hasNext() { return true; }                 public E next() { return e; }                 public void remove() { }             };         }     }      static class ListContainer extends Container<List<String>> {         public ListContainer(List<String> list) { super(list); }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.serialization;  import org.junit.Test; import org.mockitousage.IMethods; import org.mockitoutil.SimpleSerializationUtil;  import java.nio.charset.CharacterCodingException; import java.util.ArrayList; import java.util.List; import java.util.Random; import java.util.concurrent.*;  import static org.mockito.Mockito.mock; import static org.mockito.Mockito.withSettings;  public class ParallelSerializationTest {      @Test     public void single_mock_being_serialized_in_different_classloaders_by_multiple_threads() throws ExecutionException, InterruptedException {         // given         int iterations = 2;         int threadingFactor = 200;         final ExecutorService executorService = Executors.newFixedThreadPool(threadingFactor);         final IMethods iMethods_that_store_invocations = mock(IMethods.class, withSettings().serializable());          // when         for (int i = 0; i <= iterations; i++) {             List<Future> futures = new ArrayList<Future>(threadingFactor);             final CyclicBarrier barrier_that_will_wait_until_threads_are_ready = new CyclicBarrier(threadingFactor);              // prepare all threads by submitting a callable             //  - that will serialize the mock a 'threadingFactor' times             //  - that will use the mock a 'threadingFactor' times             for (int j = 0; j < threadingFactor; j++) {                 // submit a callable that will serialize the mock 'iMethods'                 futures.add(executorService.submit(new Callable<Object>() {                     public Object call() throws Exception {                         barrier_that_will_wait_until_threads_are_ready.await();                          randomCallOn(iMethods_that_store_invocations);                          return SimpleSerializationUtil.serializeMock(iMethods_that_store_invocations).toByteArray();                     }                 }));                  // submit a callable that will only use the mock 'iMethods'                 executorService.submit(new Callable<Object>() {                     public Object call() throws Exception {                         barrier_that_will_wait_until_threads_are_ready.await();                         return iMethods_that_store_invocations.longObjectReturningMethod();                     }                 });             }              // ensure we are getting the futures             for (Future future : futures) {                 future.get();             }         }     }      private void randomCallOn(IMethods iMethods) throws CharacterCodingException {         int random = new Random().nextInt(10);         switch (random) {             case 0 : iMethods.arrayReturningMethod(); break;             case 1 : iMethods.longObjectReturningMethod(); break;             case 2 : iMethods.linkedListReturningMethod(); break;             case 3 : iMethods.iMethodsReturningMethod(); break;             case 4 : iMethods.canThrowException(); break;             case 5 : iMethods.differentMethod(); break;             case 6 : iMethods.voidMethod(); break;             case 7 : iMethods.varargsString(1, ""); break;             case 8 : iMethods.forMap(null); break;             case 9 : iMethods.throwsNothing(false); break;             default:         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.spies;  import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockitoutil.ExtraMatchers; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class PartialMockingWithSpiesTest extends TestBase {      @Before     public void pleaseMakeStackTracesClean() {         makeStackTracesClean();     }          class InheritMe {         private String inherited = "100$";         protected String getInherited() {             return inherited;         }     }          class Person extends InheritMe {         private final Name defaultName = new Name("Default name");          public String getName() {             return guessName().name;         }          Name guessName() {             return defaultName;         }                  public String howMuchDidYouInherit() {             return getInherited();         }                  public String getNameButDelegateToMethodThatThrows() {             throwSomeException();             return guessName().name;         }          private void throwSomeException() {             throw new RuntimeException("boo");         }     }          class Name {         private final String name;          public Name(String name) {             this.name = name;         }     }      Person spy = spy(new Person());      @Test     public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod() {         // when         String name = spy.getName();          // then         assertEquals("Default name", name);     }          @Test     public void shouldAllowStubbingOfMethodsThatDelegateToOtherMethods() {         // when         when(spy.getName()).thenReturn("foo");                  // then         assertEquals("foo", spy.getName());     }      @Test     public void shouldAllowStubbingWithThrowablesMethodsThatDelegateToOtherMethods() {         // when         doThrow(new RuntimeException("appetite for destruction"))             .when(spy).getNameButDelegateToMethodThatThrows();                  // then         try {             spy.getNameButDelegateToMethodThatThrows();             fail();         } catch(Exception e) {             assertEquals("appetite for destruction", e.getMessage());         }     }          @Test     public void shouldStackTraceGetFilteredOnUserExceptions() {         try {             // when             spy.getNameButDelegateToMethodThatThrows();             fail();         } catch (Throwable t) {             // then             assertThat(t, ExtraMatchers.hasMethodsInStackTrace(                     "throwSomeException",                     "getNameButDelegateToMethodThatThrows",                     "shouldStackTraceGetFilteredOnUserExceptions"                     ));         }     }  //    @Test //manual verification     public void verifyTheStackTrace() {         spy.getNameButDelegateToMethodThatThrows();     }      @Test     public void shouldVerify() {         // when         spy.getName();          // then         verify(spy).guessName();     }      @Test     public void shouldStub() {         // given         when(spy.guessName()).thenReturn(new Name("John"));         // when         String name = spy.getName();         // then         assertEquals("John", name);     }          @Test     public void shouldDealWithPrivateFieldsOfSubclasses() {         assertEquals("100$", spy.howMuchDidYouInherit());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.spies;  import static org.mockito.Mockito.*;  import java.util.List;  import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import org.mockitoutil.TestBase;  @SuppressWarnings({"unchecked"}) public class SpyingOnInterfacesTest extends TestBase {      @Test     public void shouldFailFastWhenCallingRealMethodOnInterface() throws Exception {         List list = mock(List.class);         try {             //when             when(list.get(0)).thenCallRealMethod();             //then             fail();         } catch (MockitoException e) {}     }          @Test     public void shouldFailInRuntimeWhenCallingRealMethodOnInterface() throws Exception {         //given         List list = mock(List.class);         when(list.get(0)).thenAnswer(             new Answer() {                 public Object answer(InvocationOnMock invocation) throws Throwable {                     return invocation.callRealMethod();                 }             }         );         try {             //when             list.get(0);                         //then             fail();         } catch (MockitoException e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.spies;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.util.Arrays; import java.util.LinkedList; import java.util.List;  import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mockito; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.TooLittleActualInvocations; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class SpyingOnRealObjectsTest extends TestBase {      List list = new LinkedList();     List spy = Mockito.spy(list);          @Test     public void shouldVerify() {         spy.add("one");         spy.add("two");          assertEquals("one", spy.get(0));         assertEquals("two", spy.get(1));          verify(spy).add("one");         verify(spy).add("two");     }      @Test     public void shouldBeAbleToMockObjectBecauseWhyNot() {         spy(new Object());     }          @Test     public void shouldStub() {         spy.add("one");         when(spy.get(0))             .thenReturn("1")             .thenReturn("1 again");                         assertEquals("1", spy.get(0));         assertEquals("1 again", spy.get(0));         assertEquals("one", spy.iterator().next());                  assertEquals(1, spy.size());     }          @Test     public void shouldAllowOverridingStubs() {         when(spy.contains(anyObject())).thenReturn(true);         when(spy.contains("foo")).thenReturn(false);                  assertTrue(spy.contains("bar"));         assertFalse(spy.contains("foo"));     }          @SuppressWarnings("deprecation")     @Test     public void shouldStubVoid() {         stubVoid(spy)             .toReturn()             .toThrow(new RuntimeException())             .on().clear();          spy.add("one");         spy.clear();         try {             spy.clear();             fail();         } catch (RuntimeException e) {}                      assertEquals(1, spy.size());     }          @Test     public void shouldStubWithDoReturnAndVerify() {         doReturn("foo")         .doReturn("bar")         .when(spy).get(0);                  assertEquals("foo", spy.get(0));         assertEquals("bar", spy.get(0));                  verify(spy, times(2)).get(0);         verifyNoMoreInteractions(spy);     }          @Test     public void shouldVerifyInOrder() {         spy.add("one");         spy.add("two");                  InOrder inOrder = inOrder(spy);         inOrder.verify(spy).add("one");         inOrder.verify(spy).add("two");                  verifyNoMoreInteractions(spy);     }          @Test     public void shouldVerifyInOrderAndFail() {         spy.add("one");         spy.add("two");                  InOrder inOrder = inOrder(spy);         inOrder.verify(spy).add("two");         try {             inOrder.verify(spy).add("one");             fail();         } catch (VerificationInOrderFailure f) {}     }          @Test     public void shouldVerifyNumberOfTimes() {         spy.add("one");         spy.add("one");                  verify(spy, times(2)).add("one");         verifyNoMoreInteractions(spy);     }          @Test     public void shouldVerifyNumberOfTimesAndFail() {         spy.add("one");         spy.add("one");                  try {             verify(spy, times(3)).add("one");             fail();         } catch (TooLittleActualInvocations e) {}     }          @Test     public void shouldVerifyNoMoreInteractionsAndFail() {         spy.add("one");         spy.add("two");                  verify(spy).add("one");         try {             verifyNoMoreInteractions(spy);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void shouldToString() {         spy.add("foo");         assertEquals("[foo]" , spy.toString());     }          interface Foo {         String print();     }          @Test     public void shouldAllowSpyingAnonymousClasses() {         //when         Foo spy = spy(new Foo() {             public String print() {                 return "foo";             }         });          //then         assertEquals("foo", spy.print());     }          @Test     public void shouldSayNiceMessageWhenSpyingOnPrivateClass() throws Exception {         List real = Arrays.asList("first", "second");         try {             spy(real);             fail();         } catch (MockitoException e) {             assertContains("Most likely it is a private class that is not visible by Mockito", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.spies;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.util.Collection; import java.util.Map;  import org.junit.Test; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class StubbingSpiesDoesNotYieldNPETest extends TestBase {          class Foo {         public int len(String text) {             return text.length();         }                  public int size(Map map) {             return map.size();         }                  public int size(Collection collection) {             return collection.size();         }     }          @Test     public void shouldNotThrowNPE() throws Exception {         Foo foo = new Foo();         Foo spy = spy(foo);                  spy.len(anyString());         spy.size(anyMap());         spy.size(anyList());         spy.size(anyCollection());         spy.size(anySet());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stacktrace;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class ClickableStackTracesTest extends TestBase {          @Mock private IMethods mock;      private void callMethodOnMock(String param) {         mock.simpleMethod(param);     }      private void verifyTheMock(int times, String param) {         verify(mock, times(times)).simpleMethod(param);     }          @Test     public void shouldShowActualAndExpectedWhenArgumentsAreDifferent() {         callMethodOnMock("foo");         try {             verifyTheMock(1, "not foo");             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("callMethodOnMock(", e.getMessage());             assertContains("verifyTheMock(", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stacktrace;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.After; import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.misusing.InvalidUseOfMatchersException; import org.mockito.exceptions.misusing.UnfinishedStubbingException; import org.mockito.exceptions.misusing.UnfinishedVerificationException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class ClickableStackTracesWhenFrameworkMisusedTest extends TestBase {          @Mock private IMethods mock;      @After     public void resetState() {         super.resetState();     }          private void misplacedArgumentMatcherHere() {         anyString();     }      @Test     public void shouldPointOutMisplacedMatcher() {         misplacedArgumentMatcherHere();         try {             verify(mock).simpleMethod();             fail();         } catch (InvalidUseOfMatchersException e) {             assertContains("-> at ", e.getMessage());             assertContains("misplacedArgumentMatcherHere(", e.getMessage());         }     }      private void unfinishedStubbingHere() {         when(mock.simpleMethod());     }          @Test     public void shouldPointOutUnfinishedStubbing() {         unfinishedStubbingHere();                  try {             verify(mock).simpleMethod();             fail();         } catch (UnfinishedStubbingException e) {             assertContains("-> at ", e.getMessage());             assertContains("unfinishedStubbingHere(", e.getMessage());         }     }          @Test     public void shouldShowWhereIsUnfinishedVerification() throws Exception {         unfinishedVerificationHere();         try {             mock(IMethods.class);             fail();         } catch (UnfinishedVerificationException e) {             assertContains("unfinishedVerificationHere(", e.getMessage());         }     }      private void unfinishedVerificationHere() {         verify(mock);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stacktrace;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.util.LinkedList; import java.util.List;  import org.junit.Before; import org.junit.Ignore; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.ArgumentCaptor; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.runners.MockitoJUnitRunner; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @Ignore @RunWith(MockitoJUnitRunner.class) public class ModellingDescriptiveMessagesTest extends TestBase {          @Mock private IMethods mock;          @Before     public void cleanStackTrace() {         super.makeStackTracesClean();     }      @Test     public void makeSureStateIsValidatedInTheVeryFirstTestThanksToTheRunner() {         //mess up the state:         verify(mock);     }          @Test     public void shouldSayWantedButNotInvoked() {         verify(mock).otherMethod();     }          @Test     public void shouldPointOutInteractionsOnMockWhenOrdinaryVerificationFails() {         mock.otherMethod();         mock.booleanObjectReturningMethod();                  verify(mock).simpleMethod();     }              @Test     public void shouldShowActualAndExpected() {         mock.simpleMethod("blah");         verify(mock).simpleMethod();     }          @Test     public void shouldSayTooLittleInvocations() {         mock.simpleMethod();         verify(mock, times(2)).simpleMethod();     }          @Test     public void shouldSayTooManyInvocations() {         mock.simpleMethod();         mock.simpleMethod();         verify(mock, times(1)).simpleMethod();     }          @Test     public void shouldSayWantedButNotInvokedInOrder() {         mock.simpleMethod();         mock.otherMethod();         InOrder inOrder = inOrder(mock);         inOrder.verify(mock).otherMethod();         inOrder.verify(mock).simpleMethod();     }          @Test     public void shouldSayTooLittleInvocationsInOrder() {         mock.simpleMethod();         mock.otherMethod();         mock.otherMethod();          InOrder inOrder = inOrder(mock);         inOrder.verify(mock).simpleMethod();         inOrder.verify(mock, times(3)).otherMethod();     }          @Test     public void shouldSayTooManyInvocationsInOrder() {         mock.otherMethod();         mock.otherMethod();                  InOrder inOrder = inOrder(mock);         inOrder.verify(mock, times(1)).otherMethod();     }      @Test     public void shouldSayNeverWantedButInvokedHere() {         mock.otherMethod();                  verify(mock, never()).otherMethod();     }          @Test     public void shouldSayTooLittleInvocationsInAtLeastModeInOrder() {         mock.simpleMethod();          InOrder inOrder = inOrder(mock);         inOrder.verify(mock, atLeast(2)).simpleMethod();     }          @Test     public void shouldSayTooLittleInvocationsInAtLeastMode() {         mock.simpleMethod();                  verify(mock, atLeast(2)).simpleMethod();     }      @Test     public void shouldSayNoMoreInteractions() {         mock.simpleMethod();                  verifyNoMoreInteractions(mock);     }          @Test     public void shouldSayUnstubbedMethodWasInvokedHere() {         mock = mock(IMethods.class, RETURNS_SMART_NULLS);                  IMethods m = mock.iMethodsReturningMethod();                  m.simpleMethod();     }          @Test     public void shouldPointOutUnfinishedStubbing() {         when(mock.simpleMethod());                  verify(mock).simpleMethod();     }          @Test     public void shouldMentionFinalAndObjectMethodsWhenMissingMockCall() {         when("".equals(null)).thenReturn(false);     }          @Test     public void shouldMentionFinalAndObjectMethodsWhenVerifying() {         verify(mock).equals(null);         verify(mock).simpleMethod();     }          @Test     public void shouldMentionFinalAndObjectMethodsWhenMisplacedArgumentMatcher() {         when(mock.equals(anyObject())).thenReturn(false);     }          @Test     public void shouldShowExampleOfCorrectArgumentCapturing() {         ArgumentCaptor<String> argument = ArgumentCaptor.forClass(String.class);         argument.capture();         argument.getValue();     }          @Test     public void shouldScreamWhenNullPassedInsteadOfAnInterface() {         mock(IMethods.class, withSettings().extraInterfaces(List.class, null));     }          @Test     public void shouldScreamWhenNonInterfacePassed() {         mock(IMethods.class, withSettings().extraInterfaces(LinkedList.class));     }          @Test     public void shouldScreamWhenExtraIsTheSame() {         mock(IMethods.class, withSettings().extraInterfaces(IMethods.class));     }          @Test     public void shouldScreamWhenExtraInterfacesEmpty() {         mock(IMethods.class, withSettings().extraInterfaces());     }          @Test     public void shouldScreamWhenExtraInterfacesIsANullArray() {         mock(IMethods.class, withSettings().extraInterfaces((Class[]) null));     }      @Test     public void shouldMentionSpiesWhenVoidMethodIsToldToReturnValue() {         List list = mock(List.class);         doReturn("foo").when(list).clear();     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stacktrace;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.runners.MockitoJUnitRunner; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @RunWith(MockitoJUnitRunner.class) public class PointingStackTraceToActualInvocationChunkInOrderTest extends TestBase {          @Mock private IMethods mock;     @Mock private IMethods mockTwo;     private InOrder inOrder;      @Before     public void setup() {         inOrder = inOrder(mock, mockTwo);                  firstChunk();         secondChunk();         thirdChunk();         fourthChunk();     }      private void firstChunk() {         mock.simpleMethod(1);         mock.simpleMethod(1);     }     private void secondChunk() {         mockTwo.simpleMethod(2);         mockTwo.simpleMethod(2);     }     private void thirdChunk() {         mock.simpleMethod(3);         mock.simpleMethod(3);     }     private void fourthChunk() {         mockTwo.simpleMethod(4);         mockTwo.simpleMethod(4);     }          @Test     public void shouldPointStackTraceToPreviousInvocation() {         inOrder.verify(mock, times(2)).simpleMethod(anyInt());         inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());                  try {             inOrder.verify(mock).simpleMethod(999);             fail();         } catch (VerificationInOrderFailure e) {             assertContains("secondChunk(", e.getMessage());         }     }          @Test     public void shouldPointToThirdInteractionBecauseAtLeastOnceUsed() {         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());                  try {             inOrder.verify(mockTwo).simpleMethod(999);             fail();         } catch (VerificationInOrderFailure e) {             assertContains("thirdChunk(", e.getMessage());         }     }          @Test     public void shouldPointToThirdChunkWhenTooLittleActualInvocations() {         inOrder.verify(mock, times(2)).simpleMethod(anyInt());         inOrder.verify(mockTwo, times(2)).simpleMethod(anyInt());         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());                  try {             inOrder.verify(mockTwo, times(3)).simpleMethod(999);             fail();         } catch (VerificationInOrderFailure e) {             assertContains("thirdChunk(", e.getMessage());         }     }          @Test     public void shouldPointToFourthChunkBecauseTooManyActualInvocations() {         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());                  try {             inOrder.verify(mockTwo, times(0)).simpleMethod(anyInt());             fail();         } catch (VerificationInOrderFailure e) {             assertContains("fourthChunk(", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stacktrace;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.runners.MockitoJUnitRunner; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  //This is required to make sure stack trace is well filtered when runner is ON @RunWith(MockitoJUnitRunner.class) public class PointingStackTraceToActualInvocationInOrderTest extends TestBase {          @Mock private IMethods mock;     @Mock private IMethods mockTwo;     private InOrder inOrder;      @Before     public void setup() {         inOrder = inOrder(mock, mockTwo);                  first();         second();         third();         fourth();     }      private void first() {         mock.simpleMethod(1);     }     private void second() {         mockTwo.simpleMethod(2);     }     private void third() {         mock.simpleMethod(3);     }     private void fourth() {         mockTwo.simpleMethod(4);     }          @Test     public void shouldPointStackTraceToPreviousVerified() {         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());         inOrder.verify(mockTwo).simpleMethod(anyInt());                  try {             inOrder.verify(mock).simpleMethod(999);             fail();         } catch (VerificationInOrderFailure e) {             assertContains("fourth(", e.getMessage());         }     }          @Test     public void shouldPointToThirdMethod() {         inOrder.verify(mock, atLeastOnce()).simpleMethod(anyInt());                  try {             inOrder.verify(mockTwo).simpleMethod(999);             fail();         } catch (VerificationInOrderFailure e) {             assertContains("third(", e.getMessage());         }     }          @Test     public void shouldPointToSecondMethod() {         inOrder.verify(mock).simpleMethod(anyInt());         inOrder.verify(mockTwo).simpleMethod(anyInt());                  try {             inOrder.verify(mockTwo, times(3)).simpleMethod(999);             fail();         } catch (VerificationInOrderFailure e) {             assertContains("second(", e.getMessage());         }     }          @Test     public void shouldPointToFirstMethodBecauseOfTooManyActualInvocations() {         try {             inOrder.verify(mock, times(0)).simpleMethod(anyInt());             fail();         } catch (VerificationInOrderFailure e) {             assertContains("first(", e.getMessage());         }     }              @Test     public void shouldPointToSecondMethodBecauseOfTooManyActualInvocations() {         inOrder.verify(mock).simpleMethod(anyInt());                  try {             inOrder.verify(mockTwo, times(0)).simpleMethod(anyInt());             fail();         } catch (VerificationInOrderFailure e) {             assertContains("second(", e.getMessage());         }     }          @Test     public void shouldPointToFourthMethodBecauseOfTooLittleActualInvocations() {         inOrder.verify(mock).simpleMethod(anyInt());         inOrder.verify(mockTwo).simpleMethod(anyInt());         inOrder.verify(mock).simpleMethod(anyInt());                  try {             inOrder.verify(mockTwo, times(3)).simpleMethod(anyInt());             fail();         } catch (VerificationInOrderFailure e) {             assertContains("fourth(", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stacktrace;  import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.junit.runner.RunWith; import org.mockito.Mock; import org.mockito.exceptions.verification.NeverWantedButInvoked; import org.mockito.runners.MockitoJUnit44Runner; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  //This is required to make sure stack trace is well filtered when runner is ON @SuppressWarnings("deprecation") @RunWith(MockitoJUnit44Runner.class) public class PointingStackTraceToActualInvocationTest extends TestBase {          @Mock private IMethods mock;     @Mock private IMethods mockTwo;      @Before     public void setup() {         first();         second();         third();         fourth();     }      private void first() {         mock.simpleMethod(1);     }     private void second() {         mockTwo.simpleMethod(2);     }     private void third() {         mock.simpleMethod(3);     }     private void fourth() {         mockTwo.simpleMethod(4);     }          @Test     public void shouldPointToTooManyInvocationsChunkOnError() {         try {             verify(mock, times(0)).simpleMethod(1);             fail();         } catch (NeverWantedButInvoked e) {             assertContains("first(", e.getMessage());         }     }             @Test     public void shouldNotPointStackTracesToRunnersCode() {         try {             verify(mock, times(0)).simpleMethod(1);             fail();         } catch (NeverWantedButInvoked e) {             assertNotContains(".runners.", e.getMessage());         }     }    }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stacktrace;  import static org.mockito.Mockito.*; import static org.mockitoutil.ExtraMatchers.*;  import org.junit.After; import org.junit.Before; import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class StackTraceFilteringTest extends TestBase {          @Mock private IMethods mock;      @After     public void resetState() {         super.resetState();     }          @Before     public void setup() {         super.makeStackTracesClean();     }          @Test     public void shouldFilterStackTraceOnVerify() {         try {             verify(mock).simpleMethod();             fail();         } catch (WantedButNotInvoked e) {             assertThat(e, hasFirstMethodInStackTrace("shouldFilterStackTraceOnVerify"));         }     }          @Test     public void shouldFilterStackTraceOnVerifyNoMoreInteractions() {         mock.oneArg(true);         try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {             assertThat(e, hasFirstMethodInStackTrace("shouldFilterStackTraceOnVerifyNoMoreInteractions"));         }     }          @Test     public void shouldFilterStackTraceOnVerifyZeroInteractions() {         mock.oneArg(true);         try {             verifyZeroInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {             assertThat(e, hasFirstMethodInStackTrace("shouldFilterStackTraceOnVerifyZeroInteractions"));         }     }          @Test     public void shouldFilterStacktraceOnMockitoException() {         verify(mock);         try {             verify(mock).oneArg(true);              fail();         } catch (MockitoException expected) {             assertThat(expected, hasFirstMethodInStackTrace("shouldFilterStacktraceOnMockitoException"));         }     }          @Test     public void shouldFilterStacktraceWhenVerifyingInOrder() {         InOrder inOrder = inOrder(mock);         mock.oneArg(true);         mock.oneArg(false);                  inOrder.verify(mock).oneArg(false);         try {             inOrder.verify(mock).oneArg(true);             fail();         } catch (VerificationInOrderFailure e) {             assertThat(e, hasFirstMethodInStackTrace("shouldFilterStacktraceWhenVerifyingInOrder"));         }     }          @Test     public void shouldFilterStacktraceWhenInOrderThrowsMockitoException() {         try {             inOrder();             fail();         } catch (MockitoException expected) {             assertThat(expected, hasFirstMethodInStackTrace("shouldFilterStacktraceWhenInOrderThrowsMockitoException"));         }     }          @Test     public void shouldFilterStacktraceWhenInOrderVerifies() {         try {             InOrder inOrder = inOrder(mock);             inOrder.verify(null);             fail();         } catch (MockitoException expected) {             assertThat(expected, hasFirstMethodInStackTrace("shouldFilterStacktraceWhenInOrderVerifies"));         }     }          @Test     public void shouldFilterStackTraceWhenThrowingExceptionFromMockHandler() {         try {             when(mock.oneArg(true)).thenThrow(new Exception());             fail();         } catch (MockitoException expected) {             assertThat(expected, hasFirstMethodInStackTrace("shouldFilterStackTraceWhenThrowingExceptionFromMockHandler"));         }     }          @Test     public void shouldShowProperExceptionStackTrace() throws Exception {         when(mock.simpleMethod()).thenThrow(new RuntimeException());          try {             mock.simpleMethod();             fail();         } catch (RuntimeException e) {             assertThat(e, hasFirstMethodInStackTrace("shouldShowProperExceptionStackTrace"));         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stubbing;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.misusing.CannotVerifyStubOnlyMock; import org.mockito.exceptions.misusing.MissingMethodInvocationException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.mockito.Matchers.isA; import static org.mockito.Mockito.*;  public class BasicStubbingTest extends TestBase {      private IMethods mock;      @Before     public void setup() {         mock = mock(IMethods.class);     }          @Test     public void should_evaluate_latest_stubbing_first() throws Exception {         when(mock.objectReturningMethod(isA(Integer.class))).thenReturn(100);         when(mock.objectReturningMethod(200)).thenReturn(200);                  assertEquals(200, mock.objectReturningMethod(200));         assertEquals(100, mock.objectReturningMethod(666));         assertEquals("default behavior should return null", null, mock.objectReturningMethod("blah"));     }          @Test     public void should_stubbing_be_treated_as_interaction() throws Exception {         when(mock.booleanReturningMethod()).thenReturn(true);                  mock.booleanReturningMethod();                  try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void should_allow_stubbing_to_string() throws Exception {         IMethods mockTwo = mock(IMethods.class);         when(mockTwo.toString()).thenReturn("test");                  assertContains("Mock for IMethods", mock.toString());         assertEquals("test", mockTwo.toString());     }          @Test     public void should_stubbing_not_be_treated_as_interaction() {         when(mock.simpleMethod("one")).thenThrow(new RuntimeException());         doThrow(new RuntimeException()).when(mock).simpleMethod("two");                  verifyZeroInteractions(mock);     }      @Test     public void unfinished_stubbing_cleans_up_the_state() {         reset(mock);         try {             when("").thenReturn("");             fail();          } catch (MissingMethodInvocationException e) {}          //anything that can cause state validation         verifyZeroInteractions(mock);     }          @Test     public void should_to_string_mock_name() {         IMethods mock = mock(IMethods.class, "mockie");         IMethods mockTwo = mock(IMethods.class);                  assertContains("Mock for IMethods", "" + mockTwo);         assertEquals("mockie", "" + mock);     }          class Foo {         public final String toString() {             return "foo";         }     }          @Test     public void should_allow_mocking_when_to_string_is_final() throws Exception {         mock(Foo.class);     }      @Test     public void test_stub_only_not_verifiable() throws Exception {         IMethods localMock = mock(IMethods.class, withSettings().stubOnly());          when(localMock.objectReturningMethod(isA(Integer.class))).thenReturn(100);         when(localMock.objectReturningMethod(200)).thenReturn(200);          assertEquals(200, localMock.objectReturningMethod(200));         assertEquals(100, localMock.objectReturningMethod(666));         assertEquals("default behavior should return null", null, localMock.objectReturningMethod("blah"));          try {             verify(localMock, atLeastOnce()).objectReturningMethod(eq(200));             fail();         } catch (CannotVerifyStubOnlyMock e) {}     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.stubbing;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Assert; import org.junit.Test; import org.mockito.Mock; import org.mockitoutil.TestBase;  public class CallingRealMethodTest extends TestBase {          @Mock TestedObject mock;      static class TestedObject {         String value;          void setValue(String value) {             this.value = value;         }          String getValue() {             return "HARD_CODED_RETURN_VALUE";         }                  String callInternalMethod() {             return getValue();         }     }          @Test     public void shouldAllowCallingInternalMethod() {         when(mock.getValue()).thenReturn("foo");         when(mock.callInternalMethod()).thenCallRealMethod();                  assertEquals("foo", mock.callInternalMethod());     }      @Test     public void shouldReturnRealValue() {         when(mock.getValue()).thenCallRealMethod();          Assert.assertEquals("HARD_CODED_RETURN_VALUE", mock.getValue());     }      @Test     public void shouldExecuteRealMethod() {         doCallRealMethod().when(mock).setValue(anyString());          mock.setValue("REAL_VALUE");          Assert.assertEquals("REAL_VALUE", mock.value);     }      @Test     public void shouldCallRealMethodByDefault() {         TestedObject mock = mock(TestedObject.class, CALLS_REAL_METHODS);          Assert.assertEquals("HARD_CODED_RETURN_VALUE", mock.getValue());     }      @Test     public void shouldNotCallRealMethodWhenStubbedLater() {         TestedObject mock = mock(TestedObject.class);          when(mock.getValue()).thenCallRealMethod();         when(mock.getValue()).thenReturn("FAKE_VALUE");          Assert.assertEquals("FAKE_VALUE", mock.getValue());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stubbing;  import static org.mockito.Mockito.*;  import java.util.List;  import org.junit.Test; import org.mockito.internal.stubbing.answers.ClonesArguments; import org.mockitoutil.TestBase;  public class CloningParameterTest extends TestBase {      @Test     public void shouldVerifyEvenIfArgumentsWereMutated() throws Exception {          // given         EmailSender emailSender = mock(EmailSender.class, new ClonesArguments());          // when         businessLogic(emailSender);          // then         verify(emailSender).sendEmail(1, new Person("Wes"));     }      private void businessLogic(EmailSender emailSender) {         Person person = new Person("Wes");         emailSender.sendEmail(1, person);         person.emailSent();     }      @Test     public void shouldReturnDefaultValueWithCloningAnswer() throws Exception {          // given         EmailSender emailSender = mock(EmailSender.class, new ClonesArguments());         when(emailSender.getAllEmails(new Person("Wes"))).thenAnswer(new ClonesArguments());          // when         List<?> emails = emailSender.getAllEmails(new Person("Wes"));          // then         assertNotNull(emails);     }      public class Person {          private final String name;         private boolean emailSent;          public Person(String name) {             this.name = name;         }          public void emailSent() {             emailSent = true;         }          @Override         public int hashCode() {             final int prime = 31;             int result = 1;             result = prime * result + getOuterType().hashCode();             result = prime * result + (emailSent ? 1231 : 1237);             result = prime * result + ((name == null) ? 0 : name.hashCode());             return result;         }          @Override         public boolean equals(Object obj) {             if (this == obj)                 return true;             if (obj == null)                 return false;             if (getClass() != obj.getClass())                 return false;             Person other = (Person) obj;             if (!getOuterType().equals(other.getOuterType()))                 return false;             if (emailSent != other.emailSent)                 return false;             if (name == null) {                 if (other.name != null)                     return false;             } else if (!name.equals(other.name))                 return false;             return true;         }          private CloningParameterTest getOuterType() {             return CloningParameterTest.this;         }      }      public interface EmailSender {          void sendEmail(int i, Person person);          List<?> getAllEmails(Person person);      } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.stubbing;  import static org.mockito.BDDMockito.given; import static org.mockito.Matchers.anyInt; import static org.mockito.Matchers.anyString; import static org.mockito.Matchers.eq; import static org.mockito.Mockito.RETURNS_DEEP_STUBS; import static org.mockito.Mockito.atLeast; import static org.mockito.Mockito.atMost; import static org.mockito.Mockito.inOrder; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.never; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.when; import java.io.ByteArrayOutputStream; import java.io.OutputStream; import java.net.Socket; import java.util.Locale; import javax.net.SocketFactory; import org.fest.assertions.Assertions; import org.junit.Test; import org.mockito.InOrder; import org.mockito.exceptions.verification.TooManyActualInvocations; import org.mockitoutil.TestBase;   public class DeepStubbingTest extends TestBase {      static class Person {         Address address;          public Address getAddress() {             return address;         }                  public Address getAddress(String addressName) {             return address;         }                  public FinalClass getFinalClass() {             return null;         }     }          static class Address {         Street street;          public Street getStreet() {             return street;         }          public Street getStreet(Locale locale) {             return street;         }     }          static class Street {         String name;          public String getName() {             return name;         }          public String getLongName() {             return name;         }     }              static final class FinalClass {}          @Test     public void myTest() throws Exception {         SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);         when(sf.createSocket(anyString(), eq(80))).thenReturn(null);         sf.createSocket("what", 80);     }      @Test     public void simpleCase() throws Exception {         OutputStream out = new ByteArrayOutputStream();         Socket socket = mock(Socket.class);         when(socket.getOutputStream()).thenReturn(out);          assertSame(out, socket.getOutputStream());     }      /**      * Test that deep stubbing works for one intermediate level      */     @Test     public void oneLevelDeep() throws Exception {         OutputStream out = new ByteArrayOutputStream();          SocketFactory socketFactory = mock(SocketFactory.class, RETURNS_DEEP_STUBS);         when(socketFactory.createSocket().getOutputStream()).thenReturn(out);          assertSame(out, socketFactory.createSocket().getOutputStream());     }      /**      * Test that stubbing of two mocks stubs don't interfere      */     @Test     public void interactions() throws Exception {         OutputStream out1 = new ByteArrayOutputStream();         OutputStream out2 = new ByteArrayOutputStream();          SocketFactory sf1 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);         when(sf1.createSocket().getOutputStream()).thenReturn(out1);          SocketFactory sf2 = mock(SocketFactory.class, RETURNS_DEEP_STUBS);         when(sf2.createSocket().getOutputStream()).thenReturn(out2);          assertSame(out1, sf1.createSocket().getOutputStream());         assertSame(out2, sf2.createSocket().getOutputStream());     }      /**      * Test that stubbing of methods of different arguments don't interfere      */     @Test     public void withArguments() throws Exception {         OutputStream out1 = new ByteArrayOutputStream();         OutputStream out2 = new ByteArrayOutputStream();         OutputStream out3 = new ByteArrayOutputStream();          SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);         when(sf.createSocket().getOutputStream()).thenReturn(out1);         when(sf.createSocket("google.com", 80).getOutputStream()).thenReturn(out2);         when(sf.createSocket("stackoverflow.com", 80).getOutputStream()).thenReturn(out3);          assertSame(out1, sf.createSocket().getOutputStream());         assertSame(out2, sf.createSocket("google.com", 80).getOutputStream());         assertSame(out3, sf.createSocket("stackoverflow.com", 80).getOutputStream());     }      /**      * Test that deep stubbing work with argument patterns      */     @Test     public void withAnyPatternArguments() throws Exception {         OutputStream out = new ByteArrayOutputStream();          //TODO: should not use javax in case it changes         SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);         when(sf.createSocket(anyString(), anyInt()).getOutputStream()).thenReturn(out);          assertSame(out, sf.createSocket("google.com", 80).getOutputStream());         assertSame(out, sf.createSocket("stackoverflow.com", 8080).getOutputStream());     }      /**      * Test that deep stubbing work with argument patterns      */     @Test     public void withComplexPatternArguments() throws Exception {         OutputStream out1 = new ByteArrayOutputStream();         OutputStream out2 = new ByteArrayOutputStream();          SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);         when(sf.createSocket(anyString(), eq(80)).getOutputStream()).thenReturn(out1);         when(sf.createSocket(anyString(), eq(8080)).getOutputStream()).thenReturn(out2);          assertSame(out2, sf.createSocket("stackoverflow.com", 8080).getOutputStream());         assertSame(out1, sf.createSocket("google.com", 80).getOutputStream());         assertSame(out2, sf.createSocket("google.com", 8080).getOutputStream());         assertSame(out1, sf.createSocket("stackoverflow.com", 80).getOutputStream());     }      /**      * Test that deep stubbing work with primitive expected values      */     @Test     public void withSimplePrimitive() throws Exception {         int a = 32;          SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);         when(sf.createSocket().getPort()).thenReturn(a);          assertEquals(a, sf.createSocket().getPort());     }      /**      * Test that deep stubbing work with primitive expected values with      * pattern method arguments      */     @Test     public void withPatternPrimitive() throws Exception {         int a = 12, b = 23, c = 34;          SocketFactory sf = mock(SocketFactory.class, RETURNS_DEEP_STUBS);         when(sf.createSocket(eq("stackoverflow.com"), eq(80)).getPort()).thenReturn(a);         when(sf.createSocket(eq("google.com"), anyInt()).getPort()).thenReturn(b);         when(sf.createSocket(eq("stackoverflow.com"), eq(8080)).getPort()).thenReturn(c);          assertEquals(b, sf.createSocket("google.com", 80).getPort());         assertEquals(c, sf.createSocket("stackoverflow.com", 8080).getPort());         assertEquals(a, sf.createSocket("stackoverflow.com", 80).getPort());     }          Person person = mock(Person.class, RETURNS_DEEP_STUBS);             @Test     public void shouldStubbingBasicallyWorkFine() throws Exception {         //given         given(person.getAddress().getStreet().getName()).willReturn("Norymberska");                  //when         String street = person.getAddress().getStreet().getName();                  //then         assertEquals("Norymberska", street);     }              @Test     public void shouldVerificationBasicallyWorkFine() throws Exception {         //given         person.getAddress().getStreet().getName();                  //then         verify(person.getAddress().getStreet()).getName();     }          @Test     public void verification_work_with_argument_Matchers_in_nested_calls() throws Exception {         //given         person.getAddress("111 Mock Lane").getStreet();         person.getAddress("111 Mock Lane").getStreet(Locale.ITALIAN).getName();          //then         verify(person.getAddress(anyString())).getStreet();         verify(person.getAddress(anyString()).getStreet(Locale.CHINESE), never()).getName();         verify(person.getAddress(anyString()).getStreet(eq(Locale.ITALIAN))).getName();     }      @Test     public void deep_stub_return_same_mock_instance_if_invocation_matchers_matches() throws Exception {         when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");          person.getAddress("the docks").getStreet().getName();          assertSame(person.getAddress("the docks").getStreet(), person.getAddress(anyString()).getStreet());         assertSame(person.getAddress(anyString()).getStreet(), person.getAddress(anyString()).getStreet());         assertSame(person.getAddress("the docks").getStreet(), person.getAddress("the docks").getStreet());         assertSame(person.getAddress(anyString()).getStreet(), person.getAddress("the docks").getStreet());         assertSame(person.getAddress("111 Mock Lane").getStreet(), person.getAddress("the docks").getStreet());     }      @Test     public void times_never_atLeast_atMost_verificationModes_should_work() throws Exception {         when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");          person.getAddress("the docks").getStreet().getName();         person.getAddress("the docks").getStreet().getName();         person.getAddress("the docks").getStreet().getName();         person.getAddress("the docks").getStreet(Locale.ITALIAN).getName();          verify(person.getAddress("the docks").getStreet(), times(3)).getName();         verify(person.getAddress("the docks").getStreet(Locale.CHINESE), never()).getName();         verify(person.getAddress("the docks").getStreet(Locale.ITALIAN), atMost(1)).getName();     }       @Test     public void inOrder_only_work_on_the_very_last_mock_but_it_works() throws Exception {         when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");         when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn("deep");         when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn("deep");          person.getAddress("the docks").getStreet().getName();         person.getAddress("the docks").getStreet().getLongName();         person.getAddress("the docks").getStreet(Locale.ITALIAN).getName();         person.getAddress("the docks").getStreet(Locale.CHINESE).getName();          InOrder inOrder = inOrder(                 person.getAddress("the docks").getStreet(),                 person.getAddress("the docks").getStreet(Locale.CHINESE),                 person.getAddress("the docks").getStreet(Locale.ITALIAN)         );         inOrder.verify(person.getAddress("the docks").getStreet(), times(1)).getName();         inOrder.verify(person.getAddress("the docks").getStreet()).getLongName();         inOrder.verify(person.getAddress("the docks").getStreet(Locale.ITALIAN), atLeast(1)).getName();         inOrder.verify(person.getAddress("the docks").getStreet(Locale.CHINESE)).getName();     }      @Test     public void verificationMode_only_work_on_the_last_returned_mock() throws Exception {         // 1st invocation on Address mock (stubbing)         when(person.getAddress("the docks").getStreet().getName()).thenReturn("deep");          // 2nd invocation on Address mock (real)         person.getAddress("the docks").getStreet().getName();         // 3rd invocation on Address mock (verification)         // (Address mock is not in verification mode)         verify(person.getAddress("the docks").getStreet()).getName();          try {             verify(person.getAddress("the docks"), times(1)).getStreet();             fail();         } catch (TooManyActualInvocations e) {             Assertions.assertThat(e.getMessage())                     .contains("Wanted 1 time")                     .contains("But was 3 times");         }     }      @Test     public void shouldFailGracefullyWhenClassIsFinal() throws Exception {         //when                 FinalClass value = new FinalClass();         given(person.getFinalClass()).willReturn(value);                  //then         assertEquals(value, person.getFinalClass());     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stubbing;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("deprecation") public class DeprecatedStubbingTest extends TestBase {      @Mock private IMethods mock;      @Before     public void setup() {         mock = mock(IMethods.class);     }          @Test     public void shouldEvaluateLatestStubbingFirst() throws Exception {         stub(mock.objectReturningMethod(isA(Integer.class))).toReturn(100);         stub(mock.objectReturningMethod(200)).toReturn(200);                  assertEquals(200, mock.objectReturningMethod(200));         assertEquals(100, mock.objectReturningMethod(666));         assertEquals("default behavior should return null", null, mock.objectReturningMethod("blah"));     }          @Test     public void shouldStubbingBeTreatedAsInteraction() throws Exception {         stub(mock.booleanReturningMethod()).toReturn(true);                  mock.booleanReturningMethod();                  try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void shouldAllowStubbingToString() throws Exception {         IMethods mockTwo = mock(IMethods.class);         stub(mockTwo.toString()).toReturn("test");                  assertContains("Mock for IMethods", mock.toString());         assertEquals("test", mockTwo.toString());     }          @Test     public void shouldStubbingNotBeTreatedAsInteraction() {         stub(mock.simpleMethod("one")).toThrow(new RuntimeException());         stubVoid(mock).toThrow(new RuntimeException()).on().simpleMethod("two");                  verifyZeroInteractions(mock);     }          @Test     public void shouldAllowConsecutiveStubbing() throws Exception {         //when         stub(mock.simpleMethod())             .toReturn("100")             .toReturn("200");                  //then         assertEquals("100", mock.simpleMethod());         assertEquals("200", mock.simpleMethod());     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stubbing;  import java.util.LinkedList; import java.util.List; import java.util.Map;  import org.junit.Test; import org.mockito.Mock; import org.mockito.Mockito; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class ReturningDefaultValuesTest extends TestBase {      @Mock private IMethods mock;      @Test     public void shouldReturnAllKindsOfPrimitives() throws Exception {         assertEquals((byte) 0, mock.byteReturningMethod());         assertEquals((short) 0, mock.shortReturningMethod());         assertEquals(0, mock.intReturningMethod());         assertEquals(0L, mock.longReturningMethod());         assertEquals(0.0F, mock.floatReturningMethod(), 0.0F);         assertEquals(0.0D, mock.doubleReturningMethod(), 0.0D);         assertEquals((char) 0, mock.charReturningMethod());         assertEquals(false, mock.booleanReturningMethod());         assertEquals(null, mock.objectReturningMethod());     }          @Test     public void shouldReturnTheSameValuesForWrapperClasses() throws Exception {         assertEquals(new Byte((byte) 0), mock.byteObjectReturningMethod());         assertEquals(new Short((short) 0), mock.shortObjectReturningMethod());         assertEquals(new Integer(0), mock.integerReturningMethod());         assertEquals(new Long(0L), mock.longObjectReturningMethod());         assertEquals(new Float(0.0F), mock.floatObjectReturningMethod(), 0.0F);         assertEquals(new Double(0.0D), mock.doubleObjectReturningMethod(), 0.0D);         assertEquals(new Character((char) 0), mock.charObjectReturningMethod());         assertEquals(new Boolean(false), mock.booleanObjectReturningMethod());     }          @Test      public void shouldReturnEmptyCollections() {         CollectionsServer mock = Mockito.mock(CollectionsServer.class);                  assertTrue(mock.list().isEmpty());         assertTrue(mock.linkedList().isEmpty());         assertTrue(mock.map().isEmpty());         assertTrue(mock.hashSet().isEmpty());     }          @Test      public void shouldReturnMutableEmptyCollection() {         CollectionsServer mock = Mockito.mock(CollectionsServer.class);                  List list = mock.list();         list.add("test");                 assertTrue(mock.list().isEmpty());     }          private class CollectionsServer {         List list() {             return null;         }          LinkedList linkedList() {             return null;         }          Map map() {             return null;         }          java.util.HashSet hashSet() {             return null;         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stubbing;  import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.Mockito; import org.mockito.exceptions.verification.SmartNullPointerException; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class SmartNullsStubbingTest extends TestBase {      private IMethods mock;      @Before     public void setup() {         mock = mock(IMethods.class, Mockito.RETURNS_SMART_NULLS);     }          public IMethods unstubbedMethodInvokedHere(IMethods mock) {         return mock.iMethodsReturningMethod();     }      @Test     public void shouldSmartNPEPointToUnstubbedCall() throws Exception {         IMethods methods = unstubbedMethodInvokedHere(mock);          try {             methods.simpleMethod();             fail();         } catch (SmartNullPointerException e) {             assertContains("unstubbedMethodInvokedHere(", e.getMessage());         }     }      interface Bar {         void boo();     }          class Foo {         Foo getSomeClass() {             return null;         }                  Bar getSomeInterface() {             return null;         }          Bar getBarWithParams(int x, String y) {             return null;         }          void boo() {}     }      @Test     public void shouldThrowSmartNPEWhenMethodReturnsClass() throws Exception {         Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);         Foo foo = mock.getSomeClass();         try {             foo.boo();             fail();         } catch (SmartNullPointerException e) {}     }      @Test     public void shouldThrowSmartNPEWhenMethodReturnsInterface() throws Exception {         Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);         Bar bar = mock.getSomeInterface();         try {             bar.boo();             fail();         } catch (SmartNullPointerException e) {}     }       @Test     public void shouldReturnOrdinaryEmptyValuesForOrdinaryTypes() throws Exception {         IMethods mock = mock(IMethods.class, RETURNS_SMART_NULLS);          assertEquals("", mock.stringReturningMethod());         assertEquals(0, mock.intReturningMethod());         assertEquals(true, mock.listReturningMethod().isEmpty());         assertEquals(0, mock.arrayReturningMethod().length);     }      @Test     public void shouldNotThrowSmartNullPointerOnToString() {         Object smartNull = mock.objectReturningMethod();         try {             verify(mock).simpleMethod(smartNull);             fail();         } catch (WantedButNotInvoked e) {}     }      @Test     public void shouldNotThrowSmartNullPointerOnObjectMethods() {         Object smartNull = mock.objectReturningMethod();         smartNull.toString();     }      @Test     public void shouldShowParameters() {         Foo foo = mock(Foo.class, RETURNS_SMART_NULLS);         Bar smartNull = foo.getBarWithParams(10, "yes sir");          try {             smartNull.boo();             fail();         } catch (Exception e) {             assertContains("yes sir", e.getMessage());         }     }      @Test     public void shouldShowParametersWhenParamsAreHuge() {         Foo foo = mock(Foo.class, RETURNS_SMART_NULLS);         String longStr = "Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.";         Bar smartNull = foo.getBarWithParams(10, longStr);          try {             smartNull.boo();             fail();         } catch (Exception e) {             assertContains("Lorem Ipsum", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stubbing;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("deprecation") public class StubbingConsecutiveAnswersTest extends TestBase {      @Mock private IMethods mock;         @Test     public void shouldReturnConsecutiveValues() throws Exception {         when(mock.simpleMethod())             .thenReturn("one")             .thenReturn("two")             .thenReturn("three");                  assertEquals("one", mock.simpleMethod());         assertEquals("two", mock.simpleMethod());         assertEquals("three", mock.simpleMethod());         assertEquals("three", mock.simpleMethod());         assertEquals("three", mock.simpleMethod());     }      @SuppressWarnings("all")     @Test     public void shouldReturnConsecutiveValuesForTwoNulls() throws Exception {         when(mock.simpleMethod()).thenReturn(null, (String[])null);                  assertNull(mock.simpleMethod());                 assertNull(mock.simpleMethod());             }      @Test     public void shouldReturnConsecutiveValuesSetByShortenThenReturnMethod() throws Exception {                 when(mock.simpleMethod())             .thenReturn("one", "two", "three");                  assertEquals("one", mock.simpleMethod());         assertEquals("two", mock.simpleMethod());         assertEquals("three", mock.simpleMethod());         assertEquals("three", mock.simpleMethod());         assertEquals("three", mock.simpleMethod());     }      @Test     public void shouldReturnConsecutiveValueAndThrowExceptionssSetByShortenReturnMethods()             throws Exception {         when(mock.simpleMethod())             .thenReturn("zero")             .thenReturn("one", "two")             .thenThrow(new NullPointerException(), new RuntimeException())             .thenReturn("three")             .thenThrow(new IllegalArgumentException());          assertEquals("zero", mock.simpleMethod());         assertEquals("one", mock.simpleMethod());         assertEquals("two", mock.simpleMethod());         try {             mock.simpleMethod();             fail();         } catch (NullPointerException e) {}         try {             mock.simpleMethod();             fail();         } catch (RuntimeException e) {}         assertEquals("three", mock.simpleMethod());         try {             mock.simpleMethod();             fail();         } catch (IllegalArgumentException e) {}     }          @Test     public void shouldThrowConsecutively() throws Exception {         when(mock.simpleMethod())             .thenThrow(new RuntimeException())             .thenThrow(new IllegalArgumentException())             .thenThrow(new NullPointerException());          try {             mock.simpleMethod();             fail();         } catch (RuntimeException e) {}                  try {             mock.simpleMethod();             fail();         } catch (IllegalArgumentException e) {}                  try {             mock.simpleMethod();             fail();         } catch (NullPointerException e) {}                  try {             mock.simpleMethod();             fail();         } catch (NullPointerException e) {}     }      @Test     public void shouldThrowConsecutivelySetByShortenThenThrowMethod() throws Exception {         when(mock.simpleMethod())             .thenThrow(new RuntimeException(), new IllegalArgumentException(), new NullPointerException());          try {             mock.simpleMethod();             fail();         } catch (RuntimeException e) {}                  try {             mock.simpleMethod();             fail();         } catch (IllegalArgumentException e) {}                  try {             mock.simpleMethod();             fail();         } catch (NullPointerException e) {}                  try {             mock.simpleMethod();             fail();         } catch (NullPointerException e) {}     }          @Test     public void shouldMixConsecutiveReturnsWithExcepions() throws Exception {         when(mock.simpleMethod())             .thenThrow(new IllegalArgumentException())             .thenReturn("one")             .thenThrow(new NullPointerException())             .thenReturn(null);                  try {             mock.simpleMethod();             fail();         } catch (IllegalArgumentException e) {}                  assertEquals("one", mock.simpleMethod());                  try {             mock.simpleMethod();             fail();         } catch (NullPointerException e) {}                  assertEquals(null, mock.simpleMethod());         assertEquals(null, mock.simpleMethod());     }          @Test(expected=MockitoException.class)     public void shouldValidateConsecutiveException() throws Exception {         when(mock.simpleMethod())             .thenReturn("one")             .thenThrow(new Exception());     }          @Test     public void shouldStubVoidMethodAndContinueThrowing() throws Exception {         stubVoid(mock)             .toThrow(new IllegalArgumentException())             .toReturn()             .toThrow(new NullPointerException())             .on().voidMethod();                  try {             mock.voidMethod();             fail();         } catch (IllegalArgumentException e) {}                  mock.voidMethod();                  try {             mock.voidMethod();             fail();         } catch (NullPointerException e) {}                  try {             mock.voidMethod();             fail();         } catch (NullPointerException e) {}             }          @Test     public void shouldStubVoidMethod() throws Exception {         stubVoid(mock)             .toReturn()             .toThrow(new NullPointerException())             .toReturn()             .on().voidMethod();                  mock.voidMethod();                  try {             mock.voidMethod();             fail();         } catch (NullPointerException e) {}                  mock.voidMethod();         mock.voidMethod();     }          @Test(expected=MockitoException.class)     public void shouldValidateConsecutiveExceptionForVoidMethod() throws Exception {         stubVoid(mock)             .toReturn()             .toThrow(new Exception())             .on().voidMethod();     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stubbing;  import org.junit.After; import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import org.mockitousage.IMethods; import org.mockitousage.MethodsImpl; import org.mockitoutil.TestBase;  import java.io.IOException;  import static org.mockito.Matchers.anyInt; import static org.mockito.Matchers.eq; import static org.mockito.Mockito.*;  @SuppressWarnings("serial") public class StubbingUsingDoReturnTest extends TestBase {      @Mock private IMethods mock;          @After public void resetState() {         super.resetState();     }      @Test     public void shouldStub() throws Exception {         doReturn("foo").when(mock).simpleMethod();         doReturn("bar").when(mock).simpleMethod();                  assertEquals("bar", mock.simpleMethod());     }          @Test     public void shouldStubWithArgs() throws Exception {         doReturn("foo").when(mock).simpleMethod("foo");         doReturn("bar").when(mock).simpleMethod(eq("one"), anyInt());                  assertEquals("foo", mock.simpleMethod("foo"));         assertEquals("bar", mock.simpleMethod("one", 234));         assertEquals(null, mock.simpleMethod("xxx", 234));     }          class FooRuntimeException extends RuntimeException {}          @Test     public void shouldStubWithThrowable() throws Exception {         doThrow(new FooRuntimeException()).when(mock).voidMethod();         try {             mock.voidMethod();             fail();         } catch (FooRuntimeException e) {}     }          @Test     public void shouldAllowSettingValidCheckedException() throws Exception {         doThrow(new IOException()).when(mock).throwsIOException(0);                  try {             mock.throwsIOException(0);             fail();         } catch (IOException e) {}     }          class FooCheckedException extends Exception {}          @Test     public void shouldDetectInvalidCheckedException() throws Exception {         try {             doThrow(new FooCheckedException()).when(mock).throwsIOException(0);             fail();         } catch (Exception e) {             assertContains("Checked exception is invalid", e.getMessage());         }     }          @Test     public void shouldScreamWhenReturnSetForVoid() throws Exception {         try {             doReturn("foo").when(mock).voidMethod();             fail();         } catch (MockitoException e) {             assertContains("void method", e.getMessage());             assertContains("cannot", e.getMessage());         }     }          @Test     public void shouldScreamWhenNotAMockPassed() throws Exception {         try {             doReturn("foo").when("foo").toString();             fail();         } catch (Exception e) {             assertContains("Argument passed to when() is not a mock", e.getMessage());         }     }          @Test     public void shouldScreamWhenNullPassed() throws Exception {         try {             doReturn("foo").when((Object) null).toString();             fail();         } catch (Exception e) {             assertContains("Argument passed to when() is null", e.getMessage());         }     }              @Test     public void shouldAllowChainedStubbing() {         doReturn("foo").         doThrow(new RuntimeException()).         doReturn("bar")         .when(mock).simpleMethod();                  assertEquals("foo", mock.simpleMethod());         try {             mock.simpleMethod();             fail();         } catch (RuntimeException e) {}                  assertEquals("bar", mock.simpleMethod());         assertEquals("bar", mock.simpleMethod());     }      @Test     public void shouldAllowDoCallRealMethodInChainedStubbing() throws Exception {         MethodsImpl methods = mock(MethodsImpl.class);         doReturn("A").doCallRealMethod()                 .when(methods).simpleMethod();          assertEquals("A", methods.simpleMethod());         assertEquals(null, methods.simpleMethod());     }      @Test(expected = IllegalArgumentException.class)     public void shouldAllowChainedStubbingWithExceptionClass() throws Exception {         doReturn("whatever").doThrow(IllegalArgumentException.class).when(mock).simpleMethod();          assertEquals("whatever", mock.simpleMethod());         mock.simpleMethod();     }      @Test     public void shouldAllowChainedStubbingOnVoidMethods() {         doNothing().         doNothing().         doThrow(new RuntimeException())         .when(mock).voidMethod();                  mock.voidMethod();         mock.voidMethod();         try {             mock.voidMethod();             fail();         } catch (RuntimeException e) {}         try {             mock.voidMethod();             fail();         } catch (RuntimeException e) {}     }          @Test     public void shouldStubWithGenericAnswer() {         doAnswer(new Answer<Object>() {             public Object answer(InvocationOnMock invocation) throws Throwable {                 return "foo";             }         })         .when(mock).simpleMethod();                  assertEquals("foo", mock.simpleMethod());     }          @Test     public void shouldNotAllowDoNothingOnNonVoids() {         try {             doNothing().when(mock).simpleMethod();             fail();         } catch (MockitoException e) {             assertContains("Only void methods can doNothing()", e.getMessage());         }     }          @Test     public void shouldStubbingBeTreatedAsInteraction() throws Exception {         doReturn("foo").when(mock).simpleMethod();         mock.simpleMethod();         try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void shouldVerifyStubbedCall() throws Exception {         doReturn("foo").when(mock).simpleMethod();         mock.simpleMethod();         mock.simpleMethod();                  verify(mock, times(2)).simpleMethod();         verifyNoMoreInteractions(mock);     }          @Test     public void shouldAllowStubbingToString() throws Exception {         doReturn("test").when(mock).toString();         assertEquals("test", mock.toString());     }       @Test     public void shouldDetectInvalidReturnType() throws Exception {         try {             doReturn("foo").when(mock).booleanObjectReturningMethod();             fail();         } catch (Exception e) {             assertContains("String cannot be returned by booleanObjectReturningMethod()" +                     "\n" +                     "booleanObjectReturningMethod() should return Boolean",                     e.getMessage());         }     }          @Test     public void shouldDetectWhenNullAssignedToBoolean() throws Exception {         try {             doReturn(null).when(mock).intReturningMethod();             fail();         } catch (Exception e) {             assertContains("null cannot be returned by intReturningMethod", e.getMessage());         }     }          @Test     public void shouldAllowStubbingWhenTypesMatchSignature() throws Exception {         doReturn("foo").when(mock).objectReturningMethodNoArgs();         doReturn("foo").when(mock).simpleMethod();         doReturn(1).when(mock).intReturningMethod();         doReturn(new Integer(2)).when(mock).intReturningMethod();     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.stubbing;  import org.junit.Test; import org.mockito.Mock; import org.mockito.invocation.InvocationOnMock; import org.mockito.stubbing.Answer; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import java.lang.reflect.Method; import java.util.Set;  import static org.mockito.Matchers.anyString; import static org.mockito.Mockito.mock; import static org.mockito.Mockito.stubVoid; import static org.mockito.Mockito.when;  @SuppressWarnings({"unchecked", "deprecation"}) public class StubbingWithCustomAnswerTest extends TestBase {     @Mock     private IMethods mock;      @Test     public void shouldAnswer() throws Exception {         when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {             public String answer(InvocationOnMock invocation) throws Throwable {                 String arg = (String) invocation.getArguments()[0];                  return invocation.getMethod().getName() + "-" + arg;             }         });          assertEquals("simpleMethod-test", mock.simpleMethod("test"));     }      @Test     public void shouldAnswerWithThenAnswerAlias() throws Exception {         RecordCall recordCall = new RecordCall();         Set mockedSet = when(mock(Set.class).isEmpty()).then(recordCall).getMock();          mockedSet.isEmpty();          assertTrue(recordCall.isCalled());     }      @Test     public void shouldAnswerConsecutively() throws Exception {         when(mock.simpleMethod())                 .thenAnswer(new Answer<String>() {                     public String answer(InvocationOnMock invocation) throws Throwable {                         return invocation.getMethod().getName();                     }                 })                 .thenReturn("Hello")                 .thenAnswer(new Answer<String>() {                     public String answer(InvocationOnMock invocation) throws Throwable {                         return invocation.getMethod().getName() + "-1";                     }                 });          assertEquals("simpleMethod", mock.simpleMethod());         assertEquals("Hello", mock.simpleMethod());         assertEquals("simpleMethod-1", mock.simpleMethod());         assertEquals("simpleMethod-1", mock.simpleMethod());     }      @Test     public void shoudAnswerVoidMethod() throws Exception {         RecordCall recordCall = new RecordCall();          stubVoid(mock).toAnswer(recordCall).on().voidMethod();          mock.voidMethod();         assertTrue(recordCall.isCalled());     }      @Test     public void shouldAnswerVoidMethodConsecutively() throws Exception {         RecordCall call1 = new RecordCall();         RecordCall call2 = new RecordCall();          stubVoid(mock).toAnswer(call1)                 .toThrow(new UnsupportedOperationException())                 .toAnswer(call2)                 .on().voidMethod();          mock.voidMethod();         assertTrue(call1.isCalled());         assertFalse(call2.isCalled());          try {             mock.voidMethod();             fail();         } catch (UnsupportedOperationException e) {         }          mock.voidMethod();         assertTrue(call2.isCalled());     }      @Test     public void shouldMakeSureTheInterfaceDoesNotChange() throws Exception {         when(mock.simpleMethod(anyString())).thenAnswer(new Answer<String>() {             public String answer(InvocationOnMock invocation) throws Throwable {                 assertTrue(invocation.getArguments().getClass().isArray());                 assertEquals(Method.class, invocation.getMethod().getClass());                  return "assertions passed";             }         });          assertEquals("assertions passed", mock.simpleMethod("test"));     }      private static class RecordCall implements Answer {         private boolean called = false;          public boolean isCalled() {             return called;         }          public Object answer(InvocationOnMock invocation) throws Throwable {             called = true;             return null;         }     }  } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.stubbing;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import static org.mockito.AdditionalAnswers.delegatesTo; import static org.mockito.Mockito.doReturn; import static org.mockito.Mockito.mock; import static junit.framework.Assert.assertEquals; import java.util.ArrayList; import java.util.Collection; import java.util.List; import org.junit.Test; import org.mockito.Mockito; import org.mockito.exceptions.base.MockitoException; import org.mockitousage.IMethods; import org.mockitousage.MethodsImpl;  @SuppressWarnings("unchecked") public class StubbingWithDelegateTest {     public class FakeList<T> {         private T value;          public T get(int i) {             return value;         }          public T set(int i, T value) {             T oldValue = value;             this.value = value;             return oldValue;         }          public int size() {             return 10;         }          public ArrayList<T> subList(int fromIndex, int toIndex) {             return new ArrayList<T>();         }     }      public class FakeListWithWrongMethods<T> {         public double size() {             return 10;         }          public Collection<T> subList(int fromIndex, int toIndex) {             return new ArrayList<T>();         }     }      @Test     public void when_not_stubbed_delegate_should_be_called() {         List<String> delegatedList = new ArrayList<String>();         delegatedList.add("un");          List<String> mock = mock(List.class, delegatesTo(delegatedList));          mock.add("two");          assertEquals(2, mock.size());     }      @Test     public void when_stubbed_the_delegate_should_not_be_called() {         List<String> delegatedList = new ArrayList<String>();         delegatedList.add("un");         List<String> mock = mock(List.class, delegatesTo(delegatedList));          doReturn(10).when(mock).size();          mock.add("two");          assertEquals(10, mock.size());         assertEquals(2, delegatedList.size());     }      @Test     public void delegate_should_not_be_called_when_stubbed2() {         List<String> delegatedList = new ArrayList<String>();         delegatedList.add("un");         List<String> mockedList = mock(List.class, delegatesTo(delegatedList));          doReturn(false).when(mockedList).add(Mockito.anyString());          mockedList.add("two");          assertEquals(1, mockedList.size());         assertEquals(1, delegatedList.size());     }      @Test     public void null_wrapper_dont_throw_exception_from_org_mockito_package() throws Exception {         IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl()));          try {             byte b = methods.byteObjectReturningMethod(); // real method returns null             fail();         } catch (Exception e) {             assertThat(e.toString()).doesNotContain("org.mockito");         }     }      @Test     public void instance_of_different_class_can_be_called() {         List<String> mock = mock(List.class, delegatesTo(new FakeList<String>()));          mock.set(1, "1");         assertThat(mock.get(1).equals("1"));     }      @Test     public void method_with_subtype_return_can_be_called() {         List<String> mock = mock(List.class, delegatesTo(new FakeList<String>()));          List<String> subList = mock.subList(0, 0);         assertThat(subList.isEmpty());     }      @Test     public void calling_missing_method_should_throw_exception() {         List<String> mock = mock(List.class, delegatesTo(new FakeList<String>()));          try {             mock.isEmpty();             fail();         } catch (MockitoException e) {             assertThat(e.toString()).contains("Methods called on mock must exist");         }     }      @Test     public void calling_method_with_wrong_primitive_return_should_throw_exception() {         List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<String>()));          try {             mock.size();             fail();         } catch (MockitoException e) {             assertThat(e.toString()).contains("Methods called on delegated instance must have compatible return type");         }     }      @Test     public void calling_method_with_wrong_reference_return_should_throw_exception() {         List<String> mock = mock(List.class, delegatesTo(new FakeListWithWrongMethods<String>()));          try {             mock.subList(0, 0);             fail();         } catch (MockitoException e) {             assertThat(e.toString()).contains("Methods called on delegated instance must have compatible return type");         }     }      @Test     public void exception_should_be_propagated_from_delegate() throws Exception {         final RuntimeException failure = new RuntimeException("angry-method");         IMethods methods = mock(IMethods.class, delegatesTo(new MethodsImpl() {             @Override             public String simpleMethod() {                 throw failure;             }         }));          try {             methods.simpleMethod(); // delegate throws an exception             fail();         } catch (RuntimeException e) {             assertThat(e).isEqualTo(failure);         }     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stubbing;  import static java.util.Arrays.*; import static org.mockito.Mockito.*;  import java.util.List;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockito.stubbing.answers.ReturnsElementsOf; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class StubbingWithExtraAnswersTest extends TestBase {      @Mock private IMethods mock;          @Test     public void shouldWorkAsStandardMockito() throws Exception {         //when         List<Integer> list = asList(1, 2, 3);         when(mock.objectReturningMethodNoArgs()).thenAnswer(new ReturnsElementsOf(list));                  //then         assertEquals(1, mock.objectReturningMethodNoArgs());         assertEquals(2, mock.objectReturningMethodNoArgs());         assertEquals(3, mock.objectReturningMethodNoArgs());         //last element is returned continuously         assertEquals(3, mock.objectReturningMethodNoArgs());         assertEquals(3, mock.objectReturningMethodNoArgs());     }          @Test     public void shouldReturnNullIfNecessary() throws Exception {         //when         List<Integer> list = asList(1, null);         when(mock.objectReturningMethodNoArgs()).thenAnswer(new ReturnsElementsOf(list));                  //then         assertEquals(1, mock.objectReturningMethodNoArgs());         assertEquals(null, mock.objectReturningMethodNoArgs());         assertEquals(null, mock.objectReturningMethodNoArgs());     }          @Test     public void shouldScreamWhenNullPassed() throws Exception {         try {             //when             new ReturnsElementsOf(null);             //then             fail();         } catch (MockitoException e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.stubbing;  import org.junit.Before; import org.junit.Test; import org.mockito.Mockito; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitoutil.TestBase;  import java.io.IOException; import java.io.Reader; import java.util.HashMap; import java.util.LinkedList; import java.util.Map;  import static org.mockito.Mockito.*;  @SuppressWarnings({"serial", "unchecked", "all", "deprecation"}) public class StubbingWithThrowablesTest extends TestBase {      private LinkedList mock;     private Map mockTwo;      @Before      public void setup() {         mock = mock(LinkedList.class);         mockTwo = mock(HashMap.class);     }          @Test     public void shouldStubWithThrowable() throws Exception {         IllegalArgumentException expected = new IllegalArgumentException("thrown by mock");         when(mock.add("throw")).thenThrow(expected);                  try {             mock.add("throw");             fail();         } catch (IllegalArgumentException e) {             assertEquals(expected, e);         }     }          @Test     public void shouldSetThrowableToVoidMethod() throws Exception {         IllegalArgumentException expected = new IllegalArgumentException("thrown by mock");                  stubVoid(mock).toThrow(expected).on().clear();         try {             mock.clear();             fail();         } catch (Exception e) {             assertEquals(expected, e);         }     }           @Test     public void shouldLastStubbingVoidBeImportant() throws Exception {         stubVoid(mock).toThrow(new ExceptionOne()).on().clear();         stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();                  try {             mock.clear();             fail();         } catch (ExceptionTwo e) {}     }          @Test     public void shouldFailStubbingThrowableOnTheSameInvocationDueToAcceptableLimitation() throws Exception {         when(mock.get(1)).thenThrow(new ExceptionOne());                  try {             when(mock.get(1)).thenThrow(new ExceptionTwo());             fail();         } catch (ExceptionOne e) {}     }             @Test     public void shouldAllowSettingCheckedException() throws Exception {         Reader reader = mock(Reader.class);         IOException ioException = new IOException();                  when(reader.read()).thenThrow(ioException);                  try {             reader.read();             fail();         } catch (Exception e) {             assertEquals(ioException, e);         }     }          @Test     public void shouldAllowSettingError() throws Exception {         Error error = new Error();                  when(mock.add("quake")).thenThrow(error);                  try {             mock.add("quake");             fail();         } catch (Error e) {             assertEquals(error, e);         }     }       @Test(expected = IllegalArgumentException.class)     public void shouldInstantiateExceptionClassOnInteraction() {         when(mock.add(null)).thenThrow(IllegalArgumentException.class);          mock.add(null);     }      @Test(expected = IllegalArgumentException.class)     public void shouldInstantiateExceptionClassWithOngoingStubbingOnInteraction() {         Mockito.doThrow(IllegalArgumentException.class).when(mock).add(null);          mock.add(null);     }          @Test(expected=MockitoException.class)     public void shouldNotAllowSettingInvalidCheckedException() throws Exception {         when(mock.add("monkey island")).thenThrow(new Exception());     }          @Test(expected=MockitoException.class)     public void shouldNotAllowSettingNullThrowable() throws Exception {         when(mock.add("monkey island")).thenThrow((Throwable) null);     }      @Test(expected=MockitoException.class)     public void shouldNotAllowSettingNullThrowableArray() throws Exception {         when(mock.add("monkey island")).thenThrow((Throwable[]) null);     }          @Test     public void shouldMixThrowablesAndReturnsOnDifferentMocks() throws Exception {         when(mock.add("ExceptionOne")).thenThrow(new ExceptionOne());         when(mock.getLast()).thenReturn("last");         stubVoid(mock).toThrow(new ExceptionTwo()).on().clear();                  stubVoid(mockTwo).toThrow(new ExceptionThree()).on().clear();         when(mockTwo.containsValue("ExceptionFour")).thenThrow(new ExceptionFour());         when(mockTwo.get("Are you there?")).thenReturn("Yes!");          assertNull(mockTwo.get("foo"));         assertTrue(mockTwo.keySet().isEmpty());         assertEquals("Yes!", mockTwo.get("Are you there?"));         try {             mockTwo.clear();             fail();         } catch (ExceptionThree e) {}         try {             mockTwo.containsValue("ExceptionFour");             fail();         } catch (ExceptionFour e) {}                  assertNull(mock.getFirst());         assertEquals("last", mock.getLast());         try {             mock.add("ExceptionOne");             fail();         } catch (ExceptionOne e) {}         try {             mock.clear();             fail();         } catch (ExceptionTwo e) {}     }          @Test     public void shouldStubbingWithThrowableBeVerifiable() {         when(mock.size()).thenThrow(new RuntimeException());         stubVoid(mock).toThrow(new RuntimeException()).on().clone();                  try {             mock.size();             fail();         } catch (RuntimeException e) {}                  try {             mock.clone();             fail();         } catch (RuntimeException e) {}                  verify(mock).size();         verify(mock).clone();         verifyNoMoreInteractions(mock);     }          @Test     public void shouldStubbingWithThrowableFailVerification() {         when(mock.size()).thenThrow(new RuntimeException());         stubVoid(mock).toThrow(new RuntimeException()).on().clone();                  verifyZeroInteractions(mock);                  mock.add("test");                  try {             verify(mock).size();             fail();         } catch (WantedButNotInvoked e) {}                  try {             verify(mock).clone();             fail();         } catch (WantedButNotInvoked e) {}                  try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {}     }          private class ExceptionOne extends RuntimeException {}     private class ExceptionTwo extends RuntimeException {}     private class ExceptionThree extends RuntimeException {}     private class ExceptionFour extends RuntimeException {}      public class NaughtyException extends RuntimeException {         public NaughtyException() {             throw new RuntimeException("boo!");         }     }      @Test(expected = NaughtyException.class)     public void shouldShowDecentMessageWhenExcepionIsNaughty() throws Exception {         when(mock.add("")).thenThrow(NaughtyException.class);         mock.add("");     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import org.junit.Test; import static org.mockito.Matchers.anyString; import org.mockito.Mock; import static org.mockito.Mockito.*; import org.mockito.exceptions.base.MockitoAssertionError; import org.mockitoutil.TestBase;  import java.util.List;  @SuppressWarnings("unchecked") public class AtLeastXVerificationTest extends TestBase {      @Mock private List mock;      @Test     public void shouldVerifyAtLeastXTimes() throws Exception {         //when         mock.clear();         mock.clear();         mock.clear();          //then         verify(mock, atLeast(2)).clear();     }      @Test     public void shouldFailVerifiationAtLeastXTimes() throws Exception {         mock.add("one");         verify(mock, atLeast(1)).add(anyString());          try {             verify(mock, atLeast(2)).add(anyString());             fail();         } catch (MockitoAssertionError e) {}     }          @Test     public void shouldAllowAtLeastZeroForTheSakeOfVerifyNoMoreInteractionsSometimes() throws Exception {         //when         mock.add("one");         mock.clear();          //then         verify(mock, atLeast(0)).add("one");         verify(mock, atLeast(0)).clear();          verifyNoMoreInteractions(mock);             } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.util.List;  import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoAssertionError; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class AtMostXVerificationTest extends TestBase {      @Mock private List mock;          @Test     public void shouldVerifyAtMostXTimes() throws Exception {         mock.clear();         mock.clear();                  verify(mock, atMost(2)).clear();         verify(mock, atMost(3)).clear();                  try {             verify(mock, atMost(1)).clear();             fail();         } catch (MockitoAssertionError e) {}     }          @Test     public void shouldWorkWithArgumentMatchers() throws Exception {         mock.add("one");         verify(mock, atMost(5)).add(anyString());                  try {             verify(mock, atMost(0)).add(anyString());             fail();         } catch (MockitoAssertionError e) {}     }          @Test     public void shouldNotAllowNegativeNumber() throws Exception {         try {             verify(mock, atMost(-1)).clear();             fail();         } catch (MockitoException e) {             assertEquals("Negative value is not allowed here", e.getMessage());         }     }          @Test     public void shouldPrintDecentMessage() throws Exception {         mock.clear();         mock.clear();                  try {             verify(mock, atMost(1)).clear();             fail();         } catch (MockitoAssertionError e) {             assertEquals("\nWanted at most 1 time but was 2", e.getMessage());         }     }          @Test     public void shouldNotAllowInOrderMode() throws Exception {         mock.clear();         InOrder inOrder = inOrder(mock);                  try {             inOrder.verify(mock, atMost(1)).clear();             fail();         } catch (MockitoException e) {             assertEquals("AtMost is not implemented to work with InOrder", e.getMessage());         }     }      @Test     public void shouldMarkInteractionsAsVerified() throws Exception {         mock.clear();         mock.clear();                  verify(mock, atMost(3)).clear();         verifyNoMoreInteractions(mock);     }      @Test     public void shouldDetectUnverifiedInMarkInteractionsAsVerified() throws Exception {         mock.clear();         mock.clear();         undesiredInteraction();                  verify(mock, atMost(3)).clear();         try {             verifyNoMoreInteractions(mock);             fail();         } catch(NoInteractionsWanted e) {             assertContains("undesiredInteraction(", e.getMessage());         }     }      private void undesiredInteraction() {         mock.add("");     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.InOrder; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class BasicVerificationInOrderTest extends TestBase {      private IMethods mockOne;     private IMethods mockTwo;     private IMethods mockThree;     private InOrder inOrder;      @Before     public void setUp() {         mockOne = mock(IMethods.class);         mockTwo = mock(IMethods.class);         mockThree = mock(IMethods.class);          inOrder = inOrder(mockOne, mockTwo, mockThree);          mockOne.simpleMethod(1);         mockTwo.simpleMethod(2);         mockTwo.simpleMethod(2);         mockThree.simpleMethod(3);         mockTwo.simpleMethod(2);         mockOne.simpleMethod(4);     }      @Test     public void shouldVerifyInOrder() {         inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);     }      @Test     public void shouldVerifyInOrderUsingAtLeastOnce() {         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(4);         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);     }      @Test     public void shouldVerifyInOrderWhenExpectingSomeInvocationsToBeCalledZeroTimes() {         inOrder.verify(mockOne, times(0)).oneArg(false);         inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockTwo, times(0)).simpleMethod(22);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);         inOrder.verify(mockThree, times(0)).oneArg(false);         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);     }      @Test     public void shouldFailWhenFirstMockCalledTwice() {         inOrder.verify(mockOne).simpleMethod(1);         try {             inOrder.verify(mockOne).simpleMethod(1);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailWhenLastMockCalledTwice() {         inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);         try {             inOrder.verify(mockOne).simpleMethod(4);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test(expected = VerificationInOrderFailure.class)     public void shouldFailOnFirstMethodBecauseOneInvocationWanted() {         inOrder.verify(mockOne, times(0)).simpleMethod(1);     }      @Test(expected = VerificationInOrderFailure.class)     public void shouldFailOnFirstMethodBecauseOneInvocationWantedAgain() {         inOrder.verify(mockOne, times(2)).simpleMethod(1);     }      @Test     public void shouldFailOnSecondMethodBecauseFourInvocationsWanted() {         inOrder.verify(mockOne, times(1)).simpleMethod(1);         try {             inOrder.verify(mockTwo, times(4)).simpleMethod(2);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailOnSecondMethodBecauseTwoInvocationsWantedAgain() {         inOrder.verify(mockOne, times(1)).simpleMethod(1);         try {             inOrder.verify(mockTwo, times(0)).simpleMethod(2);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailOnLastMethodBecauseOneInvocationWanted() {         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree, atLeastOnce()).simpleMethod(3);         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);         try {             inOrder.verify(mockOne, times(0)).simpleMethod(4);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailOnLastMethodBecauseOneInvocationWantedAgain() {         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree, atLeastOnce()).simpleMethod(3);         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);         try {             inOrder.verify(mockOne, times(2)).simpleMethod(4);             fail();         } catch (VerificationInOrderFailure e) {         }     }      /* ------------- */      @Test(expected = ArgumentsAreDifferent.class)     public void shouldFailOnFirstMethodBecauseDifferentArgsWanted() {         inOrder.verify(mockOne).simpleMethod(100);     }      @Test(expected = WantedButNotInvoked.class)     public void shouldFailOnFirstMethodBecauseDifferentMethodWanted() {         inOrder.verify(mockOne).oneArg(true);     }      @Test     public void shouldFailOnSecondMethodBecauseDifferentArgsWanted() {         inOrder.verify(mockOne).simpleMethod(1);         try {             inOrder.verify(mockTwo, times(2)).simpleMethod(-999);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailOnSecondMethodBecauseDifferentMethodWanted() {         inOrder.verify(mockOne, times(1)).simpleMethod(1);         try {             inOrder.verify(mockTwo, times(2)).oneArg(true);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailOnLastMethodBecauseDifferentArgsWanted() {         inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         try {             inOrder.verify(mockOne).simpleMethod(-666);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailOnLastMethodBecauseDifferentMethodWanted() {         inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         try {             inOrder.verify(mockOne).oneArg(false);             fail();         } catch (VerificationInOrderFailure e) {         }     }      /* -------------- */      @Test     public void shouldFailWhenLastMethodVerifiedFirst() {         inOrder.verify(mockOne).simpleMethod(4);         try {             inOrder.verify(mockOne).simpleMethod(1);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailWhenMiddleMethodVerifiedFirst() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         try {             inOrder.verify(mockOne).simpleMethod(1);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailWhenMiddleMethodVerifiedFirstInAtLeastOnceMode() {         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);         try {             inOrder.verify(mockOne).simpleMethod(1);             fail();         } catch (VerificationInOrderFailure e) {         }     }      @Test     public void shouldFailOnVerifyNoMoreInteractions() {         inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);          try {             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);             fail();         } catch (NoInteractionsWanted e) {         }     }      @Test(expected = NoInteractionsWanted.class)     public void shouldFailOnVerifyZeroInteractions() {         verifyZeroInteractions(mockOne);     }      @SuppressWarnings("all")     @Test(expected = MockitoException.class)     public void shouldScreamWhenNullPassed() {         inOrder((Object[])null);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import java.util.List;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.TooManyActualInvocations; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class BasicVerificationTest extends TestBase {      @Mock private List mock;     @Mock private List mockTwo;          @Test     public void shouldVerify() throws Exception {         mock.clear();         verify(mock).clear();          mock.add("test");         verify(mock).add("test");          verifyNoMoreInteractions(mock);     }      @Test(expected=WantedButNotInvoked.class)     public void shouldFailVerification() throws Exception {         verify(mock).clear();     }      @Test     public void shouldFailVerificationOnMethodArgument() throws Exception {         mock.clear();         mock.add("foo");          verify(mock).clear();         try {             verify(mock).add("bar");             fail();         } catch (AssertionError expected) {}     }      @Test     public void shouldFailOnWrongMethod() throws Exception {         mock.clear();         mock.clear();                  mockTwo.add("add");          verify(mock, atLeastOnce()).clear();         verify(mockTwo, atLeastOnce()).add("add");         try {             verify(mockTwo, atLeastOnce()).add("foo");             fail();         } catch (WantedButNotInvoked e) {}     }      @Test     public void shouldDetectRedundantInvocation() throws Exception {         mock.clear();         mock.add("foo");         mock.add("bar");          verify(mock).clear();         verify(mock).add("foo");          try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void shouldDetectWhenInvokedMoreThanOnce() throws Exception {         mock.add("foo");         mock.clear();         mock.clear();                  verify(mock).add("foo");          try {             verify(mock).clear();             fail();         } catch (TooManyActualInvocations e) {}     }      @Test     public void shouldVerifyStubbedMethods() throws Exception {         when(mock.add("test")).thenReturn(Boolean.FALSE);                  mock.add("test");                  verify(mock).add("test");     }           @Test     public void shouldDetectWhenOverloadedMethodCalled() throws Exception {         IMethods mockThree = mock(IMethods.class);                  mockThree.varargs((Object[]) new Object[] {});         try {             verify(mockThree).varargs((String[]) new String[] {});             fail();         } catch(WantedButNotInvoked e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mockito; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class DescriptiveMessagesOnVerificationInOrderErrorsTest extends TestBase {          private IMethods one;     private IMethods two;     private IMethods three;     private InOrder inOrder;      @Before     public void setup() {         one = Mockito.mock(IMethods.class);         two = Mockito.mock(IMethods.class);         three = Mockito.mock(IMethods.class);                  one.simpleMethod(1);         one.simpleMethod(11);         two.simpleMethod(2);         two.simpleMethod(2);         three.simpleMethod(3);                  inOrder = inOrder(one, two, three);     }          @Test     public void shouldPrintVerificationInOrderErrorAndShowBothWantedAndPrevious() {         inOrder.verify(one).simpleMethod(1);         inOrder.verify(two, atLeastOnce()).simpleMethod(2);                  try {             inOrder.verify(one, atLeastOnce()).simpleMethod(11);             fail();         } catch (VerificationInOrderFailure e) {             String expected =                      "\n" +                     "Verification in order failure" +                     "\n" +                     "Wanted but not invoked:" +                     "\n" +                     "iMethods.simpleMethod(11);" +                     "\n" +                     "-> at ";                           assertContains(expected, e.getMessage());                          String expectedCause =                  "\n" +                 "Wanted anywhere AFTER following interaction:" +                 "\n" +                 "iMethods.simpleMethod(2);" +                 "\n" +                 "-> at ";                          assertContains(expectedCause, e.getMessage());         }     }            @Test     public void shouldPrintVerificationInOrderErrorAndShowWantedOnly() {         try {             inOrder.verify(one).differentMethod();             fail();         } catch (WantedButNotInvoked e) {             String expected =                      "\n" +                     "Wanted but not invoked:" +                     "\n" +                     "iMethods.differentMethod();" +                     "\n" +                     "-> at";                           assertContains(expected, e.getMessage());         }     }           @Test     public void shouldPrintVerificationInOrderErrorAndShowWantedAndActual() {         try {             inOrder.verify(one).simpleMethod(999);             fail();         } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {                        assertContains("has different arguments", e.getMessage());         }     }          @Test     public void shouldNotSayArgumentsAreDifferent() {         //this is the last invocation so any next verification in order should simply say wanted but not invoked         inOrder.verify(three).simpleMethod(3);         try {             inOrder.verify(one).simpleMethod(999);             fail();         } catch (VerificationInOrderFailure e) {             assertContains("Wanted but not invoked", e.getMessage());         }     }           @Test     public void shouldPrintMethodThatWasNotInvoked() {         inOrder.verify(one).simpleMethod(1);         inOrder.verify(one).simpleMethod(11);         inOrder.verify(two, times(2)).simpleMethod(2);         inOrder.verify(three).simpleMethod(3);         try {             inOrder.verify(three).simpleMethod(999);             fail();         } catch (VerificationInOrderFailure e) {             String actualMessage = e.getMessage();             String expectedMessage =                      "\n" +                     "Verification in order failure" +                     "\n" +                     "Wanted but not invoked:" +                     "\n" +                     "iMethods.simpleMethod(999);";              assertContains(expectedMessage, actualMessage);              }     }             @Test     public void shouldPrintTooManyInvocations() {         inOrder.verify(one).simpleMethod(1);         inOrder.verify(one).simpleMethod(11);         try {             inOrder.verify(two, times(1)).simpleMethod(2);             fail();         } catch (VerificationInOrderFailure e) {             String actualMessage = e.getMessage();             String expectedMessage =                      "\n" +                     "Verification in order failure:" +                     "\n" +                     "iMethods.simpleMethod(2);" +                     "\n" +                     "Wanted 1 time:" +                     "\n" +                     "-> at";              assertContains(expectedMessage, actualMessage);                    String expectedCause =                 "\n" +                 "But was 2 times. Undesired invocation:" +                 "\n" +                 "-> at";             assertContains(expectedCause, e.getMessage());         }     }            @Test     public void shouldPrintTooLittleInvocations() {         two.simpleMethod(2);                  inOrder.verify(one, atLeastOnce()).simpleMethod(anyInt());         inOrder.verify(two, times(2)).simpleMethod(2);         inOrder.verify(three, atLeastOnce()).simpleMethod(3);                  try {             inOrder.verify(two, times(2)).simpleMethod(2);             fail();         } catch (VerificationInOrderFailure e) {             String actualMessage = e.getMessage();             String expectedMessage =                      "\n" +                     "Verification in order failure:" +                     "\n" +                     "iMethods.simpleMethod(2);" +                     "\n" +                     "Wanted 2 times:" +                     "\n" +                     "-> at";             assertContains(expectedMessage, actualMessage);                          String expectedCause =                  "\n" +                 "But was 1 time:" +                 "\n" +                 "-> at";                          assertContains(expectedCause, e.getMessage());         }     }    }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import java.util.LinkedList;  import org.junit.Test; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.exceptions.verification.TooLittleActualInvocations; import org.mockito.exceptions.verification.TooManyActualInvocations; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class DescriptiveMessagesWhenTimesXVerificationFailsTest extends TestBase {      @Mock private LinkedList mock;      @Test     public void shouldVerifyActualNumberOfInvocationsSmallerThanWanted() throws Exception {         mock.clear();         mock.clear();         mock.clear();          Mockito.verify(mock, times(3)).clear();         try {             Mockito.verify(mock, times(100)).clear();             fail();         } catch (TooLittleActualInvocations e) {             assertContains("mock.clear();", e.getMessage());             assertContains("Wanted 100 times", e.getMessage());             assertContains("was 3", e.getMessage());         }     }      @Test     public void shouldVerifyActualNumberOfInvocationsLargerThanWanted() throws Exception {         mock.clear();         mock.clear();         mock.clear();         mock.clear();          Mockito.verify(mock, times(4)).clear();         try {             Mockito.verify(mock, times(1)).clear();             fail();         } catch (TooManyActualInvocations e) {             assertContains("mock.clear();", e.getMessage());             assertContains("Wanted 1 time", e.getMessage());             assertContains("was 4", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import org.junit.Before; import org.junit.Ignore; import org.junit.Test; import org.mockito.Mock; import org.mockito.Mockito; import org.mockito.exceptions.verification.NeverWantedButInvoked; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.mockito.AdditionalMatchers.aryEq; import static org.mockito.Matchers.anyInt; import static org.mockito.Matchers.eq; import static org.mockito.Matchers.matches; import static org.mockito.Mockito.atLeastOnce; import static org.mockito.Mockito.never; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.verifyNoMoreInteractions; import static org.mockito.Mockito.verifyZeroInteractions;  public class DescriptiveMessagesWhenVerificationFailsTest extends TestBase {      private IMethods mock;      @Before     public void setup() {         mock = Mockito.mock(IMethods.class, "iMethods");     }      @Test     public void should_print_method_name() {         try {             verify(mock).simpleMethod();             fail();         } catch (WantedButNotInvoked e) {             String actualMessage = e.getMessage();             String expectedMessage =                     "\n" +                     "Wanted but not invoked:" +                     "\n" +                     "iMethods.simpleMethod();" +                     "\n" +                     "-> at";             assertContains(expectedMessage, actualMessage);         }     }      private class Foo {         public String toString() {             return "foo";         }     }      @Test     public void should_print_method_name_and_arguments() {         try {             verify(mock).threeArgumentMethod(12, new Foo(), "xx");             fail();         } catch (WantedButNotInvoked e) {             assertContains("iMethods.threeArgumentMethod(12, foo, \"xx\")", e.getMessage());         }     }      @Test     public void should_print_actual_and_wanted_in_line() {         mock.varargs(1, 2);          try {             verify(mock).varargs(1, 1000);             fail();         } catch (ArgumentsAreDifferent e) {             String wanted =                     "\n" +                     "Argument(s) are different! Wanted:" +                     "\n" +                     "iMethods.varargs(1, 1000);";              assertContains(wanted, e.getMessage());              String actual =                     "\n" +                     "Actual invocation has different arguments:" +                     "\n" +                     "iMethods.varargs(1, 2);";              assertContains(actual, e.getMessage());         }     }      @Test     public void should_print_actual_and_wanted_in_multiple_lines() {         mock.varargs("this is very long string", "this is another very long string");          try {             verify(mock).varargs("x", "y", "z");             fail();         } catch (ArgumentsAreDifferent e) {             String wanted =                     "\n" +                     "Argument(s) are different! Wanted:" +                     "\n" +                     "iMethods.varargs(" +                     "\n" +                     "    \"x\"," +                     "\n" +                     "    \"y\"," +                     "\n" +                     "    \"z\"" +                     "\n" +                     ");";              assertContains(wanted, e.getMessage());              String actual =                     "\n" +                     "Actual invocation has different arguments:" +                     "\n" +                     "iMethods.varargs(" +                     "\n" +                     "    \"this is very long string\"," +                     "\n" +                     "    \"this is another very long string\"" +                     "\n" +                     ");";              assertContains(actual, e.getMessage());         }     }      @Test     public void should_print_actual_and_wanted_when_actual_method_name_and_wanted_method_name_are_the_same() {         mock.simpleMethod();          try {             verify(mock).simpleMethod(10);             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("simpleMethod(10)", e.getMessage());             assertContains("simpleMethod()", e.getMessage());         }     }      @Test     public void should_print_actual_and_unverified_wanted_when_the_difference_is_about_arguments() {         mock.twoArgumentMethod(1, 1);         mock.twoArgumentMethod(2, 2);          verify(mock).twoArgumentMethod(1, 1);         try {             verify(mock).twoArgumentMethod(2, 1000);             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("(2, 1000)", e.getMessage());             assertContains("(2, 2)", e.getMessage());         }     }      @Test     public void should_print_first_unexpected_invocation() {         mock.oneArg(true);         mock.oneArg(false);         mock.threeArgumentMethod(1, "2", "3");          verify(mock).oneArg(true);         try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {             String expectedMessage =                     "\n" +                     "No interactions wanted here:" +                     "\n" +                     "-> at";             assertContains(expectedMessage, e.getMessage());              String expectedCause =                     "\n" +                     "But found this interaction on mock '" + mock + "':" +                     "\n" +                     "-> at";             assertContains(expectedCause, e.getMessage());         }     }      @Test     public void should_print_first_unexpected_invocation_when_verifying_zero_interactions() {         mock.twoArgumentMethod(1, 2);         mock.threeArgumentMethod(1, "2", "3");          try {             verifyZeroInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {             String expected =                     "\n" +                     "No interactions wanted here:" +                     "\n" +                     "-> at";              assertContains(expected, e.getMessage());              String expectedCause =                 "\n" +                 "But found this interaction on mock '" + mock + "':" +                 "\n" +                 "-> at";              assertContains(expectedCause, e.getMessage());         }     }      @Test     public void should_print_method_name_when_verifying_at_least_once() throws Exception {         try {             verify(mock, atLeastOnce()).twoArgumentMethod(1, 2);             fail();         } catch (WantedButNotInvoked e) {             assertContains("twoArgumentMethod(1, 2)", e.getMessage());         }     }      @Test     public void should_print_method_when_matcher_used() throws Exception {         try {             verify(mock, atLeastOnce()).twoArgumentMethod(anyInt(), eq(100));             fail();         } catch (WantedButNotInvoked e) {             String actualMessage = e.getMessage();             String expectedMessage =                 "\n" +                 "Wanted but not invoked:" +                 "\n" +                 "iMethods.twoArgumentMethod(\n" +                 "    isA(java.lang.Integer),\n" +                 "    100\n" +                 ");";             assertContains(expectedMessage, actualMessage);         }     }      @Test     public void should_print_method_when_missing_invocation_with_array_matcher() {         mock.oneArray(new boolean[] { true, false, false });          try {             verify(mock).oneArray(aryEq(new boolean[] { false, false, false }));             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("[false, false, false]", e.getMessage());             assertContains("[true, false, false]", e.getMessage());         }     }      @Test     public void should_print_method_when_missing_invocation_with_vararg_matcher() {         mock.varargsString(10, "xxx", "yyy", "zzz");          try {             verify(mock).varargsString(10, "111", "222", "333");             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("111", e.getMessage());             assertContains("\"xxx\"", e.getMessage());         }     }      @Test     public void should_print_method_when_missing_invocation_with_matcher() {         mock.simpleMethod("foo");          try {             verify(mock).simpleMethod(matches("burrito from Exmouth"));             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("matches(\"burrito from Exmouth\")", e.getMessage());             assertContains("\"foo\"", e.getMessage());         }     }      @Test     public void should_print_null_arguments() throws Exception {         mock.simpleMethod(null, (Integer) null);         try {             verify(mock).simpleMethod("test");             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("simpleMethod(null, null);", e.getMessage());         }     }      @Test     public void should_say_never_wanted_but_invoked() throws Exception {         mock.simpleMethod(1);          verify(mock, never()).simpleMethod(2);         try {             verify(mock, never()).simpleMethod(1);             fail();         } catch (NeverWantedButInvoked e) {             assertContains("Never wanted here:", e.getMessage());             assertContains("But invoked here:", e.getMessage());         }     }      @Test     public void should_show_right_actual_method() throws Exception {         mock.simpleMethod(9191);         mock.simpleMethod("foo");          try {             verify(mock).simpleMethod("bar");             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("bar", e.getMessage());             assertContains("foo", e.getMessage());         }     }      @Mock private IMethods iHavefunkyName;      @Test     public void should_print_field_name_when_annotations_used() throws Exception {         iHavefunkyName.simpleMethod(10);          try {             verify(iHavefunkyName).simpleMethod(20);             fail();         } catch (ArgumentsAreDifferent e) {             assertContains("iHavefunkyName.simpleMethod(20)", e.getMessage());             assertContains("iHavefunkyName.simpleMethod(10)", e.getMessage());         }     }      @Test     public void should_print_interactions_on_mock_when_ordinary_verification_fail() throws Exception {         mock.otherMethod();         mock.booleanReturningMethod();          try {             verify(mock).simpleMethod();             fail();         } catch (WantedButNotInvoked e) { //            assertContains("")         }     }      @Mock private IMethods veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock;      @Test     public void should_never_break_method_string_when_no_args_in_method() throws Exception {         try {             verify(veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock).simpleMethod();             fail();         } catch(WantedButNotInvoked e) {             assertContains("veeeeeeeeeeeeeeeeeeeeeeeerylongNameMock.simpleMethod()", e.getMessage());         }     }      @Test     public void should_print_method_name_and_arguments_of_other_interactions_with_different_methods() throws Exception {         try {             mock.arrayMethod(new String[] {"a", "b", "c"});             mock.forByte((byte) 25);              verify(mock).threeArgumentMethod(12, new Foo(), "xx");             fail();         } catch (WantedButNotInvoked e) {             System.out.println(e);             assertContains("iMethods.threeArgumentMethod(12, foo, \"xx\")", e.getMessage());             assertContains("iMethods.arrayMethod([\"a\", \"b\", \"c\"])", e.getMessage());             assertContains("iMethods.forByte(25)", e.getMessage());         }     }      @Test     @Ignore("issue 380 related")     public void should_print_method_name_and_arguments_of_other_interactions_of_same_method() throws Exception {         try {             mock.forByte((byte) 25);             mock.forByte((byte) 12);              verify(mock).forByte((byte) 42);             fail();         } catch (WantedButNotInvoked e) {             System.out.println(e);             assertContains("iMethods.forByte(42)", e.getMessage());             assertContains("iMethods.forByte(25)", e.getMessage());             assertContains("iMethods.forByte(12)", e.getMessage());         }     }      @Test     @Ignore("issue 380 related")     public void test1() {         AnInterface m = Mockito.mock(AnInterface.class);          for (int i = 1; i <= 2; i++) {             m.foo(i);         }          verify(m).foo(1);         verify(m).foo(2);         verify(m).foo(3); // XXX: doesn't mention the parameters of foo(1) and foo(2)         verify(m).foo(4);     }      @Test     @Ignore("issue 380 related")     public void test2() {         AnInterface m = Mockito.mock(AnInterface.class);          for (int i = 1; i <= 4; i++) {             m.foo(i);         }          verify(m).foo(1);         verify(m).foo(2);         verify(m).foo(5); // XXX: doesn't mention foo(4) at all     }      public interface AnInterface {         void foo(int i);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import java.util.LinkedList;  import org.junit.Before; import org.junit.Test; import org.mockito.InOrder; import org.mockito.exceptions.verification.NeverWantedButInvoked; import org.mockito.exceptions.verification.TooLittleActualInvocations; import org.mockito.exceptions.verification.TooManyActualInvocations; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class ExactNumberOfTimesVerificationTest extends TestBase {      private LinkedList mock;      @Before     public void setup() {         mock = mock(LinkedList.class);     }      @Test     public void shouldDetectTooLittleActualInvocations() throws Exception {         mock.clear();         mock.clear();          verify(mock, times(2)).clear();         try {             verify(mock, times(100)).clear();             fail();         } catch (TooLittleActualInvocations e) {             assertContains("Wanted 100 times", e.getMessage());             assertContains("was 2", e.getMessage());         }     }      @Test     public void shouldDetectTooManyActualInvocations() throws Exception {         mock.clear();         mock.clear();          verify(mock, times(2)).clear();         try {             verify(mock, times(1)).clear();             fail();         } catch (TooManyActualInvocations e) {             assertContains("Wanted 1 time", e.getMessage());             assertContains("was 2 times", e.getMessage());         }     }      @Test     public void shouldDetectActualInvocationsCountIsMoreThanZero() throws Exception {         verify(mock, times(0)).clear();         try {             verify(mock, times(15)).clear();             fail();         } catch (WantedButNotInvoked e) {}     }      @Test     public void shouldDetectActuallyCalledOnce() throws Exception {         mock.clear();          try {             verify(mock, times(0)).clear();             fail();         } catch (NeverWantedButInvoked e) {             assertContains("Never wanted here", e.getMessage());         }     }      @Test     public void shouldPassWhenMethodsActuallyNotCalled() throws Exception {         verify(mock, times(0)).clear();         verify(mock, times(0)).add("yes, I wasn't called");     }      @Test     public void shouldNotCountInStubbedInvocations() throws Exception {         when(mock.add("test")).thenReturn(false);         when(mock.add("test")).thenReturn(true);          mock.add("test");         mock.add("test");          verify(mock, times(2)).add("test");     }          @Test     public void shouldAllowVerifyingInteractionNeverHappened() throws Exception {         mock.add("one");          verify(mock, never()).add("two");         verify(mock, never()).clear();                  try {             verify(mock, never()).add("one");             fail();         } catch (NeverWantedButInvoked e) {}     }          @Test     public void shouldAllowVerifyingInteractionNeverHappenedInOrder() throws Exception {         mock.add("one");         mock.add("two");          InOrder inOrder = inOrder(mock);                  inOrder.verify(mock, never()).add("xxx");         inOrder.verify(mock).add("one");         inOrder.verify(mock, never()).add("one");                  try {             inOrder.verify(mock, never()).add("two");             fail();         } catch (VerificationInOrderFailure e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.misusing.UnfinishedVerificationException; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class FindingRedundantInvocationsInOrderTest extends TestBase {      @Mock private IMethods mock;     @Mock private IMethods mock2;          @Test     public void shouldWorkFineIfNoInvocatins() throws Exception {         //when         InOrder inOrder = inOrder(mock);                  //then         inOrder.verifyNoMoreInteractions();             }          @Test     public void shouldSayNoInteractionsWanted() throws Exception {         //when         mock.simpleMethod();                  //then         InOrder inOrder = inOrder(mock);         try {             inOrder.verifyNoMoreInteractions();             fail();         } catch(VerificationInOrderFailure e) {             assertContains("No interactions wanted", e.getMessage());         }     }          @Test     public void shouldVerifyNoMoreInteractionsInOrder() throws Exception {         //when         mock.simpleMethod();         mock.simpleMethod(10);         mock.otherMethod();                  //then         InOrder inOrder = inOrder(mock);         inOrder.verify(mock).simpleMethod(10);         inOrder.verify(mock).otherMethod();         inOrder.verifyNoMoreInteractions();             }          @Test     public void shouldVerifyNoMoreInteractionsInOrderWithMultipleMocks() throws Exception {         //when         mock.simpleMethod();         mock2.simpleMethod();         mock.otherMethod();                  //then         InOrder inOrder = inOrder(mock, mock2);         inOrder.verify(mock2).simpleMethod();         inOrder.verify(mock).otherMethod();         inOrder.verifyNoMoreInteractions();             }          @Test     public void shouldFailToVerifyNoMoreInteractionsInOrder() throws Exception {         //when         mock.simpleMethod();         mock.simpleMethod(10);         mock.otherMethod();                  //then         InOrder inOrder = inOrder(mock);         inOrder.verify(mock).simpleMethod(10);         try {             inOrder.verifyNoMoreInteractions();             fail();         } catch(VerificationInOrderFailure e) {}     }          @Test     public void shouldFailToVerifyNoMoreInteractionsInOrderWithMultipleMocks() throws Exception {         //when         mock.simpleMethod();         mock2.simpleMethod();         mock.otherMethod();                  //then         InOrder inOrder = inOrder(mock, mock2);         inOrder.verify(mock2).simpleMethod();         try {             inOrder.verifyNoMoreInteractions();             fail();         } catch(VerificationInOrderFailure e) {}     }          @Test     public void shouldValidateState() throws Exception {         //when         InOrder inOrder = inOrder(mock);         verify(mock); // mess up state                  //then         try {             inOrder.verifyNoMoreInteractions();             fail();         } catch(UnfinishedVerificationException e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import java.util.LinkedList; import java.util.List; import java.util.Map;  import org.junit.Before; import org.junit.Test; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class NoMoreInteractionsVerificationTest extends TestBase {      private LinkedList mock;          @Before     public void setup() {         mock = mock(LinkedList.class);     }      @Test     public void shouldStubbingNotRegisterRedundantInteractions() throws Exception {         when(mock.add("one")).thenReturn(true);         when(mock.add("two")).thenReturn(true);          mock.add("one");                  verify(mock).add("one");         verifyNoMoreInteractions(mock);     }          @Test     public void shouldVerifyWhenWantedNumberOfInvocationsUsed() throws Exception {         mock.add("one");         mock.add("one");         mock.add("one");                  verify(mock, times(3)).add("one");                  verifyNoMoreInteractions(mock);     }          @Test     public void shouldVerifyNoInteractionsAsManyTimesAsYouWant() throws Exception {         verifyNoMoreInteractions(mock);         verifyNoMoreInteractions(mock);                  verifyZeroInteractions(mock);         verifyZeroInteractions(mock);     }          @Test     public void shouldFailZeroInteractionsVerification() throws Exception {         mock.clear();                  try {             verifyZeroInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void shouldFailNoMoreInteractionsVerification() throws Exception {         mock.clear();                  try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void shouldPrintAllInvocationsWhenVerifyingNoMoreInvocations() throws Exception {         mock.add(1);         mock.add(2);         mock.clear();                  verify(mock).add(2);         try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {             assertContains("list of all invocations", e.getMessage());         }     }          @Test     public void shouldNotContainAllInvocationsWhenSingleUnwantedFound() throws Exception {         mock.add(1);                  try {             verifyNoMoreInteractions(mock);             fail();         } catch (NoInteractionsWanted e) {             assertNotContains("list of all invocations", e.getMessage());         }     }              @Test     public void shouldVerifyOneMockButFailOnOther() throws Exception {         List list = mock(List.class);         Map map = mock(Map.class);          list.add("one");         list.add("one");                  map.put("one", 1);                  verify(list, times(2)).add("one");                  verifyNoMoreInteractions(list);         try {             verifyZeroInteractions(map);             fail();         } catch (NoInteractionsWanted e) {}     }          @SuppressWarnings("all")     @Test(expected=MockitoException.class)     public void verifyNoMoreInteractionsShouldScreamWhenNullPassed() throws Exception {         verifyNoMoreInteractions((Object[])null);     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Matchers.anyInt; import static org.mockito.Mockito.only; import static org.mockito.Mockito.verify;  import java.util.List;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitoutil.TestBase;  public class OnlyVerificationTest extends TestBase {      @Mock private List<Object> mock;      @Mock private List<Object> mock2;      @Test     public void shouldVerifyMethodWasInvokedExclusively() {         mock.clear();         verify(mock, only()).clear();     }      @Test     public void shouldVerifyMethodWasInvokedExclusivelyWithMatchersUsage() {         mock.get(0);         verify(mock, only()).get(anyInt());     }      @Test     public void shouldFailIfMethodWasNotInvoked() {         mock.clear();         try {             verify(mock, only()).get(0);             fail();         } catch (WantedButNotInvoked e) {}     }      @Test     public void shouldFailIfMethodWasInvokedMoreThanOnce() {         mock.clear();         mock.clear();         try {             verify(mock, only()).clear();             fail();         } catch (NoInteractionsWanted e) {}     }      @Test     public void shouldFailIfMethodWasInvokedButWithDifferentArguments() {         mock.get(0);         mock.get(2);         try {             verify(mock, only()).get(999);             fail();         } catch (WantedButNotInvoked e) {}     }          @Test     public void shouldFailIfExtraMethodWithDifferentArgsFound() {         mock.get(0);         mock.get(2);         try {             verify(mock, only()).get(2);             fail();         } catch (NoInteractionsWanted e) {}     }      @Test     public void shouldVerifyMethodWasInvokedExclusivelyWhenTwoMocksInUse() {         mock.clear();         mock2.get(0);         verify(mock, only()).clear();         verify(mock2, only()).get(0);     }  }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.Mock; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class OrdinaryVerificationPrintsAllInteractionsTest extends TestBase {      @Mock private IMethods mock;     @Mock private IMethods mockTwo;      @Test     public void shouldShowAllInteractionsOnMockWhenOrdinaryVerificationFail() throws Exception {         firstInteraction();         secondInteraction();                  try {             verify(mock).simpleMethod();             fail();         } catch (WantedButNotInvoked e) {             assertContains("However, there were other interactions with this mock", e.getMessage());             assertContains("firstInteraction(", e.getMessage());             assertContains("secondInteraction(", e.getMessage());         }     }          @Test     public void shouldNotShowAllInteractionsOnDifferentMock() throws Exception {         differentMockInteraction();         firstInteraction();                  try {             verify(mock).simpleMethod();             fail();         } catch (WantedButNotInvoked e) {             assertContains("firstInteraction(", e.getMessage());             assertNotContains("differentMockInteraction(", e.getMessage());         }     }          @Test     public void shouldNotShowAllInteractionsHeaderWhenNoOtherInteractions() throws Exception {         try {             verify(mock).simpleMethod();             fail();         } catch (WantedButNotInvoked e) {             assertContains("there were zero interactions with this mock.", e.getMessage());         }     }      private void differentMockInteraction() {         mockTwo.simpleMethod();     }      private void secondInteraction() {         mock.booleanReturningMethod();     }      private void firstInteraction() {         mock.otherMethod();     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Test; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class PrintingVerboseTypesWithArgumentsTest extends TestBase {      class Boo {         public void withLong(long x) {         }                  public void withLongAndInt(long x, int y) {         }     }          @Test     public void shouldNotReportArgumentTypesWhenToStringIsTheSame() throws Exception {         //given         Boo boo = mock(Boo.class);         boo.withLong(100);                  try {             //when             verify(boo).withLong(eq(100));             fail();         } catch (ArgumentsAreDifferent e) {             //then             assertContains("withLong((Integer) 100);", e.getMessage());             assertContains("withLong((Long) 100);", e.getMessage());         }     }          @Test     public void shouldShowTheTypeOfOnlyTheArgumentThatDoesntMatch() throws Exception {         //given         Boo boo = mock(Boo.class);         boo.withLongAndInt(100, 200);                  try {             //when             verify(boo).withLongAndInt(eq(100), eq(200));             fail();         } catch (ArgumentsAreDifferent e) {             //then             assertContains("withLongAndInt((Integer) 100, 200)", e.getMessage());             assertContains("withLongAndInt((Long) 100, 200)", e.getMessage());         }     }          @Test     public void shouldShowTheTypeOfTheMismatchingArgumentWhenOutputDescriptionsForInvocationsAreDifferent() throws Exception {         //given         Boo boo = mock(Boo.class);         boo.withLongAndInt(100, 200);                  try {             //when             verify(boo).withLongAndInt(eq(100), any(Integer.class));             fail();         } catch (ArgumentsAreDifferent e) {             //then             assertContains("withLongAndInt((Long) 100, 200)", e.getMessage());             assertContains("withLongAndInt((Integer) 100, <any>", e.getMessage());         }     }          @Test     public void shouldNotShowTypesWhenArgumentValueIsDifferent() throws Exception {         //given         Boo boo = mock(Boo.class);         boo.withLongAndInt(100, 200);                  try {             //when             verify(boo).withLongAndInt(eq(100L), eq(230));             fail();         } catch (ArgumentsAreDifferent e) {             //then             assertContains("withLongAndInt(100, 200)", e.getMessage());             assertContains("withLongAndInt(100, 230)", e.getMessage());         }     }          class Foo {                  private final int x;          public Foo(int x) {             this.x = x;         }                  public boolean equals(Object obj) {             return x == ((Foo) obj).x;         }                  public int hashCode() {             return 1;         }                  public String toString() {             return "foo";         }     }          @Test     public void shouldNotShowTypesWhenTypesAreTheSameEvenIfToStringGivesTheSameResult() throws Exception {         //given         IMethods mock = mock(IMethods.class);         mock.simpleMethod(new Foo(10));                  try {             //when             verify(mock).simpleMethod(new Foo(20));             fail();         } catch (ArgumentsAreDifferent e) {             //then             assertContains("simpleMethod(foo)", e.getMessage());         }     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.InOrder; import org.mockito.exceptions.verification.NeverWantedButInvoked; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  /**  * ignored since 'relaxed' in order verification is not implemented (too complex to bother, maybe later).  */ public class RelaxedVerificationInOrderTest extends TestBase {          private IMethods mockOne;     private IMethods mockTwo;     private IMethods mockThree;     private InOrder inOrder;      @Before     public void setUp() {         mockOne = mock(IMethods.class);         mockTwo = mock(IMethods.class);         mockThree = mock(IMethods.class);                  inOrder = inOrder(mockOne, mockTwo, mockThree);          mockOne.simpleMethod(1);         mockTwo.simpleMethod(2);         mockTwo.simpleMethod(2);         mockThree.simpleMethod(3);         mockTwo.simpleMethod(2);         mockOne.simpleMethod(4);     }          @Test     public void shouldVerifyInOrderAllInvocations() {         inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);     }           @Test     public void shouldVerifyInOrderAndBeRelaxed() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);                  verifyNoMoreInteractions(mockThree);     }              @Test     public void shouldAllowFirstChunkBeforeLastInvocation() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);                  try {             verifyNoMoreInteractions(mockTwo);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void shouldAllowAllChunksBeforeLastInvocation() {         inOrder.verify(mockTwo, times(3)).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);                  verifyNoMoreInteractions(mockTwo);     }          @Test     public void shouldVerifyDetectFirstChunkOfInvocationThatExistInManyChunks() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         try {             verifyNoMoreInteractions(mockTwo);             fail();         } catch(NoInteractionsWanted e) {}     }            @Test     public void shouldVerifyDetectAllChunksOfInvocationThatExistInManyChunks() {         inOrder.verify(mockTwo, times(3)).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);         verifyNoMoreInteractions(mockTwo);     }          @Test     public void shouldVerifyInteractionsFromAllChunksWhenAtLeastOnceMode() {         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);         verifyNoMoreInteractions(mockTwo);         try {             inOrder.verify(mockThree).simpleMethod(3);             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test     public void shouldVerifyInteractionsFromFirstChunk() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         try {             verifyNoMoreInteractions(mockTwo);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test(expected=VerificationInOrderFailure.class)     public void shouldFailVerificationOfNonFirstChunk() {         inOrder.verify(mockTwo, times(1)).simpleMethod(2);     }          @Test     public void shouldPassOnCombinationOfTimesAndAtLeastOnce() {         mockTwo.simpleMethod(2);                  inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);         verifyNoMoreInteractions(mockTwo);     }          @Test     public void shouldPassOnEdgyCombinationOfTimesAndAtLeastOnce() {         mockTwo.simpleMethod(2);         mockThree.simpleMethod(3);                  inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);                  verifyNoMoreInteractions(mockThree);     }          @Test     public void shouldVerifyInOrderMockTwoAndThree() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         verifyNoMoreInteractions(mockTwo, mockThree);     }               @Test     public void shouldVerifyInOrderMockOneAndThree() {         inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockOne).simpleMethod(4);         verifyNoMoreInteractions(mockOne, mockThree);     }           @Test     public void shouldVerifyInOrderOnlyTwoInvocations() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);     }          @Test     public void shouldVerifyInOrderOnlyMockTwo() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockTwo).simpleMethod(2);         verifyNoMoreInteractions(mockTwo);     }          @Test     public void shouldVerifyMockTwoCalledTwice() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);     }          @Test     public void shouldVerifyMockTwoCalledAtLeastOnce() {         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);     }          @Test(expected=WantedButNotInvoked.class)     public void shouldFailOnWrongMethodCalledOnMockTwo() {         inOrder.verify(mockTwo, atLeastOnce()).differentMethod();     }          @Test     public void shouldAllowTimesZeroButOnlyInOrder() {         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);         inOrder.verify(mockOne, times(0)).simpleMethod(1);                  try {             verify(mockOne, times(0)).simpleMethod(1);             fail();         } catch (NeverWantedButInvoked e) {}     }          @Test     public void shouldFailTimesZeroInOrder() {         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         try {             inOrder.verify(mockThree, times(0)).simpleMethod(3);             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test(expected=VerificationInOrderFailure.class)     public void shouldFailWhenMockTwoWantedZeroTimes() {         inOrder.verify(mockTwo, times(0)).simpleMethod(2);     }          @Test     public void shouldVerifyLastInvocation() {         inOrder.verify(mockOne).simpleMethod(4);     }          @Test     public void shouldVerifySecondAndLastInvocation() {         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);     }          @Test     public void shouldVerifySecondAndLastInvocationWhenAtLeastOnceUsed() {         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);     }          @Test     public void shouldFailOnLastTwoInvocationsInWrongOrder() {         inOrder.verify(mockOne).simpleMethod(4);         try {             inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test     public void shouldFailOnLastAndFirstInWrongOrder() {         inOrder.verify(mockOne).simpleMethod(4);         try {             inOrder.verify(mockOne).simpleMethod(1);             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test     public void shouldFailOnWrongMethodAfterLastInvocation() {         inOrder.verify(mockOne).simpleMethod(4);         try {             inOrder.verify(mockOne).simpleMethod(999);             fail();         } catch (VerificationInOrderFailure e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.InOrder; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class SelectedMocksInOrderVerificationTest extends TestBase {          private IMethods mockOne;     private IMethods mockTwo;     private IMethods mockThree;      @Before     public void setUp() {         mockOne = mock(IMethods.class);         mockTwo = mock(IMethods.class);         mockThree = mock(IMethods.class);          mockOne.simpleMethod(1);         mockTwo.simpleMethod(2);         mockTwo.simpleMethod(2);         mockThree.simpleMethod(3);         mockTwo.simpleMethod(2);         mockOne.simpleMethod(4);     }          @Test     public void shouldVerifyAllInvocationsInOrder() {         InOrder inOrder = inOrder(mockOne, mockTwo, mockThree);         inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         inOrder.verify(mockOne).simpleMethod(4);         verifyNoMoreInteractions(mockOne, mockTwo, mockThree);     }           @Test     public void shouldVerifyInOrderMockTwoAndThree() {         InOrder inOrder = inOrder(mockTwo, mockThree);                  inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         verifyNoMoreInteractions(mockTwo, mockThree);     }               @Test     public void shouldVerifyInOrderMockOneAndThree() {         InOrder inOrder = inOrder(mockOne, mockThree);                  inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockOne).simpleMethod(4);         verifyNoMoreInteractions(mockOne, mockThree);     }           @Test     public void shouldVerifyMockOneInOrder() {         InOrder inOrder = inOrder(mockOne);                  inOrder.verify(mockOne).simpleMethod(1);         inOrder.verify(mockOne).simpleMethod(4);                  verifyNoMoreInteractions(mockOne);     }           @Test     public void shouldFailVerificationForMockOne() {         InOrder inOrder = inOrder(mockOne);                  inOrder.verify(mockOne).simpleMethod(1);         try {             inOrder.verify(mockOne).differentMethod();             fail();         } catch (VerificationInOrderFailure e) {}     }           @Test     public void shouldFailVerificationForMockOneBecauseOfWrongOrder() {         InOrder inOrder = inOrder(mockOne);                  inOrder.verify(mockOne).simpleMethod(4);         try {             inOrder.verify(mockOne).simpleMethod(1);             fail();         } catch (VerificationInOrderFailure e) {}     }       @Test     public void shouldVerifyMockTwoWhenThreeTimesUsed() {         InOrder inOrder = inOrder(mockTwo);                  inOrder.verify(mockTwo, times(3)).simpleMethod(2);                  verifyNoMoreInteractions(mockTwo);     }           @Test     public void shouldVerifyMockTwo() {         InOrder inOrder = inOrder(mockTwo);                  inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(2);                  verifyNoMoreInteractions(mockTwo);     }           @Test     public void shouldFailVerificationForMockTwo() {         InOrder inOrder = inOrder(mockTwo);          try {             inOrder.verify(mockTwo).simpleMethod(2);             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test     public void shouldThrowNoMoreInvocationsForMockTwo() {         InOrder inOrder = inOrder(mockTwo);          try {             inOrder.verify(mockTwo, times(2)).simpleMethod(2);             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test     public void shouldThrowTooLittleInvocationsForMockTwo() {         InOrder inOrder = inOrder(mockTwo);          try {             inOrder.verify(mockTwo, times(4)).simpleMethod(2);             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test     public void shouldThrowTooManyInvocationsForMockTwo() {         InOrder inOrder = inOrder(mockTwo);          try {             inOrder.verify(mockTwo, times(2)).simpleMethod(2);             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test     public void shouldAllowThreeTimesOnMockTwo() {         InOrder inOrder = inOrder(mockTwo);          inOrder.verify(mockTwo, times(3)).simpleMethod(2);         verifyNoMoreInteractions(mockTwo);     }          @Test     public void shouldVerifyMockTwoCompletely() {         InOrder inOrder = inOrder(mockTwo, mockThree);          inOrder.verify(mockTwo, times(2)).simpleMethod(2);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockTwo).simpleMethod(2);         verifyNoMoreInteractions(mockTwo, mockThree);     }          @Test     public void shouldAllowTwoTimesOnMockTwo() {         InOrder inOrder = inOrder(mockTwo, mockThree);          inOrder.verify(mockTwo, times(2)).simpleMethod(2);         try {             verifyNoMoreInteractions(mockTwo);             fail();         } catch (NoInteractionsWanted e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.after; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify;  import java.util.LinkedList; import java.util.List;  import org.junit.After; import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoAssertionError; import org.mockitoutil.TestBase;  public class VerificationAfterDelayTest extends TestBase {          @Rule     public ExpectedException expected = ExpectedException.none();      @Mock     private List<String> mock;      private List<Exception> exceptions = new LinkedList<Exception>();      @After     public void teardown() {         // making sure there are no threading related exceptions         assertTrue(exceptions.isEmpty());     }      @Test     public void shouldVerifyNormallyWithSpecificTimes() {} // Defects4J: flaky method //     @Test //     public void shouldVerifyNormallyWithSpecificTimes() throws Exception { //         // given //         Thread t = waitAndExerciseMock(20); //  //         // when //         t.start(); //  //         // then //         verify(mock, after(50).times(1)).clear(); //     }      @Test     public void shouldVerifyNormallyWithAtLeast() {} // Defects4J: flaky method //     @Test //     public void shouldVerifyNormallyWithAtLeast() throws Exception { //         // given //         Thread t = waitAndExerciseMock(20); //  //         // when //         t.start(); //  //         // then //         verify(mock, after(100).atLeast(1)).clear(); //     }      @Test     public void shouldFailVerificationWithWrongTimes() {} // Defects4J: flaky method //     @Test //     public void shouldFailVerificationWithWrongTimes() throws Exception { //         // given //         Thread t = waitAndExerciseMock(20); //  //         // when //         t.start(); //  //         // then //         verify(mock, times(0)).clear(); //          //         expected.expect(MockitoAssertionError.class); //         verify(mock, after(50).times(2)).clear(); //     }      @Test     public void shouldWaitTheFullTimeIfTheTestCouldPass() throws Exception {         // given         Thread t = waitAndExerciseMock(50);          // when         t.start();          // then                 long startTime = System.currentTimeMillis();                  try {             verify(mock, after(100).atLeast(2)).clear();             fail();         } catch (MockitoAssertionError e) {}                  assertTrue(System.currentTimeMillis() - startTime >= 100);     }          @Test     public void shouldStopEarlyIfTestIsDefinitelyFailed() {} // Defects4J: flaky method //     @Test(timeout=100) //     public void shouldStopEarlyIfTestIsDefinitelyFailed() throws Exception { //         // given //         Thread t = waitAndExerciseMock(50); //          //         // when //         t.start(); //          //         // then //         expected.expect(MockitoAssertionError.class); //         verify(mock, after(10000).never()).clear(); //     }      private Thread waitAndExerciseMock(final int sleep) {         Thread t = new Thread() {              @Override             public void run() {                 try {                     Thread.sleep(sleep);                 } catch (InterruptedException e) {                     exceptions.add(e);                     throw new RuntimeException(e);                 }                 mock.clear();             }         };         return t;     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.misusing.NotAMockException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  @SuppressWarnings("unchecked") public class VerificationExcludingStubsTest extends TestBase {      @Mock IMethods mock;      @Test     public void shouldAllowToExcludeStubsForVerification() throws Exception {         //given         when(mock.simpleMethod()).thenReturn("foo");          //when         String stubbed = mock.simpleMethod(); //irrelevant call because it is stubbing         mock.objectArgMethod(stubbed);          //then         verify(mock).objectArgMethod("foo");          //verifyNoMoreInteractions fails:         try { verifyNoMoreInteractions(mock); fail(); } catch (NoInteractionsWanted e) {};                  //but it works when stubs are ignored:         ignoreStubs(mock);         verifyNoMoreInteractions(mock);     }      @Test     public void shouldExcludeFromVerificationInOrder() throws Exception {         //given         when(mock.simpleMethod()).thenReturn("foo");          //when         mock.objectArgMethod("1");         mock.objectArgMethod("2");         mock.simpleMethod(); //calling the stub          //then         InOrder inOrder = inOrder(ignoreStubs(mock));         inOrder.verify(mock).objectArgMethod("1");         inOrder.verify(mock).objectArgMethod("2");         inOrder.verifyNoMoreInteractions();         verifyNoMoreInteractions(mock);     }      @Test(expected = NotAMockException.class)     public void shouldIgnoringStubsDetectNulls() throws Exception {         ignoreStubs(mock, null);     }      @Test(expected = NotAMockException.class)     public void shouldIgnoringStubsDetectNonMocks() throws Exception {         ignoreStubs(mock, new Object());     }  }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.InOrder; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class VerificationInOrderMixedWithOrdiraryVerificationTest extends TestBase {          private IMethods mockOne;     private IMethods mockTwo;     private IMethods mockThree;     private InOrder inOrder;      @Before     public void setUp() {         mockOne = mock(IMethods.class);         mockTwo = mock(IMethods.class);         mockThree = mock(IMethods.class);          mockOne.simpleMethod(1);         mockOne.simpleMethod(1);         mockTwo.simpleMethod(2);         mockThree.simpleMethod(3);         mockThree.simpleMethod(4);          inOrder = inOrder(mockOne, mockThree);     }          @Test     public void shouldMixVerificationInOrderAndOrdinaryVerification() {         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockThree).simpleMethod(4);         verify(mockTwo).simpleMethod(2);                  verifyNoMoreInteractions(mockOne, mockTwo, mockThree);     }          @Test     public void shouldAllowOrdinarilyVerifyingMockPassedToInOrderObject() {         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);          verify(mockThree).simpleMethod(3);         verify(mockThree).simpleMethod(4);         verify(mockTwo).simpleMethod(2);                  verifyNoMoreInteractions(mockOne, mockTwo, mockThree);     }          @Test     public void shouldAllowRedundantVerifications() {         verify(mockOne, atLeastOnce()).simpleMethod(1);         verify(mockTwo).simpleMethod(2);         verify(mockThree).simpleMethod(3);         verify(mockThree).simpleMethod(4);                  inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockThree).simpleMethod(4);                  verifyNoMoreInteractions(mockOne, mockTwo, mockThree);     }          @Test     public void shouldFailOnNoMoreInteractions() {         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);         inOrder.verify(mockThree).simpleMethod(3);         inOrder.verify(mockThree).simpleMethod(4);                  try {             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void shouldFailOnNoMoreInteractionsOnMockVerifiedInOrder() {         inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);         inOrder.verify(mockThree).simpleMethod(3);         verify(mockTwo).simpleMethod(2);                  try {             verifyNoMoreInteractions(mockOne, mockTwo, mockThree);             fail();         } catch (NoInteractionsWanted e) {}     }          @Test     public void shouldAllowOneMethodVerifiedInOrder() {         verify(mockTwo).simpleMethod(2);         verify(mockOne, atLeastOnce()).simpleMethod(1);          inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);     }          @Test     public void shouldFailOnLastInvocationTooEarly() {         inOrder.verify(mockThree).simpleMethod(4);                  verify(mockThree).simpleMethod(4);         verify(mockTwo).simpleMethod(2);                  try {             inOrder.verify(mockOne, atLeastOnce()).simpleMethod(1);             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test(expected=MockitoException.class)     public void shouldScreamWhenUnfamiliarMockPassedToInOrderObject() {         inOrder.verify(mockTwo, atLeastOnce()).simpleMethod(1);     }           @Test     public void shouldUseEqualsToVerifyMethodArguments() {         mockOne = mock(IMethods.class);                  String textOne = "test";         String textTwo = new String(textOne);                  assertEquals(textOne, textTwo);         assertNotSame(textOne, textTwo);                  mockOne.simpleMethod(textOne);         mockOne.simpleMethod(textTwo);                  verify(mockOne, times(2)).simpleMethod(textOne);                  inOrder = inOrder(mockOne);         inOrder.verify(mockOne, times(2)).simpleMethod(textOne);     }           @Test     public void shouldUseEqualsToVerifyMethodVarargs() {         mockOne = mock(IMethods.class);                  String textOne = "test";         String textTwo = new String(textOne);                  assertEquals(textOne, textTwo);         assertNotSame(textOne, textTwo);                  mockOne.varargsObject(1, textOne, textOne);         mockOne.varargsObject(1, textTwo, textTwo);                  verify(mockOne, times(2)).varargsObject(1, textOne, textOne);                  inOrder = inOrder(mockOne);         inOrder.verify(mockOne, times(2)).varargsObject(1, textOne, textOne);     }  }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.InOrder; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class VerificationInOrderTest extends TestBase {          private IMethods mockOne;     private IMethods mockTwo;     private IMethods mockThree;     private InOrder inOrder;      @Before     public void setUp() {         mockOne = mock(IMethods.class);         mockTwo = mock(IMethods.class);         mockThree = mock(IMethods.class);                  inOrder = inOrder(mockOne, mockTwo, mockThree);     }          @Test     public void shouldVerifySingleMockInOrderAndNotInOrder() {         mockOne = mock(IMethods.class);         inOrder = inOrder(mockOne);                  mockOne.simpleMethod(1);         mockOne.simpleMethod(2);                  verify(mockOne).simpleMethod(2);         verify(mockOne).simpleMethod(1);                  inOrder.verify(mockOne).simpleMethod(2);         try {             inOrder.verify(mockOne).simpleMethod(1);             fail();         } catch (VerificationInOrderFailure e) {}     }           @Test     public void shouldMessagesPointToProperMethod() {         mockTwo.differentMethod();         mockOne.simpleMethod();                  try {             inOrder.verify(mockOne, atLeastOnce()).differentMethod();             fail();         } catch (WantedButNotInvoked e) {             assertContains("differentMethod()", e.getMessage());         }     }          @Test     public void shouldVerifyInOrderWhenTwoChunksAreEqual() {         mockOne.simpleMethod();         mockOne.simpleMethod();         mockTwo.differentMethod();         mockOne.simpleMethod();         mockOne.simpleMethod();                  inOrder.verify(mockOne, times(2)).simpleMethod();         inOrder.verify(mockTwo).differentMethod();         inOrder.verify(mockOne, times(2)).simpleMethod();         try {             inOrder.verify(mockOne, atLeastOnce()).simpleMethod();             fail();         } catch (VerificationInOrderFailure e) {}     }          @Test     public void shouldVerifyInOrderUsingMatcher() {         mockOne.simpleMethod(1);         mockOne.simpleMethod(2);         mockTwo.differentMethod();         mockOne.simpleMethod(3);         mockOne.simpleMethod(4);                  verify(mockOne, times(4)).simpleMethod(anyInt());                  inOrder.verify(mockOne, times(2)).simpleMethod(anyInt());         inOrder.verify(mockTwo).differentMethod();         inOrder.verify(mockOne, times(2)).simpleMethod(anyInt());         try {             inOrder.verify(mockOne, times(3)).simpleMethod(anyInt());             fail();         } catch (VerificationInOrderFailure e) {}     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */ package org.mockitousage.verification;  import org.junit.Rule; import org.junit.Test; import org.junit.rules.ExpectedException; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoException; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.VerificationInOrderFailure; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  import static org.mockito.Mockito.*;  public class VerificationInOrderWithCallsTest extends TestBase {      @Mock private IMethods mockOne;     @Mock private IMethods mockTwo;     @Rule     public ExpectedException exceptionRule = ExpectedException.none();      @Test     public void shouldFailWhenMethodNotCalled() {} // Defects4J: flaky method //     @Test //     public void shouldFailWhenMethodNotCalled(){ //         // Given //         mockOne.oneArg( 1 ); //         InOrder verifier = inOrder( mockOne ); //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //  //         exceptionRule.expect( VerificationInOrderFailure.class ); //         exceptionRule.expectMessage( "Verification in order failure" ); //         exceptionRule.expectMessage( "Wanted but not invoked" ); //         exceptionRule.expectMessage( "mockOne.oneArg(2)" ); //  //         // When //         verifier.verify( mockOne, calls(1)).oneArg( 2 ); //  //         // Then - expected exception thrown //     }      @Test     public void shouldFailWhenMethodCalledTooFewTimes() {} // Defects4J: flaky method //     @Test //     public void shouldFailWhenMethodCalledTooFewTimes(){ //         // Given //         mockOne.oneArg( 1 ); //         mockOne.oneArg( 2 ); //  //         InOrder verifier = inOrder( mockOne ); //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //  //         exceptionRule.expect( VerificationInOrderFailure.class ); //         exceptionRule.expectMessage( "Verification in order failure" ); //         exceptionRule.expectMessage( "mockOne.oneArg(2)" ); //         exceptionRule.expectMessage( "Wanted 2 times" ); //         exceptionRule.expectMessage( "But was 1 time" ); //  //         // When //         verifier.verify( mockOne, calls(2)).oneArg( 2 ); //  //         // Then - expected exception thrown //     }      @Test     public void shouldFailWhenSingleMethodCallsAreOutOfSequence() {} // Defects4J: flaky method //     @Test //     public void shouldFailWhenSingleMethodCallsAreOutOfSequence(){ //         // Given //         mockOne.oneArg( 1 ); //         mockOne.oneArg( 2 ); //  //         InOrder verifier = inOrder( mockOne ); //         verifier.verify( mockOne, calls(1)).oneArg( 2 ); //  //         exceptionRule.expect( VerificationInOrderFailure.class ); //         exceptionRule.expectMessage( "Verification in order failure" ); //         exceptionRule.expectMessage( "Wanted but not invoked" ); //         exceptionRule.expectMessage( "mockOne.oneArg(1)" ); //  //         // When //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //  //         // Then - expected exception thrown //     }      @Test     public void shouldFailWhenDifferentMethodCallsAreOutOfSequence() {} // Defects4J: flaky method //     @Test //     public void shouldFailWhenDifferentMethodCallsAreOutOfSequence(){ //         // Given //         mockOne.oneArg( 1 ); //         mockOne.voidMethod(); //  //         InOrder verifier = inOrder( mockOne ); //         verifier.verify( mockOne, calls(1)).voidMethod(); //  //         exceptionRule.expect( VerificationInOrderFailure.class ); //         exceptionRule.expectMessage( "Verification in order failure" ); //         exceptionRule.expectMessage( "Wanted but not invoked" ); //         exceptionRule.expectMessage( "mockOne.oneArg(1)" ); //  //         // When //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //  //         // Then - expected exception thrown //     }      @Test     public void shouldFailWhenMethodCallsOnDifferentMocksAreOutOfSequence() {} // Defects4J: flaky method //     @Test //     public void shouldFailWhenMethodCallsOnDifferentMocksAreOutOfSequence(){ //         // Given //         mockOne.voidMethod(); //         mockTwo.voidMethod(); //  //         InOrder verifier = inOrder( mockOne, mockTwo ); //         verifier.verify( mockTwo, calls(1)).voidMethod(); //  //         exceptionRule.expect( VerificationInOrderFailure.class ); //         exceptionRule.expectMessage( "Verification in order failure" ); //         exceptionRule.expectMessage( "Wanted but not invoked" ); //         exceptionRule.expectMessage( "mockOne.voidMethod()" ); //  //         // When //         verifier.verify( mockOne, calls(1)).voidMethod(); //  //         // Then - expected exception thrown //     }           @Test     public void shouldAllowSequentialCallsToCallsForSingleMethod(){         // Given         mockOne.oneArg( 1 );         mockOne.oneArg( 2 );         mockOne.oneArg( 2 );         mockOne.oneArg( 1 );          InOrder verifier = inOrder( mockOne );          // When         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifier.verify( mockOne, calls(2)).oneArg( 2 );         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifyNoMoreInteractions(mockOne);         verifier.verifyNoMoreInteractions();          // Then - no exception thrown     }      @Test     public void shouldAllowSequentialCallsToCallsForDifferentMethods(){         // Given         mockOne.oneArg( 1 );         mockOne.voidMethod();         mockOne.voidMethod();         mockOne.oneArg( 1 );          InOrder verifier = inOrder( mockOne );          // When         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifier.verify( mockOne, calls(2)).voidMethod();         verifier.verify( mockOne, calls(1)).oneArg(1);         verifyNoMoreInteractions(mockOne);         verifier.verifyNoMoreInteractions();          // Then - no exception thrown     }      @Test     public void shouldAllowSequentialCallsToCallsForMethodsOnDifferentMocks(){         // Given         mockOne.voidMethod();         mockTwo.voidMethod();         mockTwo.voidMethod();         mockOne.voidMethod();          InOrder verifier = inOrder( mockOne, mockTwo );          // When         verifier.verify( mockOne, calls(1)).voidMethod();         verifier.verify( mockTwo, calls(2)).voidMethod();         verifier.verify( mockOne, calls(1)).voidMethod();         verifyNoMoreInteractions(mockOne);         verifyNoMoreInteractions(mockTwo);         verifier.verifyNoMoreInteractions();          // Then - no exception thrown     }               @Test     public void shouldAllowFewerCallsForSingleMethod(){         // Given         mockOne.oneArg( 1 );         mockOne.oneArg( 2 );         mockOne.oneArg( 2 );         mockOne.oneArg( 1 );         mockOne.oneArg( 2 );          InOrder verifier = inOrder( mockOne );          // When         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifier.verify( mockOne, calls(1)).oneArg( 2 );         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifier.verify( mockOne, calls(1)).oneArg( 2 );          // Then - no exception thrown     }      @Test     public void shouldNotVerifySkippedCallsWhenFewerCallsForSingleMethod() {} // Defects4J: flaky method //     @Test //     public void shouldNotVerifySkippedCallsWhenFewerCallsForSingleMethod(){ //         // Given //         mockOne.oneArg( 1 ); //         mockOne.oneArg( 2 ); //         mockOne.oneArg( 2 ); //         mockOne.oneArg( 1 ); //  //         InOrder verifier = inOrder( mockOne ); //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //         verifier.verify( mockOne, calls(1)).oneArg( 2 ); //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //          //         exceptionRule.expect( NoInteractionsWanted.class ); //  //         // When //         verifyNoMoreInteractions( mockOne ); //  //         // Then - expected exception thrown //     }      @Test     public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForSingleMethod() {} // Defects4J: flaky method //     @Test //     public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForSingleMethod(){ //         // Given //         mockOne.oneArg( 1 ); //         mockOne.oneArg( 2 ); //         mockOne.oneArg( 2 ); //  //         InOrder verifier = inOrder( mockOne ); //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //         verifier.verify( mockOne, calls(1)).oneArg( 2 ); //  //         exceptionRule.expect( VerificationInOrderFailure.class ); //         exceptionRule.expectMessage( "No interactions wanted here" ); //  //         // When //         verifier.verifyNoMoreInteractions(); //  //         // Then - expected exception thrown //     }      @Test     public void shouldAllowFewerCallsForDifferentMethods(){         // Given         mockOne.oneArg( 1 );         mockOne.voidMethod();         mockOne.voidMethod();         mockOne.oneArg( 1 );         mockOne.voidMethod();          InOrder verifier = inOrder( mockOne );          // When         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifier.verify( mockOne, calls(1)).voidMethod();         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifier.verify( mockOne, calls(1)).voidMethod();          // Then - no exception thrown     }      @Test     public void shouldNotVerifySkippedCallsWhenFewerCallsForDifferentMethods() {} // Defects4J: flaky method //     @Test //     public void shouldNotVerifySkippedCallsWhenFewerCallsForDifferentMethods(){ //         // Given //         mockOne.oneArg( 1 ); //         mockOne.voidMethod(); //         mockOne.voidMethod(); //         mockOne.oneArg( 1 ); //  //         InOrder verifier = inOrder( mockOne ); //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //         verifier.verify( mockOne, calls(1)).voidMethod(); //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //  //         exceptionRule.expect( NoInteractionsWanted.class ); //  //         // When //         verifyNoMoreInteractions( mockOne ); //  //         // Then - no exception thrown //     }      @Test     public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForDifferentMethods() {} // Defects4J: flaky method //     @Test //     public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForDifferentMethods(){ //         // Given //         mockOne.oneArg( 1 ); //         mockOne.voidMethod(); //         mockOne.voidMethod(); //  //         InOrder verifier = inOrder( mockOne ); //         verifier.verify( mockOne, calls(1)).oneArg( 1 ); //         verifier.verify( mockOne, calls(1)).voidMethod(); //  //         exceptionRule.expect( VerificationInOrderFailure.class ); //         exceptionRule.expectMessage( "No interactions wanted here" ); //  //         // When //         verifier.verifyNoMoreInteractions(); //  //         // Then - expected exception thrown //     }      @Test     public void shouldAllowFewerCallsForMethodsOnDifferentMocks(){         // Given         mockOne.voidMethod();         mockTwo.voidMethod();         mockTwo.voidMethod();         mockOne.voidMethod();         mockTwo.voidMethod();          InOrder verifier = inOrder( mockOne, mockTwo );          // When         verifier.verify( mockOne, calls(1)).voidMethod();         verifier.verify( mockTwo, calls(1)).voidMethod();         verifier.verify( mockOne, calls(1)).voidMethod();         verifier.verify( mockTwo, calls(1)).voidMethod();          // Then - no exception thrown     }      @Test     public void shouldNotVerifySkippedCallsWhenFewerCallsForMethodsOnDifferentMocks() {} // Defects4J: flaky method //     @Test //     public void shouldNotVerifySkippedCallsWhenFewerCallsForMethodsOnDifferentMocks(){ //         // Given //         mockOne.voidMethod(); //         mockTwo.voidMethod(); //         mockTwo.voidMethod(); //         mockOne.voidMethod(); //  //         InOrder verifier = inOrder( mockOne, mockTwo ); //         verifier.verify( mockOne, calls(1)).voidMethod(); //         verifier.verify( mockTwo, calls(1)).voidMethod(); //         verifier.verify( mockOne, calls(1)).voidMethod(); //  //         exceptionRule.expect(NoInteractionsWanted.class); //  //         // When //         verifyNoMoreInteractions( mockTwo ); //  //         // Then - expected exception thrown //     }      @Test     public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForMethodsOnDifferentMocks() {} // Defects4J: flaky method //     @Test //     public void shouldNotVerifySkippedCallsInInOrderWhenFewerCallsForMethodsOnDifferentMocks(){ //         // Given //         mockOne.voidMethod(); //         mockTwo.voidMethod(); //         mockTwo.voidMethod(); //  //         InOrder verifier = inOrder( mockOne, mockTwo ); //         verifier.verify( mockOne, calls(1)).voidMethod(); //         verifier.verify( mockTwo, calls(1)).voidMethod(); //  //         exceptionRule.expect( VerificationInOrderFailure.class ); //         exceptionRule.expectMessage( "No interactions wanted here" ); //  //         // When //         verifier.verifyNoMoreInteractions(); //  //         // Then - expected exception thrown //     }      @Test     public void shouldVerifyWithCallsAfterUseOfTimes(){         // Given         mockOne.oneArg( 1 );         mockOne.oneArg( 2 );         mockOne.oneArg( 2 );         mockOne.oneArg( 1 );          InOrder verifier = inOrder( mockOne );          // When         verifier.verify( mockOne, times(1)).oneArg( 1 );         verifier.verify( mockOne, calls(2)).oneArg( 2 );         verifier.verify( mockOne, calls(1)).oneArg( 1 );          // Then - no exception thrown     }      @Test     public void shouldVerifyWithCallsAfterUseOfAtLeast(){         // Given         mockOne.oneArg( 1 );         mockOne.oneArg( 2 );         mockOne.oneArg( 2 );          InOrder verifier = inOrder( mockOne );          // When         verifier.verify( mockOne, atLeast(1)).oneArg( 1 );         verifier.verify( mockOne, calls(2)).oneArg( 2 );          // Then - no exception thrown     }      @Test     public void shouldVerifyWithTimesAfterUseOfCalls(){         // Given         mockOne.oneArg( 1 );         mockOne.oneArg( 2 );         mockOne.oneArg( 2 );         mockOne.oneArg( 1 );          InOrder verifier = inOrder( mockOne );          // When         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifier.verify( mockOne, times(2)).oneArg( 2 );         verifier.verify( mockOne, times(1)).oneArg( 1 );          // Then - no exception thrown     }      @Test     public void shouldVerifyWithAtLeastAfterUseOfCalls(){         // Given         mockOne.oneArg( 1 );         mockOne.oneArg( 2 );         mockOne.oneArg( 2 );         mockOne.oneArg( 1 );          InOrder verifier = inOrder( mockOne );          // When         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifier.verify( mockOne, atLeast(1)).oneArg( 2 );         verifier.verify( mockOne, atLeast(1)).oneArg( 1 );          // Then - no exception thrown     }      @Test     public void shouldVerifyWithTimesAfterCallsInSameChunk(){         // Given         mockOne.oneArg( 1 );         mockOne.oneArg( 1 );         mockOne.oneArg( 1 );          InOrder verifier = inOrder( mockOne );          // When         verifier.verify( mockOne, calls(1)).oneArg( 1 );         verifier.verify( mockOne, times(2)).oneArg( 1 );         verifier.verifyNoMoreInteractions();          // Then - no exception thrown     }      @Test     public void shouldFailToCreateCallsWithZeroArgument(){         // Given         InOrder verifier = inOrder( mockOne );         exceptionRule.expect( MockitoException.class );         exceptionRule.expectMessage( "Negative and zero values are not allowed here" );          // When         verifier.verify( mockOne, calls(0)).voidMethod();          // Then - expected exception thrown     }      @Test     public void shouldFailToCreateCallsWithNegativeArgument(){         // Given         InOrder verifier = inOrder( mockOne );         exceptionRule.expect( MockitoException.class );         exceptionRule.expectMessage( "Negative and zero values are not allowed here" );          // When         verifier.verify( mockOne, calls(-1)).voidMethod();          // Then - expected exception thrown     }      @Test     public void shouldFailToCreateCallsForNonInOrderVerification(){         // Given         mockOne.voidMethod();         exceptionRule.expect( MockitoException.class );         exceptionRule.expectMessage( "calls is only intended to work with InOrder" );          // When         verify( mockOne, calls(1)).voidMethod();          // Then - expected exception thrown     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set;  import org.junit.Test; import org.mockito.Mockito; import org.mockitoutil.TestBase;  @SuppressWarnings("unchecked") public class VerificationOnMultipleMocksUsingMatchersTest extends TestBase {      @Test     public void shouldVerifyUsingMatchers() throws Exception {         List list = Mockito.mock(List.class);         HashMap map = Mockito.mock(HashMap.class);                  list.add("test");         list.add(1, "test two");                  map.put("test", 100);         map.put("test two", 200);                  verify(list).add(anyObject());         verify(list).add(anyInt(), eq("test two"));                  verify(map, times(2)).put(anyObject(), anyObject());         verify(map).put(eq("test two"), eq(200));                  verifyNoMoreInteractions(list, map);     }          @Test     public void shouldVerifyMultipleMocks() throws Exception {         List list = mock(List.class);         Map map = mock(Map.class);         Set set = mock(Set.class);          list.add("one");         list.add("one");         list.add("two");                  map.put("one", 1);         map.put("one", 1);                  verify(list, times(2)).add("one");         verify(list, times(1)).add("two");         verify(list, times(0)).add("three");                  verify(map, times(2)).put(anyObject(), anyInt());                  verifyNoMoreInteractions(list, map);         verifyZeroInteractions(set);     } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.AdditionalMatchers.*; import static org.mockito.Matchers.*; import static org.mockito.Mockito.*;  import org.junit.Before; import org.junit.Test; import org.mockito.Matchers; import org.mockito.Mockito; import org.mockito.exceptions.verification.WantedButNotInvoked; import org.mockito.exceptions.verification.junit.ArgumentsAreDifferent; import org.mockitousage.IMethods; import org.mockitoutil.TestBase;  public class VerificationUsingMatchersTest extends TestBase {     private IMethods mock;      @Before     public void setUp() {         mock = Mockito.mock(IMethods.class);     }          @Test     public void shouldVerifyExactNumberOfInvocationsUsingMatcher() {         mock.simpleMethod(1);         mock.simpleMethod(2);         mock.simpleMethod(3);                  verify(mock, times(3)).simpleMethod(anyInt());     }      @Test     public void shouldVerifyUsingSameMatcher() {         Object one = new String("1243");         Object two = new String("1243");         Object three = new String("1243");          assertNotSame(one, two);         assertEquals(one, two);         assertEquals(two, three);          mock.oneArg(one);         mock.oneArg(two);                  verify(mock).oneArg(same(one));         verify(mock, times(2)).oneArg(two);                  try {             verify(mock).oneArg(same(three));             fail();         } catch (WantedButNotInvoked e) {}     }            @Test     public void shouldVerifyUsingMixedMatchers() {         mock.threeArgumentMethod(11, "", "01234");          try {             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains("123"));             fail();         } catch (ArgumentsAreDifferent e) {}          mock.threeArgumentMethod(8, new Object(), "01234");                  try {             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains("123"));             fail();         } catch (ArgumentsAreDifferent e) {}                  mock.threeArgumentMethod(8, "", "no match");          try {             verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains("123"));             fail();         } catch (ArgumentsAreDifferent e) {}                  mock.threeArgumentMethod(8, "", "123");                  verify(mock).threeArgumentMethod(and(geq(7), leq(10)), isA(String.class), Matchers.contains("123"));     } }
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitousage.verification;  import static org.mockito.Matchers.anyString; import static org.mockito.Mockito.inOrder; import static org.mockito.Mockito.never; import static org.mockito.Mockito.timeout; import static org.mockito.Mockito.times; import static org.mockito.Mockito.verify; import static org.mockito.Mockito.verifyNoMoreInteractions; import java.util.LinkedList; import java.util.List; import org.junit.After; import org.junit.Ignore; import org.junit.Test; import org.mockito.InOrder; import org.mockito.Mock; import org.mockito.exceptions.base.MockitoAssertionError; import org.mockito.exceptions.verification.NoInteractionsWanted; import org.mockito.exceptions.verification.TooLittleActualInvocations; import org.mockitoutil.TestBase;  public class VerificationWithTimeoutTest extends TestBase {      List<Exception> exceptions = new LinkedList<Exception>();      @After     public void after() {         //making sure there are no threading related exceptions         assertTrue(exceptions.isEmpty());         exceptions.clear();     }      @Mock     private List<String> mock;      @Test     public void shouldVerifyWithTimeout() {} // Defects4J: flaky method //     @Test //     public void shouldVerifyWithTimeout() throws Exception { //         //given //         Thread t = waitAndExerciseMock(20); //  //         //when //         t.start(); //  //         //then //         verify(mock, timeout(100)).clear(); //  //         verify(mock, timeout(100).atLeastOnce()).clear(); //         verify(mock, timeout(100).times(1)).clear(); //  //  //         verify(mock).clear(); //         verify(mock, times(1)).clear(); //     }      @Test     public void shouldFailVerificationWithTimeout() {} // Defects4J: flaky method //     @Test //     public void shouldFailVerificationWithTimeout() throws Exception { //         //given //         Thread t = waitAndExerciseMock(80); //  //         //when //         t.start(); //  //         //then //         verify(mock, never()).clear(); //         try { //             verify(mock, timeout(20).atLeastOnce()).clear(); //             fail(); //         } catch (MockitoAssertionError e) { //         } //     }      @Test     public void shouldAllowMixingOtherModesWithTimeout() {} // Defects4J: flaky method //     @Test //     public void shouldAllowMixingOtherModesWithTimeout() throws Exception { //         //given //         Thread t1 = waitAndExerciseMock(30); //         Thread t2 = waitAndExerciseMock(30); //  //         //when //         t1.start(); //         t2.start(); //  //         //then //         verify(mock, timeout(50).atLeast(1)).clear(); //         verify(mock, timeout(50).times(2)).clear(); //         verifyNoMoreInteractions(mock); //     }      @Test     public void shouldAllowMixingOtherModesWithTimeoutAndFail() {} // Defects4J: flaky method //     @Test //     public void shouldAllowMixingOtherModesWithTimeoutAndFail() throws Exception { //         //given //         Thread t1 = waitAndExerciseMock(30); //         Thread t2 = waitAndExerciseMock(30); //  //         //when //         t1.start(); //         t2.start(); //  //         //then //         verify(mock, timeout(50).atLeast(1)).clear(); //         try { //             verify(mock, timeout(100).times(3)).clear(); //             fail(); //         } catch (TooLittleActualInvocations e) {} //     }      @Test     public void shouldAllowMixingOnlyWithTimeout() {} // Defects4J: flaky method //     @Test //     public void shouldAllowMixingOnlyWithTimeout() throws Exception { //         //given //         Thread t1 = waitAndExerciseMock(20); //  //         //when //         t1.start(); //  //         //then //         verify(mock, never()).clear(); //         verify(mock, timeout(40).only()).clear(); //     }      @Test     public void shouldAllowMixingOnlyWithTimeoutAndFail() {} // Defects4J: flaky method //     @Test //     public void shouldAllowMixingOnlyWithTimeoutAndFail() throws Exception { //         //given //         Thread t1 = waitAndExerciseMock(20); //  //         //when //         t1.start(); //         mock.add("foo"); //  //         //then //         verify(mock, never()).clear(); //         try { //             verify(mock, timeout(40).only()).clear(); //             fail(); //         } catch (NoInteractionsWanted e) {} //     }      /**      * This test is JUnit-specific because the code behaves different if JUnit is used.      */     @Test     public void canIgnoreInvocationsWithJunit() {         //given         Thread t1 = new Thread() {             @Override             public void run() {                 mock.add("0");                 mock.add("1");                 VerificationWithTimeoutTest.this.sleep(100);                 mock.add("2");             }         };          //when         t1.start();          //then         verify(mock, timeout(200)).add("1");         verify(mock, timeout(200)).add("2");     }      private void sleep(long milliseconds) {         try {             Thread.sleep(milliseconds);         } catch (InterruptedException ignored) {             // we do not need to handle this.         }     }      //TODO not yet implemented     @Ignore("TODO not yet implemented")     @Test     public void shouldAllowTimeoutVerificationInOrder() throws Exception {         //given         Thread t1 = waitAndExerciseMock(20);          //when         t1.start();         mock.add("foo");          //then         InOrder inOrder = inOrder(mock);         inOrder.verify(mock).add(anyString());         inOrder.verify(mock, never()).clear();         inOrder.verify(mock, timeout(40)).clear();     }      private Thread waitAndExerciseMock(final int sleep) {         Thread t = new Thread() {             @Override             public void run() {                 try {                     Thread.sleep(sleep);                 } catch (InterruptedException e) {                     exceptions.add(e);                     throw new RuntimeException(e);                 }                 mock.clear();             }         };         return t;     } } 
package org.mockitoutil;  import org.junit.Test; import org.mockito.Mockito;  import static org.fest.assertions.Assertions.assertThat; import static org.junit.Assert.fail; import static org.mockitoutil.ClassLoaders.currentClassLoader; import static org.mockitoutil.ClassLoaders.excludingClassLoader; import static org.mockitoutil.ClassLoaders.isolatedClassLoader; import static org.mockitoutil.ClassLoaders.jdkClassLoader;  public class ClassLoadersTest {      public static final String CLASS_NAME_USING_INTERFACE = "org.mockitoutil.ClassLoadersTest$ClassUsingInterface1";     public static final String INTERFACE_NAME = "org.mockitoutil.ClassLoadersTest$Interface1";      @Test(expected = ClassNotFoundException.class)     public void isolated_class_loader_cannot_load_classes_when_no_given_prefix() throws Exception {         // given         ClassLoader cl = isolatedClassLoader().build();          // when         cl.loadClass("org.mockito.Mockito");          // then raises CNFE     }      @Test     public void isolated_class_loader_cannot_load_classes_if_no_code_source_path() throws Exception {         // given         ClassLoader cl = isolatedClassLoader()                 .withPrivateCopyOf(CLASS_NAME_USING_INTERFACE)                 .build();          // when         try {             cl.loadClass(CLASS_NAME_USING_INTERFACE);             fail();         } catch (ClassNotFoundException e) {             // then             assertThat(e.getMessage()).contains(CLASS_NAME_USING_INTERFACE);         }     }      @Test     public void isolated_class_loader_cannot_load_classes_not_matching_the_prefix() throws Exception {         // given         ClassLoader cl = isolatedClassLoader()                 .withCurrentCodeSourceUrls()                 .withPrivateCopyOf(CLASS_NAME_USING_INTERFACE)                 .build();          // when         try {             cl.loadClass(CLASS_NAME_USING_INTERFACE);             fail();         } catch (NoClassDefFoundError e) {             // then             assertThat(e.getMessage()).contains("org/mockitoutil/ClassLoadersTest$Interface1");         }     }      @Test     public void isolated_class_loader_can_load_all_classes_unless_all_classes_mathch_the_prefixes() throws Exception {         // given         ClassLoader cl = isolatedClassLoader()                 .withCurrentCodeSourceUrls()                 .withPrivateCopyOf(CLASS_NAME_USING_INTERFACE)                 .withPrivateCopyOf(INTERFACE_NAME)                 .build();          // when         Class<?> aClass = cl.loadClass(CLASS_NAME_USING_INTERFACE);          // then         assertThat(aClass).isNotNull();         assertThat(aClass.getClassLoader()).isEqualTo(cl);         assertThat(aClass.getInterfaces()[0].getClassLoader()).isEqualTo(cl);     }      @Test     public void isolated_class_loader_has_no_parent() throws Exception {         ClassLoader cl = isolatedClassLoader()                 .withCurrentCodeSourceUrls()                 .withPrivateCopyOf(CLASS_NAME_USING_INTERFACE)                 .withPrivateCopyOf(INTERFACE_NAME)                 .build();          assertThat(cl.getParent()).isNull();     }      @Test(expected = ClassNotFoundException.class)     public void excluding_class_loader_cannot_load_classes_when_no_correct_source_url_set() throws Exception {         // given         ClassLoader cl = excludingClassLoader()                 .withCodeSourceUrlOf(this.getClass())                 .build();          // when         cl.loadClass("org.mockito.Mockito");          // then class CNFE     }      @Test     public void excluding_class_loader_can_load_classes_when_correct_source_url_set() throws Exception {         // given         ClassLoader cl = excludingClassLoader()                 .withCodeSourceUrlOf(Mockito.class)                 .build();          // when         cl.loadClass("org.mockito.Mockito");          // then class successfully loaded     }      @Test     public void excluding_class_loader_cannot_load_class_when_excluded_prefix_match_class_to_load() throws Exception {         // given         ClassLoader cl = excludingClassLoader()                 .withCodeSourceUrlOf(Mockito.class)                 .without("org.mockito.BDDMockito")                 .build();          cl.loadClass("org.mockito.Mockito");          // when         try {             cl.loadClass("org.mockito.BDDMockito");             fail("should have raise a ClassNotFoundException");         } catch (ClassNotFoundException e) {             assertThat(e.getMessage()).contains("org.mockito.BDDMockito");         }          // then class successfully loaded     }      @Test     public void can_not_load_a_class_not_previously_registered_in_builder() throws Exception {         // given         ClassLoader cl = ClassLoaders                 .inMemoryClassLoader()                 .withClassDefinition("yop.Dude", SimpleClassGenerator.makeMarkerInterface("yop.Dude"))                 .build();          // when         try {             cl.loadClass("not.Defined");             fail();         } catch (ClassNotFoundException e) {             // then             assertThat(e.getMessage()).contains("not.Defined");         }     }      @Test     public void can_load_a_class_in_memory_from_bytes() throws Exception {         // given         ClassLoader cl = ClassLoaders                 .inMemoryClassLoader()                 .withClassDefinition("yop.Dude", SimpleClassGenerator.makeMarkerInterface("yop.Dude"))                 .build();          // when         Class<?> aClass = cl.loadClass("yop.Dude");          // then         assertThat(aClass).isNotNull();         assertThat(aClass.getClassLoader()).isEqualTo(cl);         assertThat(aClass.getName()).isEqualTo("yop.Dude");     }      @Test     public void cannot_load_a_class_file_not_in_parent() throws Exception {         // given         ClassLoader cl = ClassLoaders                 .inMemoryClassLoader()                 .withParent(jdkClassLoader())                 .build();          cl.loadClass("java.lang.String");          try {             // when             cl.loadClass("org.mockito.Mockito");             fail("should have not found Mockito class");         } catch (ClassNotFoundException e) {             // then             assertThat(e.getMessage()).contains("org.mockito.Mockito");         }     }      @Test     public void can_list_all_classes_reachable_in_a_classloader() throws Exception {         ClassLoader classLoader = ClassLoaders.inMemoryClassLoader()                 .withParent(jdkClassLoader())                 .withClassDefinition("a.A", SimpleClassGenerator.makeMarkerInterface("a.A"))                 .withClassDefinition("a.b.B", SimpleClassGenerator.makeMarkerInterface("a.b.B"))                 .withClassDefinition("c.C", SimpleClassGenerator.makeMarkerInterface("c.C")) //                .withCodeSourceUrlOf(ClassLoaders.class)                 .build();          assertThat(ClassLoaders.in(classLoader).listOwnedClasses()).containsOnly("a.A", "a.b.B", "c.C");         assertThat(ClassLoaders.in(classLoader).omit("b", "c").listOwnedClasses()).containsOnly("a.A");     }      @Test     public void return_bootstrap_classloader() throws Exception {         assertThat(jdkClassLoader()).isNotEqualTo(Mockito.class.getClassLoader());         assertThat(jdkClassLoader()).isNotEqualTo(ClassLoaders.class.getClassLoader());         assertThat(jdkClassLoader()).isEqualTo(Number.class.getClassLoader());         assertThat(jdkClassLoader()).isEqualTo(null);     }      @Test     public void return_current_classloader() throws Exception {         assertThat(currentClassLoader()).isEqualTo(this.getClass().getClassLoader());     }      static class ClassUsingInterface1 implements Interface1 { }     interface Interface1 { } } 
/*  * Copyright (c) 2007 Mockito contributors  * This program is made available under the terms of the MIT License.  */  package org.mockitoutil;  import org.junit.Test;  public class CustomAssertionsTest extends TestBase {      @Test     public void shouldKnowWhenStringContainsIgnoringCase() throws Exception {         assertContainsIgnoringCase("foo", "foo");         assertContainsIgnoringCase("fOo", "foo");         assertContainsIgnoringCase("FoO", "foo");         assertContainsIgnoringCase("foo", "a foo :)");         assertContainsIgnoringCase("fOo", "a foo :)");         assertContainsIgnoringCase("FoO", "a foo :)");         assertContainsIgnoringCase("", "a foo :)");         assertContainsIgnoringCase("", "");     }      @Test(expected = AssertionError.class)     public void shouldKnowWhenStringDoesNotContainIgnoringCase() throws Exception {         assertContainsIgnoringCase("fooo", "foo");     }      @Test(expected = AssertionError.class)     public void shouldKnowWhenStringDoesNotContainIgnoringCase2() throws Exception {         assertContainsIgnoringCase("fOo", "f oo");     } }
