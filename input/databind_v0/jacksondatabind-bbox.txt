package com.fasterxml.jackson.databind;  import java.io.*; import java.math.BigDecimal; import java.math.BigInteger;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.IOContext; import com.fasterxml.jackson.core.base.ParserBase; import com.fasterxml.jackson.core.base.GeneratorBase; import com.fasterxml.jackson.databind.ObjectMapper;  /**  * Basic tests to ensure that {@link FormatSchema} instances are properly  * passed to {@link JsonGenerator} and {@link JsonParser} instances if  * mapper, reader or writer is configured with one.  */ public class TestFormatSchema extends BaseMapTest {     /*     /**********************************************************************     /* Helper classes     /**********************************************************************      */      static class MySchema implements FormatSchema {         @Override         public String getSchemaType() { return "test"; }     }          static class FactoryWithSchema extends JsonFactory     {         @Override         public String getFormatName() { return "test"; }          @Override         public boolean canUseSchema(FormatSchema schema) {             return (schema instanceof MySchema);         }                  private static final long serialVersionUID = 1L;         @Override         protected JsonParser _createParser(Reader r, IOContext ctxt)             throws IOException, JsonParseException         {             return new ParserWithSchema(ctxt, _parserFeatures);         }          @Override         protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException         {             return new GeneratorWithSchema(_generatorFeatures, _objectCodec);         }     }      // Ugly, but easiest way to get schema back is to throw exception...     @SuppressWarnings("serial")     static class SchemaException extends RuntimeException     {         public final FormatSchema _schema;                  public SchemaException(FormatSchema s) {             _schema = s;         }     }          static class ParserWithSchema extends ParserBase     {         public ParserWithSchema(IOContext ioCtxt, int features)         {             super(ioCtxt, features);         }          @Override         public void setSchema(FormatSchema schema) {             throw new SchemaException(schema);         }          @Override         protected void _finishString() throws IOException, JsonParseException { }          @Override         public byte[] getBinaryValue(Base64Variant b64variant) {             return null;         }          @Override         public byte[] getEmbeddedObject() {             return null;         }          @Override         public String getText() throws IOException, JsonParseException {             return null;         }          @Override         public char[] getTextCharacters() throws IOException {             return null;         }          @Override         public int getTextLength() throws IOException, JsonParseException {             return 0;         }          @Override         public int getTextOffset() throws IOException, JsonParseException {             return 0;         }          @Override         public JsonToken nextToken() throws IOException, JsonParseException {             return null;         }          @Override         public ObjectCodec getCodec() {             return null;         }          @Override         public void setCodec(ObjectCodec c) { }          @Override         protected boolean loadMore() throws IOException {             return false;         }          @Override         protected void _closeInput() throws IOException {         }          @Override         public int readBinaryValue(Base64Variant b64variant, OutputStream out) {             return 0;         }     }      static class GeneratorWithSchema extends GeneratorBase     {         public GeneratorWithSchema(int features, ObjectCodec codec)         {             super(features, codec);         }          @Override         public void setSchema(FormatSchema schema) {             throw new SchemaException(schema);         }          @Override         protected void _releaseBuffers() { }          @Override         protected void _verifyValueWrite(String typeMsg) throws IOException { }          @Override         public void flush() throws IOException { }          @Override         public void writeBinary(Base64Variant b64variant, byte[] data,                 int offset, int len) throws IOException { }          @Override         public void writeBoolean(boolean state) throws IOException { }          @Override         public void writeFieldName(String name) throws IOException { }          @Override         public void writeNull() throws IOException, JsonGenerationException { }          @Override         public void writeNumber(short v) throws IOException { }          @Override         public void writeNumber(int v) throws IOException { }          @Override         public void writeNumber(long v) throws IOException { }          @Override         public void writeNumber(BigInteger v) throws IOException { }          @Override         public void writeNumber(double d) throws IOException { }          @Override         public void writeNumber(float f) throws IOException { }          @Override         public void writeNumber(BigDecimal dec) throws IOException { }          @Override         public void writeNumber(String encodedValue) throws IOException { }          @Override         public void writeRaw(String text) throws IOException { }          @Override         public void writeRaw(String text, int offset, int len) { }          @Override         public void writeRaw(char[] text, int offset, int len) { }          @Override         public void writeRaw(char c) throws IOException { }          @Override         public void writeRawUTF8String(byte[] text, int offset, int length) { }          @Override         public void writeString(String text) throws IOException { }          @Override         public void writeString(char[] text, int offset, int len) { }          @Override         public void writeUTF8String(byte[] text, int offset, int length) { }          @Override         public void writeStartArray() { }          @Override         public void writeEndArray() throws IOException, JsonGenerationException { }          @Override         public void writeStartObject() { }          @Override         public void writeEndObject() { }          @Override         public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) {             return -1;         }     }          /*     /**********************************************************************     /* Unit tests     /**********************************************************************      */          public void testFormatForParsers() throws Exception     {         ObjectMapper mapper = new ObjectMapper(new FactoryWithSchema());         MySchema s = new MySchema();         StringReader r = new StringReader("{}");         //  bit ugly, but can't think of cleaner simple way to check this...         try {             mapper.reader(s).withType(Object.class).readValue(r);             fail("Excpected exception");         } catch (SchemaException e) {             assertSame(s, e._schema);         }     }      public void testFormatForGenerators() throws Exception     {         ObjectMapper mapper = new ObjectMapper(new FactoryWithSchema());         MySchema s = new MySchema();         StringWriter sw = new StringWriter();         //  bit ugly, but can't think of cleaner simple way to check this...         try {             mapper.writer(s).writeValue(sw, "Foobar");             fail("Excpected exception");         } catch (SchemaException e) {             assertSame(s, e._schema);         }     }  } 
package com.fasterxml.jackson.databind;  import java.io.IOException; import java.io.StringWriter;  import com.fasterxml.jackson.core.JsonFactory; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.SerializableString; import com.fasterxml.jackson.core.io.CharacterEscapes;  public class TestGeneratorUsingMapper extends BaseMapTest {     final static class Pojo     {         public int getX() { return 4; }     }      /*     /**********************************************************     /* Tests for data binding integration     /**********************************************************      */      public void testPojoWriting()         throws IOException     {         JsonFactory jf = new MappingJsonFactory();         StringWriter sw = new StringWriter();         JsonGenerator gen = jf.createGenerator(sw);         gen.writeObject(new Pojo());         gen.close();         // trimming needed if main-level object has leading space         String act = sw.toString().trim();         assertEquals("{\"x\":4}", act);     }      public void testPojoWritingFailing()         throws IOException     {         // regular factory can't do it, without a call to setCodec()         JsonFactory jf = new JsonFactory();         try {             StringWriter sw = new StringWriter();             JsonGenerator gen = jf.createGenerator(sw);             gen.writeObject(new Pojo());             gen.close();             fail("Expected an exception: got sw '"+sw.toString()+"'");         } catch (IllegalStateException e) {             verifyException(e, "No ObjectCodec defined");         }     }      public void testIssue820() throws IOException     {         StringBuffer sb = new StringBuffer();         while (sb.length() <= 5000) {             sb.append("Yet another line of text...\n");         }         String sampleText = sb.toString();         assertTrue(                 "Sanity check so I don't mess up the sample text later.",                 sampleText.contains("\n"));          final ObjectMapper mapper = new ObjectMapper();         final CharacterEscapes defaultCharacterEscapes = new CharacterEscapes() {             private static final long serialVersionUID = 1L;              @Override             public int[] getEscapeCodesForAscii() {                 return standardAsciiEscapesForJSON();             }              @Override             public SerializableString getEscapeSequence(final int ch) {                 return null;             }         };          mapper.getFactory().setCharacterEscapes(defaultCharacterEscapes);         String jacksonJson = mapper.writeValueAsString(sampleText);         boolean hasLFs = jacksonJson.indexOf('\n') > 0;         assertFalse("Should NOT contain linefeeds, should have been escaped", hasLFs);     }     } 
package com.fasterxml.jackson.databind;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.JsonDeserializer; import com.fasterxml.jackson.databind.JsonSerializer; import com.fasterxml.jackson.databind.KeyDeserializer; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializerProvider; import com.fasterxml.jackson.databind.annotation.*; import com.fasterxml.jackson.databind.cfg.HandlerInstantiator; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.introspect.Annotated; import com.fasterxml.jackson.databind.jsontype.TypeIdResolver; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.type.TypeFactory;  public class TestHandlerInstantiation extends BaseMapTest {     /*     /**********************************************************************     /* Helper classes, beans     /**********************************************************************      */      @JsonDeserialize(using=MyBeanDeserializer.class)     @JsonSerialize(using=MyBeanSerializer.class)     static class MyBean     {         public String value;          public MyBean() { this(null); }         public MyBean(String s) { value = s; }     }      @SuppressWarnings("serial")     @JsonDeserialize(keyUsing=MyKeyDeserializer.class)     static class MyMap extends HashMap<String,String> { }      @JsonTypeInfo(use=Id.CUSTOM, include=As.WRAPPER_ARRAY)     @JsonTypeIdResolver(CustomIdResolver.class)     static class TypeIdBean {         public int x;                  public TypeIdBean() { }         public TypeIdBean(int x) { this.x = x; }     }      static class TypeIdBeanWrapper {         public TypeIdBean bean;                  public TypeIdBeanWrapper() { this(null); }         public TypeIdBeanWrapper(TypeIdBean b) { bean = b; }     }          /*     /**********************************************************************     /* Helper classes, serializers/deserializers/resolvers     /**********************************************************************      */          static class MyBeanDeserializer extends JsonDeserializer<MyBean>     {         public String _prefix = "";          public MyBeanDeserializer(String p) {             _prefix  = p;         }                  @Override         public MyBean deserialize(JsonParser jp, DeserializationContext ctxt)                 throws IOException, JsonProcessingException         {             return new MyBean(_prefix+jp.getText());         }     }      static class MyKeyDeserializer extends KeyDeserializer     {         public MyKeyDeserializer() { }                  @Override         public Object deserializeKey(String key, DeserializationContext ctxt)                 throws IOException, JsonProcessingException         {             return "KEY";         }     }          static class MyBeanSerializer extends JsonSerializer<MyBean>     {         public String _prefix = "";          public MyBeanSerializer(String p) {             _prefix  = p;         }                  @Override         public void serialize(MyBean value, JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonProcessingException         {             jgen.writeString(_prefix + value.value);         }     }          // copied from "TestCustomTypeIdResolver"     static class CustomIdResolver implements TypeIdResolver     {         static List<JavaType> initTypes;          final String _id;                  public CustomIdResolver(String idForBean) {             _id = idForBean;         }                  @Override         public Id getMechanism() {             return Id.CUSTOM;         }         @Override         public String idFromValue(Object value)         {             if (value.getClass() == TypeIdBean.class) {                 return _id;             }             return "unknown";         }         @Override         public String idFromValueAndType(Object value, Class<?> type) {             return idFromValue(value);         }         @Override         public void init(JavaType baseType) {             if (initTypes != null) {                 initTypes.add(baseType);             }         }         @Override         public JavaType typeFromId(String id)         {             if (id.equals(_id)) {                 return TypeFactory.defaultInstance().constructType(TypeIdBean.class);             }             return null;         }         @Override         public String idFromBaseType() {             return "xxx";         }     }      /*     /**********************************************************************     /* Helper classes, handler instantiator     /**********************************************************************      */          static class MyInstantiator extends HandlerInstantiator     {         private final String _prefix;                  public MyInstantiator(String p) {             _prefix = p;         }                  @Override         public JsonDeserializer<?> deserializerInstance(DeserializationConfig config,                 Annotated annotated,                 Class<?> deserClass)         {             if (deserClass == MyBeanDeserializer.class) {                 return new MyBeanDeserializer(_prefix);             }             return null;         }          @Override         public KeyDeserializer keyDeserializerInstance(DeserializationConfig config,                 Annotated annotated, Class<?> keyDeserClass)         {             if (keyDeserClass == MyKeyDeserializer.class) {                 return new MyKeyDeserializer();             }             return null;                      }                  @Override         public JsonSerializer<?> serializerInstance(SerializationConfig config,                 Annotated annotated, Class<?> serClass)         {             if (serClass == MyBeanSerializer.class) {                 return new MyBeanSerializer(_prefix);             }             return null;         }          @Override         public TypeIdResolver typeIdResolverInstance(MapperConfig<?> config,                 Annotated annotated, Class<?> resolverClass)         {             if (resolverClass == CustomIdResolver.class) {                 return new CustomIdResolver("!!!");             }             return null;         }          @Override         public TypeResolverBuilder<?> typeResolverBuilderInstance(MapperConfig<?> config, Annotated annotated,                 Class<?> builderClass)         {             return null;         }     }          /*     /**********************************************************************     /* Unit tests     /**********************************************************************      */      public void testDeserializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setHandlerInstantiator(new MyInstantiator("abc:"));         MyBean result = mapper.readValue(quote("123"), MyBean.class);         assertEquals("abc:123", result.value);     }      public void testKeyDeserializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setHandlerInstantiator(new MyInstantiator("abc:"));         MyMap map = mapper.readValue("{\"a\":\"b\"}", MyMap.class);         // easiest to test by just serializing...         assertEquals("{\"KEY\":\"b\"}", mapper.writeValueAsString(map));     }          public void testSerializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setHandlerInstantiator(new MyInstantiator("xyz:"));         assertEquals(quote("xyz:456"), mapper.writeValueAsString(new MyBean("456")));     }      public void testTypeIdResolver() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setHandlerInstantiator(new MyInstantiator("foobar"));         String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123)));         // should now use our custom id scheme:         assertEquals("{\"bean\":[\"!!!\",{\"x\":123}]}", json);         // and bring it back too:         TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class);         TypeIdBean bean = result.bean;         assertEquals(123, bean.x);     }  } 
package com.fasterxml.jackson.databind;  import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream;  /**  * Tests to verify that most core Jackson components can be serialized  * using default JDK serialization: this feature is useful for some  * platforms, such as Android, where memory management is handled  * much more aggressively.  */ public class TestJDKSerialization extends BaseMapTest {     static class MyPojo {         public int x;         private int y;                  public MyPojo() { }         public MyPojo(int x0, int y0) {             x = x0;             y = y0;         }                  public int getY() { return y; }         public void setY(int y) { this.y = y; }     }          /*     /**********************************************************     /* Tests for individual objects     /**********************************************************      */      public void testConfigs() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         byte[] base = jdkSerialize(mapper.getDeserializationConfig().getBaseSettings());         assertNotNull(jdkDeserialize(base));          // first things first: underlying BaseSettings                  DeserializationConfig origDC = mapper.getDeserializationConfig();         SerializationConfig origSC = mapper.getSerializationConfig();         byte[] dcBytes = jdkSerialize(origDC);         byte[] scBytes = jdkSerialize(origSC);          DeserializationConfig dc = jdkDeserialize(dcBytes);         assertNotNull(dc);         assertEquals(dc._deserFeatures, origDC._deserFeatures);         SerializationConfig sc = jdkDeserialize(scBytes);         assertNotNull(sc);         assertEquals(sc._serFeatures, origSC._serFeatures);     }      public void testObjectWriter() throws IOException     {         ObjectWriter origWriter = new ObjectMapper().writer();         final String EXP_JSON = "{\"x\":2,\"y\":3}";         final MyPojo p = new MyPojo(2, 3);         assertEquals(EXP_JSON, origWriter.writeValueAsString(p));         byte[] bytes = jdkSerialize(origWriter);         ObjectWriter writer2 = jdkDeserialize(bytes);         assertEquals(EXP_JSON, writer2.writeValueAsString(p));     }          public void testObjectReader() throws IOException     {         ObjectReader origReader = new ObjectMapper().reader(MyPojo.class);         final String JSON = "{\"x\":1,\"y\":2}";         MyPojo p1 = origReader.readValue(JSON);         assertEquals(2, p1.y);         byte[] bytes = jdkSerialize(origReader);         ObjectReader reader2 = jdkDeserialize(bytes);         MyPojo p2 = reader2.readValue(JSON);         assertEquals(2, p2.y);     }      public void testObjectMapper() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         final String EXP_JSON = "{\"x\":2,\"y\":3}";         final MyPojo p = new MyPojo(2, 3);         assertEquals(EXP_JSON, mapper.writeValueAsString(p));          byte[] bytes = jdkSerialize(mapper);         ObjectMapper mapper2 = jdkDeserialize(bytes);         assertEquals(EXP_JSON, mapper2.writeValueAsString(p));         MyPojo p2 = mapper2.readValue(EXP_JSON, MyPojo.class);         assertEquals(p.x, p2.x);         assertEquals(p.y, p2.y);     }          /*     /**********************************************************     /* Helper methods     /**********************************************************      */          protected byte[] jdkSerialize(Object o) throws IOException     {         ByteArrayOutputStream bytes = new ByteArrayOutputStream(1000);         ObjectOutputStream obOut = new ObjectOutputStream(bytes);         obOut.writeObject(o);         obOut.close();         return bytes.toByteArray();     }      @SuppressWarnings("unchecked")     protected <T> T jdkDeserialize(byte[] raw) throws IOException     {         ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(raw));         try {             return (T) objIn.readObject();         } catch (ClassNotFoundException e) {             fail("Missing class: "+e.getMessage());             return null;         } finally {             objIn.close();         }     }  } 
package com.fasterxml.jackson.databind;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.PropertyNamingStrategy; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.annotation.JsonNaming; import com.fasterxml.jackson.databind.cfg.MapperConfig; import com.fasterxml.jackson.databind.introspect.AnnotatedField; import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;  /**  * Unit tests to verify functioning of {@link PropertyNamingStrategy} which  * was added in Jackson 1.8, as per [JACKSON-178].  */ @SuppressWarnings("serial") public class TestNamingStrategy extends BaseMapTest {     /*     /**********************************************************************     /* Helper classes     /**********************************************************************      */  	static class PrefixStrategy extends PropertyNamingStrategy     {         @Override         public String nameForField(MapperConfig<?> config,                 AnnotatedField field, String defaultName)         {             return "Field-"+defaultName;         }          @Override         public String nameForGetterMethod(MapperConfig<?> config,                 AnnotatedMethod method, String defaultName)         {             return "Get-"+defaultName;         }          @Override         public String nameForSetterMethod(MapperConfig<?> config,                 AnnotatedMethod method, String defaultName)         {             return "Set-"+defaultName;         }     }          static class CStyleStrategy extends PropertyNamingStrategy     {         @Override         public String nameForField(MapperConfig<?> config, AnnotatedField field, String defaultName)         {             return convert(defaultName);         }          @Override         public String nameForGetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName)         {             return convert(defaultName);         }          @Override         public String nameForSetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName)         {             return convert(defaultName);         }          private String convert(String input)         {             // easy: replace capital letters with underscore, lower-cases equivalent             StringBuilder result = new StringBuilder();             for (int i = 0, len = input.length(); i < len; ++i) {                 char c = input.charAt(i);                 if (Character.isUpperCase(c)) {                     result.append('_');                     c = Character.toLowerCase(c);                 }                 result.append(c);             }             return result.toString();         }     }          static class GetterBean {         public int getKey() { return 123; }     }      static class SetterBean {         protected int value;                  public void setKey(int v) {             value = v;         }     }      static class FieldBean {         public int key;          public FieldBean() { this(0); }         public FieldBean(int v) { key = v; }     }      @JsonPropertyOrder({"first_name", "last_name"})     static class PersonBean {         public String firstName;         public String lastName;         public int age;          public PersonBean() { this(null, null, 0); }         public PersonBean(String f, String l, int a)         {             firstName = f;             lastName = l;             age = a;         }     }      static class Value {         public int intValue;                  public Value() { this(0); }         public Value(int v) { intValue = v; }     }      static class SetterlessWithValue     {         protected ArrayList<Value> values = new ArrayList<Value>();          public List<Value> getValueList() { return values; }          public SetterlessWithValue add(int v) {             values.add(new Value(v));             return this;         }     }      // [JACKSON-687]     static class LcStrategy extends PropertyNamingStrategy.PropertyNamingStrategyBase     {         @Override         public String translate(String propertyName) {             return propertyName.toLowerCase();         }     }          static class RenamedCollectionBean     {         @JsonDeserialize         private List<String> THEvalues = Collections.emptyList();                  // intentionally odd name, to be renamed by naming strategy         public List<String> getTheVALUEs() { return THEvalues; }     }      // [Issue#45]: Support @JsonNaming     @JsonNaming(PrefixStrategy.class)     static class BeanWithPrefixNames     {         protected int a = 3;                  public int getA() { return a; }         public void setA(int value) { a = value; }     }          /*     /**********************************************************************     /* Test methods     /**********************************************************************      */          public void testSimpleGetters() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setPropertyNamingStrategy(new PrefixStrategy());         assertEquals("{\"Get-key\":123}", mapper.writeValueAsString(new GetterBean()));     }      public void testSimpleSetters() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setPropertyNamingStrategy(new PrefixStrategy());         SetterBean bean = mapper.readValue("{\"Set-key\":13}", SetterBean.class);         assertEquals(13, bean.value);     }      public void testSimpleFields() throws Exception     {         // First serialize         ObjectMapper mapper = new ObjectMapper();         mapper.setPropertyNamingStrategy(new PrefixStrategy());         String json = mapper.writeValueAsString(new FieldBean(999));         assertEquals("{\"Field-key\":999}", json);          // then deserialize         FieldBean result = mapper.readValue(json, FieldBean.class);         assertEquals(999, result.key);     }      public void testCStyleNaming() throws Exception     {         // First serialize         ObjectMapper mapper = new ObjectMapper();         mapper.setPropertyNamingStrategy(new CStyleStrategy());         String json = mapper.writeValueAsString(new PersonBean("Joe", "Sixpack", 42));         assertEquals("{\"first_name\":\"Joe\",\"last_name\":\"Sixpack\",\"age\":42}", json);                  // then deserialize         PersonBean result = mapper.readValue(json, PersonBean.class);         assertEquals("Joe", result.firstName);         assertEquals("Sixpack", result.lastName);         assertEquals(42, result.age);     }      public void testWithGetterAsSetter() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setPropertyNamingStrategy(new CStyleStrategy());         SetterlessWithValue input = new SetterlessWithValue().add(3);         String json = mapper.writeValueAsString(input);         assertEquals("{\"value_list\":[{\"int_value\":3}]}", json);          SetterlessWithValue result = mapper.readValue(json, SetterlessWithValue.class);         assertNotNull(result.values);         assertEquals(1, result.values.size());         assertEquals(3, result.values.get(0).intValue);     }      // For [JACKSON-687]     public void testJson() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setPropertyNamingStrategy(new LcStrategy()); //        mapper.disable(DeserializationConfig.DeserializationFeature.USE_GETTERS_AS_SETTERS);         RenamedCollectionBean foo = mapper.readValue("{\"thevalues\":[\"a\"]}", RenamedCollectionBean.class);         assertNotNull(foo.getTheVALUEs());         assertEquals(1, foo.getTheVALUEs().size());         assertEquals("a", foo.getTheVALUEs().get(0));     }      // @JsonNaming / [Issue#45]     public void testPerClassAnnotation() throws Exception     {         final ObjectMapper mapper = new ObjectMapper();         mapper.setPropertyNamingStrategy(new LcStrategy());         BeanWithPrefixNames input = new BeanWithPrefixNames();         String json = mapper.writeValueAsString(input);         assertEquals("{\"Get-a\":3}", json);          BeanWithPrefixNames output = mapper.readValue("{\"Set-a\":7}",                 BeanWithPrefixNames.class);         assertEquals(7, output.a);     } } 
package com.fasterxml.jackson.databind;  import java.io.*;  import com.fasterxml.jackson.core.JsonFactory; import com.fasterxml.jackson.core.JsonParser;  import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext; import com.fasterxml.jackson.databind.node.*; import com.fasterxml.jackson.databind.type.TypeFactory;  public class TestObjectMapper extends BaseMapTest {     static class Bean {         int value = 3;                  public void setX(int v) { value = v; }     }      // for [Issue#206]     @SuppressWarnings("serial")     static class CustomMapper extends ObjectMapper {         @Override         protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,                 DeserializationConfig cfg) {             return super.createDeserializationContext(jp, cfg);         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */          final static ObjectMapper MAPPER = new ObjectMapper();          public void testProps()     {         ObjectMapper m = new ObjectMapper();         // should have default factory         assertNotNull(m.getNodeFactory());         JsonNodeFactory nf = JsonNodeFactory.instance;         m.setNodeFactory(nf);         assertSame(nf, m.getNodeFactory());     }      public void testSupport()     {         assertTrue(MAPPER.canSerialize(String.class));         assertTrue(MAPPER.canDeserialize(TypeFactory.defaultInstance().constructType(String.class)));     }      public void testTreeRead() throws Exception     {         String JSON = "{ }";         JsonNode n = MAPPER.readTree(JSON);         assertTrue(n instanceof ObjectNode);          n = MAPPER.readTree(new StringReader(JSON));         assertTrue(n instanceof ObjectNode);          n = MAPPER.readTree(new ByteArrayInputStream(JSON.getBytes("UTF-8")));         assertTrue(n instanceof ObjectNode);     }      // Test to ensure that we can check property ordering defaults...     public void testConfigForPropertySorting() throws Exception     {         ObjectMapper m = new ObjectMapper();                  // sort-alphabetically is disabled by default:         assertFalse(m.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));         SerializationConfig sc = m.getSerializationConfig();         assertFalse(sc.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));         assertFalse(sc.shouldSortPropertiesAlphabetically());         DeserializationConfig dc = m.getDeserializationConfig();         assertFalse(dc.shouldSortPropertiesAlphabetically());          // but when enabled, should be visible:         m.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);         sc = m.getSerializationConfig();         assertTrue(sc.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));         assertTrue(sc.shouldSortPropertiesAlphabetically());         dc = m.getDeserializationConfig();         // and not just via SerializationConfig, but also via DeserializationConfig         assertTrue(dc.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));         assertTrue(dc.shouldSortPropertiesAlphabetically());     }       public void testJsonFactoryLinkage()     {         // first, implicit factory, giving implicit linkage         assertSame(MAPPER, MAPPER.getFactory().getCodec());          // and then explicit factory, which should also be implicitly linked         JsonFactory f = new JsonFactory();         ObjectMapper m = new ObjectMapper(f);         assertSame(f, m.getFactory());         assertSame(m, f.getCodec());     }          /**      * Test for verifying working of [JACKSON-191]      */     public void testProviderConfig() throws Exception        {         ObjectMapper m = new ObjectMapper();          assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());         // and then should get one constructed for:         Bean bean = m.readValue("{ \"x\" : 3 }", Bean.class);         assertNotNull(bean);         assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount());         m._deserializationContext._cache.flushCachedDeserializers();         assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());     }          // [Issue#28]: ObjectMapper.copy()     public void testCopy() throws Exception     {         ObjectMapper m = new ObjectMapper();         assertTrue(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));         m.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);         assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));          // // First: verify that handling of features is decoupled:                  ObjectMapper m2 = m.copy();         assertFalse(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));         m2.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);         assertTrue(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));         // but should NOT change the original         assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));          // nor vice versa:         assertFalse(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));         assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));         m.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);         assertTrue(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));         assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));          // // Also, underlying JsonFactory instances should be distinct                  assertNotSame(m.getFactory(), m2.getFactory());          // [Issue#122]: Need to ensure mix-ins are not shared         assertEquals(0, m.getSerializationConfig().mixInCount());         assertEquals(0, m2.getSerializationConfig().mixInCount());         assertEquals(0, m.getDeserializationConfig().mixInCount());         assertEquals(0, m2.getDeserializationConfig().mixInCount());          m.addMixInAnnotations(String.class, Integer.class);         assertEquals(1, m.getSerializationConfig().mixInCount());         assertEquals(0, m2.getSerializationConfig().mixInCount());         assertEquals(1, m.getDeserializationConfig().mixInCount());         assertEquals(0, m2.getDeserializationConfig().mixInCount());     } } 
package com.fasterxml.jackson.databind;  import java.io.*; import java.net.URI; import java.util.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.JsonMappingException; import com.fasterxml.jackson.databind.JsonSerializable; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializerProvider; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.test.BaseTest;  /**  * Unit tests for verifying deserialization of Beans.  */ public class TestObjectMapperBeanDeserializer     extends BaseTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      final static class CtorValueBean         implements JsonSerializable // so we can output as simple String     {         final String _desc;          public CtorValueBean(String d) { _desc = d; }         public CtorValueBean(int value) { _desc = String.valueOf(value); }         public CtorValueBean(long value) { _desc = String.valueOf(value); }          @Override         public void serialize(JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonGenerationException         {             jgen.writeString(_desc);         }          @Override public String toString() { return _desc; }          @Override public boolean equals(Object o) {             if (!(o instanceof CtorValueBean)) return false;             CtorValueBean other = (CtorValueBean) o;             return _desc.equals(other._desc);         }         @Override         public void serializeWithType(JsonGenerator jgen,                 SerializerProvider provider, TypeSerializer typeSer)                 throws IOException, JsonProcessingException {         }     }      final static class FactoryValueBean     {         final String _desc;          protected FactoryValueBean(String desc, int dummy) { _desc = desc; }          public static FactoryValueBean valueOf(String v) { return new FactoryValueBean(v, 0); }         public static FactoryValueBean valueOf(int v) { return new FactoryValueBean(String.valueOf(v), 0); }         public static FactoryValueBean valueOf(long v) { return new FactoryValueBean(String.valueOf(v), 0); }          @Override public String toString() { return _desc; }     }      /**      * Simple test bean      */     public final static class TestBean     {         int _x;         long _y;         String _desc;         URI _uri;         Collection<?> _misc;          // Explicit constructor         public TestBean(int x, long y, String desc, URI uri, Collection<?> misc)         {             _x = x;             _y = y;             _desc = desc;             _uri = uri;             _misc = misc;         }          // plus default one that is needed for deserialization         public TestBean() { }          public String getDesc() { return _desc; }         public int getX() { return _x; }         public long getY() { return _y; }         public URI getURI() { return _uri; }         public Collection<?> getMisc() { return _misc; }          public void setDesc(String value) { _desc = value; }         public void setX(int value) { _x = value; }         public void setY(long value) { _y = value; }         public void setURI(URI value) { _uri = value; }         public void setMisc(Collection<?> value) { _misc = value; }          @Override         public boolean equals(Object o)         {             if (o == null || o.getClass() != getClass()) return false;             TestBean other = (TestBean) o;             return (other._x == _x)                 && (other._y == _y)                 && (other._desc.equals(_desc))                 && (other._uri.equals(_uri))                 && (other._misc.equals(_misc))                 ;         }          @Override         public String toString()         {             StringBuilder sb = new StringBuilder();             sb.append("[TestBean ");             sb.append("x=").append(_x);             sb.append(" y=").append(_y);             sb.append(" desc=").append(_desc);             sb.append(" uri=").append(_uri);             sb.append(" misc=").append(_misc);             sb.append("]");             return sb.toString();         }     }      /**      * Another test bean, this one containing a typed list. Needed to ensure      * that generics type information is properly accessed via mutator methods.      * Note: List elements must be something other than what 'untyped' mapper      * would produce from serialization.      */     public final static class BeanWithList     {         List<CtorValueBean> _beans;          public BeanWithList() { }         public BeanWithList(List<CtorValueBean> beans) { _beans = beans; }          public List<CtorValueBean> getBeans() { return _beans; }          public void setBeans(List<CtorValueBean> beans) {             _beans = beans;         }          @Override         public int hashCode() { return (_beans == null) ? -1 : _beans.size(); }          @Override         public boolean equals(Object o) {             if (!(o instanceof BeanWithList)) return false;             BeanWithList other = BeanWithList.class.cast(o);             return _beans.equals(other._beans);         }          @Override             public String toString() {             StringBuilder sb = new StringBuilder();             sb.append("[Bean, list ");             if (_beans == null) {                 sb.append("NULL");             } else {                 sb.append('(').append(_beans.size()).append('/');                 sb.append(_beans.getClass().getName()).append(") ");                 boolean type = false;                 for (CtorValueBean bean : _beans) {                     if (!type) {                         sb.append("(").append(bean.getClass().getSimpleName()).append(")");                         type = true;                     }                     sb.append(bean);                     sb.append(' ');                 }             }             sb.append(']');             return sb.toString();         }     }      /*     /**********************************************************     /* Deserialization from simple types (String, int)     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testFromStringCtor() throws Exception     {         CtorValueBean result = MAPPER.readValue("\"abc\"", CtorValueBean.class);         assertEquals("abc", result.toString());     }      public void testFromIntCtor() throws Exception     {         CtorValueBean result = MAPPER.readValue("13", CtorValueBean.class);         assertEquals("13", result.toString());     }      public void testFromLongCtor() throws Exception     {         // Must use something that is forced as Long...         long value = 12345678901244L;         CtorValueBean result = MAPPER.readValue(""+value, CtorValueBean.class);         assertEquals(""+value, result.toString());     }      public void testFromStringFactory() throws Exception     {         FactoryValueBean result = MAPPER.readValue("\"abc\"", FactoryValueBean.class);         assertEquals("abc", result.toString());     }      public void testFromIntFactory() throws Exception     {         FactoryValueBean result = MAPPER.readValue("13", FactoryValueBean.class);         assertEquals("13", result.toString());     }      public void testFromLongFactory() throws Exception     {         // Must use something that is forced as Long...         long value = 12345678901244L;         FactoryValueBean result = MAPPER.readValue(""+value, FactoryValueBean.class);         assertEquals(""+value, result.toString());     }      /*     /**********************************************************     /* Deserialization from JSON Object     /**********************************************************      */      public void testSimpleBean() throws Exception     {         ArrayList<Object> misc = new ArrayList<Object>();         misc.add("xyz");         misc.add(42);         misc.add(null);         misc.add(Boolean.TRUE);         TestBean bean = new TestBean(13, -900L, "\"test\"", new URI("http://foobar.com"), misc);          // Hmmh. We probably should use serializer too... easier         String json = MAPPER.writeValueAsString(bean);          TestBean result = MAPPER.readValue(json, TestBean.class);         assertEquals(bean, result);     }      public void testListBean() throws Exception     {         final int COUNT = 13;         ArrayList<CtorValueBean> beans = new ArrayList<CtorValueBean>();         for (int i = 0; i < COUNT; ++i) {             beans.add(new CtorValueBean(i));         }         BeanWithList bean = new BeanWithList(beans);          StringWriter sw = new StringWriter();         MAPPER.writeValue(sw, bean);          BeanWithList result = MAPPER.readValue(sw.toString(), BeanWithList.class);         assertEquals(bean, result);     }      /**      * Also, let's verify that unknown fields cause an exception with default      * settings.      */     public void testUnknownFields() throws Exception     {         try {             TestBean bean = MAPPER.readValue("{ \"foobar\" : 3 }", TestBean.class);             fail("Expected an exception, got bean: "+bean);         } catch (JsonMappingException jse) {             ;         }     } } 
package com.fasterxml.jackson.databind;   import java.io.*; import java.net.*; import java.math.BigDecimal; import java.math.BigInteger;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.test.BaseTest;  /**  * This unit test suite tries to verify that the "Native" java type  * mapper can properly serialize Java core objects to JSON.  *  * @author Scott Dixon  */ public class TestObjectMapperBeanSerializer     extends BaseTest {     /**      * Sanity test to ensure the pieces all work when put together.      */     public void testComplexObject()         throws Exception     {         FixtureObject  aTestObj = new FixtureObject();         ObjectMapper aMapper  = new ObjectMapper();         StringWriter aWriter = new StringWriter();         JsonGenerator aGen = new JsonFactory().createGenerator(aWriter);         aMapper.writeValue(aGen, aTestObj);         aGen.close();         JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString()));          assertEquals(JsonToken.START_OBJECT, jp.nextToken());          while (jp.nextToken() != JsonToken.END_OBJECT) {             assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken());             String name = jp.getCurrentName();             JsonToken t = jp.nextToken();              if (name.equals("uri")) {                 assertToken(JsonToken.VALUE_STRING, t);                 assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp));             } else if (name.equals("url")) {                 assertToken(JsonToken.VALUE_STRING, t);                 assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp));             } else if (name.equals("testNull")) {                 assertToken(JsonToken.VALUE_NULL, t);             } else if (name.equals("testString")) {                 assertToken(JsonToken.VALUE_STRING, t);                 assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp));             } else if (name.equals("testBoolean")) {                 assertToken(JsonToken.VALUE_TRUE, t);             } else if (name.equals("testEnum")) {                 assertToken(JsonToken.VALUE_STRING, t);                 assertEquals(FixtureObject.VALUE_ENUM.toString(),getAndVerifyText(jp));             } else if (name.equals("testInteger")) {                 assertToken(JsonToken.VALUE_NUMBER_INT, t);                 assertEquals(jp.getIntValue(),FixtureObject.VALUE_INT);             } else if (name.equals("testLong")) {                 assertToken(JsonToken.VALUE_NUMBER_INT, t);                 assertEquals(jp.getLongValue(),FixtureObject.VALUE_LONG);             } else if (name.equals("testBigInteger")) {                 assertToken(JsonToken.VALUE_NUMBER_INT, t);                 assertEquals(jp.getLongValue(),FixtureObject.VALUE_BIGINT.longValue());             } else if (name.equals("testBigDecimal")) {                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, t);                 assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString());             } else if (name.equals("testCharacter")) {                 assertToken(JsonToken.VALUE_STRING, t);                 assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp));             } else if (name.equals("testShort")) {                 assertToken(JsonToken.VALUE_NUMBER_INT, t);                 assertEquals(jp.getIntValue(),FixtureObject.VALUE_SHORT);             } else if (name.equals("testByte")) {                 assertToken(JsonToken.VALUE_NUMBER_INT, t);                 assertEquals(jp.getIntValue(),FixtureObject.VALUE_BYTE);             } else if (name.equals("testFloat")) {                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, t);                 assertEquals(jp.getDecimalValue().floatValue(),FixtureObject.VALUE_FLOAT);             } else if (name.equals("testDouble")) {                 assertToken(JsonToken.VALUE_NUMBER_FLOAT, t);                 assertEquals(jp.getDoubleValue(),FixtureObject.VALUE_DBL);             } else if (name.equals("testStringBuffer")) {                 assertToken(JsonToken.VALUE_STRING, t);                 assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp));             } else if (name.equals("testError")) {                 // More complicated...                 assertToken(JsonToken.START_OBJECT, t);                  //getTestError->Exception::getCause                                  while (jp.nextToken() == JsonToken.FIELD_NAME) {                     name = jp.getCurrentName();                     if (name.equals("cause")) {                         assertEquals(JsonToken.VALUE_NULL, jp.nextToken());                     } else if (name.equals("message")) {                         assertEquals(JsonToken.VALUE_STRING, jp.nextToken());                         assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp));                     } else if (name.equals("localizedMessage")) {                         assertEquals(JsonToken.VALUE_STRING, jp.nextToken());                     } else if (name.equals("stackTrace")) {                         assertEquals(JsonToken.START_ARRAY,jp.nextToken());                         int i = 0;                         while(jp.nextToken() != JsonToken.END_ARRAY) {                             if(i >= 100000) {                                 assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.",false);                             }                         }                     } else if (name.equals("suppressed")) {                         // JDK 7 has introduced a new property 'suppressed' to Throwable; skip if seen                         assertEquals(JsonToken.START_ARRAY,jp.nextToken());                         assertEquals(JsonToken.END_ARRAY,jp.nextToken());                     } else {                         fail("Unexpected field name '"+name+"'");                     }                 }                 //CLOSE OF THE EXCEPTION                 assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken());             } else {                 fail("Unexpected field, name '"+name+"'");             }         }          //END OF TOKEN PARSING         assertNull(jp.nextToken());     }      private static enum EFixtureEnum     {         THIS_IS_AN_ENUM_VALUE_0,         THIS_IS_AN_ENUM_VALUE_1,         THIS_IS_AN_ENUM_VALUE_2,         THIS_IS_AN_ENUM_VALUE_3,     }      @SuppressWarnings("unused")     private static class FixtureObjectBase     {         public static final String       VALUE_STRING = "foobar";         public static final EFixtureEnum VALUE_ENUM   = EFixtureEnum.THIS_IS_AN_ENUM_VALUE_2;         public static final int          VALUE_INT    = Integer.MIN_VALUE;         public static final long         VALUE_LONG   = Long.MIN_VALUE;         public static final BigInteger   VALUE_BIGINT = new BigInteger((new Long(Long.MAX_VALUE)).toString());         public static final BigDecimal   VALUE_BIGDEC = new BigDecimal((new Double(Double.MAX_VALUE)).toString());         // this is not necessarily a good char to check         public static final char         VALUE_CHAR   = Character.MAX_VALUE;         public static final short        VALUE_SHORT  = Short.MAX_VALUE;         public static final byte         VALUE_BYTE   = Byte.MAX_VALUE;         public static final float        VALUE_FLOAT  = Float.MAX_VALUE;         public static final double       VALUE_DBL    = Double.MAX_VALUE;         public static final String       VALUE_ERRTXT = "This is the message text for the test error.";          public static final String       VALUE_URSTR  = "http://jackson.codehaus.org/hi?var1=foo%20bar";          public URL getURL() throws IOException         {             return new URL(VALUE_URSTR);         }          public URI getURI() throws IOException         {             try {                 return new URI(VALUE_URSTR);             } catch (Exception e) {                 throw new IllegalArgumentException(e);             }         }         public String getTestNull()         {             return null;         }         public String getTestString()         {             return VALUE_STRING;         }         public boolean getTestBoolean()         {             return true;         }         public EFixtureEnum getTestEnum()         {             return VALUE_ENUM;         }         public int getTestInteger()         {             return VALUE_INT;         }         public long getTestLong()         {             return VALUE_LONG;         }         public BigInteger getTestBigInteger()         {             return VALUE_BIGINT;         }         public BigDecimal getTestBigDecimal()         {             return VALUE_BIGDEC;         }         public char getTestCharacter()         {             return VALUE_CHAR;         }         public short getTestShort()         {             return VALUE_SHORT;         }         public byte getTestByte()         {             return VALUE_BYTE;         }         public float getTestFloat()         {             return VALUE_FLOAT;         }         public double getTestDouble()         {             return VALUE_DBL;         }         public StringBuffer getTestStringBuffer()         {             return new StringBuffer(VALUE_STRING);         }     }      @SuppressWarnings("unused")     private static class FixtureObject extends FixtureObjectBase     {         public Exception getTestError()         {             return new Exception(VALUE_ERRTXT);         }     } } 
package com.fasterxml.jackson.databind;  import java.io.IOException; import java.io.StringReader;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.io.CharacterEscapes; import com.fasterxml.jackson.core.io.SerializedString;  import com.fasterxml.jackson.databind.ObjectMapper;  public class TestParserUsingMapper  extends com.fasterxml.jackson.test.BaseTest {     final static int TWO_BYTE_ESCAPED = 0x111;     final static int THREE_BYTE_ESCAPED = 0x1111;      final static SerializedString TWO_BYTE_ESCAPED_STRING = new SerializedString("&111;");     final static SerializedString THREE_BYTE_ESCAPED_STRING = new SerializedString("&1111;");          final static class Pojo     {         int _x;          public void setX(int x) { _x = x; }     }          /*     /********************************************************     /* Helper types     /********************************************************      */      /**      * Trivial simple custom escape definition set.      */     static class MyEscapes extends CharacterEscapes     {         private static final long serialVersionUID = 1L;          private final int[] _asciiEscapes;          public MyEscapes() {             _asciiEscapes = standardAsciiEscapesForJSON();             _asciiEscapes['a'] = 'A'; // to basically give us "\A"             _asciiEscapes['b'] = CharacterEscapes.ESCAPE_STANDARD; // too force "\u0062"             _asciiEscapes['d'] = CharacterEscapes.ESCAPE_CUSTOM;         }                  @Override         public int[] getEscapeCodesForAscii() {             return _asciiEscapes;         }          @Override         public SerializableString getEscapeSequence(int ch)         {             if (ch == 'd') {                 return new SerializedString("[D]");             }             if (ch == TWO_BYTE_ESCAPED) {                 return TWO_BYTE_ESCAPED_STRING;             }             if (ch == THREE_BYTE_ESCAPED) {                 return THREE_BYTE_ESCAPED_STRING;             }             return null;         }     }          /*     /********************************************************     /* Unit tests     /********************************************************      */      public void testReadingArrayAsTree() throws IOException     {         JsonFactory jf = new MappingJsonFactory();         final String JSON = "[ 1, 2, false ]";          for (int i = 0; i < 2; ++i) {             JsonParser jp = jf.createParser(new StringReader(JSON));             // whether to try advancing first or not? Try both             if (i == 0) {                 assertToken(JsonToken.START_ARRAY, jp.nextToken());             }             JsonNode root = (JsonNode) jp.readValueAsTree();             jp.close();             assertTrue(root.isArray());             assertEquals(3, root.size());             assertEquals(1, root.get(0).intValue());             assertEquals(2, root.get(1).intValue());             assertFalse(root.get(2).booleanValue());         }     }          public void testPojoReading() throws IOException     {         JsonFactory jf = new MappingJsonFactory();         final String JSON = "{ \"x\" : 9 }";         JsonParser jp = jf.createParser(new StringReader(JSON));          // let's try first by advancing:         assertToken(JsonToken.START_OBJECT, jp.nextToken());         Pojo p = jp.readValueAs(Pojo.class);         assertEquals(9, p._x);         jp.close();          // and without         jp = jf.createParser(new StringReader(JSON));         p = jp.readValueAs(Pojo.class);         assertEquals(9, p._x);         jp.close();     }      /**      * Test similar to above, but instead reads a sequence of values      */     public void testIncrementalPojoReading()         throws IOException     {         JsonFactory jf = new MappingJsonFactory();         final String JSON = "[ 1, true, null, \"abc\" ]";         JsonParser jp = jf.createParser(new StringReader(JSON));          // let's advance past array start to prevent full binding         assertToken(JsonToken.START_ARRAY, jp.nextToken());          assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertEquals(Integer.valueOf(1), jp.readValueAs(Integer.class));         assertEquals(Boolean.TRUE, jp.readValueAs(Boolean.class));         /* note: null can be returned both when there is no more          * data in current scope, AND when Json null literal is          * bound!          */         assertNull(jp.readValueAs(Object.class));         // but we can verify that it was Json null by:         assertEquals(JsonToken.VALUE_NULL, jp.getLastClearedToken());          assertEquals("abc", jp.readValueAs(String.class));          // this null is for actually hitting the END_ARRAY         assertNull(jp.readValueAs(Object.class));         assertEquals(JsonToken.END_ARRAY, jp.getLastClearedToken());          // afrer which there should be nothing to advance to:         assertNull(jp.nextToken());          jp.close();     }      public void testPojoReadingFailing()         throws IOException     {         // regular factory can't do it, without a call to setCodec()         JsonFactory jf = new JsonFactory();         try {             final String JSON = "{ \"x\" : 9 }";             JsonParser jp = jf.createParser(new StringReader(JSON));             Pojo p = jp.readValueAs(Pojo.class);             fail("Expected an exception: got "+p);         } catch (IllegalStateException e) {             verifyException(e, "No ObjectCodec defined");         }     }          // for [JACKSON-672]     public void testEscapingUsingMapper() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);         assertEquals(quote("\\u0101"), mapper.writeValueAsString(String.valueOf((char) 257)));     } } 
package com.fasterxml.jackson.databind;  import java.util.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestReadValues extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      static class Bean {         public int a;     }          /*     /**********************************************************     /* Unit tests; root-level value sequences via Mapper     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testRootBeans() throws Exception     {         final String JSON = "{\"a\":3}{\"a\":27}  ";         Iterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);          assertNotNull(((MappingIterator<?>) it).getCurrentLocation());         assertTrue(it.hasNext());         Bean b = it.next();         assertEquals(3, b.a);         assertTrue(it.hasNext());         b = it.next();         assertEquals(27, b.a);         assertFalse(it.hasNext());     }      public void testRootMaps() throws Exception     {         final String JSON = "{\"a\":3}{\"a\":27}  ";         Iterator<Map<?,?>> it = MAPPER.reader(Map.class).readValues(JSON);          assertNotNull(((MappingIterator<?>) it).getCurrentLocation());         assertTrue(it.hasNext());         Map<?,?> map = it.next();         assertEquals(1, map.size());         assertEquals(Integer.valueOf(3), map.get("a"));         assertTrue(it.hasNext());         assertNotNull(((MappingIterator<?>) it).getCurrentLocation());         map = it.next();         assertEquals(1, map.size());         assertEquals(Integer.valueOf(27), map.get("a"));         assertFalse(it.hasNext());     }      /*     /**********************************************************     /* Unit tests; root-level value sequences via JsonParser     /**********************************************************      */      public void testRootBeansWithParser() throws Exception     {         final String JSON = "{\"a\":3}{\"a\":27}  ";         JsonParser jp = MAPPER.getFactory().createParser(JSON);                  Iterator<Bean> it = jp.readValuesAs(Bean.class);          assertTrue(it.hasNext());         Bean b = it.next();         assertEquals(3, b.a);         assertTrue(it.hasNext());         b = it.next();         assertEquals(27, b.a);         assertFalse(it.hasNext());     }      public void testRootArraysWithParser() throws Exception     {         final String JSON = "[1][3]";         JsonParser jp = MAPPER.getFactory().createParser(JSON);          // NOTE: We must point JsonParser to the first element; if we tried to         // use "managed" accessor, it would try to advance past START_ARRAY.         assertToken(JsonToken.START_ARRAY, jp.nextToken());                  Iterator<int[]> it = MAPPER.reader(int[].class).readValues(jp);         assertTrue(it.hasNext());         int[] array = it.next();         assertEquals(1, array.length);         assertEquals(1, array[0]);         assertTrue(it.hasNext());         array = it.next();         assertEquals(1, array.length);         assertEquals(3, array[0]);         assertFalse(it.hasNext());     }          public void testHasNextWithEndArray() throws Exception {         final String JSON = "[1,3]";         JsonParser jp = MAPPER.getFactory().createParser(JSON);          // NOTE: We must point JsonParser to the first element; if we tried to         // use "managed" accessor, it would try to advance past START_ARRAY.         assertToken(JsonToken.START_ARRAY, jp.nextToken());         jp.nextToken();                  Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(jp);         assertTrue(it.hasNext());         int value = it.next();         assertEquals(1, value);         assertTrue(it.hasNext());         value = it.next();         assertEquals(3, value);         assertFalse(it.hasNext());         assertFalse(it.hasNext());     }          public void testHasNextWithEndArrayManagedParser() throws Exception {         final String JSON = "[1,3]";          Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON);         assertTrue(it.hasNext());         int value = it.next();         assertEquals(1, value);         assertTrue(it.hasNext());         value = it.next();         assertEquals(3, value);         assertFalse(it.hasNext());         assertFalse(it.hasNext());     }          /*     /**********************************************************     /* Unit tests; non-root arrays     /**********************************************************      */      public void testNonRootBeans() throws Exception     {         final String JSON = "{\"leaf\":[{\"a\":3},{\"a\":27}]}";         JsonParser jp = MAPPER.getFactory().createParser(JSON);         assertToken(JsonToken.START_OBJECT, jp.nextToken());         assertToken(JsonToken.FIELD_NAME, jp.nextToken());         assertToken(JsonToken.START_ARRAY, jp.nextToken());         // can either advance to first START_OBJECT, or clear current token;         // explicitly passed JsonParser MUST point to the first token of         // the first element         assertToken(JsonToken.START_OBJECT, jp.nextToken());                  Iterator<Bean> it = MAPPER.reader(Bean.class).readValues(jp);          assertTrue(it.hasNext());         Bean b = it.next();         assertEquals(3, b.a);         assertTrue(it.hasNext());         b = it.next();         assertEquals(27, b.a);         assertFalse(it.hasNext());         jp.close();     }      public void testNonRootMapsWithParser() throws Exception     {         final String JSON = "[{\"a\":3},{\"a\":27}]";         JsonParser jp = MAPPER.getFactory().createParser(JSON);         assertToken(JsonToken.START_ARRAY, jp.nextToken());          // can either advance to first START_OBJECT, or clear current token;         // explicitly passed JsonParser MUST point to the first token of         // the first element         jp.clearCurrentToken();                  Iterator<Map<?,?>> it = MAPPER.reader(Map.class).readValues(jp);          assertTrue(it.hasNext());         Map<?,?> map = it.next();         assertEquals(1, map.size());         assertEquals(Integer.valueOf(3), map.get("a"));         assertTrue(it.hasNext());         map = it.next();         assertEquals(1, map.size());         assertEquals(Integer.valueOf(27), map.get("a"));         assertFalse(it.hasNext());         jp.close();     }      public void testNonRootMapsWithObjectReader() throws Exception     {         String JSON = "[{ \"hi\": \"ho\", \"neighbor\": \"Joe\" },\n"             +"{\"boy\": \"howdy\", \"huh\": \"what\"}]";         final MappingIterator<Map<String, Object>> iterator = MAPPER                 .reader()                 .withType(new TypeReference<Map<String, Object>>(){})                 .readValues(JSON);          Map<String,Object> map;         assertTrue(iterator.hasNext());         map = iterator.nextValue();         assertEquals(2, map.size());         assertTrue(iterator.hasNext());         map = iterator.nextValue();         assertEquals(2, map.size());         assertFalse(iterator.hasNext());     }          public void testNonRootArraysUsingParser() throws Exception     {         final String JSON = "[[1],[3]]";         JsonParser jp = MAPPER.getFactory().createParser(JSON);         assertToken(JsonToken.START_ARRAY, jp.nextToken());                  // Important: as of 2.1, START_ARRAY can only be skipped if the         // target type is NOT a Collection or array Java type.         // So we have to explicitly skip it in this particular case.         assertToken(JsonToken.START_ARRAY, jp.nextToken());                  Iterator<int[]> it = MAPPER.readValues(jp, int[].class);          assertTrue(it.hasNext());         int[] array = it.next();         assertEquals(1, array.length);         assertEquals(1, array[0]);         assertTrue(it.hasNext());         array = it.next();         assertEquals(1, array.length);         assertEquals(3, array[0]);         assertFalse(it.hasNext());         jp.close();     } } 
package com.fasterxml.jackson.databind;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.ObjectMapper;  /**  * Unit tests dealing with handling of "root element wrapping",  * including configuration of root name to use.  */ public class TestRootName extends BaseMapTest {     @JsonRootName("rudy")     static class Bean {         public int a = 3;     }          @JsonRootName("")     static class RootBeanWithEmpty {         public int a = 2;     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testRootViaMapper() throws Exception     {         ObjectMapper mapper = rootMapper();         String json = mapper.writeValueAsString(new Bean());         assertEquals("{\"rudy\":{\"a\":3}}", json);         Bean bean = mapper.readValue(json, Bean.class);         assertNotNull(bean);          // also same with explicitly "not defined"...         json = mapper.writeValueAsString(new RootBeanWithEmpty());         assertEquals("{\"RootBeanWithEmpty\":{\"a\":2}}", json);         RootBeanWithEmpty bean2 = mapper.readValue(json, RootBeanWithEmpty.class);         assertNotNull(bean2);         assertEquals(2, bean2.a);     }      public void testRootViaWriterAndReader() throws Exception     {         ObjectMapper mapper = rootMapper();         String json = mapper.writer().writeValueAsString(new Bean());         assertEquals("{\"rudy\":{\"a\":3}}", json);         Bean bean = mapper.reader(Bean.class).readValue(json);         assertNotNull(bean);     }      public void testReconfiguringOfWrapping() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         // default: no wrapping         final Bean input = new Bean();         String jsonUnwrapped = mapper.writeValueAsString(input);         assertEquals("{\"a\":3}", jsonUnwrapped);         // secondary: wrapping         String jsonWrapped = mapper.writer(SerializationFeature.WRAP_ROOT_VALUE)             .writeValueAsString(input);         assertEquals("{\"rudy\":{\"a\":3}}", jsonWrapped);          // and then similarly for readers:         Bean result = mapper.readValue(jsonUnwrapped, Bean.class);         assertNotNull(result);         try { // must not have extra wrapping             result = mapper.reader(Bean.class).with(DeserializationFeature.UNWRAP_ROOT_VALUE)                 .readValue(jsonUnwrapped);             fail("Should have failed");         } catch (JsonMappingException e) {             verifyException(e, "Root name 'a'");         }         // except wrapping may be expected:         result = mapper.reader(Bean.class).with(DeserializationFeature.UNWRAP_ROOT_VALUE)             .readValue(jsonWrapped);         assertNotNull(result);     }          // [JACKSON-764]     public void testRootUsingExplicitConfig() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         ObjectWriter writer = mapper.writer().withRootName("wrapper");         String json = writer.writeValueAsString(new Bean());         assertEquals("{\"wrapper\":{\"a\":3}}", json);          ObjectReader reader = mapper.reader(Bean.class).withRootName("wrapper");         Bean bean = reader.readValue(json);         assertNotNull(bean);          // also: verify that we can override SerializationFeature as well:         ObjectMapper wrapping = rootMapper();         json = wrapping.writer().withRootName("something").writeValueAsString(new Bean());         assertEquals("{\"something\":{\"a\":3}}", json);         json = wrapping.writer().withRootName("").writeValueAsString(new Bean());         assertEquals("{\"a\":3}", json);          bean = wrapping.reader(Bean.class).withRootName("").readValue(json);         assertNotNull(bean);     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */          private ObjectMapper rootMapper()     {         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);         mapper.configure(DeserializationFeature.UNWRAP_ROOT_VALUE, true);         return mapper;     } } 
package com.fasterxml.jackson.databind;  import java.util.*;  import com.fasterxml.jackson.databind.util.StdDateFormat;  public class TestStdDateFormat     extends BaseMapTest {     public void testFactories() {         assertNotNull(StdDateFormat.getBlueprintISO8601Format());         assertNotNull(StdDateFormat.getBlueprintRFC1123Format());         TimeZone tz = TimeZone.getTimeZone("GMT");         assertNotNull(StdDateFormat.getISO8601Format(tz));         assertNotNull(StdDateFormat.getRFC1123Format(tz));     }      public void testInvalid() {         StdDateFormat std = new StdDateFormat();         try {             std.parse("foobar");         } catch (java.text.ParseException e) {             verifyException(e, "Can not parse");         }     } } 
package com.fasterxml.jackson.databind;    import java.util.Arrays;  import java.util.List;    import org.junit.Test;    import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.ObjectMapper;  import com.fasterxml.jackson.databind.PropertyNamingStrategy;  import com.fasterxml.jackson.databind.TestNamingStrategy.PersonBean;    /**   * Unit tests to verify functioning of    * {@link PropertyNamingStrategy#CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES}    * inside the context of an ObjectMapper.   * CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES was added in Jackson 1.9,    * as per [JACKSON-598].   *    * and   *    * Unit test to verify translations of    * {@link PropertyNamingStrategy#PASCAL_CASE_TO_CAMEL_CASE }    * outside the context of an ObjectMapper.   * PASCAL_CASE_TO_CAMEL_CASE was added in Jackson 2.1.0,    * as per [JACKSON-63].   *    * @since 2.1.0   */  public class TestStdNamingStrategies extends BaseMapTest  {      /*      /**********************************************************      /* Helper types      /**********************************************************       */        @JsonPropertyOrder({"www", "some_url", "some_uris"})      static class Acronyms      {          public String WWW;          public String someURL;          public String someURIs;                    public Acronyms() {this(null, null, null);}          public Acronyms(String WWW, String someURL, String someURIs)          {              this.WWW = WWW;              this.someURL = someURL;              this.someURIs = someURIs;          }      }            @JsonPropertyOrder({"from_user", "user", "from$user", "from7user", "_"})      static class UnchangedNames      {          public String from_user;          public String _user;          public String from$user;          public String from7user;          public String _;                    public UnchangedNames() {this(null, null, null, null, null);}          public UnchangedNames(String from_user, String _user, String from$user, String from7user, String _)          {              this.from_user = from_user;              this._user = _user;              this.from$user = from$user;              this.from7user = from7user;              this._ = _;          }      }            @JsonPropertyOrder({"results", "user", "__", "$_user"})      static class OtherNonStandardNames      {          public String Results;          public String _User;          public String ___;          public String $User;                    public OtherNonStandardNames() {this(null, null, null, null);}          public OtherNonStandardNames(String Results, String _User, String ___, String $User)          {              this.Results = Results;              this._User = _User;              this.___ = ___;              this.$User = $User;          }      }            /*      /**********************************************************      /* Set up      /**********************************************************       */        public static List<Object[]> NAME_TRANSLATIONS = Arrays.asList(new Object[][] {                  {null, null},                  {"", ""},                  {"a", "a"},                  {"abc", "abc"},                  {"1", "1"},                  {"123", "123"},                  {"1a", "1a"},                  {"a1", "a1"},                  {"$", "$"},                  {"$a", "$a"},                  {"a$", "a$"},                  {"$_a", "$_a"},                  {"a_$", "a_$"},                  {"a$a", "a$a"},                  {"$A", "$_a"},                  {"$_A", "$_a"},                  {"_", "_"},                  {"__", "_"},                  {"___", "__"},                  {"A", "a"},                  {"A1", "a1"},                  {"1A", "1_a"},                  {"_a", "a"},                  {"_A", "a"},                  {"a_a", "a_a"},                  {"a_A", "a_a"},                  {"A_A", "a_a"},                  {"A_a", "a_a"},                  {"WWW", "www"},                  {"someURI", "some_uri"},                  {"someURIs", "some_uris"},                  {"Results", "results"},                  {"_Results", "results"},                  {"_results", "results"},                  {"__results", "_results"},                  {"__Results", "_results"},                  {"___results", "__results"},                  {"___Results", "__results"},                  {"userName", "user_name"},                  {"user_name", "user_name"},                  {"user__name", "user__name"},                  {"UserName", "user_name"},                  {"User_Name", "user_name"},                  {"User__Name", "user__name"},                  {"_user_name", "user_name"},                  {"_UserName", "user_name"},                  {"_User_Name", "user_name"},                  {"UGLY_NAME", "ugly_name"},                  {"_Bars", "bars" }      });            private ObjectMapper mapper;            @Override      public void setUp() throws Exception      {          super.setUp();          mapper = new ObjectMapper();          mapper.setPropertyNamingStrategy(PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES);      }            /*      /**********************************************************      /* Test methods for CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES      /**********************************************************       */        /**       * Unit test to verify translations of        * {@link PropertyNamingStrategy#CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES}        * outside the context of an ObjectMapper.       * CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES was added in Jackson 1.9,        * as per [JACKSON-598].       */      @Test      public void testLowerCaseStrategyStandAlone()      {          for (Object[] pair : NAME_TRANSLATIONS) {              String translatedJavaName = PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES.nameForField(null, null,                      (String) pair[0]);              assertEquals((String) pair[1], translatedJavaName);          }      }            public void testLowerCaseTranslations() throws Exception      {          // First serialize          String json = mapper.writeValueAsString(new PersonBean("Joe", "Sixpack", 42));          assertEquals("{\"first_name\":\"Joe\",\"last_name\":\"Sixpack\",\"age\":42}", json);                    // then deserialize          PersonBean result = mapper.readValue(json, PersonBean.class);          assertEquals("Joe", result.firstName);          assertEquals("Sixpack", result.lastName);          assertEquals(42, result.age);      }            public void testLowerCaseAcronymsTranslations() throws Exception      {          // First serialize          String json = mapper.writeValueAsString(new Acronyms("world wide web", "http://jackson.codehaus.org", "/path1/,/path2/"));          assertEquals("{\"www\":\"world wide web\",\"some_url\":\"http://jackson.codehaus.org\",\"some_uris\":\"/path1/,/path2/\"}", json);                    // then deserialize          Acronyms result = mapper.readValue(json, Acronyms.class);          assertEquals("world wide web", result.WWW);          assertEquals("http://jackson.codehaus.org", result.someURL);          assertEquals("/path1/,/path2/", result.someURIs);      }        public void testLowerCaseOtherNonStandardNamesTranslations() throws Exception      {          // First serialize          String json = mapper.writeValueAsString(new OtherNonStandardNames("Results", "_User", "___", "$User"));          assertEquals("{\"results\":\"Results\",\"user\":\"_User\",\"__\":\"___\",\"$_user\":\"$User\"}", json);                    // then deserialize          OtherNonStandardNames result = mapper.readValue(json, OtherNonStandardNames.class);          assertEquals("Results", result.Results);          assertEquals("_User", result._User);          assertEquals("___", result.___);          assertEquals("$User", result.$User);      }        public void testLowerCaseUnchangedNames() throws Exception      {          // First serialize          String json = mapper.writeValueAsString(new UnchangedNames("from_user", "_user", "from$user", "from7user", "_"));          assertEquals("{\"from_user\":\"from_user\",\"user\":\"_user\",\"from$user\":\"from$user\",\"from7user\":\"from7user\",\"_\":\"_\"}", json);                    // then deserialize          UnchangedNames result = mapper.readValue(json, UnchangedNames.class);          assertEquals("from_user", result.from_user);          assertEquals("_user", result._user);          assertEquals("from$user", result.from$user);          assertEquals("from7user", result.from7user);          assertEquals("_", result._);      }            /*      /**********************************************************      /* Test methods for PASCAL_CASE_TO_CAMEL_CASE (added in 2.1)      /**********************************************************       */        /**       * Unit test to verify translations of        * {@link PropertyNamingStrategy#PASCAL_CASE_TO_CAMEL_CASE }        * outside the context of an ObjectMapper.       * PASCAL_CASE_TO_CAMEL_CASE was added in Jackson 2.1.0,        * as per [JACKSON-63].       */      @Test      public void testPascalCaseStandAlone()      {      	String translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField      	        (null, null, "userName");          assertEquals("UserName", translatedJavaName);            translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField                  (null, null, "User");          assertEquals("User", translatedJavaName);            translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField                  (null, null, "user");          assertEquals("User", translatedJavaName);          translatedJavaName = PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE.nameForField                  (null, null, "x");          assertEquals("X", translatedJavaName);      }  }  
package com.fasterxml.jackson.databind;  import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.core.Versioned;  import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector; import com.fasterxml.jackson.databind.cfg.PackageVersion;  /**  * Tests to ensure that we get proper Version information via  * things defined as Versioned.  */ public class TestVersions extends com.fasterxml.jackson.test.BaseTest {     public void testMapperVersions()     {         ObjectMapper mapper = new ObjectMapper();         assertVersion(mapper);         assertVersion(mapper.reader());         assertVersion(mapper.writer());         assertVersion(new JacksonAnnotationIntrospector());     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */          private void assertVersion(Versioned vers)     {         Version v = vers.version();         assertFalse("Should find version information (got "+v+")", v.isUknownVersion());         Version exp = PackageVersion.VERSION;         assertEquals(exp.toFullString(), v.toFullString());         assertEquals(exp, v);     } }  
package com.fasterxml.jackson.databind.access;  import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.databind.*;  /**  * Separate tests located in different package than code being  * exercised; needed to trigger some access-related failures.  */ public class TestSerAnyGetter     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      static class DynaBean {         public int id;          protected HashMap<String,String> other = new HashMap<String,String>();                  @JsonAnyGetter         public Map<String,String> any() {             return other;         }          @JsonAnySetter         public void set(String name, String value) {             other.put(name, value);         }     }      private static class PrivateThing     {         @JsonAnyGetter         public Map<?,?> getProperties()         {             HashMap<String,String> map = new HashMap<String,String>();             map.put("a", "A");             return map;         }     }      /*     /**********************************************************     /* Test cases     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testDynaBean() throws Exception     {         DynaBean b = new DynaBean();         b.id = 123;         b.set("name", "Billy");         assertEquals("{\"id\":123,\"name\":\"Billy\"}", MAPPER.writeValueAsString(b));          DynaBean result = MAPPER.readValue("{\"id\":2,\"name\":\"Joe\"}", DynaBean.class);         assertEquals(2, result.id);         assertEquals("Joe", result.other.get("name"));     }      public void testPrivate() throws Exception     {         String json = MAPPER.writeValueAsString(new PrivateThing());         assertEquals("{\"a\":\"A\"}", json);     } } 
package com.fasterxml.jackson.databind.contextual;  import java.io.IOException; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.ContextualDeserializer; import com.fasterxml.jackson.databind.module.SimpleModule;  /**  * Test cases to verify that it is possible to define deserializers  * that can use contextual information (like field/method  * annotations) for configuration.  */ public class TestContextualDeserialization extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      /* NOTE: important; MUST be considered a 'Jackson' annotation to be seen      * (or recognized otherwise via AnnotationIntrospect.isHandled())      */     @Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @JacksonAnnotation     public @interface Name {         public String value();     }          static class StringValue {         protected String value;                  public StringValue(String v) { value = v; }     }          static class ContextualBean     {         @Name("NameA")         public StringValue a;         @Name("NameB")         public StringValue b;     }          static class ContextualCtorBean     {         protected String a, b;          @JsonCreator         public ContextualCtorBean(                 @Name("CtorA") @JsonProperty("a") StringValue a,                 @Name("CtorB") @JsonProperty("b") StringValue b)         {             this.a = a.value;             this.b = b.value;         }     }      @Name("Class")     static class ContextualClassBean     {         public StringValue a;          @Name("NameB")         public StringValue b;     }          static class ContextualArrayBean     {         @Name("array")         public StringValue[] beans;     }          static class ContextualListBean     {         @Name("list")         public List<StringValue> beans;     }          static class ContextualMapBean     {         @Name("map")         public Map<String, StringValue> beans;     }          static class MyContextualDeserializer         extends JsonDeserializer<StringValue>         implements ContextualDeserializer     {         protected final String _fieldName;                  public MyContextualDeserializer() { this(""); }         public MyContextualDeserializer(String fieldName) {             _fieldName = fieldName;         }          @Override         public StringValue deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException         {             return new StringValue(""+_fieldName+"="+jp.getText());         }          @Override         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,                 BeanProperty property)             throws JsonMappingException         {             String name = (property == null) ? "NULL" : property.getName();             return new MyContextualDeserializer(name);         }     }      /**      * Alternative that uses annotation for choosing name to use      */     static class AnnotatedContextualDeserializer         extends JsonDeserializer<StringValue>         implements ContextualDeserializer     {         protected final String _fieldName;                  public AnnotatedContextualDeserializer() { this(""); }         public AnnotatedContextualDeserializer(String fieldName) {             _fieldName = fieldName;         }              @Override         public StringValue deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException         {             return new StringValue(""+_fieldName+"="+jp.getText());         }              @Override         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,                 BeanProperty property)             throws JsonMappingException         {             Name ann = property.getAnnotation(Name.class);             if (ann == null) {                 ann = property.getContextAnnotation(Name.class);             }             String propertyName = (ann == null) ?  "UNKNOWN" : ann.value();             return new MyContextualDeserializer(propertyName);         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testSimple() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addDeserializer(StringValue.class, new MyContextualDeserializer());         mapper.registerModule(module);         ContextualBean bean = mapper.readValue("{\"a\":\"1\",\"b\":\"2\"}", ContextualBean.class);         assertEquals("a=1", bean.a.value);         assertEquals("b=2", bean.b.value);          // try again, to ensure caching etc works         bean = mapper.readValue("{\"a\":\"3\",\"b\":\"4\"}", ContextualBean.class);         assertEquals("a=3", bean.a.value);         assertEquals("b=4", bean.b.value);     }      public void testSimpleWithAnnotations() throws Exception     {         ObjectMapper mapper = _mapperWithAnnotatedContextual();         ContextualBean bean = mapper.readValue("{\"a\":\"1\",\"b\":\"2\"}", ContextualBean.class);         assertEquals("NameA=1", bean.a.value);         assertEquals("NameB=2", bean.b.value);          // try again, to ensure caching etc works         bean = mapper.readValue("{\"a\":\"x\",\"b\":\"y\"}", ContextualBean.class);         assertEquals("NameA=x", bean.a.value);         assertEquals("NameB=y", bean.b.value);     }      public void testSimpleWithClassAnnotations() throws Exception     {         ObjectMapper mapper = _mapperWithAnnotatedContextual();         ContextualClassBean bean = mapper.readValue("{\"a\":\"1\",\"b\":\"2\"}", ContextualClassBean.class);         assertEquals("Class=1", bean.a.value);         assertEquals("NameB=2", bean.b.value);         // and again         bean = mapper.readValue("{\"a\":\"123\",\"b\":\"345\"}", ContextualClassBean.class);         assertEquals("Class=123", bean.a.value);         assertEquals("NameB=345", bean.b.value);     }          public void testAnnotatedCtor() throws Exception     {         ObjectMapper mapper = _mapperWithAnnotatedContextual();         ContextualCtorBean bean = mapper.readValue("{\"a\":\"foo\",\"b\":\"bar\"}", ContextualCtorBean.class);         assertEquals("CtorA=foo", bean.a);         assertEquals("CtorB=bar", bean.b);          bean = mapper.readValue("{\"a\":\"1\",\"b\":\"0\"}", ContextualCtorBean.class);         assertEquals("CtorA=1", bean.a);         assertEquals("CtorB=0", bean.b);     }      public void testAnnotatedArray() throws Exception     {         ObjectMapper mapper = _mapperWithAnnotatedContextual();         ContextualArrayBean bean = mapper.readValue("{\"beans\":[\"x\"]}", ContextualArrayBean.class);         assertEquals(1, bean.beans.length);         assertEquals("array=x", bean.beans[0].value);          bean = mapper.readValue("{\"beans\":[\"a\",\"b\"]}", ContextualArrayBean.class);         assertEquals(2, bean.beans.length);         assertEquals("array=a", bean.beans[0].value);         assertEquals("array=b", bean.beans[1].value);     }      public void testAnnotatedList() throws Exception     {         ObjectMapper mapper = _mapperWithAnnotatedContextual();         ContextualListBean bean = mapper.readValue("{\"beans\":[\"x\"]}", ContextualListBean.class);         assertEquals(1, bean.beans.size());         assertEquals("list=x", bean.beans.get(0).value);          bean = mapper.readValue("{\"beans\":[\"x\",\"y\",\"z\"]}", ContextualListBean.class);         assertEquals(3, bean.beans.size());         assertEquals("list=x", bean.beans.get(0).value);         assertEquals("list=y", bean.beans.get(1).value);         assertEquals("list=z", bean.beans.get(2).value);     }      public void testAnnotatedMap() throws Exception     {         ObjectMapper mapper = _mapperWithAnnotatedContextual();         ContextualMapBean bean = mapper.readValue("{\"beans\":{\"a\":\"b\"}}", ContextualMapBean.class);         assertEquals(1, bean.beans.size());         Map.Entry<String,StringValue> entry = bean.beans.entrySet().iterator().next();         assertEquals("a", entry.getKey());         assertEquals("map=b", entry.getValue().value);          bean = mapper.readValue("{\"beans\":{\"x\":\"y\",\"1\":\"2\"}}", ContextualMapBean.class);         assertEquals(2, bean.beans.size());         Iterator<Map.Entry<String,StringValue>> it = bean.beans.entrySet().iterator();         entry = it.next();         assertEquals("x", entry.getKey());         assertEquals("map=y", entry.getValue().value);         entry = it.next();         assertEquals("1", entry.getKey());         assertEquals("map=2", entry.getValue().value);     }          /*     /**********************************************************     /* Helper methods     /**********************************************************      */      private ObjectMapper _mapperWithAnnotatedContextual()     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addDeserializer(StringValue.class, new AnnotatedContextualDeserializer());         mapper.registerModule(module);         return mapper;     } } 
package com.fasterxml.jackson.databind.contextual;  import java.io.IOException; import java.util.*;   import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.ContextualKeyDeserializer; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.ContextualSerializer; import com.fasterxml.jackson.databind.type.TypeFactory;  /**  * Tests to ensure that we can do contextual key serializers and  * deserializers as well as value ser/deser.  */ public class TestContextualKeyTypes extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      static class ContextualKeySerializer         extends JsonSerializer<String>         implements ContextualSerializer     {         protected final String _prefix;              public ContextualKeySerializer() { this(""); }         public ContextualKeySerializer(String p) {             _prefix = p;         }          @Override         public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException         {             if (_prefix != null) {                 value = _prefix + value;             }             jgen.writeFieldName(value);         }          @Override         public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property)             throws JsonMappingException         {             return new ContextualKeySerializer(_prefix+":");         }     }      static class ContextualDeser         extends KeyDeserializer         implements ContextualKeyDeserializer     {         protected final String _prefix;                  protected ContextualDeser(String p) {             _prefix = p;         }                  @Override         public Object deserializeKey(String key, DeserializationContext ctxt)                 throws IOException, JsonProcessingException         {             return _prefix + ":" + key;         }          @Override         public KeyDeserializer createContextual(DeserializationContext ctxt,                 BeanProperty property) throws JsonMappingException         {             return new ContextualDeser((property == null) ? "ROOT" : property.getName());         }     }      static class MapBean {         public Map<String, Integer> map;     }          /*     /**********************************************************     /* Unit tests, serialization     /**********************************************************      */      public void testSimpleKeySer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addKeySerializer(String.class, new ContextualKeySerializer("prefix"));         mapper.registerModule(module);         Map<String,Object> input = new HashMap<String,Object>();         input.put("a", Integer.valueOf(3));         String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class))             .writeValueAsString(input);         assertEquals("{\"prefix:a\":3}", json);     }          /*     /**********************************************************     /* Unit tests, deserialization     /**********************************************************      */      public void testSimpleKeyDeser() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addKeyDeserializer(String.class, new ContextualDeser("???"));         mapper.registerModule(module);         MapBean result = mapper.readValue("{\"map\":{\"a\":3}}", MapBean.class);         Map<String,Integer> map = result.map;         assertNotNull(map);         assertEquals(1, map.size());         Map.Entry<String,Integer> entry = map.entrySet().iterator().next();         assertEquals(Integer.valueOf(3), entry.getValue());         assertEquals("map:a", entry.getKey());     } } 
package com.fasterxml.jackson.databind.contextual;  import java.io.IOException; import java.lang.annotation.*; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.ContextualSerializer; import com.fasterxml.jackson.databind.ser.ResolvableSerializer;  /**  * Test cases to verify that it is possible to define serializers  * that can use contextual information (like field/method  * annotations) for configuration.  */ public class TestContextualSerialization extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      /* NOTE: important; MUST be considered a 'Jackson' annotation to be seen      * (or recognized otherwise via AnnotationIntrospect.isHandled())      */     @Target({ElementType.FIELD, ElementType.TYPE, ElementType.METHOD})     @Retention(RetentionPolicy.RUNTIME)     @JacksonAnnotation     public @interface Prefix {         public String value();     }      static class ContextualBean     {         protected final String _value;          public ContextualBean(String s) { _value = s; }          @Prefix("see:")         public String getValue() { return _value; }     }      // For [JACKSON-569]     static class AnnotatedContextualBean     {         @Prefix("prefix->")         @JsonSerialize(using=AnnotatedContextualSerializer.class)         protected final String value;          public AnnotatedContextualBean(String s) { value = s; }     }           @Prefix("wrappedBean:")     static class ContextualBeanWrapper     {         @Prefix("wrapped:")         public ContextualBean wrapped;                  public ContextualBeanWrapper(String s) {             wrapped = new ContextualBean(s);         }     }          static class ContextualArrayBean     {         @Prefix("array->")         public final String[] beans;                  public ContextualArrayBean(String... strings) {             beans = strings;         }     }      static class ContextualArrayElementBean     {         @Prefix("elem->")         @JsonSerialize(contentUsing=AnnotatedContextualSerializer.class)         public final String[] beans;                  public ContextualArrayElementBean(String... strings) {             beans = strings;         }     }          static class ContextualListBean     {         @Prefix("list->")         public final List<String> beans = new ArrayList<String>();          public ContextualListBean(String... strings) {             for (String string : strings) {                 beans.add(string);             }         }     }          static class ContextualMapBean     {         @Prefix("map->")         public final Map<String, String> beans = new HashMap<String, String>();     }          /**      * Another bean that has class annotations that should be visible for      * contextualizer, too      */     @Prefix("Voila->")     static class BeanWithClassConfig     {         public String value;          public BeanWithClassConfig(String v) { value = v; }     }          /**      * Annotation-based contextual serializer that simply prepends piece of text.      */     static class AnnotatedContextualSerializer         extends JsonSerializer<String>         implements ContextualSerializer     {         protected final String _prefix;                  public AnnotatedContextualSerializer() { this(""); }         public AnnotatedContextualSerializer(String p) {             _prefix = p;         }          @Override         public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException         {             jgen.writeString(_prefix + value);         }          @Override         public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property)                 throws JsonMappingException         {             String prefix = "UNKNOWN";             Prefix ann = null;             if (property != null) {                 ann = property.getAnnotation(Prefix.class);                 if (ann == null) {                     ann = property.getContextAnnotation(Prefix.class);                 }             }             if (ann != null) {                 prefix = ann.value();             }             return new AnnotatedContextualSerializer(prefix);         }     }      static class ContextualAndResolvable         extends JsonSerializer<String>         implements ContextualSerializer, ResolvableSerializer     {         protected int isContextual;         protected int isResolved;          public ContextualAndResolvable() { this(0, 0); }                  public ContextualAndResolvable(int resolved, int contextual)         {             isContextual = contextual;             isResolved = resolved;         }                  @Override         public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException         {             jgen.writeString("contextual="+isContextual+",resolved="+isResolved);         }          @Override         public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property)                 throws JsonMappingException         {             return new ContextualAndResolvable(isResolved, isContextual+1);         }          @Override         public void resolve(SerializerProvider provider) {             ++isResolved;         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */          // Test to verify that contextual serializer can make use of property     // (method, field) annotations.     public void testMethodAnnotations() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addSerializer(String.class, new AnnotatedContextualSerializer());         mapper.registerModule(module);         assertEquals("{\"value\":\"see:foobar\"}", mapper.writeValueAsString(new ContextualBean("foobar")));     }      // Test to verify that contextual serializer can also use annotations     // for enclosing class.     public void testClassAnnotations() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addSerializer(String.class, new AnnotatedContextualSerializer());         mapper.registerModule(module);         assertEquals("{\"value\":\"Voila->xyz\"}", mapper.writeValueAsString(new BeanWithClassConfig("xyz")));     }      public void testWrappedBean() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addSerializer(String.class, new AnnotatedContextualSerializer());         mapper.registerModule(module);         assertEquals("{\"wrapped\":{\"value\":\"see:xyz\"}}", mapper.writeValueAsString(new ContextualBeanWrapper("xyz")));     }          // Serializer should get passed property context even if contained in an array.     public void testMethodAnnotationInArray() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addSerializer(String.class, new AnnotatedContextualSerializer());         mapper.registerModule(module);         ContextualArrayBean beans = new ContextualArrayBean("123");         assertEquals("{\"beans\":[\"array->123\"]}", mapper.writeValueAsString(beans));     }      // Serializer should get passed property context even if contained in a Collection.     public void testMethodAnnotationInList() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addSerializer(String.class, new AnnotatedContextualSerializer());         mapper.registerModule(module);         ContextualListBean beans = new ContextualListBean("abc");         assertEquals("{\"beans\":[\"list->abc\"]}", mapper.writeValueAsString(beans));     }      // Serializer should get passed property context even if contained in a Collection.     public void testMethodAnnotationInMap() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addSerializer(String.class, new AnnotatedContextualSerializer());         mapper.registerModule(module);         ContextualMapBean map = new ContextualMapBean();         map.beans.put("first", "In Map");         assertEquals("{\"beans\":{\"first\":\"map->In Map\"}}", mapper.writeValueAsString(map));     }      public void testContextualViaAnnotation() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AnnotatedContextualBean bean = new AnnotatedContextualBean("abc");         assertEquals("{\"value\":\"prefix->abc\"}", mapper.writeValueAsString(bean));     }      /*     // [JACKSON-647]: is resolve() called for contextual instances?     public void testResolveOnContextual() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addSerializer(String.class, new ContextualAndResolvable());         mapper.registerModule(module);         assertEquals(quote("contextual=1,resolved=1"), mapper.writeValueAsString("abc"));     }      public void testContextualArrayElement() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         ContextualArrayElementBean beans = new ContextualArrayElementBean("456");         assertEquals("{\"beans\":[\"elem->456\"]}", mapper.writeValueAsString(beans));     }     */ } 
package com.fasterxml.jackson.databind.contextual;  import java.io.IOException; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target;  import com.fasterxml.jackson.annotation.JacksonAnnotation; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.deser.ContextualDeserializer;  public class TestContextualWithAnnDeserializer extends BaseMapTest {     @Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})     @Retention(RetentionPolicy.RUNTIME)     @JacksonAnnotation     public @interface Name {         public String value();     }          static class StringValue {         protected String value;                  public StringValue(String v) { value = v; }     }      static class AnnotatedContextualClassBean     {         @Name("xyz")         @JsonDeserialize(using=AnnotatedContextualDeserializer.class)         public StringValue value;     }          static class AnnotatedContextualDeserializer         extends JsonDeserializer<StringValue>         implements ContextualDeserializer     {         protected final String _fieldName;                  public AnnotatedContextualDeserializer() { this(""); }         public AnnotatedContextualDeserializer(String fieldName) {             _fieldName = fieldName;         }          @Override         public StringValue deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException         {             return new StringValue(""+_fieldName+"="+jp.getText());         }          @Override         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,                 BeanProperty property)             throws JsonMappingException         {             Name ann = property.getAnnotation(Name.class);             if (ann == null) {                 ann = property.getContextAnnotation(Name.class);             }             String propertyName = (ann == null) ?  "UNKNOWN" : ann.value();             return new MyContextualDeserializer(propertyName);         }     }      static class MyContextualDeserializer         extends JsonDeserializer<StringValue>         implements ContextualDeserializer     {         protected final String _fieldName;                  public MyContextualDeserializer() { this(""); }         public MyContextualDeserializer(String fieldName) {             _fieldName = fieldName;         }              @Override         public StringValue deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException         {             return new StringValue(""+_fieldName+"="+jp.getText());         }          @Override         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,                 BeanProperty property)             throws JsonMappingException         {             String name = (property == null) ? "NULL" : property.getName();             return new MyContextualDeserializer(name);         }     }           // ensure that direct associations also work     public void testAnnotatedContextual() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AnnotatedContextualClassBean bean = mapper.readValue(                 "{\"value\":\"a\"}",               AnnotatedContextualClassBean.class);         assertNotNull(bean);         assertEquals("xyz=a", bean.value.value);     }  } 
package com.fasterxml.jackson.databind.convert;  import java.math.*; import java.util.*; import java.lang.reflect.Array;   import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.*;  public class TestArrayConversions     extends com.fasterxml.jackson.databind.BaseMapTest {     final static String OVERFLOW_MSG_BYTE = "out of range of Java byte";     final static String OVERFLOW_MSG = "overflow";      final ObjectMapper mapper = new ObjectMapper();      public void testNullXform() throws Exception     {         /* when given null, null should be returned without conversion          * (Java null has no type)          */         assertNull(mapper.convertValue(null, Integer.class));         assertNull(mapper.convertValue(null, String.class));         assertNull(mapper.convertValue(null, byte[].class));     }      /**      * Tests to verify that primitive number arrays round-trip      * correctly, i.e. type -> type gives equal (although      * not necessarily same) output      */     public void testArrayIdentityTransforms() throws Exception     {         // first integral types         // (note: byte[] is ok, even if it goes to base64 and back)         verifyByteArrayConversion(bytes(), byte[].class);         verifyShortArrayConversion(shorts(), short[].class);         verifyIntArrayConversion(ints(), int[].class);         verifyLongArrayConversion(longs(), long[].class);         // then primitive decimal types         verifyFloatArrayConversion(floats(), float[].class);         verifyDoubleArrayConversion(doubles(), float[].class);     }      public void testByteArrayFrom() throws Exception     {         /* Note: byte arrays are tricky, since they are considered          * binary data primarily, not as array of numbers. Hence          * output will be base64 encoded...          */         byte[] data = _convert("c3VyZS4=", byte[].class);         byte[] exp = "sure.".getBytes("Ascii");         verifyIntegralArrays(exp, data, exp.length);     }          public void testShortArrayToX() throws Exception     {         short[] data = shorts();         verifyShortArrayConversion(data, byte[].class);         verifyShortArrayConversion(data, int[].class);         verifyShortArrayConversion(data, long[].class);     }      public void testIntArrayToX() throws Exception     {         int[] data = ints();         verifyIntArrayConversion(data, byte[].class);         verifyIntArrayConversion(data, short[].class);         verifyIntArrayConversion(data, long[].class);          List<Number> expNums = _numberList(data, data.length);         // Alas, due to type erasure, need to use TypeRef, not just class         List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() {});         assertEquals(expNums, actNums);     }      public void testLongArrayToX() throws Exception     {         long[] data = longs();         verifyLongArrayConversion(data, byte[].class);         verifyLongArrayConversion(data, short[].class);         verifyLongArrayConversion(data, int[].class);           List<Number> expNums = _numberList(data, data.length);         List<Long> actNums = mapper.convertValue(data, new TypeReference<List<Long>>() {});         assertEquals(expNums, actNums);             }      public void testOverflows()     {         // Byte overflow         try {             mapper.convertValue(new int[] { 1000 }, byte[].class);         } catch (IllegalArgumentException e) {             verifyException(e, OVERFLOW_MSG_BYTE);         }         // Short overflow         try {             mapper.convertValue(new int[] { -99999 }, short[].class);         } catch (IllegalArgumentException e) {             verifyException(e, OVERFLOW_MSG);         }         // Int overflow         try {             mapper.convertValue(new long[] { Long.MAX_VALUE }, int[].class);         } catch (IllegalArgumentException e) {             verifyException(e, OVERFLOW_MSG);         }         // Longs need help of BigInteger...         BigInteger biggie = BigInteger.valueOf(Long.MAX_VALUE);         biggie.add(BigInteger.ONE);         List<BigInteger> l = new ArrayList<BigInteger>();         l.add(biggie);         try {             mapper.convertValue(l, int[].class);         } catch (IllegalArgumentException e) {             verifyException(e, OVERFLOW_MSG);         }              }          /*     /********************************************************     /* Helper methods     /********************************************************      */      // note: all value need to be within byte range          private byte[] bytes() { return new byte[] { 1, -1, 0, 98, 127 }; }     private short[] shorts() { return new short[] { 1, -1, 0, 98, 127 }; }     private int[] ints() { return new int[] { 1, -1, 0, 98, 127 }; }     private long[] longs() { return new long[] { 1, -1, 0, 98, 127 }; }      // note: use values that are exact in binary      private double[] doubles() { return new double[] { 0.0, 0.25, -0.125, 10.5, 9875.0 }; }     private float[] floats() { return new float[] {             0.0f, 0.25f, -0.125f, 10.5f, 9875.0f };     }      private <T> void verifyByteArrayConversion(byte[] data, Class<T> arrayType) {         T result = _convert(data, arrayType);         verifyIntegralArrays(data, result, data.length);     }     private <T> void verifyShortArrayConversion(short[] data, Class<T> arrayType) {         T result = _convert(data, arrayType);         verifyIntegralArrays(data, result, data.length);     }     private <T> void verifyIntArrayConversion(int[] data, Class<T> arrayType) {         T result = _convert(data, arrayType);         verifyIntegralArrays(data, result, data.length);     }     private <T> void verifyLongArrayConversion(long[] data, Class<T> arrayType) {         T result = _convert(data, arrayType);         verifyIntegralArrays(data, result, data.length);     }     private <T> void verifyFloatArrayConversion(float[] data, Class<T> arrayType) {         T result = _convert(data, arrayType);         verifyDoubleArrays(data, result, data.length);     }     private <T> void verifyDoubleArrayConversion(double[] data, Class<T> arrayType) {         T result = _convert(data, arrayType);         verifyDoubleArrays(data, result, data.length);     }          private <T> T _convert(Object input, Class<T> outputType)     {         // must be a primitive array, like "int[].class"         if (!outputType.isArray()) throw new IllegalArgumentException();         if (!outputType.getComponentType().isPrimitive()) throw new IllegalArgumentException();         T result = mapper.convertValue(input, outputType);         // sanity check first:         assertNotNull(result);         assertEquals(outputType, result.getClass());         return result;     }      private List<Number> _numberList(Object numberArray, int size)     {         ArrayList<Number> result = new ArrayList<Number>(size);         for (int i = 0; i < size; ++i) {             result.add((Number) Array.get(numberArray, i));         }         return result;     }          /**      * Helper method for checking that given collections contain integral Numbers      * that essentially contain same values in same order      */     private void verifyIntegralArrays(Object inputArray, Object outputArray, int size)     {         for (int i = 0; i < size; ++i) {             Number n1 = (Number) Array.get(inputArray, i);             Number n2 = (Number) Array.get(outputArray, i);             double value1 = ((Number) n1).longValue();             double value2 = ((Number) n2).longValue();             assertEquals("Entry #"+i+"/"+size+" not equal", value1, value2);         }             }      private void verifyDoubleArrays(Object inputArray, Object outputArray, int size)     {         for (int i = 0; i < size; ++i) {             Number n1 = (Number) Array.get(inputArray, i);             Number n2 = (Number) Array.get(outputArray, i);             double value1 = ((Number) n1).doubleValue();             double value2 = ((Number) n2).doubleValue();             assertEquals("Entry #"+i+"/"+size+" not equal", value1, value2);         }             }  } 
package com.fasterxml.jackson.databind.convert;  import java.util.LinkedHashMap; import java.util.Map;  import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.core.TreeNode; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.node.ObjectNode;  public class TestBeanConversions     extends com.fasterxml.jackson.databind.BaseMapTest {     final ObjectMapper MAPPER = new ObjectMapper();      static class Point {         public int x, y;          public int z = -13;          public Point() { }         public Point(int a, int b, int c)         {             x = a;             y = b;             z = c;         }     }      static class PointStrings {         public final String x, y;          public PointStrings(String x, String y) {             this.x = x;             this.y = y;         }     }      public static class BooleanBean {         public boolean boolProp;     }      static class WrapperBean {         public BooleanBean x;     }      static class ObjectWrapper     {         private Object data;          public ObjectWrapper() { }         public ObjectWrapper(Object o) { data = o; }          public Object getData() { return data; }         public void setData(Object data) { this.data = data; }     }      static class Leaf {         public int value;          public Leaf() { }         public Leaf(int v) { value = v; }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */          public void testBeanConvert()     {         // should have no problems convert between compatible beans...         PointStrings input = new PointStrings("37", "-9");         Point point = MAPPER.convertValue(input, Point.class);         assertEquals(37, point.x);         assertEquals(-9, point.y);         // z not included in input, will be whatever default constructor provides         assertEquals(-13, point.z);     }          // For [JACKSON-371]; verify that we know property that caused issue...     // (note: not optimal place for test, but will have to do for now)     public void testErrorReporting() throws Exception     {         //String json = "{\"boolProp\":\"oops\"}";         // First: unknown property         try {             MAPPER.readValue("{\"unknownProp\":true}", BooleanBean.class);         } catch (JsonProcessingException e) {             verifyException(e, "unknownProp");         }          // then bad conversion         try {             MAPPER.readValue("{\"boolProp\":\"foobar\"}", BooleanBean.class);         } catch (JsonProcessingException e) {             verifyException(e, "boolProp");         }     }      public void testIssue458() throws Exception     {         ObjectWrapper a = new ObjectWrapper("foo");         ObjectWrapper b = new ObjectWrapper(a);         ObjectWrapper b2 = MAPPER.convertValue(b, ObjectWrapper.class);         ObjectWrapper a2 = MAPPER.convertValue(b2.getData(), ObjectWrapper.class);         assertEquals("foo", a2.getData());     }      // [JACKSON-710]: should work regardless of wrapping...     public void testWrapping() throws Exception     {         ObjectMapper wrappingMapper = new ObjectMapper();         wrappingMapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);         wrappingMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);          // conversion is ok, even if it's bogus one         _convertAndVerifyPoint(wrappingMapper);          // also: ok to have mismatched settings, since as per [JACKSON-710], should         // not actually use wrapping internally in these cases         wrappingMapper = new ObjectMapper();         wrappingMapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);         wrappingMapper.disable(SerializationFeature.WRAP_ROOT_VALUE);         _convertAndVerifyPoint(wrappingMapper);          wrappingMapper = new ObjectMapper();         wrappingMapper.disable(DeserializationFeature.UNWRAP_ROOT_VALUE);         wrappingMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);         _convertAndVerifyPoint(wrappingMapper);     }      // [Issue-11]: simple cast, for POJOs etc     public void testConvertUsingCast() throws Exception     {         String str = new String("foo");         CharSequence seq = str;         String result = MAPPER.convertValue(seq, String.class);         // should just cast...         assertSame(str, result);     }          // [Issue-11]: simple cast, for Tree     public void testNodeConvert() throws Exception     {         ObjectNode src = (ObjectNode) MAPPER.readTree("{}");         TreeNode node = src;         ObjectNode result = MAPPER.treeToValue(node, ObjectNode.class);         // should just cast...         assertSame(src, result);     }          private void _convertAndVerifyPoint(ObjectMapper m)     {         final Point input = new Point(1, 2, 3);         Point output = m.convertValue(input, Point.class);         assertEquals(1, output.x);         assertEquals(2, output.y);         assertEquals(3, output.z);     }      /**      * Need to test "shortcuts" introduced by [Issue-11]      */     public void testIssue11() throws Exception     {         // First the expected use case, Node specification         ObjectNode root = MAPPER.createObjectNode();         JsonNode n = root;         ObjectNode ob2 = MAPPER.convertValue(n, ObjectNode.class);         assertSame(root, ob2);          JsonNode n2 = MAPPER.convertValue(n, JsonNode.class);         assertSame(root, n2);                  // then some other no-op conversions         String STR = "test";         CharSequence seq = MAPPER.convertValue(STR, CharSequence.class);         assertSame(STR, seq);          // and then something that should NOT use short-cut         Leaf l = new Leaf(13);         Map<?,?> m = MAPPER.convertValue(l, Map.class);         assertNotNull(m);         assertEquals(1, m.size());         assertEquals(Integer.valueOf(13), m.get("value"));          // and reverse too         Leaf l2 = MAPPER.convertValue(m, Leaf.class);         assertEquals(13, l2.value);          // also; ok to use "untyped" (Object):         Object ob = MAPPER.convertValue(l, Object.class);         assertNotNull(ob);         assertEquals(LinkedHashMap.class, ob.getClass());          // And one more: this time with a minor twist         final Object plaino = new Object();         // first, a failed attempt:         try {             m = MAPPER.convertValue(plaino, Map.class);             fail("Conversion should have failed");         } catch (IllegalArgumentException e) {             verifyException(e, "no properties discovered");         }                  ObjectMapper mapper = new ObjectMapper();         mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);         try {             assertEquals("{}", mapper.writeValueAsString(plaino));         } catch (Exception e) {             throw (Exception) e.getCause();         }         // should now work, via serialization/deserialization:         m = mapper.convertValue(plaino, Map.class);         assertNotNull(m);         assertEquals(0, m.size());     } } 
package com.fasterxml.jackson.databind.convert;  import java.util.*;  import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.util.StdConverter;  public class TestConvertingDeserializer extends com.fasterxml.jackson.databind.BaseMapTest {     @JsonDeserialize(converter=ConvertingBeanConverter.class)     static class ConvertingBean     {         protected int x, y;          protected ConvertingBean(int x, int y) {             this.x = x;             this.y = y;         }     }          static class Point     {         protected int x, y;              public Point(int v1, int v2) {             x = v1;             y = v2;         }     }      static class ConvertingBeanContainer     {         public List<ConvertingBean> values;          public ConvertingBeanContainer() { }         public ConvertingBeanContainer(ConvertingBean... beans) {             values = Arrays.asList(beans);         }     }      static class ConvertingBeanConverter extends StdConverter<int[],ConvertingBean>     {         @Override         public ConvertingBean convert(int[] values) {             return new ConvertingBean(values[0], values[1]);         }     }          static class PointConverter extends StdConverter<int[], Point>     {         @Override public Point convert(int[] value) {             return new Point(value[0], value[1]);         }     }      static class PointWrapper {         @JsonDeserialize(converter=PointConverter.class)         public Point value;          protected PointWrapper() { }         public PointWrapper(int x, int y) {             value = new Point(x, y);         }     }          static class PointListWrapperArray {         @JsonDeserialize(contentConverter=PointConverter.class)         public Point[] values;     }      static class PointListWrapperList {         @JsonDeserialize(contentConverter=PointConverter.class)         public List<Point> values;     }      static class PointListWrapperMap {         @JsonDeserialize(contentConverter=PointConverter.class)         public Map<String,Point> values;     }      static class LowerCaser extends StdConverter<String, String>     {         @Override         public String convert(String value) {             return value.toLowerCase();         }              }      static class LowerCaseText {         @JsonDeserialize(converter=LowerCaser.class)         public String text;     }      static class LowerCaseTextArray {         @JsonDeserialize(contentConverter=LowerCaser.class)         public String[] texts;     }           /*     /**********************************************************     /* Test methods     /**********************************************************      */      public void testClassAnnotationSimple() throws Exception     {         ConvertingBean bean = objectReader(ConvertingBean.class).readValue("[1,2]");         assertNotNull(bean);         assertEquals(1, bean.x);         assertEquals(2, bean.y);     }      public void testClassAnnotationForLists() throws Exception     {         ConvertingBeanContainer container = objectReader(ConvertingBeanContainer.class)                 .readValue("{\"values\":[[1,2],[3,4]]}");         assertNotNull(container);         assertNotNull(container.values);         assertEquals(2, container.values.size());         assertEquals(4, container.values.get(1).y);     }      public void testPropertyAnnotationSimple() throws Exception     {         PointWrapper wrapper = objectReader(PointWrapper.class).readValue("{\"value\":[3,4]}");         assertNotNull(wrapper);         assertNotNull(wrapper.value);         assertEquals(3, wrapper.value.x);         assertEquals(4, wrapper.value.y);     }      public void testPropertyAnnotationLowerCasing() throws Exception     {         LowerCaseText text = objectReader(LowerCaseText.class).readValue("{\"text\":\"Yay!\"}");         assertNotNull(text);         assertNotNull(text.text);         assertEquals("yay!", text.text);     }      public void testPropertyAnnotationArrayLC() throws Exception     {         LowerCaseTextArray texts = objectReader(LowerCaseTextArray.class).readValue("{\"texts\":[\"ABC\"]}");         assertNotNull(texts);         assertNotNull(texts.texts);         assertEquals(1, texts.texts.length);         assertEquals("abc", texts.texts[0]);     }      public void testPropertyAnnotationForArrays() throws Exception     {         PointListWrapperArray array = objectReader(PointListWrapperArray.class)                 .readValue("{\"values\":[[4,5],[5,4]]}");         assertNotNull(array);         assertNotNull(array.values);         assertEquals(2, array.values.length);         assertEquals(5, array.values[1].x);     }      public void testPropertyAnnotationForLists() throws Exception     {         PointListWrapperList array = objectReader(PointListWrapperList.class)                 .readValue("{\"values\":[[7,8],[8,7]]}");         assertNotNull(array);         assertNotNull(array.values);         assertEquals(2, array.values.size());         assertEquals(7, array.values.get(0).x);     }      public void testPropertyAnnotationForMaps() throws Exception     {         PointListWrapperMap map = objectReader(PointListWrapperMap.class)                 .readValue("{\"values\":{\"a\":[1,2]}}");         assertNotNull(map);         assertNotNull(map.values);         assertEquals(1, map.values.size());         Point p = map.values.get("a");         assertNotNull(p);         assertEquals(1, p.x);         assertEquals(2, p.y);     } } 
package com.fasterxml.jackson.databind.convert;  import java.util.*;  import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.util.StdConverter;  public class TestConvertingSerializer     extends com.fasterxml.jackson.databind.BaseMapTest {     @JsonSerialize(converter=ConvertingBeanConverter.class)     static class ConvertingBean     {         public int x, y;          public ConvertingBean(int v1, int v2) {             x = v1;             y = v2;         }     }      static class Point     {         public int x, y;          public Point(int v1, int v2) {             x = v1;             y = v2;         }     }          static class ConvertingBeanContainer     {         public List<ConvertingBean> values;                  public ConvertingBeanContainer(ConvertingBean... beans) {             values = Arrays.asList(beans);         }     }      static class ConvertingBeanConverter extends StdConverter<ConvertingBean, int[]>     {         @Override         public int[] convert(ConvertingBean value) {             return new int[] { value.x, value.y };         }     }      static class PointConverter extends StdConverter<Point, int[]>     {         @Override public int[] convert(Point value) {             return new int[] { value.x, value.y };         }     }          static class PointWrapper {         @JsonSerialize(converter=PointConverter.class)         public Point value;          public PointWrapper(int x, int y) {             value = new Point(x, y);         }     }      static class PointListWrapperArray {         @JsonSerialize(contentConverter=PointConverter.class)         public Point[] values;          public PointListWrapperArray(int x, int y) {             values = new Point[] { new Point(x, y), new Point(y, x) };         }     }      static class PointListWrapperList {         @JsonSerialize(contentConverter=PointConverter.class)         public List<Point> values;          public PointListWrapperList(int x, int y) {             values = Arrays.asList(new Point[] { new Point(x, y), new Point(y, x) });         }     }          static class PointListWrapperMap {         @JsonSerialize(contentConverter=PointConverter.class)         public Map<String,Point> values;          public PointListWrapperMap(String key, int x, int y) {             values = new HashMap<String,Point>();             values.put(key, new Point(x, y));         }     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */      public void testClassAnnotationSimple() throws Exception     {         String json = objectWriter().writeValueAsString(new ConvertingBean(1, 2));         assertEquals("[1,2]", json);     }      public void testClassAnnotationForLists() throws Exception     {         String json = objectWriter().writeValueAsString(new ConvertingBeanContainer(                 new ConvertingBean(1, 2), new ConvertingBean(3, 4)));         assertEquals("{\"values\":[[1,2],[3,4]]}", json);     }      public void testPropertyAnnotationSimple() throws Exception     {         String json = objectWriter().writeValueAsString(new PointWrapper(3, 4));         assertEquals("{\"value\":[3,4]}", json);     }      public void testPropertyAnnotationForArrays() throws Exception {         String json = objectWriter().writeValueAsString(new PointListWrapperArray(4, 5));         assertEquals("{\"values\":[[4,5],[5,4]]}", json);     }      public void testPropertyAnnotationForLists() throws Exception {         String json = objectWriter().writeValueAsString(new PointListWrapperList(7, 8));         assertEquals("{\"values\":[[7,8],[8,7]]}", json);     }      public void testPropertyAnnotationForMaps() throws Exception {         String json = objectWriter().writeValueAsString(new PointListWrapperMap("a", 1, 2));         assertEquals("{\"values\":{\"a\":[1,2]}}", json);     } } 
package com.fasterxml.jackson.databind.convert;  import java.util.*;   import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.*;  public class TestMapConversions     extends com.fasterxml.jackson.databind.BaseMapTest {     final ObjectMapper mapper = new ObjectMapper();      enum AB { A, B; }      static class Bean {         public Integer A;         public String B;     }          /**      * Test that verifies that we can go between couple of types of Maps...      */     public void testMapToMap()     {         Map<String,Integer> input = new LinkedHashMap<String,Integer>();         input.put("A", Integer.valueOf(3));         input.put("B", Integer.valueOf(-4));         Map<AB,String> output = mapper.convertValue(input,                 new TypeReference<Map<AB,String>>() { });         assertEquals(2, output.size());         assertEquals("3", output.get(AB.A));         assertEquals("-4", output.get(AB.B));          // Let's try the other way too... and mix up types a bit         Map<String,Integer> roundtrip = mapper.convertValue(input,                 new TypeReference<TreeMap<String,Integer>>() { });         assertEquals(2, roundtrip.size());         assertEquals(Integer.valueOf(3), roundtrip.get("A"));         assertEquals(Integer.valueOf(-4), roundtrip.get("B"));     }      public void testMapToBean()     {         EnumMap<AB,String> map = new EnumMap<AB,String>(AB.class);         map.put(AB.A, "   17");         map.put(AB.B, " -1");         Bean bean = mapper.convertValue(map, Bean.class);         assertEquals(Integer.valueOf(17), bean.A);         assertEquals(" -1", bean.B);     }      public void testBeanToMap()     {         Bean bean = new Bean();         bean.A = 129;         bean.B = "13";         EnumMap<AB,String> result = mapper.convertValue(bean,                 new TypeReference<EnumMap<AB,String>>() { });         assertEquals("129", result.get(AB.A));         assertEquals("13", result.get(AB.B));     } } 
package com.fasterxml.jackson.databind.convert;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying handling of update value on polymorphic  * objects.  */ public class TestPolymorphicUpdateValue extends BaseMapTest {     @JsonTypeInfo(include=JsonTypeInfo.As.WRAPPER_ARRAY //PROPERTY             ,use=JsonTypeInfo.Id.NAME, property="type")     @JsonSubTypes(value={ @JsonSubTypes.Type(value=Child.class)})     abstract static class Parent {         public int x;         public int y;     }      @JsonTypeName("child")     public static class Child extends Parent {         public int w;         public int h;     }              /*     /********************************************************     /* Unit tests     /********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();      public void testPolymorphicTest() throws Exception     {          Child c = new Child();          c.w = 10;          c.h = 11;          MAPPER.readerForUpdating(c).readValue("{\"x\":3,\"y\":4,\"w\":111}");          assertEquals(3, c.x);          assertEquals(4, c.y);          assertEquals(111, c.w);     } } 
package com.fasterxml.jackson.databind.convert;  import java.util.*;  import static org.junit.Assert.*;  import com.fasterxml.jackson.databind.*;  public class TestStringConversions     extends com.fasterxml.jackson.databind.BaseMapTest {     final ObjectMapper MAPPER = new ObjectMapper();      public void testSimple()     {         assertEquals(Boolean.TRUE, MAPPER.convertValue("true", Boolean.class));         assertEquals(Integer.valueOf(-3), MAPPER.convertValue("  -3 ", Integer.class));         assertEquals(Long.valueOf(77), MAPPER.convertValue("77", Long.class));          int[] ints = { 1, 2, 3 };         List<Integer> Ints = new ArrayList<Integer>();         Ints.add(1);         Ints.add(2);         Ints.add(3);                  assertArrayEquals(ints, MAPPER.convertValue(Ints, int[].class));     }      public void testStringsToInts()     {         // let's verify our "neat trick" actually works...         assertArrayEquals(new int[] { 1, 2, 3, 4, -1, 0 },                           MAPPER.convertValue("1  2 3    4  -1 0".split("\\s+"), int[].class));     }      public void testBytesToBase64AndBack() throws Exception     {         byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 };         String encoded = MAPPER.convertValue(input, String.class);         assertNotNull(encoded);         byte[] result = MAPPER.convertValue(encoded, byte[].class);         assertArrayEquals(input, result);     }          public void testBytestoCharArray() throws Exception     {         byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 };         // first, do baseline encoding         char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray();         // then compare         char[] actEncoded = MAPPER.convertValue(input, char[].class);         assertArrayEquals(expEncoded, actEncoded);     } } 
package com.fasterxml.jackson.databind.convert;  import java.util.*;  import com.fasterxml.jackson.annotation.JsonView; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  import static org.junit.Assert.assertArrayEquals;  /**  * Unit tests for verifying that "updating reader" works as  * expected.  */ public class TestUpdateValue extends BaseMapTest {     /*     /********************************************************     /* Helper types     /********************************************************      */      static class Bean {         public String a = "a";         public String b = "b";          public int[] c = new int[] { 1, 2, 3 };          public Bean child = null;     }      static class XYBean {         public int x, y;     }      // [JACKSON-824]     public class TextView {}     public class NumView {}      public class Updateable {         @JsonView(NumView.class)         public int num;          @JsonView(TextView.class)         public String str;     }              /*     /********************************************************     /* Unit tests     /********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();      public void testBeanUpdate() throws Exception     {         Bean bean = new Bean();         assertEquals("b", bean.b);         assertEquals(3, bean.c.length);         assertNull(bean.child);          Object ob = MAPPER.readerForUpdating(bean).readValue("{ \"b\":\"x\", \"c\":[4,5], \"child\":{ \"a\":\"y\"} }");         assertSame(ob, bean);          assertEquals("a", bean.a);         assertEquals("x", bean.b);         assertArrayEquals(new int[] { 4, 5 }, bean.c);          Bean child = bean.child;         assertNotNull(child);         assertEquals("y", child.a);         assertEquals("b", child.b);         assertArrayEquals(new int[] { 1, 2, 3 }, child.c);         assertNull(child.child);     }      public void testListUpdate() throws Exception     {         List<String> strs = new ArrayList<String>();         strs.add("a");         // for lists, we will be appending entries         Object ob = MAPPER.readerForUpdating(strs).readValue("[ \"b\", \"c\", \"d\" ]");         assertSame(strs, ob);         assertEquals(4, strs.size());         assertEquals("a", strs.get(0));         assertEquals("b", strs.get(1));         assertEquals("c", strs.get(2));         assertEquals("d", strs.get(3));     }      public void testMapUpdate() throws Exception     {         Map<String,String> strs = new HashMap<String,String>();         strs.put("a", "a");         strs.put("b", "b");         // for maps, we will be adding and/or overwriting entries         Object ob = MAPPER.readerForUpdating(strs).readValue("{ \"c\" : \"c\", \"a\" : \"z\" }");         assertSame(strs, ob);         assertEquals(3, strs.size());         assertEquals("z", strs.get("a"));         assertEquals("b", strs.get("b"));         assertEquals("c", strs.get("c"));     }      // Test for [JACKSON-717] -- ensure 'readValues' also does update     public void testUpdateSequence() throws Exception     {         XYBean toUpdate = new XYBean();         Iterator<XYBean> it = MAPPER.readerForUpdating(toUpdate).readValues(                 "{\"x\":1,\"y\":2}\n{\"x\":16}{\"y\":37}");          assertTrue(it.hasNext());         XYBean value = it.next();         assertSame(toUpdate, value);         assertEquals(1, value.x);         assertEquals(2, value.y);          assertTrue(it.hasNext());         value = it.next();         assertSame(toUpdate, value);         assertEquals(16, value.x);         assertEquals(2, value.y); // unchanged          assertTrue(it.hasNext());         value = it.next();         assertSame(toUpdate, value);         assertEquals(16, value.x); // unchanged         assertEquals(37, value.y);                  assertFalse(it.hasNext());     }      // [JACKSON-824]     public void testUpdatingWithViews() throws Exception     {         Updateable bean = new Updateable();         bean.num = 100;         bean.str = "test";         Updateable result = MAPPER.readerForUpdating(bean)                 .withView(TextView.class)                 .readValue("{\"num\": 10, \"str\":\"foobar\"}");             assertSame(bean, result);          assertEquals(100, bean.num);         assertEquals("foobar", bean.str);     } } 
package com.fasterxml.jackson.databind.creators;  import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.annotation.JsonSetter; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;  public class TestBuilderSimple extends BaseMapTest {     // // Simple 2-property value class, builder with standard naming 	     @JsonDeserialize(builder=SimpleBuilderXY.class)     static class ValueClassXY     {         final int _x, _y;          protected ValueClassXY(int x, int y) {             _x = x+1;             _y = y+1;         }     }      static class SimpleBuilderXY     {     	public int x, y;     	     	public SimpleBuilderXY withX(int x) {     		this.x = x;     		return this;     	}      	public SimpleBuilderXY withY(int y) {     		this.y = y;     		return this;     	}      	public ValueClassXY build() {     		return new ValueClassXY(x, y);     	}     }      // // 3-property value, with more varied builder 	     @JsonDeserialize(builder=BuildABC.class)     static class ValueClassABC     {         final int a, b, c;          protected ValueClassABC(int a, int b, int c) {             this.a = a;             this.b = b;             this.c = c;         }     }      static class BuildABC     {     	public int a; // to be used as is     	private int b, c;     	     	@JsonProperty("b")     	public BuildABC assignB(int b) {     		this.b = b;     		return this;     	}      	// Also ok NOT to return 'this'     	@JsonSetter("c")     	public void c(int c) {     		this.c = c;     	}      	public ValueClassABC build() {     		return new ValueClassABC(a, b, c);     	}     }      // // Then Builder that is itself immutable          @JsonDeserialize(builder=BuildImmutable.class)     static class ValueImmutable     {         final int value;         protected ValueImmutable(int v) { value = v; }     }          static class BuildImmutable {         private final int value;                  private BuildImmutable() { this(0); }         private BuildImmutable(int v) {             value = v;         }         public BuildImmutable withValue(int v) {             return new BuildImmutable(v);         }         public ValueImmutable build() {             return new ValueImmutable(value);         }     }          // And then with custom naming:      @JsonDeserialize(builder=BuildFoo.class)     static class ValueFoo     {         final int value;         protected ValueFoo(int v) { value = v; }     }      @JsonPOJOBuilder(withPrefix="foo", buildMethodName="construct")     static class BuildFoo {         private int value;                  public BuildFoo fooValue(int v) {             value = v;             return this;         }         public ValueFoo construct() {             return new ValueFoo(value);         }     }      // And with creator(s) 	     @JsonDeserialize(builder=CreatorBuilder.class)     static class CreatorValue     {         final int a, b, c;          protected CreatorValue(int a, int b, int c) {             this.a = a;             this.b = b;             this.c = c;         }     }      static class CreatorBuilder {         private final int a, b;         private int c;          @JsonCreator         public CreatorBuilder(@JsonProperty("a") int a,                 @JsonProperty("b") int b)         {             this.a = a;             this.b = b;         }                  public CreatorBuilder withC(int v) {             c = v;             return this;         }         public CreatorValue build() {             return new CreatorValue(a, b, c);         }     }          	/*     /**********************************************************     /* Unit tests     /**********************************************************      */      private final ObjectMapper mapper = new ObjectMapper();          public void testSimple() throws Exception     {     	String json = "{\"x\":1,\"y\":2}";     	Object o = mapper.readValue(json, ValueClassXY.class);     	assertNotNull(o);     	assertSame(ValueClassXY.class, o.getClass());     	ValueClassXY value = (ValueClassXY) o;     	// note: ctor adds one to both values     	assertEquals(value._x, 2);     	assertEquals(value._y, 3);     }      public void testMultiAccess() throws Exception     {     	String json = "{\"c\":3,\"a\":2,\"b\":-9}";     	ValueClassABC value = mapper.readValue(json, ValueClassABC.class);     	assertNotNull(value);     	// note: ctor adds one to both values     	assertEquals(value.a, 2);     	assertEquals(value.b, -9);     	assertEquals(value.c, 3);     }      // test for Immutable builder, to ensure return value is used     public void testImmutable() throws Exception     {         final String json = "{\"value\":13}";         ValueImmutable value = mapper.readValue(json, ValueImmutable.class);                 assertEquals(13, value.value);     }      // test with custom 'with-prefix'     public void testCustomWith() throws Exception     {         final String json = "{\"value\":1}";         ValueFoo value = mapper.readValue(json, ValueFoo.class);                 assertEquals(1, value.value);     }      // test to ensure @JsonCreator also work     public void testWithCreator() throws Exception     {         final String json = "{\"a\":1,\"c\":3,\"b\":2}";         CreatorValue value = mapper.readValue(json, CreatorValue.class);                 assertEquals(1, value.a);         assertEquals(2, value.b);         assertEquals(3, value.c);     } } 
package com.fasterxml.jackson.databind.creators;  import java.awt.Point; // just for convenience import java.math.BigDecimal; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * This unit test suite that tests use of {@link JsonCreator}  * with "delegate" constructors and factory methods: ones that  * take a deserializable type that is bound from JSON content.  * This is usually done to get two-phase data binding, often using  * {@link java.util.Map} as the intermediate form.  */ public class TestConstructFromMap     extends BaseMapTest {     static class ConstructorFromMap     {         int _x;         String _y;          @JsonCreator         ConstructorFromMap(Map<?,?> arg)         {             _x = ((Number) arg.get("x")).intValue();             _y = (String) arg.get("y");         }     }      static class FactoryFromPoint     {         int _x, _y;          private FactoryFromPoint(Point p) {             _x = p.x;             _y = p.y;         }          @JsonCreator         static FactoryFromPoint createIt(Point p)         {             return new FactoryFromPoint(p);         }     }      // Also: let's test BigDecimal-from-JSON-String factory     static class FactoryFromDecimalString     { 	int _value;          private FactoryFromDecimalString(BigDecimal d) { 	    _value = d.intValue();         }          @JsonCreator         static FactoryFromDecimalString whateverNameWontMatter(BigDecimal d)         {             return new FactoryFromDecimalString(d);         }     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */      public void testViaConstructor() throws Exception     {         ObjectMapper m = new ObjectMapper();         ConstructorFromMap result = m.readValue             ("{ \"x\":1, \"y\" : \"abc\" }", ConstructorFromMap.class);         assertEquals(1, result._x);         assertEquals("abc", result._y);     }      public void testViaFactory() throws Exception     {         ObjectMapper m = new ObjectMapper();         FactoryFromPoint result = m.readValue("{ \"x\" : 3, \"y\" : 4 }", FactoryFromPoint.class);         assertEquals(3, result._x);         assertEquals(4, result._y);     }      public void testViaFactoryUsingString() throws Exception     {         ObjectMapper m = new ObjectMapper();         FactoryFromDecimalString result = m.readValue("\"12.57\"", FactoryFromDecimalString.class);         assertNotNull(result);         assertEquals(12, result._value);     } } 
package com.fasterxml.jackson.databind.creators;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.*;  // Mostly for [JACSON-774] public class TestCreatorNullValue extends BaseMapTest {     protected static class Container {         Contained<String> contained;          @JsonCreator         public Container(@JsonProperty("contained") Contained<String> contained) {             this.contained = contained;         }     }      private static interface Contained<T> {}      private static class NullContained implements Contained<Object> {}      private static final NullContained NULL_CONTAINED = new NullContained();      private static class ContainedDeserializer extends JsonDeserializer<Contained<?>> {         @Override         public Contained<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws JsonProcessingException {             return null;         }          @Override         public Contained<?> getNullValue() {             return NULL_CONTAINED;         }     }      private static class ContainerDeserializerResolver extends Deserializers.Base {         @Override         public JsonDeserializer<?> findBeanDeserializer(JavaType type,                 DeserializationConfig config, BeanDescription beanDesc)             throws JsonMappingException         {             if (!Contained.class.isAssignableFrom(type.getRawClass())) {                 return null;             } else {                 return new ContainedDeserializer();             }         }     }      private static class TestModule extends Module     {         @Override         public String getModuleName() {             return "ContainedModule";         }          @Override         public Version version() {             return Version.unknownVersion();         }          @Override         public void setupModule(SetupContext setupContext) {             setupContext.addDeserializers(new ContainerDeserializerResolver());         }     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */          public void testUsesDeserializersNullValue() throws Exception {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new TestModule());         Container container = mapper.readValue("{}", Container.class);         assertEquals(NULL_CONTAINED, container.contained);     } } 
package com.fasterxml.jackson.databind.creators;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying that it is possible to annotate  * various kinds of things with {@link JsonCreator} annotation.  */ public class TestCreators     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes, simple     /**********************************************************      */      /**      * Simple(st) possible demonstration of using annotated      * constructors      */     static class ConstructorBean {         int x;          @JsonCreator protected ConstructorBean(@JsonProperty("x") int x) {             this.x = x;         }     }      /**      * Another simple constructor, but with bit more unusual argument      * type      */     static class BooleanConstructorBean {         Boolean b;         @JsonCreator protected BooleanConstructorBean(Boolean b) {             this.b = b;         }     }      static class BooleanConstructorBean2 {         boolean b;         @JsonCreator protected BooleanConstructorBean2(boolean b) {             this.b = b;         }     }          static class DoubleConstructorBean {         Double d; // cup?         @JsonCreator protected DoubleConstructorBean(Double d) {             this.d = d;         }     }      static class FactoryBean {         double d; // teehee          private FactoryBean(double value, boolean dummy) { d = value; }          @JsonCreator protected static FactoryBean createIt(@JsonProperty("f") double value) {             return new FactoryBean(value, true);         }     }      static class LongFactoryBean {         long value;          private LongFactoryBean(long v) { value = v; }          @JsonCreator static protected LongFactoryBean valueOf(long v) {             return new LongFactoryBean(v);         }     }      static class StringFactoryBean {         String value;          private StringFactoryBean(String v, boolean dummy) { value = v; }          @JsonCreator static protected StringFactoryBean valueOf(String v) {             return new StringFactoryBean(v, true);         }     }      static class FactoryBeanMixIn { // static just to be able to use static methods         /**          * Note: signature (name and parameter types) must match; but          * only annotations will be used, not code or such. And use          * is by augmentation, so we only need to add things to add          * or override.          */         static FactoryBean createIt(@JsonProperty("mixed") double xyz) {             return null;         }     }      /**      * Simple demonstration of INVALID construtor annotation (only      * defining name for first arg)      */     static class BrokenBean {         @JsonCreator protected BrokenBean(@JsonProperty("a") int a,                                           int b) {         }     }      /**      * Bean that defines both creator and factory methor as      * creators. Constructors have priority; but it is possible      * to hide it using mix-in annotations.      */     static class CreatorBean     {         String a;         int x;          @JsonCreator         protected CreatorBean(@JsonProperty("a") String paramA,                               @JsonProperty("x") int paramX)         {             a = "ctor:"+paramA;             x = 1+paramX;         }          private CreatorBean(String a, int x, boolean dummy) {             this.a = a;             this.x = x;         }          @JsonCreator         public static CreatorBean buildMeUpButterCup(@JsonProperty("a") String paramA,                                                      @JsonProperty("x") int paramX)         {             return new CreatorBean("factory:"+paramA, paramX-1, false);         }     }      /**      * Class for sole purpose of hosting mix-in annotations.      * Couple of things to note: (a) MUST be static class (non-static      * get implicit pseudo-arg, 'this';      * (b) for factory methods, must have static to match (part of signature)      */     abstract static class MixIn {         @JsonIgnore private MixIn(String a, int x) { }     }      static class MultiBean {         Object value;          @JsonCreator public MultiBean(int v) { value = v; }         @JsonCreator public MultiBean(double v) { value = v; }         @JsonCreator public MultiBean(String v) { value = v; }         @JsonCreator public MultiBean(boolean v) { value = v; }     }      // for [JACKSON-850]     static class NoArgFactoryBean {         public int x;         public int y;                  public NoArgFactoryBean(int value) { x = value; }                  @JsonCreator         public static NoArgFactoryBean create() { return new NoArgFactoryBean(123); }     }          /*     /**********************************************************     /* Annotated helper classes, mixed (creator and props)     /**********************************************************      */      /**      * Test bean for ensuring that constructors can be mixed with setters      */     static class ConstructorAndPropsBean     {         final int a, b;         boolean c;          @JsonCreator protected ConstructorAndPropsBean(@JsonProperty("a") int a,                                                        @JsonProperty("b") int b)         {             this.a = a;             this.b = b;         }          public void setC(boolean value) { c = value; }     }      /**      * Test bean for ensuring that factory methods can be mixed with setters      */     static class FactoryAndPropsBean     {         boolean[] arg1;         int arg2, arg3;          @JsonCreator protected FactoryAndPropsBean(@JsonProperty("a") boolean[] arg)         {             arg1 = arg;         }          public void setB(int value) { arg2 = value; }         public void setC(int value) { arg3 = value; }     }      static class DeferredConstructorAndPropsBean     {         final int[] createA;         String propA = "xyz";         String propB;          @JsonCreator         public DeferredConstructorAndPropsBean(@JsonProperty("createA") int[] a)         {             createA = a;         }         public void setPropA(String a) { propA = a; }         public void setPropB(String b) { propB = b; }     }      static class DeferredFactoryAndPropsBean     {         String prop, ctor;          @JsonCreator DeferredFactoryAndPropsBean(@JsonProperty("ctor") String str)         {             ctor = str;         }          public void setProp(String str) { prop = str; }     }      /*     /**********************************************************     /* Annotated helper classes for Maps     /**********************************************************      */      @SuppressWarnings("serial")     static class MapWithCtor extends HashMap<Object,Object>     {         final int _number;         String _text = "initial";          MapWithCtor() { this(-1, "default"); }          @JsonCreator             public MapWithCtor(@JsonProperty("number") int nr,                                @JsonProperty("text") String t)         {             _number = nr;             _text = t;         }     }      @SuppressWarnings("serial")     static class MapWithFactory extends TreeMap<Object,Object>     {         Boolean _b;          private MapWithFactory(Boolean b) {             _b = b;         }          @JsonCreator             static MapWithFactory createIt(@JsonProperty("b") Boolean b)         {             return new MapWithFactory(b);         }     }      /*     /**********************************************************     /* Test methods, valid cases, non-deferred, no-mixins     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testSimpleConstructor() throws Exception     {         ConstructorBean bean = MAPPER.readValue("{ \"x\" : 42 }", ConstructorBean.class);         assertEquals(42, bean.x);     }      // [JACKSON-850]     public void testNoArgsFactory() throws Exception     {         NoArgFactoryBean value = MAPPER.readValue("{\"y\":13}", NoArgFactoryBean.class);         assertEquals(13, value.y);         assertEquals(123, value.x);     }          public void testSimpleDoubleConstructor() throws Exception     {         Double exp = new Double("0.25");         DoubleConstructorBean bean = MAPPER.readValue(exp.toString(), DoubleConstructorBean.class);         assertEquals(exp, bean.d);     }      public void testSimpleBooleanConstructor() throws Exception     {         BooleanConstructorBean bean = MAPPER.readValue(" true ", BooleanConstructorBean.class);         assertEquals(Boolean.TRUE, bean.b);          BooleanConstructorBean2 bean2 = MAPPER.readValue(" true ", BooleanConstructorBean2.class);         assertTrue(bean2.b);     }      public void testSimpleFactory() throws Exception     {         FactoryBean bean = MAPPER.readValue("{ \"f\" : 0.25 }", FactoryBean.class);         assertEquals(0.25, bean.d);     }      public void testLongFactory() throws Exception     {         long VALUE = 123456789000L;         LongFactoryBean bean = MAPPER.readValue(String.valueOf(VALUE), LongFactoryBean.class);         assertEquals(VALUE, bean.value);     }      public void testStringFactory() throws Exception     {         String str = "abc";         StringFactoryBean bean = MAPPER.readValue(quote(str), StringFactoryBean.class);         assertEquals(str, bean.value);     }      public void testConstructorCreator() throws Exception     {         CreatorBean bean = MAPPER.readValue             ("{ \"a\" : \"xyz\", \"x\" : 12 }", CreatorBean.class);         assertEquals(13, bean.x);         assertEquals("ctor:xyz", bean.a);     }      public void testConstructorAndProps() throws Exception     {         ConstructorAndPropsBean bean = MAPPER.readValue             ("{ \"a\" : \"1\", \"b\": 2, \"c\" : true }", ConstructorAndPropsBean.class);         assertEquals(1, bean.a);         assertEquals(2, bean.b);         assertEquals(true, bean.c);     }      public void testFactoryAndProps() throws Exception     {         FactoryAndPropsBean bean = MAPPER.readValue             ("{ \"a\" : [ false, true, false ], \"b\": 2, \"c\" : -1 }", FactoryAndPropsBean.class);         assertEquals(2, bean.arg2);         assertEquals(-1, bean.arg3);         boolean[] arg1 = bean.arg1;         assertNotNull(arg1);         assertEquals(3, arg1.length);         assertFalse(arg1[0]);         assertTrue(arg1[1]);         assertFalse(arg1[2]);     }      /**      * Test to verify that multiple creators may co-exist, iff      * they use different JSON type as input      */     public void testMultipleCreators() throws Exception     {         MultiBean bean = MAPPER.readValue("123", MultiBean.class);         assertEquals(Integer.valueOf(123), bean.value);         bean = MAPPER.readValue(quote("abc"), MultiBean.class);         assertEquals("abc", bean.value);         bean = MAPPER.readValue("0.25", MultiBean.class);         assertEquals(Double.valueOf(0.25), bean.value);     }      /*     /**********************************************************     /* Test methods, valid cases, deferred, no mixins     /**********************************************************      */      public void testDeferredConstructorAndProps() throws Exception     {         DeferredConstructorAndPropsBean bean = MAPPER.readValue             ("{ \"propB\" : \"...\", \"createA\" : [ 1 ], \"propA\" : null }",              DeferredConstructorAndPropsBean.class);          assertEquals("...", bean.propB);         assertNull(bean.propA);         assertNotNull(bean.createA);         assertEquals(1, bean.createA.length);         assertEquals(1, bean.createA[0]);     }      public void testDeferredFactoryAndProps() throws Exception     {         DeferredFactoryAndPropsBean bean = MAPPER.readValue             ("{ \"prop\" : \"1\", \"ctor\" : \"2\" }", DeferredFactoryAndPropsBean.class);         assertEquals("1", bean.prop);         assertEquals("2", bean.ctor);     }      /*     /**********************************************************     /* Test methods, valid cases, mixins     /**********************************************************      */      public void testFactoryCreatorWithMixin() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(CreatorBean.class, MixIn.class);         CreatorBean bean = m.readValue             ("{ \"a\" : \"xyz\", \"x\" : 12 }", CreatorBean.class);         assertEquals(11, bean.x);         assertEquals("factory:xyz", bean.a);     }      public void testFactoryCreatorWithRenamingMixin() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class);         // override changes property name from "f" to "mixed"         FactoryBean bean = m.readValue("{ \"mixed\" :  20.5 }", FactoryBean.class);         assertEquals(20.5, bean.d);     }      /*     /**********************************************************     /* Test methods, valid cases, Map with creator     /* (to test [JACKSON-153])     /**********************************************************      */      public void testMapWithConstructor() throws Exception     {         MapWithCtor result = MAPPER.readValue             ("{\"text\":\"abc\", \"entry\":true, \"number\":123, \"xy\":\"yx\"}",              MapWithCtor.class);         // regular Map entries:         assertEquals(Boolean.TRUE, result.get("entry"));         assertEquals("yx", result.get("xy"));         assertEquals(2, result.size());         // then ones passed via constructor         assertEquals("abc", result._text);         assertEquals(123, result._number);     }      public void testMapWithFactory() throws Exception     {         MapWithFactory result = MAPPER.readValue             ("{\"x\":\"...\",\"b\":true  }",              MapWithFactory.class);         assertEquals("...", result.get("x"));         assertEquals(1, result.size());         assertEquals(Boolean.TRUE, result._b);     }      /*     /**********************************************************     /* Test methods, invalid/broken cases     /**********************************************************      */      public void testBrokenConstructor() throws Exception     {         try {             /*BrokenBean bean =*/ MAPPER.readValue("{ \"x\" : 42 }", BrokenBean.class);         } catch (JsonMappingException je) {             verifyException(je, "has no property name");         }     } } 
 package com.fasterxml.jackson.databind.creators;  import java.io.IOException; import java.util.List; import java.util.Map;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize;  public class TestCreators2     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      static class HashTest     {         final byte[] bytes;         final String type;          @JsonCreator         public HashTest(@JsonProperty("bytes") @JsonDeserialize(using = BytesDeserializer.class) final byte[] bytes,                 @JsonProperty("type") final String type)         {             this.bytes = bytes;             this.type = type;         }     }      static class BytesDeserializer extends JsonDeserializer<byte[]>     {         @Override         public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {             String str = jp.getText();             return str.getBytes("UTF-8");         }     }      static class Primitives     {         protected int x = 3;         protected double d = -0.5;         protected boolean b = true;                  @JsonCreator         public Primitives(@JsonProperty("x") int x,                 @JsonProperty("d") double d,                 @JsonProperty("b") boolean b)         {             this.x = x;             this.d = d;             this.b = b;         }     }          protected static class Test431Container {         protected final List<Item431> items;          @JsonCreator         public Test431Container(@JsonProperty("items") final List<Item431> i) {             items = i;         } }          @JsonIgnoreProperties(ignoreUnknown = true)     protected static class Item431 {         protected final String id;          @JsonCreator         public Item431(@JsonProperty("id") String id) {             this.id = id;         }     }      // Test class for verifying that creator-call failures are reported as checked exceptions     static class BeanFor438 {         @JsonCreator         public BeanFor438(@JsonProperty("name") String s) {             throw new IllegalArgumentException("I don't like that name!");         }     }      // For [JACKSON-465]     static class MapBean     {         protected Map<String,Long> map;                  @JsonCreator         public MapBean(Map<String, Long> map) {             this.map = map;         }     }      // For [JACKSON-470]: should be appropriately detected, reported error about     static class BrokenCreatorBean     {         protected String bar;                  @JsonCreator         public BrokenCreatorBean(@JsonProperty("bar") String bar1, @JsonProperty("bar") String bar2) {             bar = ""+bar1+"/"+bar2;         }     }          // For [JACKSON-541]: should not need @JsonCreator if SerializationFeature.AUTO_DETECT_CREATORS is on.     static class AutoDetectConstructorBean     {     	protected final String foo;     	protected final String bar;      	public AutoDetectConstructorBean(@JsonProperty("bar") String bar, @JsonProperty("foo") String foo){     	    this.bar = bar;     	    this.foo = foo;     	}     }      static class BustedCtor {         @JsonCreator         BustedCtor(@JsonProperty("a") String value) {             throw new IllegalArgumentException("foobar");         }     }      // As per [JACKSON-575]     static class IgnoredCtor     {         @JsonIgnore         public IgnoredCtor(String arg) {             throw new RuntimeException("Should never use this constructor");         }          public IgnoredCtor() { }     }      abstract static class AbstractBase {         @JsonCreator         public static AbstractBase create(Map<String,Object> props)         {             return new AbstractBaseImpl(props);         }     }      static class AbstractBaseImpl extends AbstractBase     {         protected Map<String,Object> props;                  public AbstractBaseImpl(Map<String,Object> props) {             this.props = props;         }     }          static interface Issue700Set extends java.util.Set<Object> { }      static class Issue700Bean     {         protected Issue700Set item;          @JsonCreator         public Issue700Bean(@JsonProperty("item") String item) { }          public String getItem() { return null; }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          // for [JACKSON-547]     public void testExceptionFromConstructor() throws Exception     {         try {             MAPPER.readValue("{}", BustedCtor.class);             fail("Expected exception");         } catch (JsonMappingException e) {             verifyException(e, ": foobar");             // also: should have nested exception             Throwable t = e.getCause();             assertNotNull(t);             assertEquals(IllegalArgumentException.class, t.getClass());             assertEquals("foobar", t.getMessage());         }     }          public void testSimpleConstructor() throws Exception     {         HashTest test = MAPPER.readValue("{\"type\":\"custom\",\"bytes\":\"abc\" }", HashTest.class);         assertEquals("custom", test.type);         assertEquals("abc", new String(test.bytes, "UTF-8"));     }          // Test for [JACKSON-372]     public void testMissingPrimitives() throws Exception     {         Primitives p = MAPPER.readValue("{}", Primitives.class);         assertFalse(p.b);         assertEquals(0, p.x);         assertEquals(0.0, p.d);     }      public void testJackson431() throws Exception     {         final Test431Container foo = MAPPER.readValue(                 "{\"items\":\n"                 +"[{\"bar\": 0,\n"                 +"\"id\": \"id123\",\n"                 +"\"foo\": 1\n"                  +"}]}",                 Test431Container.class);         assertNotNull(foo);     }      // [JACKSON-438]: Catch and rethrow exceptions that Creator methods throw     public void testJackson438() throws Exception     {         try {             MAPPER.readValue("{ \"name\":\"foobar\" }", BeanFor438.class);             fail("Should have failed");         } catch (Exception e) {             if (!(e instanceof JsonMappingException)) {                 fail("Should have received JsonMappingException, caught "+e.getClass().getName());             }             verifyException(e, "don't like that name");             // Ok: also, let's ensure root cause is directly linked, without other extra wrapping:             Throwable t = e.getCause();             assertNotNull(t);             assertEquals(IllegalArgumentException.class, t.getClass());             verifyException(e, "don't like that name");         }     }      @SuppressWarnings("unchecked")     public void testIssue465() throws Exception     {         final String JSON = "{\"A\":12}";          // first, test with regular Map, non empty         Map<String,Long> map = MAPPER.readValue(JSON, Map.class);         assertEquals(1, map.size());         assertEquals(Integer.valueOf(12), map.get("A"));                  MapBean bean = MAPPER.readValue(JSON, MapBean.class);         assertEquals(1, bean.map.size());         assertEquals(Long.valueOf(12L), bean.map.get("A"));          // and then empty ones         final String EMPTY_JSON = "{}";          map = MAPPER.readValue(EMPTY_JSON, Map.class);         assertEquals(0, map.size());                  bean = MAPPER.readValue(EMPTY_JSON, MapBean.class);         assertEquals(0, bean.map.size());     }      public void testCreatorWithDupNames() throws Exception     {         try {             MAPPER.readValue("{\"bar\":\"x\"}", BrokenCreatorBean.class);             fail("Should have caught duplicate creator parameters");         } catch (JsonMappingException e) {             verifyException(e, "duplicate creator property \"bar\"");         }     }          public void testCreatorMultipleArgumentWithoutAnnotation() throws Exception {         AutoDetectConstructorBean value = MAPPER.readValue("{\"bar\":\"bar\",\"foo\":\"foo\"}", AutoDetectConstructorBean.class);         assertEquals("bar", value.bar);         assertEquals("foo", value.foo);     }      // for [JACKSON-575]     public void testIgnoredSingleArgCtor() throws Exception     {         try {             MAPPER.readValue(quote("abc"), IgnoredCtor.class);             fail("Should have caught missing constructor problem");         } catch (JsonMappingException e) {             verifyException(e, "no single-String constructor/factory method");         }     }      public void testAbstractFactory() throws Exception     {         AbstractBase bean = MAPPER.readValue("{\"a\":3}", AbstractBase.class);         assertNotNull(bean);         AbstractBaseImpl impl = (AbstractBaseImpl) bean;         assertEquals(1, impl.props.size());         assertEquals(Integer.valueOf(3), impl.props.get("a"));     }      // [JACKSON-700]     public void testCreatorProperties() throws Exception     {         Issue700Bean value = MAPPER.readValue("{ \"item\" : \"foo\" }", Issue700Bean.class);         assertNotNull(value);     } } 
package com.fasterxml.jackson.databind.creators;  import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JacksonInject;  import com.fasterxml.jackson.databind.*;  public class TestCreatorsDelegating extends BaseMapTest {     static class BooleanBean     {         protected Boolean value;          public BooleanBean(Boolean v) { value = v; }                  @JsonCreator         protected static BooleanBean create(Boolean value) {             return new BooleanBean(value);         }     }      // for [JACKSON-711]; should allow delegate-based one(s) too     static class CtorBean711     {         protected String name;         protected int age;                  @JsonCreator         public CtorBean711(@JacksonInject String n, int a)         {             name = n;             age = a;         }     }      // for [JACKSON-711]; should allow delegate-based one(s) too     static class FactoryBean711     {         protected String name1;         protected String name2;         protected int age;                  private FactoryBean711(int a, String n1, String n2) {             age = a;             name1 = n1;             name2 = n2;         }                  @JsonCreator         public static FactoryBean711 create(@JacksonInject String n1, int a, @JacksonInject String n2) {             return new FactoryBean711(a, n1, n2);         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testBooleanDelegate() throws Exception     {         ObjectMapper m = new ObjectMapper();         // should obviously work with booleans...         BooleanBean bb = m.readValue("true", BooleanBean.class);         assertEquals(Boolean.TRUE, bb.value);          // but also with value conversion from String         bb = m.readValue(quote("true"), BooleanBean.class);         assertEquals(Boolean.TRUE, bb.value);     }          // As per [JACKSON-711]: should also work with delegate model (single non-annotated arg)     public void testWithCtorAndDelegate() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setInjectableValues(new InjectableValues.Std()             .addValue(String.class, "Pooka")             );         CtorBean711 bean = null;         try {             bean = mapper.readValue("38", CtorBean711.class);         } catch (JsonMappingException e) {             fail("Did not expect problems, got: "+e.getMessage());         }         assertEquals(38, bean.age);         assertEquals("Pooka", bean.name);     }      public void testWithFactoryAndDelegate() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setInjectableValues(new InjectableValues.Std()             .addValue(String.class, "Fygar")             );         FactoryBean711 bean = null;         try {             bean = mapper.readValue("38", FactoryBean711.class);         } catch (JsonMappingException e) {             fail("Did not expect problems, got: "+e.getMessage());         }         assertEquals(38, bean.age);         assertEquals("Fygar", bean.name1);         assertEquals("Fygar", bean.name2);     } } 
package com.fasterxml.jackson.databind.creators;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying that it is possible to annotate  * various kinds of things with {@link JsonCreator} annotation.  */ public class TestPolymorphicCreators     extends BaseMapTest {     /*     /**********************************************************     /* Helper beans     /**********************************************************      */      static class Animal     {         // All animals have names, for our demo purposes...         public String name;          protected Animal() { }          /**          * Creator method that can instantiate instances of          * appropriate polymoprphic type          */         @JsonCreator         public static Animal create(@JsonProperty("type") String type)         { 	    if ("dog".equals(type)) { 		return new Dog(); 	    } 	    if ("cat".equals(type)) { 		return new Cat(); 	    } 	    throw new IllegalArgumentException("No such animal type ('"+type+"')");         }     }      static class Dog extends Animal     {         double barkVolume; // in decibels         public Dog() { }         public void setBarkVolume(double v) { barkVolume = v; }     }      static class Cat extends Animal     {         boolean likesCream;         public int lives;         public Cat() { }         public void setLikesCream(boolean likesCreamSurely) { likesCream = likesCreamSurely; }     }      abstract static class AbstractRoot     {         private final String opt;          private AbstractRoot(String opt) {             this.opt = opt;         }          @JsonCreator         public static final AbstractRoot make(@JsonProperty("which") int which,             @JsonProperty("opt") String opt) {             if(1 == which) {                 return new One(opt);             }             throw new RuntimeException("cannot instantiate " + which);         }          abstract public int getWhich();          public final String getOpt() {                 return opt;         }     }      static final class One extends AbstractRoot {         private One(String opt) {             super(opt);         }          @Override public int getWhich() {             return 1;         }     }          /*     /**********************************************************     /* Actual tests     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          /**      * Simple test to verify that it is possible to implement polymorphic      * deserialization manually.      */     public void testManualPolymorphicDog() throws Exception     {         // first, a dog, start with type         Animal animal = MAPPER.readValue("{ \"type\":\"dog\", \"name\":\"Fido\", \"barkVolume\" : 95.0 }", Animal.class);         assertEquals(Dog.class, animal.getClass());         assertEquals("Fido", animal.name);         assertEquals(95.0, ((Dog) animal).barkVolume);     }      public void testManualPolymorphicCatBasic() throws Exception     {         // and finally, lactose-intolerant, but otherwise robust super-cat:         Animal animal = MAPPER.readValue("{ \"name\" : \"Macavity\", \"type\":\"cat\", \"lives\":18, \"likesCream\":false }", Animal.class);         assertEquals(Cat.class, animal.getClass());         assertEquals("Macavity", animal.name); // ... there's no one like Macavity!         Cat cat = (Cat) animal;         assertEquals(18, cat.lives);         // ok, he can't drink dairy products. Let's verify:         assertEquals(false, cat.likesCream);     }      public void testManualPolymorphicCatWithReorder() throws Exception     {         // Then cat; shuffle order to mandate buffering         Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class);         assertEquals(Cat.class, animal.getClass());         assertEquals("Venla", animal.name);         // bah, of course cats like cream. But let's ensure Jackson won't mess with laws of nature!         assertTrue(((Cat) animal).likesCream);     }      public void testManualPolymorphicWithNumbered() throws Exception     {          final ObjectWriter w = MAPPER.writerWithType(AbstractRoot.class);          final ObjectReader r = MAPPER.reader(AbstractRoot.class);           AbstractRoot input = AbstractRoot.make(1, "oh hai!");          String json = w.writeValueAsString(input);          AbstractRoot result = r.readValue(json);          assertNotNull(result);          assertEquals("oh hai!", result.getOpt());     } } 
package com.fasterxml.jackson.databind.creators;  import java.util.*;  import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonValueInstantiator; import com.fasterxml.jackson.databind.deser.*; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.type.TypeFactory;  /**  * Test related to [JACKSON-580] (allow specifying custom instantiators)  */ public class TestValueInstantiator extends BaseMapTest {     static class MyBean     {         String _secret;                  public MyBean(String s, boolean bogus) {             _secret = s;         }     }      static class MysteryBean     {         Object value;                  public MysteryBean(Object v) { value = v; }     }          static class CreatorBean     {         String _secret;          public String value;                  protected CreatorBean(String s) {             _secret = s;         }     }      static abstract class InstantiatorBase extends ValueInstantiator     {         @Override         public String getValueTypeDesc() {             return "UNKNOWN";         }          @Override         public boolean canCreateUsingDelegate() { return false; }     }          static abstract class PolymorphicBeanBase { }          static class PolymorphicBean extends PolymorphicBeanBase     {         public String name;     }          @SuppressWarnings("serial")     static class MyList extends ArrayList<Object>     {         public MyList(boolean b) { super(); }     }      @SuppressWarnings("serial")     static class MyMap extends HashMap<String,Object>     {         public MyMap(boolean b) { super(); }         public MyMap(String name) {             super();             put(name, name);         }     }          static class MyBeanInstantiator extends InstantiatorBase     {         @Override         public String getValueTypeDesc() {             return MyBean.class.getName();         }                  @Override         public boolean canCreateUsingDefault() { return true; }          @Override         public MyBean createUsingDefault(DeserializationContext ctxt) {             return new MyBean("secret!", true);         }     }      /**      * Something more ambitious: semi-automated approach to polymorphic      * deserialization, using ValueInstantiator; from Object to any      * type...      */     static class PolymorphicBeanInstantiator extends InstantiatorBase     {         @Override         public String getValueTypeDesc() {             return Object.class.getName();         }                  @Override         public boolean canCreateFromObjectWith() { return true; }                  @Override         public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {             return  new CreatorProperty[] {                     new CreatorProperty("type", config.constructType(Class.class), null,                             null, null, null, 0, null, true)             };         }          @Override         public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) {             try {                 Class<?> cls = (Class<?>) args[0];                 return cls.newInstance();             } catch (Exception e) {                 throw new RuntimeException(e);             }         }     }          static class CreatorMapInstantiator extends InstantiatorBase     {         @Override         public String getValueTypeDesc() {             return MyMap.class.getName();         }                  @Override         public boolean canCreateFromObjectWith() { return true; }          @Override         public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {             return  new CreatorProperty[] {                     new CreatorProperty("name", config.constructType(String.class), null,                             null, null, null, 0, null, true)             };         }          @Override         public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) {             return new MyMap((String) args[0]);         }     }          static class MyDelegateBeanInstantiator extends ValueInstantiator     {         @Override         public String getValueTypeDesc() { return "xxx"; }                  @Override         public boolean canCreateUsingDelegate() { return true; }          @Override         public JavaType getDelegateType(DeserializationConfig config) {             return config.constructType(Object.class);         }                  @Override         public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) {             return new MyBean(""+delegate, true);         }     }          static class MyListInstantiator extends InstantiatorBase     {         @Override         public String getValueTypeDesc() {             return MyList.class.getName();         }                  @Override         public boolean canCreateUsingDefault() { return true; }          @Override         public MyList createUsingDefault(DeserializationContext ctxt) {             return new MyList(true);         }     }      static class MyDelegateListInstantiator extends ValueInstantiator     {         @Override         public String getValueTypeDesc() { return "xxx"; }                  @Override         public boolean canCreateUsingDelegate() { return true; }          @Override         public JavaType getDelegateType(DeserializationConfig config) {             return config.constructType(Object.class);         }                  @Override         public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) {             MyList list = new MyList(true);             list.add(delegate);             return list;         }     }          static class MyMapInstantiator extends InstantiatorBase     {         @Override         public String getValueTypeDesc() {             return MyMap.class.getName();         }                  @Override         public boolean canCreateUsingDefault() { return true; }          @Override         public MyMap createUsingDefault(DeserializationContext ctxt) {             return new MyMap(true);         }     }      static class MyDelegateMapInstantiator extends ValueInstantiator     {         @Override         public String getValueTypeDesc() { return "xxx"; }                  @Override         public boolean canCreateUsingDelegate() { return true; }          @Override         public JavaType getDelegateType(DeserializationConfig config) {             return TypeFactory.defaultInstance().constructType(Object.class);         }                  @Override         public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) {             MyMap map = new MyMap(true);             map.put("value", delegate);             return map;         }     }      @JsonValueInstantiator(AnnotatedBeanInstantiator.class)     static class AnnotatedBean {         protected final String a;         protected final int b;                  public AnnotatedBean(String a, int b) {             this.a = a;             this.b = b;         }     }      static class AnnotatedBeanInstantiator extends InstantiatorBase     {         @Override         public String getValueTypeDesc() {             return MyMap.class.getName();         }                  @Override         public boolean canCreateUsingDefault() { return true; }          @Override         public AnnotatedBean createUsingDefault(DeserializationContext ctxt) {             return new AnnotatedBean("foo", 3);         }     }          @SuppressWarnings("serial")     static class MyModule extends SimpleModule     {         public MyModule(Class<?> cls, ValueInstantiator inst)         {             super("Test", Version.unknownVersion());             this.addValueInstantiator(cls, inst);         }     }          /*     /**********************************************************     /* Unit tests for default creators     /**********************************************************      */      public void testCustomBeanInstantiator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MyBean.class, new MyBeanInstantiator()));         MyBean bean = mapper.readValue("{}", MyBean.class);         assertNotNull(bean);         assertEquals("secret!", bean._secret);     }      public void testCustomListInstantiator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MyList.class, new MyListInstantiator()));         MyList result = mapper.readValue("[]", MyList.class);         assertNotNull(result);         assertEquals(MyList.class, result.getClass());         assertEquals(0, result.size());     }      public void testCustomMapInstantiator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MyMap.class, new MyMapInstantiator()));         MyMap result = mapper.readValue("{ \"a\":\"b\" }", MyMap.class);         assertNotNull(result);         assertEquals(MyMap.class, result.getClass());         assertEquals(1, result.size());     }          /*     /**********************************************************     /* Unit tests for delegate creators     /**********************************************************      */      public void testDelegateBeanInstantiator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MyBean.class, new MyDelegateBeanInstantiator()));         MyBean bean = mapper.readValue("123", MyBean.class);         assertNotNull(bean);         assertEquals("123", bean._secret);     }      public void testDelegateListInstantiator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator()));         MyList result = mapper.readValue("123", MyList.class);         assertNotNull(result);         assertEquals(1, result.size());         assertEquals(Integer.valueOf(123), result.get(0));     }          public void testDelegateMapInstantiator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator()));         MyMap result = mapper.readValue("123", MyMap.class);         assertNotNull(result);         assertEquals(1, result.size());         assertEquals(Integer.valueOf(123), result.values().iterator().next());     }      /*     /**********************************************************     /* Unit tests for property-based creators     /**********************************************************      */      public void testPropertyBasedBeanInstantiator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(CreatorBean.class,                 new InstantiatorBase() {                     @Override                     public boolean canCreateFromObjectWith() { return true; }                              @Override                     public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {                         return  new CreatorProperty[] {                                 new CreatorProperty("secret", config.constructType(String.class), null,                                         null, null, null, 0, null, true)                         };                     }                              @Override                     public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) {                         return new CreatorBean((String) args[0]);                     }         }));         CreatorBean bean = mapper.readValue("{\"secret\":123,\"value\":37}", CreatorBean.class);         assertNotNull(bean);         assertEquals("123", bean._secret);     }      public void testPropertyBasedMapInstantiator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MyMap.class, new CreatorMapInstantiator()));         MyMap result = mapper.readValue("{\"name\":\"bob\", \"x\":\"y\"}", MyMap.class);         assertNotNull(result);         assertEquals(2, result.size());         assertEquals("bob", result.get("bob"));         assertEquals("y", result.get("x"));     }      /*     /**********************************************************     /* Unit tests for scalar-delegates     /**********************************************************      */      public void testBeanFromString() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MysteryBean.class,                 new InstantiatorBase() {                     @Override                     public boolean canCreateFromString() { return true; }                                          @Override                     public Object createFromString(DeserializationContext ctxt, String value) {                         return new MysteryBean(value);                     }         }));         MysteryBean result = mapper.readValue(quote("abc"), MysteryBean.class);         assertNotNull(result);         assertEquals("abc", result.value);     }      public void testBeanFromInt() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MysteryBean.class,                 new InstantiatorBase() {                     @Override                     public boolean canCreateFromInt() { return true; }                                          @Override                     public Object createFromInt(DeserializationContext ctxt, int value) {                         return new MysteryBean(value+1);                     }         }));         MysteryBean result = mapper.readValue("37", MysteryBean.class);         assertNotNull(result);         assertEquals(Integer.valueOf(38), result.value);     }      public void testBeanFromLong() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MysteryBean.class,                 new InstantiatorBase() {                     @Override                     public boolean canCreateFromLong() { return true; }                                          @Override                     public Object createFromLong(DeserializationContext ctxt, long value) {                         return new MysteryBean(value+1L);                     }         }));         MysteryBean result = mapper.readValue("9876543210", MysteryBean.class);         assertNotNull(result);         assertEquals(Long.valueOf(9876543211L), result.value);     }      public void testBeanFromDouble() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MysteryBean.class,                 new InstantiatorBase() {                     @Override                     public boolean canCreateFromDouble() { return true; }                      @Override                     public Object createFromDouble(DeserializationContext ctxt, double value) {                         return new MysteryBean(2.0 * value);                     }         }));         MysteryBean result = mapper.readValue("0.25", MysteryBean.class);         assertNotNull(result);         assertEquals(Double.valueOf(0.5), result.value);     }      public void testBeanFromBoolean() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(MysteryBean.class,                 new InstantiatorBase() {                     @Override                     public boolean canCreateFromBoolean() { return true; }                                          @Override                     public Object createFromBoolean(DeserializationContext ctxt, boolean value) {                         return new MysteryBean(Boolean.valueOf(value));                     }         }));         MysteryBean result = mapper.readValue("true", MysteryBean.class);         assertNotNull(result);         assertEquals(Boolean.TRUE, result.value);     }          /*     /**********************************************************     /* Other tests     /**********************************************************      */           /**      * Beyond basic features, it should be possible to even implement      * polymorphic handling...      */     public void testPolymorphicCreatorBean() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new MyModule(PolymorphicBeanBase.class, new PolymorphicBeanInstantiator()));         String JSON = "{\"type\":"+quote(PolymorphicBean.class.getName())+",\"name\":\"Axel\"}";         PolymorphicBeanBase result = mapper.readValue(JSON, PolymorphicBeanBase.class);         assertNotNull(result);         assertSame(PolymorphicBean.class, result.getClass());         assertEquals("Axel", ((PolymorphicBean) result).name);     }      public void testJackson633() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AnnotatedBean bean = mapper.readValue("{}", AnnotatedBean.class);         assertNotNull(bean);         assertEquals("foo", bean.a);         assertEquals(3, bean.b);     } } 
package com.fasterxml.jackson.databind.deser;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*;  /**  * Tests for checking handling of abstract types.  */ public class TestAbstract     extends BaseMapTest {     static abstract class Abstract {         public int x;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */          /**      * Test to verify details of how trying to deserialize into      * abstract type should fail (if there is no way to determine      * actual type information for the concrete type to use)      */     public void testAbstractFailure() throws Exception     {         ObjectMapper m = new ObjectMapper();         try {             m.readValue("{ \"x\" : 3 }", Abstract.class);             fail("Should fail on trying to deserialize abstract type");         } catch (JsonProcessingException e) {             verifyException(e, "can not construct");         }     } } 
package com.fasterxml.jackson.databind.deser;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * This unit test suite that tests use of {@link JsonIgnore}  * annotation with deserialization.  */ public class TestAnnotationIgnore     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      /// Class for testing {@link JsonIgnore} annotations with setters     final static class SizeClassIgnore     {         int _x = 0;         int _y = 0;          public void setX(int value) { _x = value; }         @JsonIgnore public void setY(int value) { _y = value; }          /* Just igoring won't help a lot here; let's define a replacement          * so that we won't get an exception for "unknown field"          */         @JsonProperty("y") void foobar(int value) {             ; // nop         }     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testSimpleIgnore() throws Exception     {         ObjectMapper m = new ObjectMapper();         SizeClassIgnore result = m.readValue             ("{ \"x\":1, \"y\" : 2 }",              SizeClassIgnore.class);         // x should be set, y not         assertEquals(1, result._x);         assertEquals(0, result._y);     }  } 
package com.fasterxml.jackson.databind.deser;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.core.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.deser.std.StdDeserializer;  /**  * Unit test suite that tests "usingXxx" properties of  * {@link JsonDeserialize} annotation.  */ @SuppressWarnings("serial") public class TestAnnotationUsing     extends BaseMapTest {     /*     /**********************************************************************     /* Annotated Bean classes     /**********************************************************************      */      /**      * Class for testing {@link JsonDeserializer} annotation      * for class itself.      */     @JsonDeserialize(using=ValueDeserializer.class)     final static class ValueClass {         int _a;                  /* we'll test it by not having default no-arg ctor, and leaving          * out single-int-arg ctor (because deserializer would use that too)          */         public ValueClass(int a, int b) {             _a = a;         }     }      /**      * Class for testing {@link JsonDeserializer} annotation      * for a method      */     final static class MethodBean {         int[] _ints;          /* Note: could be made to work otherwise, except that          * to trigger failure (in absence of annotation) Json          * is of type VALUE_NUMBER_INT, not an Array: array would          * work by default, but scalar not          */         @JsonDeserialize(using=IntsDeserializer.class)         public void setInts(int[] i) {             _ints = i;         }     }      static class ArrayBean {         @JsonDeserialize(contentUsing=ValueDeserializer.class)         public Object[] values;     }       static class ListBean {         @JsonDeserialize(contentUsing=ValueDeserializer.class)         public List<Object> values;     }      static class MapBean {         @JsonDeserialize(contentUsing=ValueDeserializer.class)         public Map<String,Object> values;     }      static class MapKeyBean {         @JsonDeserialize(keyUsing=MapKeyDeserializer.class)         public Map<Object,Object> values;     }      @JsonDeserialize(keyUsing=MapKeyDeserializer.class, contentUsing=ValueDeserializer.class)     static class MapKeyMap extends HashMap<Object,Object> { }          /*     /**********************************************************************     /* Deserializers     /**********************************************************************      */      static class ValueDeserializer extends StdDeserializer<ValueClass>     {         public ValueDeserializer() { super(ValueClass.class); }         @Override         public ValueClass deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException, JsonProcessingException         {             int i = jp.getIntValue();             return new ValueClass(i, i);         }     }      private final static class IntsDeserializer extends StdDeserializer<int[]>     {         public IntsDeserializer() { super(int[].class); }         @Override         public int[] deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException, JsonProcessingException         {             return new int[] { jp.getIntValue() };         }     }      private final static class MapKeyDeserializer extends KeyDeserializer     {         @Override         public Object deserializeKey(String key, DeserializationContext ctxt)         {             return new String[] { key };         }     }      /*     /**********************************************************************     /* Tests: specifying deserializer of value itself     /**********************************************************************      */      // Unit test to verify that {@link JsonDeserialize#using} annotation works     // when applied to a class     public void testClassDeserializer() throws Exception     {         ObjectMapper m = new ObjectMapper();         ValueClass result = m.readValue("  123  ", ValueClass.class);         assertEquals(123, result._a);     }      // Unit test to verify that {@link JsonDeserialize#using} annotation works     // when applied to a Method     public void testMethodDeserializer() throws Exception     {         ObjectMapper m = new ObjectMapper();         // note: since it's part of method, must parse from Object struct         MethodBean result = m.readValue(" { \"ints\" : 3 } ", MethodBean.class);         assertNotNull(result);         int[] ints = result._ints;         assertNotNull(ints);         assertEquals(1, ints.length);         assertEquals(3, ints[0]);     }      /*     /**********************************************************************     /* Tests: specifying deserializer for keys and/or contents     /**********************************************************************      */      public void testArrayContentUsing() throws Exception     {         ObjectMapper m = new ObjectMapper();         ArrayBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ArrayBean.class);         assertNotNull(result);         Object[] obs = result.values;         assertNotNull(obs);         assertEquals(3, obs.length);         assertEquals(ValueClass.class, obs[0].getClass());         assertEquals(1, ((ValueClass) obs[0])._a);         assertEquals(ValueClass.class, obs[1].getClass());         assertEquals(2, ((ValueClass) obs[1])._a);         assertEquals(ValueClass.class, obs[2].getClass());         assertEquals(3, ((ValueClass) obs[2])._a);     }      public void testListContentUsing() throws Exception     {         ObjectMapper m = new ObjectMapper();         ListBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ListBean.class);         assertNotNull(result);         List<Object> obs = result.values;         assertNotNull(obs);         assertEquals(3, obs.size());         assertEquals(ValueClass.class, obs.get(0).getClass());         assertEquals(1, ((ValueClass) obs.get(0))._a);         assertEquals(ValueClass.class, obs.get(1).getClass());         assertEquals(2, ((ValueClass) obs.get(1))._a);         assertEquals(ValueClass.class, obs.get(2).getClass());         assertEquals(3, ((ValueClass) obs.get(2))._a);     }      public void testMapContentUsing() throws Exception     {         ObjectMapper m = new ObjectMapper();         MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class);         assertNotNull(result);         Map<String,Object> map = result.values;         assertNotNull(map);         assertEquals(2, map.size());         assertEquals(ValueClass.class, map.get("a").getClass());         assertEquals(1, ((ValueClass) map.get("a"))._a);         assertEquals(ValueClass.class, map.get("b").getClass());         assertEquals(2, ((ValueClass) map.get("b"))._a);     }      public void testMapKeyUsing() throws Exception     {         ObjectMapper m = new ObjectMapper();         MapKeyBean result = m.readValue(" { \"values\" : { \"a\": true } } ", MapKeyBean.class);         assertNotNull(result);         Map<Object,Object> map = result.values;         assertNotNull(map);         assertEquals(1, map.size());         Map.Entry<Object,Object> en = map.entrySet().iterator().next();         assertEquals(String[].class, en.getKey().getClass());         assertEquals(Boolean.TRUE, en.getValue());     }          // @since 1.8     public void testRootValueWithCustomKey() throws Exception     {         ObjectMapper m = new ObjectMapper();         MapKeyMap result = m.readValue(" { \"a\": 13 } ", MapKeyMap.class);         assertNotNull(result);         assertNotNull(result);         assertEquals(1, result.size());         Map.Entry<Object,Object> en = result.entrySet().iterator().next();         assertEquals(ValueClass.class, en.getValue().getClass());         assertEquals(13, ((ValueClass) en.getValue())._a);         assertEquals(String[].class, en.getKey().getClass());     }  } 
package com.fasterxml.jackson.databind.deser;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying that {@link JsonAnySetter} annotation  * works as expected.  */ public class TestAnyProperties     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      static class MapImitator     {         HashMap<String,Object> _map;          public MapImitator() {             _map = new HashMap<String,Object>();         }          @JsonAnySetter         void addEntry(String key, Object value)         {             _map.put(key, value);         }     }      /**      * Let's also verify that it is possible to define different      * value: not often useful, but possible.      */     static class MapImitatorWithValue     {         HashMap<String,int[]> _map;          public MapImitatorWithValue() {             _map = new HashMap<String,int[]>();         }          @JsonAnySetter         void addEntry(String key, int[] value)         {             _map.put(key, value);         }     }      // Bad; 2 "any setters"     static class Broken     {         @JsonAnySetter         void addEntry1(String key, Object value) { }         @JsonAnySetter         void addEntry2(String key, Object value) { }     }      @JsonIgnoreProperties("dummy")     static class Ignored     {         HashMap<String,Object> map = new HashMap<String,Object>();           @JsonIgnore         public String bogus;                  @JsonAnySetter         void addEntry(String key, Object value)         {             map.put(key, value);         }             }      static class Bean744     {         protected Map<String,Object> additionalProperties;                  @JsonAnySetter         public void addAdditionalProperty(String key, Object value) {             if (additionalProperties == null) additionalProperties = new HashMap<String, Object>();             additionalProperties.put(key,value);         }                  public void setAdditionalProperties(Map<String, Object> additionalProperties) {             this.additionalProperties = additionalProperties;         }          @JsonAnyGetter         public Map<String,Object> getAdditionalProperties() { return additionalProperties; }          @JsonIgnore         public String getName() {            return (String) additionalProperties.get("name");         }     }      public class Bean797Base     {         @JsonAnyGetter         public Map<String, JsonNode> getUndefinedProperties() {             throw new IllegalStateException("Should not call parent version!");         }     }      public class Bean797BaseImpl extends Bean797Base     {         @Override         public Map<String, JsonNode> getUndefinedProperties() {             return new HashMap<String, JsonNode>();         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testSimpleMapImitation() throws Exception     {         MapImitator mapHolder = MAPPER.readValue             ("{ \"a\" : 3, \"b\" : true }", MapImitator.class);         Map<String,Object> result = mapHolder._map;         assertEquals(2, result.size());         assertEquals(Integer.valueOf(3), result.get("a"));         assertEquals(Boolean.TRUE, result.get("b"));     }      public void testSimpleTyped() throws Exception     {         MapImitatorWithValue mapHolder = MAPPER.readValue             ("{ \"a\" : [ 3, -1 ], \"b\" : [ ] }", MapImitatorWithValue.class);         Map<String,int[]> result = mapHolder._map;         assertEquals(2, result.size());         assertEquals(new int[] { 3, -1 }, result.get("a"));         assertEquals(new int[0], result.get("b"));     }      public void testBrokenWithDoubleAnnotations() throws Exception     {         try {             @SuppressWarnings("unused")             Broken b = MAPPER.readValue("{ \"a\" : 3 }", Broken.class);             fail("Should have gotten an exception");         } catch (JsonMappingException e) {             verifyException(e, "Multiple 'any-setters'");         }     }      // [JACKSON-313]     public void testIgnored() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);         _testIgnorals(mapper);     }      public void testIgnored383() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);         _testIgnorals(mapper);     }      public void testProblem744() throws Exception     {         Bean744 bean = MAPPER.readValue("{\"name\":\"Bob\"}", Bean744.class);         assertNotNull(bean.additionalProperties);         assertEquals(1, bean.additionalProperties.size());         assertEquals("Bob", bean.additionalProperties.get("name"));     }      public void testIssue797() throws Exception     {         String json = MAPPER.writeValueAsString(new Bean797BaseImpl());         assertEquals("{}", json);     }      /*     /**********************************************************     /* Private helper methods     /**********************************************************      */      private void _testIgnorals(ObjectMapper mapper) throws Exception     {         Ignored bean = mapper.readValue("{\"name\":\"Bob\", \"bogus\": [ 1, 2, 3], \"dummy\" : 13 }", Ignored.class);         // as of 2.0, @JsonIgnoreProperties does block; @JsonIgnore not         assertNull(bean.map.get("dummy"));         assertEquals("[1, 2, 3]", ""+bean.map.get("bogus"));         assertEquals("Bob", bean.map.get("name"));         assertEquals(2, bean.map.size());     } } 
package com.fasterxml.jackson.databind.deser;   import java.io.*; import java.util.*;  import static org.junit.Assert.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.module.SimpleModule;  /**  * This unit test suite tries to verify that the "Native" java type  * mapper can properly re-construct Java array objects from Json arrays.  */ public class TestArrayDeserialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      public final static class Bean1     {         int _x, _y;         List<Bean2> _beans;          // Just for deserialization:         @SuppressWarnings("unused")         private Bean1() { }          public Bean1(int x, int y, List<Bean2> beans)         {             _x = x;             _y = y;             _beans = beans;         }          public int getX() { return _x; }         public int getY() { return _y; }         public List<Bean2> getBeans() { return _beans; }          public void setX(int x) { _x = x; }         public void setY(int y) { _y = y; }         public void setBeans(List<Bean2> b) { _beans = b; }          @Override public boolean equals(Object o) {             if (!(o instanceof Bean1)) return false;             Bean1 other = (Bean1) o;             return (_x == other._x)                 && (_y == other._y)                 && _beans.equals(other._beans)                 ;         }     }      /**      * Simple bean that just gets serialized as a String value.      * Deserialization from String value will be done via single-arg      * constructor.      */     public final static class Bean2         implements JsonSerializable // so we can output as simple String     {         final String _desc;          public Bean2(String d)         {             _desc = d;         }          @Override         public void serialize(JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonGenerationException         {             jgen.writeString(_desc);         }          @Override public String toString() { return _desc; }          @Override public boolean equals(Object o) {             if (!(o instanceof Bean2)) return false;             Bean2 other = (Bean2) o;             return _desc.equals(other._desc);         }          @Override         public void serializeWithType(JsonGenerator jgen,                 SerializerProvider provider, TypeSerializer typeSer)                 throws IOException, JsonProcessingException {         }     }	      static class ObjectWrapper {         public Object wrapped;     }      static class ObjectArrayWrapper {     	public Object[] wrapped;     }      static class CustomNonDeserArrayDeserializer extends JsonDeserializer<NonDeserializable[]>     {         @Override         public NonDeserializable[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException         {             List<NonDeserializable> list = new ArrayList<NonDeserializable>();             while (jp.nextToken() != JsonToken.END_ARRAY) {                 list.add(new NonDeserializable(jp.getText(), false));             }             return list.toArray(new NonDeserializable[list.size()]);         }     }      static class NonDeserializable {         protected String value;                  public NonDeserializable(String v, boolean bogus) {             value = v;         }     }      static class Product {          public String name;          public List<Things> thelist;      }      static class Things {         public String height;         public String width;     }          /*     /**********************************************************     /* Tests for "untyped" arrays, Object[]     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testUntypedArray() throws Exception     {          // to get "untyped" default map-to-map, pass Object[].class         String JSON = "[ 1, null, \"x\", true, 2.0 ]";          Object[] result = MAPPER.readValue(JSON, Object[].class);         assertNotNull(result);          assertEquals(5, result.length);          assertEquals(Integer.valueOf(1), result[0]);         assertNull(result[1]);         assertEquals("x", result[2]);         assertEquals(Boolean.TRUE, result[3]);         assertEquals(Double.valueOf(2.0), result[4]);     }      public void testIntegerArray() throws Exception     {         final int LEN = 90000;          // Let's construct array to get it big enough          StringBuilder sb = new StringBuilder();         sb.append('[');         for (int i = 0; i < LEN; ++i) {             if (i > 0) {                 sb.append(',');             }             sb.append(i);         }         sb.append(']');          Integer[] result = MAPPER.readValue(sb.toString(), Integer[].class);         assertNotNull(result);          assertEquals(LEN, result.length);         for (int i = 0; i < LEN; ++i) {             assertEquals(i, result[i].intValue());         }     }      // [JACKSON-620]: allow "" to mean 'null' for Arrays, List and Maps     public void testFromEmptyString() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);         assertNull(m.readValue(quote(""), Object[].class));         assertNull( m.readValue(quote(""), String[].class));         assertNull( m.readValue(quote(""), int[].class));     }      // [JACKSON-620]: allow "" to mean 'null' for Arrays, List and Maps     public void testFromEmptyString2() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);         m.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);         Product p = m.readValue("{\"thelist\":\"\"}", Product.class);         assertNotNull(p);         assertNull(p.thelist);     }          /*     /**********************************************************     /* Arrays of arrays...     /**********************************************************      */      public void testUntypedArrayOfArrays() throws Exception     {         // to get "untyped" default map-to-map, pass Object[].class         final String JSON = "[[[-0.027512,51.503221],[-0.008497,51.503221],[-0.008497,51.509744],[-0.027512,51.509744]]]";          Object result = MAPPER.readValue(JSON, Object.class);         assertEquals(ArrayList.class, result.getClass());         assertNotNull(result);          // Should be able to get it as an Object array as well          Object[] array = MAPPER.readValue(JSON, Object[].class);         assertNotNull(array);         assertEquals(Object[].class, array.getClass());          // and as wrapped variants too         ObjectWrapper w = MAPPER.readValue("{\"wrapped\":"+JSON+"}", ObjectWrapper.class);         assertNotNull(w);         assertNotNull(w.wrapped);         assertEquals(ArrayList.class, w.wrapped.getClass());          ObjectArrayWrapper aw = MAPPER.readValue("{\"wrapped\":"+JSON+"}", ObjectArrayWrapper.class);         assertNotNull(aw);         assertNotNull(aw.wrapped);     }              /*     /**********************************************************     /* Tests for String arrays, char[]     /**********************************************************      */      public void testStringArray() throws Exception     {         final String[] STRS = new String[] {             "a", "b", "abcd", "", "???", "\"quoted\"", "lf: \n",         };         StringWriter sw = new StringWriter();         JsonGenerator jg = new JsonFactory().createGenerator(sw);         jg.writeStartArray();         for (String str : STRS) {             jg.writeString(str);         }         jg.writeEndArray();         jg.close();          String[] result = MAPPER.readValue(sw.toString(), String[].class);         assertNotNull(result);          assertEquals(STRS.length, result.length);         for (int i = 0; i < STRS.length; ++i) {             assertEquals(STRS[i], result[i]);         }     }      public void testCharArray() throws Exception     {         final String TEST_STR = "Let's just test it? Ok!";         char[] result = MAPPER.readValue("\""+TEST_STR+"\"", char[].class);         assertEquals(TEST_STR, new String(result));          // And just for [JACKSON-289], let's verify that fluffy arrays work too         result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class);         assertEquals("abc", new String(result));     }      /*     /**********************************************************     /* Tests for primitive arrays     /**********************************************************      */      public void testBooleanArray() throws Exception     {         boolean[] result = MAPPER.readValue("[ true, false, false ]", boolean[].class);         assertNotNull(result);         assertEquals(3, result.length);         assertTrue(result[0]);         assertFalse(result[1]);         assertFalse(result[2]);     }      public void testByteArrayAsNumbers() throws Exception     {         final int LEN = 37000;         StringBuilder sb = new StringBuilder();         sb.append('[');         for (int i = 0; i < LEN; ++i) {             int value = i - 128;             sb.append((value < 256) ? value : (value & 0x7F));             sb.append(',');         }         sb.append("0]");         byte[] result = MAPPER.readValue(sb.toString(), byte[].class);         assertNotNull(result);         assertEquals(LEN+1, result.length);         for (int i = 0; i < LEN; ++i) {             int value = i - 128;             byte exp = (byte) ((value < 256) ? value : (value & 0x7F));             if (exp != result[i]) {                 fail("At offset #"+i+" ("+result.length+"), expected "+exp+", got "+result[i]);             }             assertEquals(exp, result[i]);         }         assertEquals(0, result[LEN]);     }      public void testByteArrayAsBase64() throws Exception     {         /* Hmmh... let's use JsonGenerator here, to hopefully ensure we          * get proper base64 encoding. Plus, not always using that          * silly sample from Wikipedia.          */         JsonFactory jf = new JsonFactory();         StringWriter sw = new StringWriter();          int LEN = 9000;         byte[] TEST = new byte[LEN];         for (int i = 0; i < LEN; ++i) {             TEST[i] = (byte) i;         }          JsonGenerator jg = jf.createGenerator(sw);         jg.writeBinary(TEST);         jg.close();         String inputData = sw.toString();          byte[] result = MAPPER.readValue(inputData, byte[].class);         assertNotNull(result);         assertArrayEquals(TEST, result);     }      /**      * And then bit more challenging case; let's try decoding      * multiple byte arrays from an array...      */     public void testByteArraysAsBase64() throws Exception     {         JsonFactory jf = new JsonFactory();         StringWriter sw = new StringWriter(1000);          final int entryCount = 15;          JsonGenerator jg = jf.createGenerator(sw);         jg.writeStartArray();          byte[][] entries = new byte[entryCount][];         for (int i = 0; i < entryCount; ++i) {             byte[] b = new byte[1000 - i * 20];             for (int x = 0; x < b.length; ++x) {                 b[x] = (byte) (i + x);             }             entries[i] = b;             jg.writeBinary(b);         }         jg.writeEndArray();         jg.close();          String inputData = sw.toString();          byte[][] result = MAPPER.readValue(inputData, byte[][].class);         assertNotNull(result);          assertEquals(entryCount, result.length);         for (int i = 0; i < entryCount; ++i) {             byte[] b = result[i];             assertArrayEquals("Comparing entry #"+i+"/"+entryCount,entries[i], b);         }     }      // [JACKSON-763]     public void testByteArraysWith763() throws Exception     {         String[] input = new String[] { "YQ==", "Yg==", "Yw==" };         byte[][] data = MAPPER.convertValue(input, byte[][].class);         assertEquals("a", new String(data[0], "US-ASCII"));         assertEquals("b", new String(data[1], "US-ASCII"));         assertEquals("c", new String(data[2], "US-ASCII"));     }          public void testShortArray() throws Exception     {         final int LEN = 31001; // fits in signed 16-bit         StringBuilder sb = new StringBuilder();         sb.append('[');         for (int i = 0; i < LEN; ++i) {             if (i > 0) {                 sb.append(',');             }             sb.append(i);         }         sb.append(']');          short[] result = MAPPER.readValue(sb.toString(), short[].class);         assertNotNull(result);          assertEquals(LEN, result.length);         for (int i = 0; i < LEN; ++i) {             short exp = (short) i;             assertEquals(exp, result[i]);         }     }      public void testIntArray() throws Exception     {         final int LEN = 70000;          // Let's construct array to get it big enough          StringBuilder sb = new StringBuilder();         sb.append('[');         for (int i = 0; i < LEN; ++i) {             if (i > 0) {                 sb.append(',');             }             sb.append(-i);         }         sb.append(']');          int[] result = MAPPER.readValue(sb.toString(), int[].class);         assertNotNull(result);          assertEquals(LEN, result.length);         for (int i = 0; i < LEN; ++i) {             assertEquals(-i, result[i]);         }     }      public void testLongArray() throws Exception     {         final int LEN = 12300;         StringBuilder sb = new StringBuilder();         sb.append('[');         for (int i = 0; i < LEN; ++i) {             if (i > 0) {                 sb.append(',');             }             sb.append(i);         }         sb.append(']');          long[] result = MAPPER.readValue(sb.toString(), long[].class);         assertNotNull(result);          assertEquals(LEN, result.length);         for (int i = 0; i < LEN; ++i) {             long exp = (long) i;             assertEquals(exp, result[i]);         }     }      public void testDoubleArray() throws Exception     {         final int LEN = 7000;         StringBuilder sb = new StringBuilder();         sb.append('[');         for (int i = 0; i < LEN; ++i) {             // not ideal, but has to do...             if (i > 0) {                 sb.append(',');             }             sb.append(i).append('.').append(i % 10);         }         sb.append(']');          double[] result = MAPPER.readValue(sb.toString(), double[].class);         assertNotNull(result);          assertEquals(LEN, result.length);         for (int i = 0; i < LEN; ++i) {             String expStr = String.valueOf(i) + "." + String.valueOf(i % 10);             String actStr = String.valueOf(result[i]);             if (!expStr.equals(actStr)) {                 fail("Entry #"+i+"/"+LEN+"; exp '"+expStr+"', got '"+actStr+"'");             }         }     }      public void testFloatArray() throws Exception     {         final int LEN = 7000;         StringBuilder sb = new StringBuilder();         sb.append('[');         for (int i = 0; i < LEN; ++i) {             if (i > 0) {                 sb.append(',');             }             // not ideal, but has to do...             sb.append(i).append('.').append(i % 10);         }         sb.append(']');          float[] result = MAPPER.readValue(sb.toString(), float[].class);         assertNotNull(result);          assertEquals(LEN, result.length);         for (int i = 0; i < LEN; ++i) {             String expStr = String.valueOf(i) + "." + String.valueOf(i % 10);             assertEquals(expStr, String.valueOf(result[i]));         }     }      /*     /**********************************************************     /* Tests for Bean arrays     /**********************************************************      */      public void testBeanArray()         throws Exception     {         List<Bean1> src = new ArrayList<Bean1>();          List<Bean2> b2 = new ArrayList<Bean2>();         b2.add(new Bean2("a"));         b2.add(new Bean2("foobar"));         src.add(new Bean1(1, 2, b2));          b2 = new ArrayList<Bean2>();         b2.add(null);         src.add(new Bean1(4, 5, b2));          // Ok: let's assume bean serializer works ok....         StringWriter sw = new StringWriter();          MAPPER.writeValue(sw, src);          // And then test de-serializer         List<Bean1> result = MAPPER.readValue(sw.toString(), new TypeReference<List<Bean1>>() { });         assertNotNull(result);         assertEquals(src, result);     }      /*     /**********************************************************     /* And custom deserializers too     /**********************************************************      */      public void testCustomDeserializers() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule testModule = new SimpleModule("test", Version.unknownVersion());         testModule.addDeserializer(NonDeserializable[].class, new CustomNonDeserArrayDeserializer());         mapper.registerModule(testModule);                  NonDeserializable[] result = mapper.readValue("[\"a\"]", NonDeserializable[].class);         assertNotNull(result);         assertEquals(1, result.length);         assertEquals("a", result[0].value);     } } 
package com.fasterxml.jackson.databind.deser;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.introspect.VisibilityChecker;  public class TestAutoDetect     extends BaseMapTest {     /*     /********************************************************     /* Helper beans     /********************************************************      */      static class PrivateBean {         String a;          private PrivateBean() { }          private PrivateBean(String a) { this.a = a; }     }          /*     /********************************************************     /* Unit tests     /********************************************************      */          public void testPrivateCtor() throws Exception     {         // first, default settings, with which construction works ok         ObjectMapper m = new ObjectMapper();         PrivateBean bean = m.readValue("\"abc\"", PrivateBean.class);         assertEquals("abc", bean.a);          // then by increasing visibility requirement:         m = new ObjectMapper();         // note: clumsy code, but needed for Eclipse/JDK1.5 compilation (not for 1.6)         VisibilityChecker<?> vc = m.getVisibilityChecker();         vc = vc.withCreatorVisibility(JsonAutoDetect.Visibility.PUBLIC_ONLY);         m.setVisibilityChecker(vc);         try {             m.readValue("\"abc\"", PrivateBean.class);             fail("Expected exception for missing constructor");         } catch (JsonProcessingException e) {             verifyException(e, "no single-String constructor/factory");         }     }  } 
package com.fasterxml.jackson.databind.deser;  import java.io.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.deser.std.StdDeserializer;  /**  * This unit test suite tests use of basic Annotations for  * bean deserialization; ones that indicate (non-constructor)  * method types, explicit deserializer annotations.  */ @SuppressWarnings("serial") public class TestBasicAnnotations     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      /// Class for testing {@link JsonProperty} annotations     final static class SizeClassSetter     {         int _size;         int _length;         int _other;          @JsonProperty public void size(int value) { _size = value; }         @JsonProperty("length") public void foobar(int value) { _length = value; }          // note: need not be public if annotated         @JsonProperty protected void other(int value) { _other = value; }          // finally: let's add a red herring that should be avoided...         public void errorOut(int value) { throw new Error(); }     }      final static class SizeClassSetter2     {         int _x;          @JsonProperty public void setX(int value) { _x = value; }          // another red herring, which shouldn't be included         public void setXandY(int x, int y) { throw new Error(); }     }      /**      * One more, but this time checking for implied setter      * using @JsonDeserialize      */     final static class SizeClassSetter3     {         int _x;          @JsonDeserialize public void x(int value) { _x = value; }     }       /// Classes for testing Setter discovery with inheritance     static class BaseBean     {         int _x = 0, _y = 0;          public void setX(int value) { _x = value; }         @JsonProperty("y") void foobar(int value) { _y = value; }     }      static class BeanSubClass extends BaseBean     {         int _z;          public void setZ(int value) { _z = value; }     }      static class BeanWithDeserialize {         @JsonDeserialize private int a;     }          /*     /**********************************************************     /* Other helper classes     /**********************************************************      */      final static class IntsDeserializer extends StdDeserializer<int[]>     {         public IntsDeserializer() { super(int[].class); }         @Override         public int[] deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException, JsonProcessingException         {             return new int[] { jp.getIntValue() };         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testSimpleSetter() throws Exception     {         SizeClassSetter result = MAPPER.readValue             ("{ \"other\":3, \"size\" : 2, \"length\" : -999 }",              SizeClassSetter.class);                                                       assertEquals(3, result._other);         assertEquals(2, result._size);         assertEquals(-999, result._length);     }      // Test for checking [JACKSON-64]     public void testSimpleSetter2() throws Exception     {         SizeClassSetter2 result = MAPPER.readValue("{ \"x\": -3 }",              SizeClassSetter2.class);         assertEquals(-3, result._x);     }      // Checking parts of [JACKSON-120]     public void testSimpleSetter3() throws Exception     {         SizeClassSetter3 result = MAPPER.readValue             ("{ \"x\": 128 }",              SizeClassSetter3.class);         assertEquals(128, result._x);     }      /**      * Test for verifying that super-class setters are used as      * expected.      */     public void testSetterInheritance() throws Exception     {         BeanSubClass result = MAPPER.readValue             ("{ \"x\":1, \"z\" : 3, \"y\" : 2 }",              BeanSubClass.class);         assertEquals(1, result._x);         assertEquals(2, result._y);         assertEquals(3, result._z);     }      public void testImpliedProperty() throws Exception     {         BeanWithDeserialize bean = MAPPER.readValue("{\"a\":3}", BeanWithDeserialize.class);         assertNotNull(bean);         assertEquals(3, bean.a);     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.BeanDeserializer; import com.fasterxml.jackson.databind.deser.BeanDeserializerBuilder; import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier; import com.fasterxml.jackson.databind.deser.std.StdDeserializer; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.type.ArrayType; import com.fasterxml.jackson.databind.type.CollectionType; import com.fasterxml.jackson.databind.type.MapType;  @SuppressWarnings("serial") public class TestBeanDeserializer extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      static class Bean {         public String b = "b";         public String a = "a";          public Bean() { }         public Bean(String a, String b) {             this.a = a;             this.b = b;         }     }      static class ModuleImpl extends SimpleModule     {         protected BeanDeserializerModifier modifier;                  public ModuleImpl(BeanDeserializerModifier modifier)         {             super("test", Version.unknownVersion());             this.modifier = modifier;         }                  @Override         public void setupModule(SetupContext context)         {             super.setupModule(context);             if (modifier != null) {                 context.addBeanDeserializerModifier(modifier);             }         }     }      static class RemovingModifier extends BeanDeserializerModifier     {         private final String _removedProperty;                  public RemovingModifier(String remove) { _removedProperty = remove; }                  @Override         public BeanDeserializerBuilder updateBuilder(DeserializationConfig config,                 BeanDescription beanDesc, BeanDeserializerBuilder builder) {             builder.addIgnorable(_removedProperty);             return builder;         }     }          static class ReplacingModifier extends BeanDeserializerModifier     {         private final JsonDeserializer<?> _deserializer;                  public ReplacingModifier(JsonDeserializer<?> s) { _deserializer = s; }                  @Override         public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,                 BeanDescription beanDesc, JsonDeserializer<?> deserializer) {             return _deserializer;         }     }      static class BogusBeanDeserializer extends JsonDeserializer<Object>     {         private final String a, b;                  public BogusBeanDeserializer(String a, String b) {             this.a = a;             this.b = b;         }                  @Override         public Object deserialize(JsonParser jp, DeserializationContext ctxt)                 throws IOException, JsonProcessingException         {             return new Bean(a, b);         }     }      static class Issue476Bean {         public Issue476Type value1, value2;     }     static class Issue476Type {         public String name, value;     }     static class Issue476Deserializer extends BeanDeserializer         implements ContextualDeserializer     {         protected static int propCount;          public Issue476Deserializer(BeanDeserializer src) {             super(src);         }          @Override         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,                 BeanProperty property) throws JsonMappingException {             propCount++;             return this;         }             }     public class Issue476DeserializerModifier extends BeanDeserializerModifier {         @Override         public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,                 BeanDescription beanDesc, JsonDeserializer<?> deserializer) {             if (Issue476Type.class == beanDesc.getBeanClass()) {                 return new Issue476Deserializer((BeanDeserializer)deserializer);             }             return super.modifyDeserializer(config, beanDesc, deserializer);         }             }     public class Issue476Module extends SimpleModule     {         public Issue476Module() {             super("Issue476Module", Version.unknownVersion());         }                  @Override         public void setupModule(SetupContext context) {             context.addBeanDeserializerModifier(new Issue476DeserializerModifier());         }             }          // [Issue#121], arrays, collections, maps      enum EnumABC { A, B, C; }          static class ArrayDeserializerModifier extends BeanDeserializerModifier {         @Override         public JsonDeserializer<?> modifyArrayDeserializer(DeserializationConfig config, ArrayType valueType,                 BeanDescription beanDesc, JsonDeserializer<?> deserializer) {             return (JsonDeserializer<?>) new StdDeserializer<Object>(Object.class) {                 @Override public Object deserialize(JsonParser jp,                         DeserializationContext ctxt) {                     return new String[] { "foo" };                 }             };         }     }      static class CollectionDeserializerModifier extends BeanDeserializerModifier {         @Override         public JsonDeserializer<?> modifyCollectionDeserializer(DeserializationConfig config, CollectionType valueType,                 BeanDescription beanDesc, JsonDeserializer<?> deserializer) {             return (JsonDeserializer<?>) new StdDeserializer<Object>(Object.class) {                 @Override public Object deserialize(JsonParser jp,                         DeserializationContext ctxt) {                     ArrayList<String> list = new ArrayList<String>();                     list.add("foo");                     return list;                 }             };         }     }      static class MapDeserializerModifier extends BeanDeserializerModifier {         @Override         public JsonDeserializer<?> modifyMapDeserializer(DeserializationConfig config, MapType valueType,                 BeanDescription beanDesc, JsonDeserializer<?> deserializer) {             return (JsonDeserializer<?>) new StdDeserializer<Object>(Object.class) {                 @Override public Object deserialize(JsonParser jp,                         DeserializationContext ctxt) {                     HashMap<String,String> map = new HashMap<String,String>();                     map.put("a", "foo");                     return map;                 }             };         }     }      static class EnumDeserializerModifier extends BeanDeserializerModifier {         @Override         public JsonDeserializer<?> modifyEnumDeserializer(DeserializationConfig config, JavaType valueType,                 BeanDescription beanDesc, JsonDeserializer<?> deserializer) {             return (JsonDeserializer<?>) new StdDeserializer<Object>(Object.class) {                 @Override public Object deserialize(JsonParser jp,                         DeserializationContext ctxt) {                     return "foo";                 }             };         }     }      static class KeyDeserializerModifier extends BeanDeserializerModifier {         @Override         public KeyDeserializer modifyKeyDeserializer(DeserializationConfig config, JavaType valueType,                 KeyDeserializer kd) {             return new KeyDeserializer() {                 @Override                 public Object deserializeKey(String key,                         DeserializationContext ctxt) throws IOException,                         JsonProcessingException {                     return "foo";                 }             };         }     }          /*     /********************************************************     /* Unit tests     /********************************************************      */      public void testPropertyRemoval() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new ModuleImpl(new RemovingModifier("a")));         Bean bean = mapper.readValue("{\"b\":\"2\"}", Bean.class);         assertEquals("2", bean.b);         // and 'a' has its default value:         assertEquals("a", bean.a);     }       public void testDeserializerReplacement() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new ModuleImpl(new ReplacingModifier(new BogusBeanDeserializer("foo", "bar"))));         Bean bean = mapper.readValue("{\"a\":\"xyz\"}", Bean.class);         // custom deserializer always produces instance like this:         assertEquals("foo", bean.a);         assertEquals("bar", bean.b);     }      public void testIssue476() throws Exception     {         final String JSON = "{\"value1\" : {\"name\" : \"fruit\", \"value\" : \"apple\"}, \"value2\" : {\"name\" : \"color\", \"value\" : \"red\"}}";                  ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new Issue476Module());         mapper.readValue(JSON, Issue476Bean.class);          // there are 2 properties         assertEquals(2, Issue476Deserializer.propCount);     }      public void testPOJOFromEmptyString() throws Exception     {         // first, verify default settings which do not accept empty String:         ObjectMapper mapper = new ObjectMapper();         try {             mapper.readValue(quote(""), Bean.class);             fail("Should not accept Empty String for POJO");         } catch (JsonProcessingException e) {             verifyException(e, "from String value");         }          // should be ok to enable dynamically:         mapper = new ObjectMapper();         mapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);         Bean result = mapper.readValue(quote(""), Bean.class);         assertNull(result);     }      // [Issue#120]     public void testModifyArrayDeserializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setDeserializerModifier(new ArrayDeserializerModifier()));         Object[] result = mapper.readValue("[1,2]", Object[].class);         assertEquals(1, result.length);         assertEquals("foo", result[0]);     }      public void testModifyCollectionDeserializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setDeserializerModifier(new CollectionDeserializerModifier())         );         List<?> result = mapper.readValue("[1,2]", List.class);         assertEquals(1, result.size());         assertEquals("foo", result.get(0));     }      public void testModifyMapDeserializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setDeserializerModifier(new MapDeserializerModifier())         );         Map<?,?> result = mapper.readValue("{\"a\":1,\"b\":2}", Map.class);         assertEquals(1, result.size());         assertEquals("foo", result.get("a"));     }      public void testModifyEnumDeserializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setDeserializerModifier(new EnumDeserializerModifier())         );         Object result = mapper.readValue(quote("B"), EnumABC.class);         assertEquals("foo", result);     }      public void testModifyKeyDeserializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setDeserializerModifier(new KeyDeserializerModifier())         );         Map<?,?> result = mapper.readValue("{\"a\":1}", Map.class);         assertEquals(1, result.size());         assertEquals("foo", result.entrySet().iterator().next().getKey());     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*;  /**  * Unit test mostly written to cover issue [JACKSON-81]; unintended blocking  * after data binding.  */ public class TestBlocking     extends BaseMapTest {     /**      * This is an indirect test that should trigger problems if (and only if)      * underlying parser is advanced beyond the only element array.      * Basically, although content is invalid, this should be encountered      * quite yet.      */     public void testEagerAdvance() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         JsonParser jp = createParserUsingReader("[ 1  ");         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());          // And then try to map just a single entry: shouldn't fail:         Integer I = mapper.readValue(jp, Integer.class);         assertEquals(Integer.valueOf(1), I);          // and should fail only now:         try {             jp.nextToken();         } catch (IOException ioe) {             verifyException(ioe, "Unexpected end-of-input: expected close marker for ARRAY");         }     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.IOException; import java.util.*; import java.util.concurrent.ArrayBlockingQueue;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.deser.std.StdDeserializer;  @SuppressWarnings("serial") public class TestCollectionDeserialization     extends BaseMapTest {     enum Key {         KEY1, KEY2, WHATEVER;     }      @JsonDeserialize(using=ListDeserializer.class)     static class CustomList extends LinkedList<String> { }      static class ListDeserializer extends StdDeserializer<CustomList>     {         public ListDeserializer() { super(CustomList.class); }          @Override         public CustomList deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException         {             CustomList result = new CustomList();             result.add(jp.getText());             return result;         }     }      static class XBean {         public int x;     }      // [Issue#199]     static class ListAsIterable {         public Iterable<String> values;     }      static class ListAsIterableX {         public Iterable<XBean> nums;     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final static ObjectMapper MAPPER = new ObjectMapper();          public void testUntypedList() throws Exception     {         // to get "untyped" default List, pass Object.class         String JSON = "[ \"text!\", true, null, 23 ]";          // Not a guaranteed cast theoretically, but will work:         // (since we know that Jackson will construct an ArrayList here...)         Object value = MAPPER.readValue(JSON, Object.class);         assertNotNull(value);         assertTrue(value instanceof ArrayList<?>);         List<?> result = (List<?>) value;          assertEquals(4, result.size());          assertEquals("text!", result.get(0));         assertEquals(Boolean.TRUE, result.get(1));         assertNull(result.get(2));         assertEquals(Integer.valueOf(23), result.get(3));     }      public void testExactStringCollection() throws Exception     {         // to get typing, must use type reference         String JSON = "[ \"a\", \"b\" ]";         List<String> result = MAPPER.readValue(JSON, new TypeReference<ArrayList<String>>() { });          assertNotNull(result);         assertEquals(ArrayList.class, result.getClass());         assertEquals(2, result.size());          assertEquals("a", result.get(0));         assertEquals("b", result.get(1));     }      public void testHashSet() throws Exception     {         String JSON = "[ \"KEY1\", \"KEY2\" ]";          EnumSet<Key> result = MAPPER.readValue(JSON, new TypeReference<EnumSet<Key>>() { });         assertNotNull(result);         assertTrue(EnumSet.class.isAssignableFrom(result.getClass()));         assertEquals(2, result.size());          assertTrue(result.contains(Key.KEY1));         assertTrue(result.contains(Key.KEY2));         assertFalse(result.contains(Key.WHATEVER));     }      /// Test to verify that @JsonDeserialize.using works as expected     public void testCustomDeserializer() throws IOException     {         CustomList result = MAPPER.readValue(quote("abc"), CustomList.class);         assertEquals(1, result.size());         assertEquals("abc", result.get(0));     }      // Testing [JACKSON-526], "implicit JSON array" for single-element arrays,     // mostly produced by Jettison, Badgerfish conversions (from XML)     @SuppressWarnings("unchecked")     public void testImplicitArrays() throws Exception     {         // can't share mapper, custom configs (could create ObjectWriter tho)         ObjectMapper mapper = new ObjectMapper();         mapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);          // first with simple scalar types (numbers), with collections         List<Integer> ints = mapper.readValue("4", List.class);         assertEquals(1, ints.size());         assertEquals(Integer.valueOf(4), ints.get(0));         List<String> strings = mapper.readValue(quote("abc"), new TypeReference<ArrayList<String>>() { });         assertEquals(1, strings.size());         assertEquals("abc", strings.get(0));         // and arrays:         int[] intArray = mapper.readValue("-7", int[].class);         assertEquals(1, intArray.length);         assertEquals(-7, intArray[0]);         String[] stringArray = mapper.readValue(quote("xyz"), String[].class);         assertEquals(1, stringArray.length);         assertEquals("xyz", stringArray[0]);          // and then with Beans:         List<XBean> xbeanList = mapper.readValue("{\"x\":4}", new TypeReference<List<XBean>>() { });         assertEquals(1, xbeanList.size());         assertEquals(XBean.class, xbeanList.get(0).getClass());          Object ob = mapper.readValue("{\"x\":29}", XBean[].class);         XBean[] xbeanArray = (XBean[]) ob;         assertEquals(1, xbeanArray.length);         assertEquals(XBean.class, xbeanArray[0].getClass());     }      // [JACKSON-620]: allow "" to mean 'null' for Maps     public void testFromEmptyString() throws Exception     {         ObjectReader r = MAPPER.reader(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);         List<?> result = r.withType(List.class).readValue(quote(""));         assertNull(result);     }      // [Issue#161]     public void testArrayBlockingQueue() throws Exception     {         // ok to skip polymorphic type to get Object         ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class);         assertNotNull(q);         assertEquals(3, q.size());         assertEquals(Integer.valueOf(1), q.take());         assertEquals(Integer.valueOf(2), q.take());         assertEquals(Integer.valueOf(3), q.take());     }      // [Issue#199]     public void testIterableWithStrings() throws Exception     {         String JSON = "{ \"values\":[\"a\",\"b\"]}";         ListAsIterable w = MAPPER.readValue(JSON, ListAsIterable.class);         assertNotNull(w);         assertNotNull(w.values);         Iterator<String> it = w.values.iterator();         assertTrue(it.hasNext());         assertEquals("a", it.next());         assertEquals("b", it.next());         assertFalse(it.hasNext());     }      public void testIterableWithBeans() throws Exception     {         String JSON = "{ \"nums\":[{\"x\":1},{\"x\":2}]}";         ListAsIterableX w = MAPPER.readValue(JSON, ListAsIterableX.class);         assertNotNull(w);         assertNotNull(w.nums);         Iterator<XBean> it = w.nums.iterator();         assertTrue(it.hasNext());         XBean xb = it.next();         assertNotNull(xb);         assertEquals(1, xb.x);         xb = it.next();         assertEquals(2, xb.x);         assertFalse(it.hasNext());     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.IOException;  import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize;  /**  * Testing for [JACKSON-237] (NPE due to race condition)  */ public class TestConcurrency extends BaseMapTest {     /*     /**********************************************     /* Helper beans     /**********************************************      */      @JsonDeserialize(using=BeanDeserializer.class)     static class Bean     {         public int value = 42;     }      /*     /**********************************************     /* Helper classes     /**********************************************      */          /**      * Dummy deserializer used for verifying that partially handled (i.e. not yet      * resolved) deserializers are not allowed to be used.      */     static class BeanDeserializer         extends JsonDeserializer<Bean>         implements ResolvableDeserializer     {         protected volatile boolean resolved = false;                  @Override         public Bean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException         {             if (!resolved) {                 throw new IOException("Deserializer not yet completely resolved");             }             Bean b = new Bean();             b.value = 13;             return b;         }          @Override         public void resolve(DeserializationContext ctxt) throws JsonMappingException         {             try {                 Thread.sleep(100L);             } catch (Exception e) { }             resolved = true;         }     }      /*     /**********************************************     /* Unit tests     /**********************************************      */      public void testDeserializerResolution() throws Exception     {         /* Let's repeat couple of times, just to be sure; thread timing is not          * exact science; plus caching plays a role too          */         final String JSON = "{\"value\":42}";                  for (int i = 0; i < 5; ++i) {             final ObjectMapper mapper = new ObjectMapper();             Runnable r = new Runnable() {                 @Override                 public void run() {                     try {                         /*Bean b =*/ mapper.readValue(JSON, Bean.class);                     } catch (Exception e) { }                 }             };             Thread t = new Thread(r);             t.start();             // then let it proceed             Thread.sleep(10L);             // and try the same...             Bean b = mapper.readValue(JSON, Bean.class);             // note: funny deserializer, mangles data.. :)             assertEquals(13, b.value);             t.join();         }        } } 
package com.fasterxml.jackson.databind.deser;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.introspect.ClassIntrospector;  /**  * Unit tests for checking handling of DeserializationConfig.  */ public class TestConfig     extends BaseMapTest {     @JsonAutoDetect(setterVisibility=Visibility.NONE)     final static class Dummy { }      final static class EmptyDummy { }      static class AnnoBean {         int value = 3;                  @JsonProperty("y")             public void setX(int v) { value = v; }     }      enum Alpha { A, B, C; }      public static class SimpleBean {         public int x, y;     }          /*     /**********************************************************     /* Main tests     /**********************************************************      */      /* Test to verify that we don't overflow number of features; if we      * hit the limit, need to change implementation -- this test just      * gives low-water mark      */     public void testEnumIndexes()     {         int max = 0;                  for (DeserializationFeature f : DeserializationFeature.values()) {             max = Math.max(max, f.ordinal());         }         if (max >= 31) { // 31 is actually ok; 32 not             fail("Max number of DeserializationFeature enums reached: "+max);         }     }          public void testDefaults()     {         ObjectMapper m = new ObjectMapper();         DeserializationConfig cfg = m.getDeserializationConfig();          // Expected defaults:         assertTrue(cfg.isEnabled(MapperFeature.USE_ANNOTATIONS));         assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));         assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_CREATORS));         assertTrue(cfg.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS));         assertTrue(cfg.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS));           assertFalse(cfg.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS));         assertFalse(cfg.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS));          assertTrue(cfg.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));     }      public void testOverrideIntrospectors()     {         ObjectMapper m = new ObjectMapper();         DeserializationConfig cfg = m.getDeserializationConfig();         // and finally, ensure we could override introspectors         cfg = cfg.with((ClassIntrospector) null); // no way to verify tho         cfg = cfg.with((AnnotationIntrospector) null);         assertNull(cfg.getAnnotationIntrospector());     }              public void testAnnotationsDisabled() throws Exception     {         // first: verify that annotation introspection is enabled by default         ObjectMapper m = new ObjectMapper();         assertTrue(m.getDeserializationConfig().isEnabled(MapperFeature.USE_ANNOTATIONS));         // with annotations, property is renamed         AnnoBean bean = m.readValue("{ \"y\" : 0 }", AnnoBean.class);         assertEquals(0, bean.value);          m = new ObjectMapper();         m.configure(MapperFeature.USE_ANNOTATIONS, false);         // without annotations, should default to default bean-based name...         bean = m.readValue("{ \"x\" : 0 }", AnnoBean.class);         assertEquals(0, bean.value);     }      // [JACKSON-875]     public void testEnumsWhenDisabled() throws Exception     {         ObjectMapper m = new ObjectMapper();         assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class));          m = new ObjectMapper();         m.configure(MapperFeature.USE_ANNOTATIONS, false);         // should still use the basic name handling here         assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class));     }      public void testNoAccessOverrides() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.disable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS);         SimpleBean bean = m.readValue("{\"x\":1,\"y\":2}", SimpleBean.class);         assertEquals(1, bean.x);         assertEquals(2, bean.y);     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonProperty;  import com.fasterxml.jackson.core.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer; import com.fasterxml.jackson.databind.deser.std.StdDeserializer; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.util.StdConverter;  /**  * Test to check that customizations work as expected.  */ @SuppressWarnings("serial") public class TestCustomDeserializers     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      static class DummyDeserializer<T>         extends StdDeserializer<T>     {         final T value;          public DummyDeserializer(T v, Class<T> cls) {             super(cls);             value = v;         }          @Override         public T deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException, JsonProcessingException         {             // need to skip, if structured...             jp.skipChildren();             return value;         }     }      static class TestBeans {         public List<TestBean> beans;     }     static class TestBean {         public CustomBean c;         public String d;     }     @JsonDeserialize(using=CustomBeanDeserializer.class)     static class CustomBean {         protected final int a, b;         public CustomBean(int a, int b) {             this.a = a;             this.b = b;         }     }      static class CustomBeanDeserializer extends JsonDeserializer<CustomBean>     {         @Override         public CustomBean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException         {             int a = 0, b = 0;             JsonToken t = jp.getCurrentToken();             if (t == JsonToken.START_OBJECT) {                 t = jp.nextToken();             } else if (t != JsonToken.FIELD_NAME) {                 throw new Error();             }             while(t == JsonToken.FIELD_NAME) {                 final String fieldName = jp.getCurrentName();                 t = jp.nextToken();                 if (t != JsonToken.VALUE_NUMBER_INT) {                     throw new JsonParseException("expecting number got "+ t, jp.getCurrentLocation());                 }                 if (fieldName.equals("a")) {                     a = jp.getIntValue();                 } else if (fieldName.equals("b")) {                     b = jp.getIntValue();                 } else {                     throw new Error();                 }                 t = jp.nextToken();             }             return new CustomBean(a, b);         }     }      public static class Immutable {         protected int x, y;                  public Immutable(int x0, int y0) {             x = x0;             y = y0;         }     }      // [JACKSON-882]     public static class CustomKey {         private final int id;          public CustomKey(int id) {this.id = id;}          public int getId() { return id; }     }          public static class Model     {         protected final Map<CustomKey, String> map;          @JsonCreator         public Model(@JsonProperty("map") @JsonDeserialize(keyUsing = CustomKeyDeserializer.class) Map<CustomKey, String> map)         {             this.map = new HashMap<CustomKey, String>(map);         }          @JsonProperty         @JsonSerialize(keyUsing = CustomKeySerializer.class)         public Map<CustomKey, String> getMap() {             return map;         }     }           static class CustomKeySerializer extends JsonSerializer<CustomKey> {         @Override         public void serialize(CustomKey value, JsonGenerator jgen, SerializerProvider provider) throws IOException {             jgen.writeFieldName(String.valueOf(value.getId()));         }     }      static class CustomKeyDeserializer extends KeyDeserializer {         @Override         public CustomKey deserializeKey(String key, DeserializationContext ctxt) throws IOException {             return new CustomKey(Integer.valueOf(key));         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      final ObjectMapper MAPPER = new ObjectMapper();          public void testCustomBeanDeserializer() throws Exception     {         String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}";         TestBeans beans = MAPPER.readValue(json, TestBeans.class);          assertNotNull(beans);         List<TestBean> results = beans.beans;         assertNotNull(results);         assertEquals(1, results.size());         TestBean bean = results.get(0);         assertEquals("hello, tatu", bean.d);         CustomBean c = bean.c;         assertNotNull(c);         assertEquals(10, c.a);         assertEquals(20, c.b);          json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"},"             +"{\"d\":\"abc\", \"c\":{\"b\":15}}]}";         beans = MAPPER.readValue(json, TestBeans.class);          assertNotNull(beans);         results = beans.beans;         assertNotNull(results);         assertEquals(2, results.size());          bean = results.get(0);         assertEquals("", bean.d);         c = bean.c;         assertNotNull(c);         assertEquals(-4, c.a);         assertEquals(3, c.b);          bean = results.get(1);         assertEquals("abc", bean.d);         c = bean.c;         assertNotNull(c);         assertEquals(0, c.a);         assertEquals(15, c.b);     }      // [Issue#87]: delegating deserializer     public void testDelegating() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addDeserializer(Immutable.class,             new StdDelegatingDeserializer<Immutable>(                 new StdConverter<JsonNode, Immutable>() {                     @Override                     public Immutable convert(JsonNode value)                     {                         int x = value.path("x").asInt();                         int y = value.path("y").asInt();                         return new Immutable(x, y);                     }                 }                 ));          mapper.registerModule(module);         Immutable imm = mapper.readValue("{\"x\":3,\"y\":7}", Immutable.class);         assertEquals(3, imm.x);         assertEquals(7, imm.y);     }      public void testIssue882() throws Exception     {         Model original = new Model(Collections.singletonMap(new CustomKey(123), "test"));         String json = MAPPER.writeValueAsString(original);         Model deserialized = MAPPER.readValue(json, Model.class);         assertNotNull(deserialized);         assertNotNull(deserialized.map);         assertEquals(1, deserialized.map.size());     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.*; import java.util.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.deser.std.StdDeserializer;  /**  * Test to check that customizations work as expected.  */ @SuppressWarnings("serial") public class TestCustomFactory     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      static class DummyDeserializer<T>         extends StdDeserializer<T>     {         final T value;          public DummyDeserializer(T v, Class<T> cls) {             super(cls);             value = v;         }          @Override         public T deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException, JsonProcessingException         {             // need to skip, if structured...             jp.skipChildren();             return value;         }     }      static class TestBeans {         public List<TestBean> beans;     }     static class TestBean {         public CustomBean c;         public String d;     }     @JsonDeserialize(using=CustomBeanDeserializer.class)     static class CustomBean {         protected final int a, b;         public CustomBean(int a, int b) {             this.a = a;             this.b = b;         }     }      static class CustomBeanDeserializer extends JsonDeserializer<CustomBean>     {         @Override         public CustomBean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException         {             int a = 0, b = 0;             JsonToken t = jp.getCurrentToken();             if (t == JsonToken.START_OBJECT) {                 t = jp.nextToken();             } else if (t != JsonToken.FIELD_NAME) {                 throw new Error();             }             while(t == JsonToken.FIELD_NAME) {                 final String fieldName = jp.getCurrentName();                 t = jp.nextToken();                 if (t != JsonToken.VALUE_NUMBER_INT) {                     throw new JsonParseException("expecting number got "+ t, jp.getCurrentLocation());                 }                 if (fieldName.equals("a")) {                     a = jp.getIntValue();                 } else if (fieldName.equals("b")) {                     b = jp.getIntValue();                 } else {                     throw new Error();                 }                 t = jp.nextToken();             }             return new CustomBean(a, b);         }     }           /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testCustomBeanDeserializer() throws Exception     {          final ObjectMapper map = new ObjectMapper();         String json = "{\"beans\":[{\"c\":{\"a\":10,\"b\":20},\"d\":\"hello, tatu\"}]}";         TestBeans beans = map.readValue(json, TestBeans.class);          assertNotNull(beans);         List<TestBean> results = beans.beans;         assertNotNull(results);         assertEquals(1, results.size());         TestBean bean = results.get(0);         assertEquals("hello, tatu", bean.d);         CustomBean c = bean.c;         assertNotNull(c);         assertEquals(10, c.a);         assertEquals(20, c.b);          json = "{\"beans\":[{\"c\":{\"b\":3,\"a\":-4},\"d\":\"\"},"             +"{\"d\":\"abc\", \"c\":{\"b\":15}}]}";         beans = map.readValue(json, TestBeans.class);          assertNotNull(beans);         results = beans.beans;         assertNotNull(results);         assertEquals(2, results.size());          bean = results.get(0);         assertEquals("", bean.d);         c = bean.c;         assertNotNull(c);         assertEquals(-4, c.a);         assertEquals(3, c.b);          bean = results.get(1);         assertEquals("abc", bean.d);         c = bean.c;         assertNotNull(c);         assertEquals(0, c.a);         assertEquals(15, c.b);     } } 
package com.fasterxml.jackson.databind.deser;  import com.fasterxml.jackson.databind.*;  /**  * Simple unit tests to verify that it is possible to handle  * potentially cyclic structures, as long as object graph itself  * is not cyclic. This is the case for directed hierarchies like  * trees and DAGs.  */ public class TestCyclicTypes     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      static class Bean     {         Bean _next;         String _name;          public Bean() { }          public void setNext(Bean b) { _next = b; }         public void setName(String n) { _name = n; }      }      static class LinkA {         public LinkB next;     }      static class LinkB {         private LinkA a;          public void setA(LinkA a) { this.a = a; }         public LinkA getA() { return a; }     }      static class GenericLink<T> {         public GenericLink<T> next;     }      static class StringLink extends GenericLink<String> {     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testLinked() throws Exception     {         Bean first = new ObjectMapper().readValue             ("{\"name\":\"first\", \"next\": { "              +" \"name\":\"last\", \"next\" : null }}",              Bean.class);          assertNotNull(first);         assertEquals("first", first._name);         Bean last = first._next;         assertNotNull(last);         assertEquals("last", last._name);         assertNull(last._next);     }      public void testLinkedGeneric() throws Exception     {         StringLink link = new ObjectMapper().readValue             ("{\"next\":null}", StringLink.class);         assertNotNull(link);         assertNull(link.next);     }      public void testCycleWith2Classes() throws Exception     {         LinkA a = new ObjectMapper().readValue("{\"next\":{\"a\":null}}", LinkA.class);         assertNotNull(a.next);         LinkB b = a.next;         assertNull(b.a);     } } 
package com.fasterxml.jackson.databind.deser;  import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.*;   import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.exc.InvalidFormatException;  public class TestDateDeserialization     extends BaseMapTest {     // Test for [JACKSON-435]     static class DateAsStringBean     {         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="/yyyy/MM/dd/")         public Date date;     }      static class CalendarAsStringBean     {         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=";yyyy/MM/dd;")         public Calendar cal;     }      static class DateInCETBean {         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd,HH", timezone="CET")         public Date date;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testDateUtil() throws Exception     {         long now = 123456789L;         java.util.Date value = new java.util.Date(now);          // First from long         assertEquals(value, MAPPER.readValue(""+now, java.util.Date.class));          // then from String         String dateStr = dateToString(value);         java.util.Date result = MAPPER.readValue("\""+dateStr+"\"", java.util.Date.class);          assertEquals("Date: expect "+value+" ("+value.getTime()+"), got "+result+" ("+result.getTime()+")",                 value.getTime(), result.getTime());     }      public void testDateUtilWithStringTimestamp() throws Exception     {         long now = 1321992375446L;         /* As of 1.5.0, should be ok to pass as JSON String, as long          * as it is plain timestamp (all numbers, 64-bit)          */         String json = quote(String.valueOf(now));         java.util.Date value = MAPPER.readValue(json, java.util.Date.class);         assertEquals(now, value.getTime());     }      public void testDateUtilRFC1123() throws Exception     {         DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);         // let's use an arbitrary value...         String inputStr = "Sat, 17 Jan 2009 06:13:58 +0000";         java.util.Date inputDate = fmt.parse(inputStr);         assertEquals(inputDate, MAPPER.readValue("\""+inputStr+"\"", java.util.Date.class));     }      public void testDateUtilRFC1123OnNonUSLocales() throws Exception     {         Locale old = Locale.getDefault();         Locale.setDefault(Locale.GERMAN);         DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);         // let's use an arbitrary value...         String inputStr = "Sat, 17 Jan 2009 06:13:58 +0000";         java.util.Date inputDate = fmt.parse(inputStr);         assertEquals(inputDate, MAPPER.readValue("\""+inputStr+"\"", java.util.Date.class));         Locale.setDefault(old);     }      /**      * ISO8601 is supported as well      */     public void testDateUtilISO8601() throws Exception     {         /* let's use simple baseline value, arbitrary date in GMT,          * using the standard notation          */         String inputStr = "1972-12-28T00:00:00.000+0000";         Date inputDate = MAPPER.readValue("\""+inputStr+"\"", java.util.Date.class);         Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));         c.setTime(inputDate);         assertEquals(1972, c.get(Calendar.YEAR));         assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));         assertEquals(28, c.get(Calendar.DAY_OF_MONTH));          // And then the same, but using 'Z' as alias for +0000 (very common)         inputStr = "1972-12-28T00:00:00.000Z";         inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);         c.setTime(inputDate);         assertEquals(1972, c.get(Calendar.YEAR));         assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));         assertEquals(28, c.get(Calendar.DAY_OF_MONTH));          // Same but using colon in timezone         inputStr = "1972-12-28T00:00:00.000+00:00";         inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);         c.setTime(inputDate);         assertEquals(1972, c.get(Calendar.YEAR));         assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));         assertEquals(28, c.get(Calendar.DAY_OF_MONTH));          // Same but only passing hour difference as timezone         inputStr = "1972-12-28T00:00:00.000+00";         inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);         c.setTime(inputDate);         assertEquals(1972, c.get(Calendar.YEAR));         assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));         assertEquals(28, c.get(Calendar.DAY_OF_MONTH));          inputStr = "1984-11-30T00:00:00.000Z";         inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);         c.setTime(inputDate);         assertEquals(1984, c.get(Calendar.YEAR));         assertEquals(Calendar.NOVEMBER, c.get(Calendar.MONTH));         assertEquals(30, c.get(Calendar.DAY_OF_MONTH));     }      public void testDateUtilISO8601NoTimezone() throws Exception     {         // Timezone itself is optional as well...          String inputStr = "1984-11-13T00:00:09";         Date inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);         Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));         c.setTime(inputDate);         assertEquals(1984, c.get(Calendar.YEAR));         assertEquals(Calendar.NOVEMBER, c.get(Calendar.MONTH));         assertEquals(13, c.get(Calendar.DAY_OF_MONTH));         assertEquals(0, c.get(Calendar.HOUR_OF_DAY));         assertEquals(0, c.get(Calendar.MINUTE));         assertEquals(9, c.get(Calendar.SECOND));         assertEquals(0, c.get(Calendar.MILLISECOND));     }      public void testDateUtilISO8601JustDate() throws Exception     {         // Plain date (no time)         String inputStr = "1972-12-28";         Date inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);         Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));         c.setTime(inputDate);         assertEquals(1972, c.get(Calendar.YEAR));         assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));         assertEquals(28, c.get(Calendar.DAY_OF_MONTH));     }      @SuppressWarnings("deprecation")     public void testDateSql() throws Exception     {         java.sql.Date value = new java.sql.Date(0L);         value.setYear(99); // 1999         value.setDate(19);         value.setMonth(Calendar.APRIL);         long now = value.getTime();          // First from long         assertEquals(value, MAPPER.readValue(String.valueOf(now), java.sql.Date.class));          // then from default java.sql.Date String serialization:                  java.sql.Date result = MAPPER.readValue(quote(value.toString()), java.sql.Date.class);         Calendar c = gmtCalendar(result.getTime());         assertEquals(1999, c.get(Calendar.YEAR));         assertEquals(Calendar.APRIL, c.get(Calendar.MONTH));         assertEquals(19, c.get(Calendar.DAY_OF_MONTH));          /* [JACKSON-200]: looks like we better add support for regular date          *   formats as well          */         String expStr = "1981-07-13";         result = MAPPER.readValue(quote(expStr), java.sql.Date.class);         c.setTimeInMillis(result.getTime());         assertEquals(1981, c.get(Calendar.YEAR));         assertEquals(Calendar.JULY, c.get(Calendar.MONTH));         assertEquals(13, c.get(Calendar.DAY_OF_MONTH));          /* 20-Nov-2009, tatus: I'll be damned if I understand why string serialization          *   is off-by-one, but day-of-month does seem to be one less. My guess is          *   that something is funky with timezones (i.e. somewhere local TZ is          *   being used), but just can't resolve it. Hence, need to comment this:          */ //        assertEquals(expStr, result.toString());     }      public void testCalendar() throws Exception     {         // not ideal, to use (ever-changing) current date, but...         java.util.Calendar value = Calendar.getInstance();         long l = 12345678L;         value.setTimeInMillis(l);          // First from long         Calendar result = MAPPER.readValue(""+l, Calendar.class);         assertEquals(l, result.getTimeInMillis());          // Then from serialized String         String dateStr = dateToString(new Date(l));         result = MAPPER.readValue(quote(dateStr), Calendar.class);          // note: representation may differ (wrt timezone etc), but underlying value must remain the same:         assertEquals(l, result.getTimeInMillis());     }      public void testCustom() throws Exception     {         final ObjectMapper mapper = new ObjectMapper();         DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");         df.setTimeZone(TimeZone.getTimeZone("PST"));         mapper.setDateFormat(df);          String dateStr = "1972-12-28X15:45:00";         java.util.Date exp = df.parse(dateStr);         java.util.Date result = mapper.readValue("\""+dateStr+"\"", java.util.Date.class);         assertEquals(exp, result);     }      /**      * Test for [JACKSON-203]: make empty Strings deserialize as nulls by default,      * without need to turn on feature (which may be added in future)      */     public void testDatesWithEmptyStrings() throws Exception     {         assertNull(MAPPER.readValue(quote(""), java.util.Date.class));         assertNull(MAPPER.readValue(quote(""), java.util.Calendar.class));         assertNull(MAPPER.readValue(quote(""), java.sql.Date.class));     }      // for [JACKSON-334]     public void test8601DateTimeNoMilliSecs() throws Exception     {         // ok, Zebra, no milliseconds         for (String inputStr : new String[] {                "2010-06-28T23:34:22Z",                "2010-06-28T23:34:22+0000",                "2010-06-28T23:34:22+00",         }) {             Date inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);             Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));             c.setTime(inputDate);             assertEquals(2010, c.get(Calendar.YEAR));             assertEquals(Calendar.JUNE, c.get(Calendar.MONTH));             assertEquals(28, c.get(Calendar.DAY_OF_MONTH));             assertEquals(23, c.get(Calendar.HOUR_OF_DAY));             assertEquals(34, c.get(Calendar.MINUTE));             assertEquals(22, c.get(Calendar.SECOND));             assertEquals(0, c.get(Calendar.MILLISECOND));         }     }      public void testTimeZone() throws Exception     {         TimeZone result = MAPPER.readValue(quote("PST"), TimeZone.class);         assertEquals("PST", result.getID());     }      public void testCustomDateWithAnnotation() throws Exception     {         DateAsStringBean result = MAPPER.readValue("{\"date\":\"/2005/05/25/\"}", DateAsStringBean.class);         assertNotNull(result);         assertNotNull(result.date);         Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));         long l = result.date.getTime();         if (l == 0L) {             fail("Should not get null date");         }         c.setTimeInMillis(l);         assertEquals(2005, c.get(Calendar.YEAR));         assertEquals(Calendar.MAY, c.get(Calendar.MONTH));         assertEquals(25, c.get(Calendar.DAY_OF_MONTH));     }      public void testCustomCalendarWithAnnotation() throws Exception     {         CalendarAsStringBean cbean = MAPPER.readValue("{\"cal\":\";2007/07/13;\"}",                 CalendarAsStringBean.class);         assertNotNull(cbean);         assertNotNull(cbean.cal);         Calendar c = cbean.cal;         assertEquals(2007, c.get(Calendar.YEAR));         assertEquals(Calendar.JULY, c.get(Calendar.MONTH));         assertEquals(13, c.get(Calendar.DAY_OF_MONTH));     }      public void testCustomCalendarWithTimeZone() throws Exception     {         // And then with different TimeZone: CET is +01:00 from GMT -- read as CET         DateInCETBean cet = MAPPER.readValue("{\"date\":\"2001-01-01,10\"}",                 DateInCETBean.class);         Calendar c = Calendar.getInstance(getUTCTimeZone());         c.setTimeInMillis(cet.date.getTime());         // so, going to UTC/GMT should reduce hour by one         assertEquals(2001, c.get(Calendar.YEAR));         assertEquals(Calendar.JANUARY, c.get(Calendar.MONTH));         assertEquals(1, c.get(Calendar.DAY_OF_MONTH));         assertEquals(9, c.get(Calendar.HOUR_OF_DAY));     }      /*     /**********************************************************     /* Tests to verify failing cases     /**********************************************************      */      public void testInvalidFormat() throws Exception     {         try {             MAPPER.readValue(quote("foobar"), Date.class);             fail("Should have failed with an exception");         } catch (InvalidFormatException e) {             verifyException(e, "Can not construct instance");             assertEquals("foobar", e.getValue());             assertEquals(Date.class, e.getTargetType());         } catch (Exception e) {             fail("Wrong type of exception ("+e.getClass().getName()+"), should get "                     +InvalidFormatException.class.getName());         }     }          /*     /**********************************************************     /* Helper methods     /**********************************************************      */      private String dateToString(java.util.Date value)     {         /* Then from String. This is bit tricky, since JDK does not really          * suggest a 'standard' format. So let's try using something...          */         DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");         return df.format(value);     }      private static Calendar gmtCalendar(long time)     {         Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));         c.setTimeInMillis(time);         return c;     }  } 
package com.fasterxml.jackson.databind.deser;  import java.util.EnumMap; import java.util.EnumSet; import java.util.Map; import java.util.concurrent.TimeUnit;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.deser.std.StdDeserializer;  @SuppressWarnings("serial") public class TestEnumDeserialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes, enums     /**********************************************************      */      enum TestEnum { JACKSON, RULES, OK; }      /**      * Alternative version that annotates which deserializer to use      */     @JsonDeserialize(using=DummySerializer.class)     enum AnnotatedTestEnum {         JACKSON, RULES, OK;     }      public static class DummySerializer extends StdDeserializer<Object>     {         public DummySerializer() { super(Object.class); }         @Override         public Object deserialize(JsonParser jp, DeserializationContext ctxt)         {             return AnnotatedTestEnum.OK;         }     }      protected enum EnumWithCreator {         A, B;          @JsonCreator         public static EnumWithCreator fromEnum(String str) {             if ("enumA".equals(str)) return A;             if ("enumB".equals(str)) return B;             return null;         }     }          protected enum LowerCaseEnum {         A, B, C;         private LowerCaseEnum() { }         @Override         public String toString() { return name().toLowerCase(); }     }      // for [JACKSON-749]     protected enum EnumWithJsonValue {         A("foo"), B("bar");         private final String name;         private EnumWithJsonValue(String n) {             name = n;         }         @JsonValue         @Override         public String toString() { return name; }     }          // [JACKSON-810]     static class ClassWithEnumMapKey {     	@JsonProperty Map<TestEnum, String> map;     }      // [JACKSON-834]     protected enum TestEnumFor834     {         ENUM_A(1), ENUM_B(2), ENUM_C(3);                  private final int id;                  private TestEnumFor834(int id) {             this.id = id;         }                  @JsonCreator public static TestEnumFor834 fromId(int id) {             for (TestEnumFor834 e: values()) {                 if (e.id == id) return e;             }             return null;         }     }      /*     /**********************************************************     /* Tests     /**********************************************************      */      protected final ObjectMapper MAPPER = new ObjectMapper();      public void testSimple() throws Exception     {         // First "good" case with Strings         String JSON = "\"OK\" \"RULES\"  null";         // multiple main-level mappings, need explicit parser:         JsonParser jp = MAPPER.getFactory().createParser(JSON);          assertEquals(TestEnum.OK, MAPPER.readValue(jp, TestEnum.class));         assertEquals(TestEnum.RULES, MAPPER.readValue(jp, TestEnum.class));          /* should be ok; nulls are typeless; handled by mapper, not by          * deserializer          */         assertNull(MAPPER.readValue(jp, TestEnum.class));          // and no more content beyond that...         assertFalse(jp.hasCurrentToken());          /* Then alternative with index (0 means first entry)          */         assertEquals(TestEnum.JACKSON, MAPPER.readValue(" 0 ", TestEnum.class));          /* Then error case: unrecognized value          */         try {             /*Object result =*/ MAPPER.readValue("\"NO-SUCH-VALUE\"", TestEnum.class);             fail("Expected an exception for bogus enum value...");         } catch (JsonMappingException jex) {             verifyException(jex, "value not one of declared");         }     }      /**      * Enums are considered complex if they have code (and hence sub-classes)... an      * example is TimeUnit      */     public void testComplexEnum() throws Exception     {         String json = MAPPER.writeValueAsString(TimeUnit.SECONDS);         assertEquals(quote("SECONDS"), json);         TimeUnit result = MAPPER.readValue(json, TimeUnit.class);         assertSame(TimeUnit.SECONDS, result);     }          /**      * Testing to see that annotation override works      */     public void testAnnotated() throws Exception     {         AnnotatedTestEnum e = MAPPER.readValue("\"JACKSON\"", AnnotatedTestEnum.class);         /* dummy deser always returns value OK, independent of input;          * only works if annotation is used          */         assertEquals(AnnotatedTestEnum.OK, e);     }      public void testEnumMaps() throws Exception     {         EnumMap<TestEnum,String> value = MAPPER.readValue("{\"OK\":\"value\"}",                 new TypeReference<EnumMap<TestEnum,String>>() { });         assertEquals("value", value.get(TestEnum.OK));     }          // Test [JACKSON-214]     public void testSubclassedEnums() throws Exception     {         EnumWithSubClass value = MAPPER.readValue("\"A\"", EnumWithSubClass.class);         assertEquals(EnumWithSubClass.A, value);     }      // [JACKSON-193]     public void testCreatorEnums() throws Exception     {         EnumWithCreator value = MAPPER.readValue("\"enumA\"", EnumWithCreator.class);         assertEquals(EnumWithCreator.A, value);     }          // [JACKSON-212]     public void testToStringEnums() throws Exception     {         // can't reuse global one due to reconfig         ObjectMapper m = new ObjectMapper();         m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true);         LowerCaseEnum value = m.readValue("\"c\"", LowerCaseEnum.class);         assertEquals(LowerCaseEnum.C, value);     }      // [JACKSON-212]     public void testToStringEnumMaps() throws Exception     {         // can't reuse global one due to reconfig         ObjectMapper m = new ObjectMapper();         m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true);         EnumMap<LowerCaseEnum,String> value = m.readValue("{\"a\":\"value\"}",                 new TypeReference<EnumMap<LowerCaseEnum,String>>() { });         assertEquals("value", value.get(LowerCaseEnum.A));     }      // [JACKSON-412], disallow use of numbers     public void testNumbersToEnums() throws Exception     {         // by default numbers are fine:         assertFalse(MAPPER.getDeserializationConfig().isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS));         TestEnum value = MAPPER.readValue("1", TestEnum.class);         assertSame(TestEnum.RULES, value);          // but can also be changed to errors:         ObjectMapper m = new ObjectMapper();         m.configure(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS, true);         try {             value = m.readValue("1", TestEnum.class);             fail("Expected an error");         } catch (JsonMappingException e) {             verifyException(e, "Not allowed to deserialize Enum value out of JSON number");         }     }      // [JACKSON-684], enums using index     public void testEnumsWithIndex() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX);         String json = m.writeValueAsString(TestEnum.RULES);         assertEquals(String.valueOf(TestEnum.RULES.ordinal()), json);         TestEnum result = m.readValue(json, TestEnum.class);         assertSame(TestEnum.RULES, result);     }          // [JACKSON-749]: @JsonValue should be considered as well     public void testEnumsWithJsonValue() throws Exception     {         // first, enum as is         EnumWithJsonValue e = MAPPER.readValue(quote("foo"), EnumWithJsonValue.class);         assertSame(EnumWithJsonValue.A, e);         e = MAPPER.readValue(quote("bar"), EnumWithJsonValue.class);         assertSame(EnumWithJsonValue.B, e);          // then in EnumSet         EnumSet<EnumWithJsonValue> set = MAPPER.readValue("[\"bar\"]",                 new TypeReference<EnumSet<EnumWithJsonValue>>() { });         assertNotNull(set);         assertEquals(1, set.size());         assertTrue(set.contains(EnumWithJsonValue.B));         assertFalse(set.contains(EnumWithJsonValue.A));          // and finally EnumMap         EnumMap<EnumWithJsonValue,Integer> map = MAPPER.readValue("{\"foo\":13}",                 new TypeReference<EnumMap<EnumWithJsonValue, Integer>>() { });         assertNotNull(map);         assertEquals(1, map.size());         assertEquals(Integer.valueOf(13), map.get(EnumWithJsonValue.A));     }      // [JACKSON-756], next three tests      public void testEnumWithCreatorEnumMaps() throws Exception {           EnumMap<EnumWithCreator,String> value = MAPPER.readValue("{\"enumA\":\"value\"}",                   new TypeReference<EnumMap<EnumWithCreator,String>>() {});           assertEquals("value", value.get(EnumWithCreator.A));     }      public void testEnumWithCreatorMaps() throws Exception {           java.util.HashMap<EnumWithCreator,String> value = MAPPER.readValue("{\"enumA\":\"value\"}",                   new TypeReference<java.util.HashMap<EnumWithCreator,String>>() {});           assertEquals("value", value.get(EnumWithCreator.A));     }      public void testEnumWithCreatorEnumSets() throws Exception {           EnumSet<EnumWithCreator> value = MAPPER.readValue("[\"enumA\"]",                   new TypeReference<EnumSet<EnumWithCreator>>() {});           assertTrue(value.contains(EnumWithCreator.A));     }      // [JACKSON-810], ability to ignore unknown Enum values:      public void testAllowUnknownEnumValuesReadAsNull() throws Exception     {         // can not use shared mapper when changing configs...         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);         assertNull(reader.withType(TestEnum.class).readValue("\"NO-SUCH-VALUE\""));         assertNull(reader.withType(TestEnum.class).readValue(" 4343 "));     }      public void testAllowUnknownEnumValuesForEnumSets() throws Exception     {         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);         EnumSet<TestEnum> result = reader.withType(new TypeReference<EnumSet<TestEnum>>() { })                 .readValue("[\"NO-SUCH-VALUE\"]");         assertEquals(0, result.size());     }          public void testAllowUnknownEnumValuesAsMapKeysReadAsNull() throws Exception     {         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);         ClassWithEnumMapKey result = reader.withType(ClassWithEnumMapKey.class)                 .readValue("{\"map\":{\"NO-SUCH-VALUE\":\"val\"}}");         assertTrue(result.map.containsKey(null));     }          public void testDoNotAllowUnknownEnumValuesAsMapKeysWhenReadAsNullDisabled() throws Exception     {         assertFalse(MAPPER.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL));          try {              MAPPER.readValue("{\"map\":{\"NO-SUCH-VALUE\":\"val\"}}", ClassWithEnumMapKey.class);              fail("Expected an exception for bogus enum value...");          } catch (JsonMappingException jex) {              verifyException(jex, "Can not construct Map key");          }     }      // [JACKSON-834]     public void testEnumsFromInts() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         TestEnumFor834 res = mapper.readValue("1 ", TestEnumFor834.class);         assertSame(TestEnumFor834.ENUM_A, res);     }      // [Issue#141]: allow mapping of empty String into null     public void testEnumsWithEmpty() throws Exception     {        final ObjectMapper m = new ObjectMapper();        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);        TestEnum result = m.readValue("\"\"", TestEnum.class);        assertNull(result);     }  } 
package com.fasterxml.jackson.databind.deser;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying that simple exceptions can be deserialized.  */ public class TestExceptionDeserialization     extends BaseMapTest {     @SuppressWarnings("serial")     static class MyException extends Exception     {         protected int value;          protected String myMessage;         protected HashMap<String,Object> stuff = new HashMap<String, Object>();                  @JsonCreator         MyException(@JsonProperty("message") String msg, @JsonProperty("value") int v)         {             super(msg);             myMessage = msg;             value = v;         }          public int getValue() { return value; }                  public String getFoo() { return "bar"; }          @JsonAnySetter public void setter(String key, Object value)         {             stuff.put(key, value);         }     }      @SuppressWarnings("serial")     static class MyNoArgException extends Exception     {         @JsonCreator MyNoArgException() { }     }          /*     /**********************************************************     /* Tests     /**********************************************************      */      final ObjectMapper MAPPER = new ObjectMapper();          public void testIOException() throws IOException     {         IOException ioe = new IOException("TEST");         String json = MAPPER.writeValueAsString(ioe);         IOException result = MAPPER.readValue(json, IOException.class);         assertEquals(ioe.getMessage(), result.getMessage());     }      // As per [JACKSON-377]     public void testWithCreator() throws IOException     {         final String MSG = "the message";         String json = MAPPER.writeValueAsString(new MyException(MSG, 3));          MyException result = MAPPER.readValue(json, MyException.class);         assertEquals(MSG, result.getMessage());         assertEquals(3, result.value);         assertEquals(1, result.stuff.size());         assertEquals(result.getFoo(), result.stuff.get("foo"));     }      // [JACKSON-388]     public void testWithNullMessage() throws IOException     {         final ObjectMapper mapper = new ObjectMapper();         mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);         String json = mapper.writeValueAsString(new IOException((String) null));         IOException result = mapper.readValue(json, IOException.class);         assertNotNull(result);         assertNull(result.getMessage());     }      public void testNoArgsException() throws IOException     {         MyNoArgException exc = MAPPER.readValue("{}", MyNoArgException.class);         assertNotNull(exc);     }      // [JACKSON-794]: try simulating JDK 7 behavior     public void testJDK7SuppressionProperty() throws IOException     {         Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class);         assertNotNull(exc);     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException; import com.fasterxml.jackson.test.BrokenStringReader;  /**  * Unit test for verifying that exceptions are properly handled (caught,  * re-thrown or wrapped, depending)  * with Object deserialization.  */ public class TestExceptionHandling     extends BaseMapTest {     static class Bean {         public String propX;     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */          /**      * Verification of [JACKSON-301]      */     public void testHandlingOfUnrecognized() throws Exception     {         UnrecognizedPropertyException exc = null;         try {             new ObjectMapper().readValue("{\"bar\":3}", Bean.class);         } catch (UnrecognizedPropertyException e) {             exc = e;         }         if (exc == null) {             fail("Should have failed binding");         }         assertEquals("bar", exc.getUnrecognizedPropertyName());         assertEquals(Bean.class, exc.getReferringClass());         // also: should get list of known properties         verifyException(exc, "propX");     }      /**      * Simple test to check behavior when end-of-stream is encountered      * without content. Used to expect EOFException (Jackson 1.x); but      * nowadays ought to be JsonMappingException      */     public void testExceptionWithEmpty() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         try {             Object result = mapper.readValue("    ", Object.class);             fail("Expected an exception, but got result value: "+result);         } catch (Exception e) {             verifyException(e, JsonMappingException.class, "No content");         }     }      public void testExceptionWithIncomplete()         throws Exception     {         BrokenStringReader r = new BrokenStringReader("[ 1, ", "TEST");         JsonFactory f = new JsonFactory();         JsonParser jp = f.createParser(r);         ObjectMapper mapper = new ObjectMapper();         try {             @SuppressWarnings("unused")             Object ob = mapper.readValue(jp, Object.class);             fail("Should have gotten an exception");         } catch (IOException e) {             /* For "bona fide" IO problems (due to low-level problem,              * thrown by reader/stream), IOException must be thrown              */             verifyException(e, IOException.class, "TEST");         }     }      public void testExceptionWithEOF()         throws Exception     {         StringReader r = new StringReader("  3");         JsonFactory f = new JsonFactory();         JsonParser jp = f.createParser(r);         ObjectMapper mapper = new ObjectMapper();          Integer I = mapper.readValue(jp, Integer.class);         assertEquals(3, I.intValue());          // and then end-of-input...         try {             I = mapper.readValue(jp, Integer.class);             fail("Should have gotten an exception");         } catch (IOException e) {             verifyException(e, JsonMappingException.class, "No content");         }         // also: should have no current token after end-of-input         JsonToken t = jp.getCurrentToken();         if (t != null) {             fail("Expected current token to be null after end-of-stream, was: "+t);         }     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */      void verifyException(Exception e, Class<?> expType, String expMsg)         throws Exception     {         if (e.getClass() != expType) {             fail("Expected exception of type "+expType.getName()+", got "+e.getClass().getName());         }         if (expMsg != null) {             verifyException(e, expMsg);         }     } } 
package com.fasterxml.jackson.databind.deser;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.*;  /**  * Unit tests for verifying that field-backed properties can also be  * deserialized (since version 1.1) as well as  * setter-accessible properties.  */ public class TestFieldDeserialization     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      static class SimpleFieldBean     {         public int x, y;          // not auto-detectable, not public         int z;          // ignored, not detectable either         @JsonIgnore public int a;     }      static class SimpleFieldBean2     {         @JsonDeserialize String[] values;     }      @JsonAutoDetect(fieldVisibility=Visibility.NONE)     static class NoAutoDetectBean     {         // not auto-detectable any more         public int z;          @JsonProperty("z")         public int _z;     }      // Let's test invalid bean too     static class DupFieldBean     {         public int z;          @JsonProperty("z")         public int _z;     }      public static class DupFieldBean2     {         @JsonProperty("foo")         public int _z;          @JsonDeserialize         private int foo;     }      public static class OkDupFieldBean         extends SimpleFieldBean     {         @JsonProperty("x")         protected int myX = 10;          public int y = 11;     }          abstract static class Abstract { }     static class Concrete extends Abstract     {         String value;          public Concrete(String v) { value = v; }     }      static class AbstractWrapper {         @JsonDeserialize(as=Concrete.class)         public Abstract value;     }      /*     /**********************************************************     /* Main tests     /**********************************************************      */      public void testSimpleAutoDetect() throws Exception     {         ObjectMapper m = new ObjectMapper();         SimpleFieldBean result = m.readValue("{ \"x\" : -13 }",                                            SimpleFieldBean.class);         assertEquals(-13, result.x);         assertEquals(0, result.y);     }      public void testSimpleAnnotation() throws Exception     {         ObjectMapper m = new ObjectMapper();         SimpleFieldBean2 bean = m.readValue("{ \"values\" : [ \"x\", \"y\" ] }",                 SimpleFieldBean2.class);         String[] values = bean.values;         assertNotNull(values);         assertEquals(2, values.length);         assertEquals("x", values[0]);         assertEquals("y", values[1]);     }      public void testNoAutoDetect() throws Exception     {         ObjectMapper m = new ObjectMapper();         NoAutoDetectBean bean = m.readValue("{ \"z\" : 7 }",                                             NoAutoDetectBean.class);         assertEquals(7, bean._z);     }      public void testTypeAnnotation() throws Exception     {         ObjectMapper m = new ObjectMapper();         AbstractWrapper w = m.readValue("{ \"value\" : \"abc\" }",                                         AbstractWrapper.class);         Abstract bean = w.value;         assertNotNull(bean);         assertEquals(Concrete.class, bean.getClass());         assertEquals("abc", ((Concrete)bean).value);     }      public void testFailureDueToDups() throws Exception     {         try {             writeAndMap(new ObjectMapper(), new DupFieldBean());         } catch (JsonMappingException e) {             verifyException(e, "Multiple fields representing property");         }     }      public void testFailureDueToDups2() throws Exception     {         try {             writeAndMap(new ObjectMapper(), new DupFieldBean2());         } catch (JsonMappingException e) {             verifyException(e, "Multiple fields representing property");         }     }      // For [JACKSON-226], acceptable field overrides     public void testOkFieldOverride() throws Exception     {         ObjectMapper m = new ObjectMapper();         OkDupFieldBean result = m.readValue("{ \"x\" : 1, \"y\" : 2 }",                 OkDupFieldBean.class);         assertEquals(1, result.myX);         assertEquals(2, result.y);     } } 
package com.fasterxml.jackson.databind.deser;  import java.util.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize;  @SuppressWarnings("serial") public class TestGenericCollectionDeser     extends BaseMapTest {     /*     /**********************************************************     /* Test classes, enums     /**********************************************************      */      static class ListSubClass extends ArrayList<StringWrapper> { }      /**      * Map class that should behave like {@link ListSubClass}, but by      * using annotations.      */     @JsonDeserialize(contentAs=StringWrapper.class)     static class AnnotatedStringList extends ArrayList<Object> { }      @JsonDeserialize(contentAs=BooleanWrapper.class)     static class AnnotatedBooleanList extends ArrayList<Object> { }      /*     /**********************************************************     /* Test methods     /**********************************************************      */      /*     /**********************************************************     /* Tests for sub-classing     /**********************************************************      */      /**      * Verifying that sub-classing works ok wrt generics information      */     public void testListSubClass() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         ListSubClass result = mapper.readValue("[ \"123\" ]", ListSubClass.class);         assertEquals(1, result.size());         Object value = result.get(0);         assertEquals(StringWrapper.class, value.getClass());         StringWrapper bw = (StringWrapper) value;         assertEquals("123", bw.str);     }      /*     /**********************************************************     /* Tests for annotations     /**********************************************************      */      // Verifying that sub-classing works ok wrt generics information     public void testAnnotatedLStringist() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AnnotatedStringList result = mapper.readValue("[ \"...\" ]", AnnotatedStringList.class);         assertEquals(1, result.size());         Object ob = result.get(0);         assertEquals(StringWrapper.class, ob.getClass());         assertEquals("...", ((StringWrapper) ob).str);     }      public void testAnnotatedBooleanList() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AnnotatedBooleanList result = mapper.readValue("[ false ]", AnnotatedBooleanList.class);         assertEquals(1, result.size());         Object ob = result.get(0);         assertEquals(BooleanWrapper.class, ob.getClass());         assertFalse(((BooleanWrapper) ob).b);     } } 
package com.fasterxml.jackson.databind.deser;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.type.TypeFactory;  @SuppressWarnings("serial") public class TestGenericMapDeser     extends BaseMapTest {     /*     /**********************************************************     /* Test classes, enums     /**********************************************************      */      static class BooleanWrapper {         final Boolean b;         @JsonCreator BooleanWrapper(Boolean value) { b = value; }     }      static class StringWrapper {         final String str;         @JsonCreator StringWrapper(String value) {             str = value;         }     }      static class MapSubClass extends HashMap<String,BooleanWrapper> { }      /**      * Map class that should behave like {@link MapSubClass}, but by      * using annotations.      */     @JsonDeserialize(keyAs=StringWrapper.class, contentAs=BooleanWrapper.class)         static class AnnotatedMap extends HashMap<Object,Object> { }      interface MapWrapper<K,V> extends java.io.Serializable {         public abstract Map<K,V> getEntries();     }      static class StringMap implements MapWrapper<String,Long>     {         private Map<String,Long> entries = new LinkedHashMap<String,Long>();          public StringMap() { }          @Override         public Map<String,Long> getEntries() { return entries; }     }      static class StringWrapperValueMap<KEY> extends HashMap<KEY,StringWrapper> { }      static class StringStringWrapperMap extends StringWrapperValueMap<String> { }      static class KeyTypeCtor  {         protected String value;         public KeyTypeCtor(String v) { value = v; }     }      static class KeyTypeFactory  {         protected String value;         private KeyTypeFactory(String v, boolean foo) { value = v; }          @JsonCreator         public static KeyTypeFactory create(String str) {             return new KeyTypeFactory(str, true);         }     }          /*     /**********************************************************     /* Test methods for sub-classing     /**********************************************************      */      /**      * Verifying that sub-classing works ok wrt generics information      */     public void testMapSubClass() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         MapSubClass result = mapper.readValue             ("{\"a\":true }", MapSubClass.class);         assertEquals(1, result.size());         Object value = result.get("a");         assertEquals(BooleanWrapper.class, value.getClass());         BooleanWrapper bw = (BooleanWrapper) value;         assertEquals(Boolean.TRUE, bw.b);     }      public void testMapWrapper() throws Exception     {         StringMap value = new ObjectMapper().readValue             ("{\"entries\":{\"a\":9} }", StringMap.class);         assertNotNull(value.getEntries());         assertEquals(1, value.getEntries().size());         assertEquals(Long.valueOf(9), value.getEntries().get("a"));     }      public void testIntermediateTypes() throws Exception     {         StringStringWrapperMap result = new ObjectMapper().readValue             ("{\"a\":\"b\"}", StringStringWrapperMap.class);         assertEquals(1, result.size());         Object value = result.get("a");         assertNotNull(value);         assertEquals(value.getClass(), StringWrapper.class);         assertEquals("b", ((StringWrapper) value).str);     }          /*     /**********************************************************     /* Test methods for sub-classing for annotation handling     /**********************************************************      */      /**      * Verifying that sub-classing works ok wrt generics information      */     public void testAnnotatedMap() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AnnotatedMap result = mapper.readValue             ("{\"a\":true }", AnnotatedMap.class);         assertEquals(1, result.size());         Map.Entry<Object,Object> en = result.entrySet().iterator().next();         assertEquals(StringWrapper.class, en.getKey().getClass());         assertEquals(BooleanWrapper.class, en.getValue().getClass());         assertEquals("a", ((StringWrapper) en.getKey()).str);         assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b);     }      /*     /**********************************************************     /* Test methods for ensuring @JsonCreator works for keys     /**********************************************************      */      public void testKeyViaCtor() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         Map<KeyTypeCtor,Integer> map = mapper.readValue("{\"a\":123}",                 TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeCtor.class, Integer.class));         assertEquals(1, map.size());         Map.Entry<?,?> entry = map.entrySet().iterator().next();         assertEquals(Integer.valueOf(123), entry.getValue());         Object key = entry.getKey();         assertEquals(KeyTypeCtor.class, key.getClass());         assertEquals("a", ((KeyTypeCtor) key).value);     }      public void testKeyViaFactory() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         Map<KeyTypeCtor,Integer> map = mapper.readValue("{\"a\":123}",                 TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class));         assertEquals(1, map.size());         Map.Entry<?,?> entry = map.entrySet().iterator().next();         assertEquals(Integer.valueOf(123), entry.getValue());         Object key = entry.getKey();         assertEquals(KeyTypeFactory.class, key.getClass());         assertEquals("a", ((KeyTypeFactory) key).value);     }  } 
package com.fasterxml.jackson.databind.deser;  import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.util.*;   import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying handling of non-specific numeric types.  */ public class TestGenericNumber     extends BaseMapTest {     public void testIntAsNumber() throws Exception     {         /* Even if declared as 'generic' type, should return using most          * efficient type... here, Integer          */         Number result = new ObjectMapper().readValue(new StringReader(" 123 "), Number.class);         assertEquals(Integer.valueOf(123), result);     }      public void testLongAsNumber() throws Exception     {         // And beyond int range, should get long         long exp = 1234567890123L;         Number result = new ObjectMapper().readValue(String.valueOf(exp), Number.class);         assertEquals(Long.valueOf(exp), result);     }      public void testBigIntAsNumber() throws Exception     {         // and after long, BigInteger         BigInteger biggie = new BigInteger("1234567890123456789012345678901234567890");         Number result = new ObjectMapper().readValue(biggie.toString(), Number.class);         assertEquals(BigInteger.class, biggie.getClass());         assertEquals(biggie, result);     }      public void testIntTypeOverride() throws Exception     {         /* Slight twist; as per [JACKSON-100], can also request binding          * to BigInteger even if value would fit in Integer          */         ObjectMapper m = new ObjectMapper();         m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS);         BigInteger exp = BigInteger.valueOf(123L);          // first test as any Number         Number result = m.readValue(new StringReader(" 123 "), Number.class);         assertEquals(BigInteger.class, result.getClass());         assertEquals(exp, result);          // then as any Object         /*Object value =*/ m.readValue(new StringReader("123"), Object.class);         assertEquals(BigInteger.class, result.getClass());         assertEquals(exp, result);     }      /**      * Related to [JACKSON-72]: by default should wrap floating-point      * Number as Double      */     public void testDoubleAsNumber() throws Exception     {         Number result = new ObjectMapper().readValue(new StringReader(" 1.0 "), Number.class);         assertEquals(Double.valueOf(1.0), result);     }      /**      * Test for verifying [JACKSON-72].      */     public void testFpTypeOverrideSimple() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);         BigDecimal dec = new BigDecimal("0.1");          // First test generic stand-alone Number         Number result = m.readValue(dec.toString(), Number.class);         assertEquals(BigDecimal.class, result.getClass());         assertEquals(dec, result);          // Then plain old Object         Object value = m.readValue(dec.toString(), Object.class);         assertEquals(BigDecimal.class, result.getClass());         assertEquals(dec, value);     }  	public void testFpTypeOverrideStructured() throws Exception     {         ObjectMapper m = new ObjectMapper();         BigDecimal dec = new BigDecimal("-19.37");          m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);          // List element types         @SuppressWarnings("unchecked")         List<Object> list = (List<Object>)m.readValue("[ "+dec.toString()+" ]", List.class);         assertEquals(1, list.size());         Object val = list.get(0);         assertEquals(BigDecimal.class, val.getClass());         assertEquals(dec, val);          // and a map         Map<?,?> map = m.readValue("{ \"a\" : "+dec.toString()+" }", Map.class);         assertEquals(1, map.size());         val = map.get("a");         assertEquals(BigDecimal.class, val.getClass());         assertEquals(dec, val);     } } 
package com.fasterxml.jackson.databind.deser;   import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.*;  public class TestGenerics     extends BaseMapTest {     static abstract class BaseNumberBean<T extends Number>     {         public abstract void setNumber(T value);     }      static class NumberBean         extends BaseNumberBean<Long>     {         long _number;          @Override         public void setNumber(Long value)         {             _number = value.intValue();         }     }      /**      * Very simple bean class      */     static class SimpleBean     {         public int x;     }      static class Wrapper<T>     {         public T value;          public Wrapper() { }          public Wrapper(T v) { value = v; }          @Override         public boolean equals(Object o) {             return (o instanceof Wrapper<?>) && (((Wrapper<?>) o).value.equals(value));         }     }      /*     /***************************************************     /* Test cases     /***************************************************      */      public void testSimpleNumberBean() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         NumberBean result = mapper.readValue("{\"number\":17}", NumberBean.class);         assertEquals(17, result._number);     }      /**      * Unit test for verifying fix to [JACKSON-109].      */     public void testGenericWrapper() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         Wrapper<SimpleBean> result = mapper.readValue             ("{\"value\": { \"x\" : 13 } }",              new TypeReference<Wrapper<SimpleBean>>() { });         assertNotNull(result);         assertEquals(Wrapper.class, result.getClass());         Object contents = result.value;         assertNotNull(contents);         assertEquals(SimpleBean.class, contents.getClass());         SimpleBean bean = (SimpleBean) contents;         assertEquals(13, bean.x);     }      /**      * Unit test for verifying that we can use different      * type bindings for individual generic types;      * problem with [JACKSON-190]      */     public void testMultipleWrappers() throws Exception     {         ObjectMapper mapper = new ObjectMapper();          // First, numeric wrapper         Wrapper<Boolean> result = mapper.readValue             ("{\"value\": true}", new TypeReference<Wrapper<Boolean>>() { });         assertEquals(new Wrapper<Boolean>(Boolean.TRUE), result);          // Then string one         Wrapper<String> result2 = mapper.readValue             ("{\"value\": \"abc\"}", new TypeReference<Wrapper<String>>() { });         assertEquals(new Wrapper<String>("abc"), result2);          // And then number         Wrapper<Long> result3 = mapper.readValue             ("{\"value\": 7}", new TypeReference<Wrapper<Long>>() { });         assertEquals(new Wrapper<Long>(7L), result3);     }      /**      * Unit test for verifying fix to [JACKSON-109].      */     public void testArrayOfGenericWrappers() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         Wrapper<SimpleBean>[] result = mapper.readValue             ("[ {\"value\": { \"x\" : 9 } } ]",              new TypeReference<Wrapper<SimpleBean>[]>() { });         assertNotNull(result);         assertEquals(Wrapper[].class, result.getClass());         assertEquals(1, result.length);         Wrapper<SimpleBean> elem = result[0];         Object contents = elem.value;         assertNotNull(contents);         assertEquals(SimpleBean.class, contents.getClass());         SimpleBean bean = (SimpleBean) contents;         assertEquals(9, bean.x);     } } 
package com.fasterxml.jackson.databind.deser;  import java.util.*;  import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.*;  import java.io.Serializable;  public class TestGenericsBounded     extends BaseMapTest {     @SuppressWarnings("serial")     static class Range<E extends Comparable<E>> implements Serializable     {          protected E start, end;           public Range(){ }          public Range(E start, E end) {              this.start = start;              this.end = end;          }           public E getEnd() { return end; }          public void setEnd(E e) { end = e; }           public E getStart() { return start; }          public void setStart(E s) {              start = s;          }     }      @SuppressWarnings("serial")     static class DoubleRange extends Range<Double> {         public DoubleRange() { }         public DoubleRange(Double s, Double e) { super(s, e); }     }           static class BoundedWrapper<A extends Serializable>     {         public List<A> values;     }      @SuppressWarnings("serial")     static class IntBean implements Serializable     {         public int x;     }      static class IntBeanWrapper<T extends IntBean> {         public T wrapped;     }      // Types for [JACKSON-778]          static class Document {}     static class Row {}     static class RowWithDoc<D extends Document> extends Row {         @JsonProperty("d") D d;     }     static class ResultSet<R extends Row> {         @JsonProperty("rows") List<R> rows;     }     static class ResultSetWithDoc<D extends Document> extends ResultSet<RowWithDoc<D>> {}      static class MyDoc extends Document {}         /*     /*******************************************************     /* Unit tests     /*******************************************************      */      public void testLowerBound() throws Exception     {         IntBeanWrapper<?> result = new ObjectMapper().readValue("{\"wrapped\":{\"x\":3}}",                 IntBeanWrapper.class);         assertNotNull(result);         assertEquals(IntBean.class, result.wrapped.getClass());         assertEquals(3, result.wrapped.x);     }          // Test related to type bound handling problem within [JACKSON-190]     public void testBounded() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         BoundedWrapper<IntBean> result = mapper.readValue             ("{\"values\":[ {\"x\":3} ] } ", new TypeReference<BoundedWrapper<IntBean>>() {});         List<?> list = result.values;         assertEquals(1, list.size());         Object ob = list.get(0);         assertEquals(IntBean.class, ob.getClass());         assertEquals(3, result.values.get(0).x);     }      public void testGenericsComplex() throws Exception     {         ObjectMapper m = new ObjectMapper();         DoubleRange in = new DoubleRange(-0.5, 0.5);         String json = m.writeValueAsString(in);         DoubleRange out = m.readValue(json, DoubleRange.class);         assertNotNull(out);         assertEquals(-0.5, out.start);         assertEquals(0.5, out.end);     }      public void testIssue778() throws Exception     {         final ObjectMapper mapper = new ObjectMapper();         String json = "{\"rows\":[{\"d\":{}}]}";          final TypeReference<?> type = new TypeReference<ResultSetWithDoc<MyDoc>>() {};                  // type passed is correct, but somehow it gets mangled when passed...         ResultSetWithDoc<MyDoc> rs = mapper.readValue(json, type);         Document d = rs.rows.iterator().next().d;              assertEquals(MyDoc.class, d.getClass()); //expected MyDoc but was Document     } } 
package com.fasterxml.jackson.databind.deser;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Test for [JACKSON-429]  */ public class TestIgnoredTypes extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */          @JsonIgnoreType     class IgnoredType { // note: non-static, can't be deserializer         public IgnoredType(IgnoredType src) { }     }      @JsonIgnoreType(false)     static class NonIgnoredType     {         public int value = 13;         public IgnoredType ignored;     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testIgnoredType() throws Exception     {         // First: should be ok in general, even though couldn't build deserializer (due to non-static inner class):         ObjectMapper mapper = new ObjectMapper();         NonIgnoredType bean = mapper.readValue("{\"value\":13}", NonIgnoredType.class);         assertNotNull(bean);         assertEquals(13, bean.value);          // And also ok to see something with that value; will just get ignored         bean = mapper.readValue("{ \"ignored\":[1,2,{}], \"value\":9 }", NonIgnoredType.class);         assertNotNull(bean);         assertEquals(9, bean.value);     } } 
package com.fasterxml.jackson.databind.deser;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  public class TestInjectables extends BaseMapTest {     static class InjectedBean     {         @JacksonInject         protected String stuff;          @JacksonInject("myId")         protected String otherStuff;          protected long third;                  public int value;          @JacksonInject         public void injectThird(long v) {             third = v;         }     }          static class BadBean1 {         @JacksonInject protected String prop1;         @JacksonInject protected String prop2;     }      static class BadBean2 {         @JacksonInject("x") protected String prop1;         @JacksonInject("x") protected String prop2;     }      static class CtorBean {         protected String name;         protected int age;                  public CtorBean(@JacksonInject String n, @JsonProperty("age") int a)         {             name = n;             age = a;         }     }      static class CtorBean2 {         protected String name;         protected Integer age;                  public CtorBean2(@JacksonInject String n, @JacksonInject("number") Integer a)         {             name = n;             age = a;         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testSimple() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setInjectableValues(new InjectableValues.Std()             .addValue(String.class, "stuffValue")             .addValue("myId", "xyz")             .addValue(Long.TYPE, Long.valueOf(37))             );         InjectedBean bean = mapper.readValue("{\"value\":3}", InjectedBean.class);         assertEquals(3, bean.value);         assertEquals("stuffValue", bean.stuff);         assertEquals("xyz", bean.otherStuff);         assertEquals(37L, bean.third);     }          public void testWithCtors() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setInjectableValues(new InjectableValues.Std()             .addValue(String.class, "Bubba")             );         CtorBean bean = mapper.readValue("{\"age\":55}", CtorBean.class);         assertEquals(55, bean.age);         assertEquals("Bubba", bean.name);     }      // [Issue-13]     public void testTwoInjectablesViaCreator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setInjectableValues(new InjectableValues.Std()             .addValue(String.class, "Bob")             .addValue("number", Integer.valueOf(13))             );         CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class);         assertEquals(Integer.valueOf(13), bean.age);         assertEquals("Bob", bean.name);     }          public void testInvalidDup() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         try {             mapper.readValue("{}", BadBean1.class);         } catch (Exception e) {             verifyException(e, "Duplicate injectable value");         }         try {             mapper.readValue("{}", BadBean2.class);         } catch (Exception e) {             verifyException(e, "Duplicate injectable value");         }     } } 
package com.fasterxml.jackson.databind.deser;  import com.fasterxml.jackson.databind.*;  public class TestInnerClass extends BaseMapTest {     // [JACKSON-594]     static class Dog     {       public String name;       public Brain brain;        public Dog() { }       public Dog(String n, boolean thinking) {           name = n;           brain = new Brain();           brain.isThinking = thinking;       }              // note: non-static       public class Brain {           public boolean isThinking;            public String parentName() { return name; }       }     }      /*     /**********************************************************     /* Tests     /**********************************************************      */      public void testSimpleNonStaticInner() throws Exception     {         // Let's actually verify by first serializing, then deserializing back         ObjectMapper mapper = new ObjectMapper();         Dog input = new Dog("Smurf", true);         String json = mapper.writeValueAsString(input);         Dog output = mapper.readValue(json, Dog.class);         assertEquals("Smurf", output.name);         assertNotNull(output.brain);         assertTrue(output.brain.isThinking);         // and verify correct binding...         assertEquals("Smurf", output.brain.parentName());         output.name = "Foo";         assertEquals("Foo", output.brain.parentName());     } } 
package com.fasterxml.jackson.databind.deser;  import java.util.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.type.TypeFactory; import com.fasterxml.jackson.databind.util.TokenBuffer;  /**  * Unit tests for those Jackson types we want to ensure can be deserialized.  */ public class TestJacksonTypes     extends com.fasterxml.jackson.databind.BaseMapTest {     public void testJsonLocation() throws Exception     {         ObjectMapper m = new ObjectMapper();         // note: source reference is untyped, only String guaranteed to work         JsonLocation loc = new JsonLocation("whatever",  -1, -1, 100, 13);         // Let's use serializer here; goal is round-tripping         String ser = serializeAsString(m, loc);         JsonLocation result = m.readValue(ser, JsonLocation.class);         assertNotNull(result);         assertEquals(loc.getSourceRef(), result.getSourceRef());         assertEquals(loc.getByteOffset(), result.getByteOffset());         assertEquals(loc.getCharOffset(), result.getCharOffset());         assertEquals(loc.getColumnNr(), result.getColumnNr());         assertEquals(loc.getLineNr(), result.getLineNr());     }      // doesn't really belong here but...     public void testJsonLocationProps()     {         JsonLocation loc = new JsonLocation(null,  -1, -1, 100, 13);         assertTrue(loc.equals(loc));         assertFalse(loc.equals(null));         assertFalse(loc.equals("abx"));          // should we check it's not 0?         loc.hashCode();     }      /**      * Verify that {@link TokenBuffer} can be properly deserialized      * automatically, using the "standard" JSON sample document      */     public void testTokenBufferWithSample() throws Exception     {         ObjectMapper m = new ObjectMapper();         // First, try standard sample doc:         TokenBuffer result = m.readValue(SAMPLE_DOC_JSON_SPEC, TokenBuffer.class);         verifyJsonSpecSampleDoc(result.asParser(), true);     }      public void testTokenBufferWithSequence() throws Exception     {         ObjectMapper m = new ObjectMapper();         // and then sequence of other things         JsonParser jp = createParserUsingReader("[ 32, [ 1 ], \"abc\", { \"a\" : true } ]");         assertToken(JsonToken.START_ARRAY, jp.nextToken());          assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         TokenBuffer buf = m.readValue(jp, TokenBuffer.class);          // check manually...         JsonParser bufParser = buf.asParser();         assertToken(JsonToken.VALUE_NUMBER_INT, bufParser.nextToken());         assertEquals(32, bufParser.getIntValue());         assertNull(bufParser.nextToken());          // then bind to another         buf = m.readValue(jp, TokenBuffer.class);         bufParser = buf.asParser();         assertToken(JsonToken.START_ARRAY, bufParser.nextToken());         assertToken(JsonToken.VALUE_NUMBER_INT, bufParser.nextToken());         assertEquals(1, bufParser.getIntValue());         assertToken(JsonToken.END_ARRAY, bufParser.nextToken());         assertNull(bufParser.nextToken());          // third one, with automatic binding         buf = m.readValue(jp, TokenBuffer.class);         String str = m.readValue(buf.asParser(), String.class);         assertEquals("abc", str);          // and ditto for last one         buf = m.readValue(jp, TokenBuffer.class);         Map<?,?> map = m.readValue(buf.asParser(), Map.class);         assertEquals(1, map.size());         assertEquals(Boolean.TRUE, map.get("a"));                  assertEquals(JsonToken.END_ARRAY, jp.nextToken());         assertNull(jp.nextToken());     }      public void testJavaType() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         TypeFactory tf = TypeFactory.defaultInstance();         // first simple type:         String json = mapper.writeValueAsString(tf.constructType(String.class));         assertEquals(quote(java.lang.String.class.getName()), json);         // and back         JavaType t = mapper.readValue(json, JavaType.class);         assertNotNull(t);         assertEquals(String.class, t.getRawClass());     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.*; import java.net.*; import java.nio.charset.Charset; import java.util.Currency; import java.util.List; import java.util.Locale; import java.util.regex.Pattern;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility; import com.fasterxml.jackson.databind.*;  public class TestJdkTypes extends BaseMapTest {     static class PrimitivesBean     {         public boolean booleanValue = true;         public byte byteValue = 3;         public char charValue = 'a';         public short shortValue = 37;         public int intValue = 1;         public long longValue = 100L;         public float floatValue = 0.25f;         public double doubleValue = -1.0;     }      // for [JACKSON-616]     static class WrappersBean     {         public Boolean booleanValue;         public Byte byteValue;         public Character charValue;         public Short shortValue;         public Integer intValue;         public Long longValue;         public Float floatValue;         public Double doubleValue;     }           static class ParamClassBean     {          public String name = "bar";          public Class<String> clazz ;           public ParamClassBean() { }          public ParamClassBean(String name) {              this.name = name;              clazz = String.class;          }     }      static class BooleanBean {         public Boolean wrapper;         public boolean primitive;                  protected Boolean ctor;                  @JsonCreator         public BooleanBean(@JsonProperty("ctor") Boolean foo) {             ctor = foo;         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */          private final ObjectMapper mapper = new ObjectMapper();      /**      * Related to issues [JACKSON-155], [#170].      */     public void testFile() throws Exception     {         // Not portable etc... has to do:         File src = new File("/test").getAbsoluteFile();         String abs = src.getAbsolutePath();          // escape backslashes (for portability with windows)         String json = mapper.writeValueAsString(abs);         File result = mapper.readValue(json, File.class);         assertEquals(abs, result.getAbsolutePath());          // Then #170         final ObjectMapper mapper2 = new ObjectMapper();         mapper2.setVisibility(PropertyAccessor.CREATOR, Visibility.NONE);          result = mapper2.readValue(json, File.class);         assertEquals(abs, result.getAbsolutePath());     }      public void testRegexps() throws IOException     {         final String PATTERN_STR = "abc:\\s?(\\d+)";         Pattern exp = Pattern.compile(PATTERN_STR);         /* Ok: easiest way is to just serialize first; problem          * is the backslash          */         String json = mapper.writeValueAsString(exp);         Pattern result = mapper.readValue(json, Pattern.class);         assertEquals(exp.pattern(), result.pattern());     }      public void testCurrency() throws IOException     {         Currency usd = Currency.getInstance("USD");         assertEquals(usd, new ObjectMapper().readValue(quote("USD"), Currency.class));     }      /**      * Test for [JACKSON-419]      */     public void testLocale() throws IOException     {         assertEquals(new Locale("en"), mapper.readValue(quote("en"), Locale.class));         assertEquals(new Locale("es", "ES"), mapper.readValue(quote("es_ES"), Locale.class));         assertEquals(new Locale("FI", "fi", "savo"), mapper.readValue(quote("fi_FI_savo"), Locale.class));     }      /**      * Test for [JACKSON-420] (add DeserializationConfig.FAIL_ON_NULL_FOR_PRIMITIVES)      */     public void testNullForPrimitives() throws IOException     {         // by default, ok to rely on defaults         PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}",                 PrimitivesBean.class);         assertNotNull(bean);         assertEquals(0, bean.intValue);         assertEquals(false, bean.booleanValue);         assertEquals(0.0, bean.doubleValue);          bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}",                 PrimitivesBean.class);         assertNotNull(bean);         assertEquals((byte) 0, bean.byteValue);         assertEquals(0L, bean.longValue);         assertEquals(0.0f, bean.floatValue);                  // but not when enabled         final ObjectMapper mapper2 = new ObjectMapper();         mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true);          // boolean         try {             mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class);             fail("Expected failure for boolean + null");         } catch (JsonMappingException e) {             verifyException(e, "Can not map JSON null into type boolean");         }         // byte/char/short/int/long         try {             mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class);             fail("Expected failure for byte + null");         } catch (JsonMappingException e) {             verifyException(e, "Can not map JSON null into type byte");         }         try {             mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class);             fail("Expected failure for char + null");         } catch (JsonMappingException e) {             verifyException(e, "Can not map JSON null into type char");         }         try {             mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class);             fail("Expected failure for short + null");         } catch (JsonMappingException e) {             verifyException(e, "Can not map JSON null into type short");         }         try {             mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class);             fail("Expected failure for int + null");         } catch (JsonMappingException e) {             verifyException(e, "Can not map JSON null into type int");         }         try {             mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class);             fail("Expected failure for long + null");         } catch (JsonMappingException e) {             verifyException(e, "Can not map JSON null into type long");         }          // float/double         try {             mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class);             fail("Expected failure for float + null");         } catch (JsonMappingException e) {             verifyException(e, "Can not map JSON null into type float");         }         try {             mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class);             fail("Expected failure for double + null");         } catch (JsonMappingException e) {             verifyException(e, "Can not map JSON null into type double");         }     }          /**      * Test for [JACKSON-483], allow handling of CharSequence      */     public void testCharSequence() throws IOException     {         CharSequence cs = mapper.readValue("\"abc\"", CharSequence.class);         assertEquals(String.class, cs.getClass());         assertEquals("abc", cs.toString());     }          // [JACKSON-484]     public void testInetAddress() throws IOException     {         InetAddress address = mapper.readValue(quote("127.0.0.1"), InetAddress.class);         assertEquals("127.0.0.1", address.getHostAddress());          // should we try resolving host names? That requires connectivity...          final String HOST = "www.ning.com";         address = mapper.readValue(quote(HOST), InetAddress.class);         assertEquals(HOST, address.getHostName());     }      // [JACKSON-597]     public void testClass() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         assertSame(String.class, mapper.readValue(quote("java.lang.String"), Class.class));          // then primitive types         assertSame(Boolean.TYPE, mapper.readValue(quote("boolean"), Class.class));         assertSame(Byte.TYPE, mapper.readValue(quote("byte"), Class.class));         assertSame(Short.TYPE, mapper.readValue(quote("short"), Class.class));         assertSame(Character.TYPE, mapper.readValue(quote("char"), Class.class));         assertSame(Integer.TYPE, mapper.readValue(quote("int"), Class.class));         assertSame(Long.TYPE, mapper.readValue(quote("long"), Class.class));         assertSame(Float.TYPE, mapper.readValue(quote("float"), Class.class));         assertSame(Double.TYPE, mapper.readValue(quote("double"), Class.class));         assertSame(Void.TYPE, mapper.readValue(quote("void"), Class.class));     }      // [JACKSON-605]     public void testClassWithParams() throws IOException     {         String json = mapper.writeValueAsString(new ParamClassBean("Foobar"));          ParamClassBean result = mapper.readValue(json, ParamClassBean.class);         assertEquals("Foobar", result.name);         assertSame(String.class, result.clazz);     }      // by default, should return nulls, n'est pas?     public void testEmptyStringForWrappers() throws IOException     {         WrappersBean bean;          // by default, ok to rely on defaults         bean = mapper.readValue("{\"booleanValue\":\"\"}", WrappersBean.class);         assertNull(bean.booleanValue);         bean = mapper.readValue("{\"byteValue\":\"\"}", WrappersBean.class);         assertNull(bean.byteValue);          // char/Character is different... not sure if this should work or not:         bean = mapper.readValue("{\"charValue\":\"\"}", WrappersBean.class);         assertNull(bean.charValue);          bean = mapper.readValue("{\"shortValue\":\"\"}", WrappersBean.class);         assertNull(bean.shortValue);         bean = mapper.readValue("{\"intValue\":\"\"}", WrappersBean.class);         assertNull(bean.intValue);         bean = mapper.readValue("{\"longValue\":\"\"}", WrappersBean.class);         assertNull(bean.longValue);         bean = mapper.readValue("{\"floatValue\":\"\"}", WrappersBean.class);         assertNull(bean.floatValue);         bean = mapper.readValue("{\"doubleValue\":\"\"}", WrappersBean.class);         assertNull(bean.doubleValue);     }      // for [JACKSON-616]     // @since 1.9     public void testEmptyStringForPrimitives() throws IOException     {         PrimitivesBean bean;         bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class);         assertFalse(bean.booleanValue);         bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class);         assertEquals((byte) 0, bean.byteValue);         bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class);         assertEquals((char) 0, bean.charValue);         bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class);         assertEquals((short) 0, bean.shortValue);         bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class);         assertEquals(0, bean.intValue);         bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class);         assertEquals(0L, bean.longValue);         bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class);         assertEquals(0.0f, bean.floatValue);         bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class);         assertEquals(0.0, bean.doubleValue);     }      // for [JACKSON-652]     // @since 1.9     public void testUntypedWithJsonArrays() throws Exception     {         // by default we get:         Object ob = mapper.readValue("[1]", Object.class);         assertTrue(ob instanceof List<?>);          // but can change to produce Object[]:         mapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);         ob = mapper.readValue("[1]", Object.class);         assertEquals(Object[].class, ob.getClass());     }      // Test for verifying that Long values are coerced to boolean correctly as well     public void testLongToBoolean() throws Exception     {         long value = 1L + Integer.MAX_VALUE;         BooleanBean b = mapper.readValue("{\"primitive\" : "+value+", \"wrapper\":"+value+", \"ctor\":"+value+"}",                     BooleanBean.class);         assertEquals(Boolean.TRUE, b.wrapper);         assertTrue(b.primitive);         assertEquals(Boolean.TRUE, b.ctor);     }      // [JACKSON-789]     public void testCharset() throws Exception     {         Charset UTF8 = Charset.forName("UTF-8");         assertSame(UTF8, mapper.readValue(quote("UTF-8"), Charset.class));     }      // [JACKSON-888]     public void testStackTraceElement() throws Exception     {         StackTraceElement elem = null;         try {             throw new IllegalStateException();         } catch (Exception e) {             elem = e.getStackTrace()[0];         }         String json = mapper.writeValueAsString(elem);         StackTraceElement back = mapper.readValue(json, StackTraceElement.class);                  assertEquals("testStackTraceElement", back.getMethodName());         assertEquals(elem.getLineNumber(), back.getLineNumber());         assertEquals(elem.getClassName(), back.getClassName());         assertEquals(elem.isNativeMethod(), back.isNativeMethod());         assertTrue(back.getClassName().endsWith("TestJdkTypes"));         assertFalse(back.isNativeMethod());     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.IOException; import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.*;  import com.fasterxml.jackson.annotation.JsonCreator; import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.type.TypeReference;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.deser.std.StdDeserializer;  @SuppressWarnings("serial") public class TestMapDeserialization     extends BaseMapTest {     /*     /**********************************************************     /* Test classes, enums     /**********************************************************      */      enum Key {         KEY1, KEY2, WHATEVER;     }      static class BrokenMap         extends HashMap<Object,Object>     {         // No default ctor, nor @JsonCreators         public BrokenMap(boolean dummy) { super(); }     }      @JsonDeserialize(using=MapDeserializer.class)     static class CustomMap extends LinkedHashMap<String,String> { }      static class MapDeserializer extends StdDeserializer<CustomMap>     {         public MapDeserializer() { super(CustomMap.class); }         @Override         public CustomMap deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException         {             CustomMap result = new CustomMap();             result.put("x", jp.getText());             return result;         }     }      static class KeyType {         protected String value;                  private KeyType(String v, boolean bogus) {             value = v;         }          @JsonCreator         public static KeyType create(String v) {             return new KeyType(v, true);         }     }      // Issue #142     public static class EnumMapContainer {         @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")         public EnumMap<KeyEnum,ITestType> testTypes;     }      public static class ListContainer {         public List<ITestType> testTypes;     }      @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")     public static interface ITestType { }      public static enum KeyEnum {         A, B     }     public static enum ConcreteType implements ITestType {         ONE, TWO;     }                /*     /**********************************************************     /* Test methods, untyped (Object valued) maps     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();      public void testUntypedMap() throws Exception     {         // to get "untyped" default map-to-map, pass Object.class         String JSON = "{ \"foo\" : \"bar\", \"crazy\" : true, \"null\" : null }";          // Not a guaranteed cast theoretically, but will work:         @SuppressWarnings("unchecked")         Map<String,Object> result = (Map<String,Object>)MAPPER.readValue(JSON, Object.class);         assertNotNull(result);         assertTrue(result instanceof Map<?,?>);          assertEquals(3, result.size());          assertEquals("bar", result.get("foo"));         assertEquals(Boolean.TRUE, result.get("crazy"));         assertNull(result.get("null"));          // Plus, non existing:         assertNull(result.get("bar"));         assertNull(result.get(3));     }      /**      * Let's also try another way to express "gimme a Map" deserialization;      * this time by specifying a Map class, to reduce need to cast      */     public void testUntypedMap2() throws Exception     {         // to get "untyped" default map-to-map, pass Object.class         String JSON = "{ \"a\" : \"x\" }";          @SuppressWarnings("unchecked")         HashMap<String,Object> result = /*(HashMap<String,Object>)*/ MAPPER.readValue(JSON, HashMap.class);         assertNotNull(result);         assertTrue(result instanceof Map<?,?>);          assertEquals(1, result.size());          assertEquals("x", result.get("a"));     }      /**      * Unit test for [JACKSON-185]      */     public void testUntypedMap3() throws Exception     {         String JSON = "{\"a\":[{\"a\":\"b\"},\"value\"]}";         Map<?,?> result = MAPPER.readValue(JSON, Map.class);         assertTrue(result instanceof Map<?,?>);         assertEquals(1, result.size());         Object ob = result.get("a");         assertNotNull(ob);         Collection<?> list = (Collection<?>)ob;         assertEquals(2, list.size());          JSON = "{ \"var1\":\"val1\", \"var2\":\"val2\", "             +"\"subvars\": ["             +" {  \"subvar1\" : \"subvar2\", \"x\" : \"y\" }, "             +" { \"a\":1 } ]"             +" }"             ;         result = MAPPER.readValue(JSON, Map.class);         assertTrue(result instanceof Map<?,?>);         assertEquals(3, result.size());     }      private static final String UNTYPED_MAP_JSON =             "{ \"double\":42.0, \"string\":\"string\","             +"\"boolean\":true, \"list\":[\"list0\"],"             +"\"null\":null }";          static class ObjectWrapperMap extends HashMap<String, ObjectWrapper> { }          public void testSpecialMap() throws IOException     {        final ObjectWrapperMap map = MAPPER.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class);        _doTestUntyped(map);     }      public void testGenericMap() throws IOException     {         final Map<String, ObjectWrapper> map = MAPPER.readValue             (UNTYPED_MAP_JSON,              new TypeReference<Map<String, ObjectWrapper>>() { });        _doTestUntyped(map);     }          private void _doTestUntyped(final Map<String, ObjectWrapper> map)     {        assertEquals(Double.valueOf(42), map.get("double").getObject());        assertEquals("string", map.get("string").getObject());        assertEquals(Boolean.TRUE, map.get("boolean").getObject());        assertEquals(Collections.singletonList("list0"), map.get("list").getObject());        assertTrue(map.containsKey("null"));        assertNull(map.get("null"));        assertEquals(5, map.size());     }          // [JACKSON-620]: allow "" to mean 'null' for Maps     public void testFromEmptyString() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);         Map<?,?> result = m.readValue(quote(""), Map.class);         assertNull(result);     }      /*     /**********************************************************     /* Test methods, typed maps     /**********************************************************      */      public void testExactStringIntMap() throws Exception     {         // to get typing, must use type reference         String JSON = "{ \"foo\" : 13, \"bar\" : -39, \n \"\" : 0 }";         Map<String,Integer> result = MAPPER.readValue             (JSON, new TypeReference<HashMap<String,Integer>>() { });          assertNotNull(result);         assertEquals(HashMap.class, result.getClass());         assertEquals(3, result.size());          assertEquals(Integer.valueOf(13), result.get("foo"));         assertEquals(Integer.valueOf(-39), result.get("bar"));         assertEquals(Integer.valueOf(0), result.get(""));         assertNull(result.get("foobar"));         assertNull(result.get(" "));     }      /**      * Let's also check that it is possible to do type conversions      * to allow use of non-String Map keys.      */     public void testIntBooleanMap() throws Exception     {         // to get typing, must use type reference         String JSON = "{ \"1\" : true, \"-1\" : false }";         Map<String,Integer> result = MAPPER.readValue             (JSON, new TypeReference<HashMap<Integer,Boolean>>() { });          assertNotNull(result);         assertEquals(HashMap.class, result.getClass());         assertEquals(2, result.size());          assertEquals(Boolean.TRUE, result.get(Integer.valueOf(1)));         assertEquals(Boolean.FALSE, result.get(Integer.valueOf(-1)));         assertNull(result.get("foobar"));         assertNull(result.get(0));     }      public void testExactStringStringMap() throws Exception     {         // to get typing, must use type reference         String JSON = "{ \"a\" : \"b\" }";         Map<String,Integer> result = MAPPER.readValue             (JSON, new TypeReference<TreeMap<String,String>>() { });          assertNotNull(result);         assertEquals(TreeMap.class, result.getClass());         assertEquals(1, result.size());          assertEquals("b", result.get("a"));         assertNull(result.get("b"));     }      /**      * Unit test that verifies that it's ok to have incomplete      * information about Map class itself, as long as it's something      * we good guess about: for example, <code>Map.Class</code> will      * be replaced by something like <code>HashMap.class</code>,      * if given.      */     public void testGenericStringIntMap() throws Exception     {         // to get typing, must use type reference; but with abstract type         String JSON = "{ \"a\" : 1, \"b\" : 2, \"c\" : -99 }";         Map<String,Integer> result = MAPPER.readValue             (JSON, new TypeReference<Map<String,Integer>>() { });         assertNotNull(result);         assertTrue(result instanceof Map<?,?>);         assertEquals(3, result.size());          assertEquals(Integer.valueOf(-99), result.get("c"));         assertEquals(Integer.valueOf(2), result.get("b"));         assertEquals(Integer.valueOf(1), result.get("a"));          assertNull(result.get(""));     }      /*     /**********************************************************     /* Test methods, maps with enums     /**********************************************************      */      public void testEnumMap() throws Exception     {         String JSON = "{ \"KEY1\" : \"\", \"WHATEVER\" : null }";          // to get typing, must use type reference         EnumMap<Key,String> result = MAPPER.readValue             (JSON, new TypeReference<EnumMap<Key,String>>() { });          assertNotNull(result);         assertEquals(EnumMap.class, result.getClass());         assertEquals(2, result.size());          assertEquals("", result.get(Key.KEY1));         // null should be ok too...         assertTrue(result.containsKey(Key.WHATEVER));         assertNull(result.get(Key.WHATEVER));          // plus we have nothing for this key         assertFalse(result.containsKey(Key.KEY2));         assertNull(result.get(Key.KEY2));     }      public void testMapWithEnums() throws Exception     {         String JSON = "{ \"KEY2\" : \"WHATEVER\" }";          // to get typing, must use type reference         Map<Enum<?>,Enum<?>> result = MAPPER.readValue             (JSON, new TypeReference<Map<Key,Key>>() { });          assertNotNull(result);         assertTrue(result instanceof Map<?,?>);         assertEquals(1, result.size());          assertEquals(Key.WHATEVER, result.get(Key.KEY2));         assertNull(result.get(Key.WHATEVER));         assertNull(result.get(Key.KEY1));     }      public void testEnumPolymorphicSerializationTest() throws Exception      {         ObjectMapper mapper = new ObjectMapper();         List<ITestType> testTypesList = new ArrayList<ITestType>();         testTypesList.add(ConcreteType.ONE);         testTypesList.add(ConcreteType.TWO);         ListContainer listContainer = new ListContainer();         listContainer.testTypes = testTypesList;         String json = mapper.writeValueAsString(listContainer);         listContainer = mapper.readValue(json, ListContainer.class);         EnumMapContainer enumMapContainer = new EnumMapContainer();         EnumMap<KeyEnum,ITestType> testTypesMap = new EnumMap<KeyEnum,ITestType>(KeyEnum.class);         testTypesMap.put(KeyEnum.A, ConcreteType.ONE);         testTypesMap.put(KeyEnum.B, ConcreteType.TWO);         enumMapContainer.testTypes = testTypesMap;                  json = mapper.writeValueAsString(enumMapContainer);         enumMapContainer = mapper.readValue(json, EnumMapContainer.class);     }      /*     /**********************************************************     /* Test methods, maps with Date     /**********************************************************      */     public void testDateMap() throws Exception     {     	 Date date1=new Date(123456000L);     	 DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);               	 String JSON = "{ \""+  fmt.format(date1)+"\" : \"\", \""+new Date(0).getTime()+"\" : null }";     	 HashMap<Date,String> result=  MAPPER.readValue     	            (JSON, new TypeReference<HashMap<Date,String>>() { });     	      	 assertNotNull(result);     	 assertEquals(HashMap.class, result.getClass());     	 assertEquals(2, result.size());     	      	 assertTrue(result.containsKey(date1));     	 assertEquals("", result.get(new Date(123456000L)));     	      	 assertTrue(result.containsKey(new Date(0)));     	 assertNull(result.get(new Date(0)));     }          /*     /**********************************************************     /* Test methods, maps with various alternative key types     /**********************************************************      */      public void testCalendarMap() throws Exception     {     	 Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));          c.setTimeInMillis(123456000L);          DateFormat fmt = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);     	 String JSON = "{ \""+fmt.format(c.getTime())+"\" : \"\", \""+new Date(0).getTime()+"\" : null }";     	 HashMap<Calendar,String> result = MAPPER.readValue     	            (JSON, new TypeReference<HashMap<Calendar,String>>() { });     	      	 assertNotNull(result);     	 assertEquals(HashMap.class, result.getClass());     	 assertEquals(2, result.size());     	     	 assertTrue(result.containsKey(c));     	 assertEquals("", result.get(c));     	 c.setTimeInMillis(0);     	 assertTrue(result.containsKey(c));     	 assertNull(result.get(c));     }      // [JACKSON-726]     public void testUUIDKeyMap() throws Exception     {          UUID key = UUID.nameUUIDFromBytes("foobar".getBytes("UTF-8"));          String JSON = "{ \""+key+"\":4}";          Map<UUID,Object> result = MAPPER.readValue(JSON, new TypeReference<Map<UUID,Object>>() { });          assertNotNull(result);          assertEquals(1, result.size());          Object ob = result.keySet().iterator().next();          assertNotNull(ob);          assertEquals(UUID.class, ob.getClass());          assertEquals(key, ob);     }      public void testLocaleKeyMap() throws Exception {         Locale key = Locale.CHINA;         String JSON = "{ \"" + key + "\":4}";         Map<Locale, Object> result = MAPPER.readValue(JSON, new TypeReference<Map<Locale, Object>>() {         });         assertNotNull(result);         assertEquals(1, result.size());         Object ob = result.keySet().iterator().next();         assertNotNull(ob);         assertEquals(Locale.class, ob.getClass());         assertEquals(key, ob);     }      // Test confirming that @JsonCreator may be used with Map Key types     public void testKeyWithCreator() throws Exception     {         // first, key should deserialize normally:         KeyType key = MAPPER.readValue(quote("abc"), KeyType.class);         assertEquals("abc", key.value);          Map<KeyType,Integer> map = MAPPER.readValue("{\"foo\":3}", new TypeReference<Map<KeyType,Integer>>() {} );         assertEquals(1, map.size());         key = map.keySet().iterator().next();         assertEquals("foo", key.value);     }          /*     /**********************************************************     /* Test methods, annotated Maps     /**********************************************************      */      /**      * Simple test to ensure that @JsonDeserialize.using is      * recognized      */     public void testMapWithDeserializer() throws IOException     {         CustomMap result = MAPPER.readValue(quote("xyz"), CustomMap.class);         assertEquals(1, result.size());         assertEquals("xyz", result.get("x"));     }      /*     /**********************************************************     /* Error tests     /**********************************************************      */      public void testMapError() throws Exception     {         try {             Object result = MAPPER.readValue("[ 1, 2 ]",                                               new TypeReference<Map<String,String>>() { });             fail("Expected an exception, but got result value: "+result);         } catch (JsonMappingException jex) {             verifyException(jex, "START_ARRAY");         }     }      public void testNoCtorMap() throws Exception     {         try {             BrokenMap result = MAPPER.readValue("{ \"a\" : 3 }", BrokenMap.class);             // should never get here; assert added to remove compiler warning             assertNull(result);         } catch (JsonMappingException e) {             // instead, should get this exception:             verifyException(e, "no default constructor found");         }     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.IOException;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.module.SimpleModule;  public class TestNullHandling extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      static class FunnyNullDeserializer extends JsonDeserializer<String>     {         @Override         public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {             return "text";         }          @Override         public String getNullValue() { return "funny"; }     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */      // Test for [JACKSON-643]     public void testCustomRootNulls() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addDeserializer(String.class, new FunnyNullDeserializer());         mapper.registerModule(module);          // should get non-default null directly:         String str = mapper.readValue("null", String.class);         assertNotNull(str);         assertEquals("funny", str);                  // as well as via ObjectReader         ObjectReader reader = mapper.reader(String.class);         str = reader.readValue("null");         assertNotNull(str);         assertEquals("funny", str);     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.IOException; import java.math.BigDecimal; import java.math.BigInteger;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize;  /**  * Tests related to [JACKSON-139]  */ public class TestNumbers     extends BaseMapTest {     /*     /**********************************************************************     /* Helper classes, beans     /**********************************************************************      */      static class MyBeanHolder {         public Long id;         public MyBeanDefaultValue defaultValue;     }      static class MyBeanDefaultValue     {         public MyBeanValue value;     }      @JsonDeserialize(using=MyBeanDeserializer.class)     static class MyBeanValue {         public BigDecimal decimal;         public MyBeanValue() { this(null); }         public MyBeanValue(BigDecimal d) { this.decimal = d; }     }      /*     /**********************************************************************     /* Helper classes, serializers/deserializers/resolvers     /**********************************************************************      */          static class MyBeanDeserializer extends JsonDeserializer<MyBeanValue>     {         @Override         public MyBeanValue deserialize(JsonParser jp, DeserializationContext ctxt)                 throws IOException         {             return new MyBeanValue(jp.getDecimalValue());         }     }      /*     /**********************************************************************     /* Unit tests     /**********************************************************************      */          public void testFloatNaN() throws Exception     {         ObjectMapper m = new ObjectMapper();         Float result = m.readValue(" \"NaN\"", Float.class);         assertEquals(Float.valueOf(Float.NaN), result);     }      public void testDoubleInf() throws Exception     {         ObjectMapper m = new ObjectMapper();         Double result = m.readValue(" \""+Double.POSITIVE_INFINITY+"\"", Double.class);         assertEquals(Double.valueOf(Double.POSITIVE_INFINITY), result);          result = m.readValue(" \""+Double.NEGATIVE_INFINITY+"\"", Double.class);         assertEquals(Double.valueOf(Double.NEGATIVE_INFINITY), result);     }      // [JACKSON-349]     public void testEmptyAsNumber() throws Exception     {         ObjectMapper m = new ObjectMapper();         assertNull(m.readValue(quote(""), Integer.class));         assertNull(m.readValue(quote(""), Long.class));         assertNull(m.readValue(quote(""), Float.class));         assertNull(m.readValue(quote(""), Double.class));         assertNull(m.readValue(quote(""), BigInteger.class));         assertNull(m.readValue(quote(""), BigDecimal.class));     }      // // Tests for [JACKSON-668]          public void testDeserializeDecimalHappyPath() throws Exception {         ObjectMapper mapper = new ObjectMapper();         String json = "{\"defaultValue\": { \"value\": 123 } }";         MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class);         assertEquals(BigDecimal.valueOf(123), result.defaultValue.value.decimal);     }      public void testDeserializeDecimalProperException() throws Exception {         ObjectMapper mapper = new ObjectMapper();         String json = "{\"defaultValue\": { \"value\": \"123\" } }";         try {             mapper.readValue(json, MyBeanHolder.class);             fail("should have raised exception");         } catch (JsonParseException e) {             verifyException(e, "not numeric");         }     }      public void testDeserializeDecimalProperExceptionWhenIdSet() throws Exception {         ObjectMapper mapper = new ObjectMapper();         String json = "{\"id\": 5, \"defaultValue\": { \"value\": \"123\" } }";         try {             MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class);             fail("should have raised exception instead value was set to " + result.defaultValue.value.decimal.toString());         } catch (JsonParseException e) {             verifyException(e, "not numeric");         }     } } 
package com.fasterxml.jackson.databind.deser;  import java.util.*;   import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.databind.*;  /**  * Unit tests related to handling of overloaded methods.  * and specifically addressing problems [JACKSON-189]  * and [JACKSON-739]  */ public class TestOverloaded     extends BaseMapTest {     static class BaseListBean     {         List<String> list;          BaseListBean() { }          public void setList(List<String> l) { list = l; }     }      static class ArrayListBean extends BaseListBean     {         ArrayListBean() { }          public void setList(ArrayList<String> l) { super.setList(l); }     }      // 27-Feb-2010, tatus: Won't fix immediately, need to comment out     /*     static class OverloadBean     {         String a;          public OverloadBean() { }          public void setA(int value) { a = String.valueOf(value); }         public void setA(String value) { a = value; }     }     */      static class NumberBean {     	protected Object value;     	     	public void setValue(Number n) { value = n; }     }      static class WasNumberBean extends NumberBean {     	public void setValue(String str) { value = str; }     }      // [JACKSON-739]     static class Overloaded739     {         protected Object _value;                  @JsonProperty         public void setValue(String str) { _value = str; }          // no annotation, should not be chosen:         public void setValue(Object o) { throw new UnsupportedOperationException(); }     }          /**      * And then a Bean that is conflicting and should not work      */     static class ConflictBean {     	public void setA(ArrayList<Object> a) { }     	public void setA(LinkedList<Object> a) { }     }          /*     /************************************************************     /* Unit tests, valid     /************************************************************     */      private final ObjectMapper MAPPER = new ObjectMapper();          /**      * Unit test related to [JACKSON-189]      */     // 27-Feb-2010, tatus: Won't fix immediately, need to comment out     /*     public void testSimpleOverload() throws Exception     {         OverloadBean bean;         try {             bean = new ObjectMapper().readValue("{ \"a\" : 13 }", OverloadBean.class);         } catch (JsonMappingException e) {             fail("Did not expect an exception, got: "+e.getMessage());             return;         }         assertEquals("13", bean.a);     }     */      /**      * It should be ok to overload with specialized       * version; more specific method should be used.      */     public void testSpecialization() throws Exception     {         ArrayListBean bean = MAPPER.readValue             ("{\"list\":[\"a\",\"b\",\"c\"]}", ArrayListBean.class);         assertNotNull(bean.list);         assertEquals(3, bean.list.size());         assertEquals(ArrayList.class, bean.list.getClass());         assertEquals("a", bean.list.get(0));         assertEquals("b", bean.list.get(1));         assertEquals("c", bean.list.get(2));     }      /**      * As per [JACKSON-255], should also allow more general overriding,      * as long as there are no in-class conflicts.      */     public void testOverride() throws Exception     {         WasNumberBean bean = MAPPER.readValue             ("{\"value\" : \"abc\"}", WasNumberBean.class);         assertNotNull(bean);         assertEquals("abc", bean.value);     }      // for [JACKSON-739]     public void testConflictResolution() throws Exception     {         Overloaded739 bean = MAPPER.readValue                 ("{\"value\":\"abc\"}", Overloaded739.class);         assertNotNull(bean);         assertEquals("abc", bean._value);     }          /*     /************************************************************     /* Unit tests, failures     /************************************************************     */          /**      * For genuine setter conflict, an exception is to be thrown.      */     public void testSetterConflict() throws Exception     {     	try {    		     	MAPPER.readValue("{ }", ConflictBean.class);     	} catch (Exception e) {     	    verifyException(e, "Conflicting setter definitions");     	}     } } 
package com.fasterxml.jackson.databind.deser;  import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;  import com.fasterxml.jackson.databind.*;  public class TestParentChildReferences     extends BaseMapTest {     /*     /**********************************************************     /* Test classes     /**********************************************************      */      /**      * First, a simple 'tree': just parent/child linkage      */     static class SimpleTreeNode     {         public String name;                  // Reference back to parent; reference, ignored during ser,         // re-constructed during deser         @JsonBackReference         public SimpleTreeNode parent;          // Reference that is serialized normally during ser, back         // reference within pointed-to instance assigned to point to         // referring bean ("this")         @JsonManagedReference         public SimpleTreeNode child;          public SimpleTreeNode() { this(null); }         public SimpleTreeNode(String n) { name = n; }     }      static class SimpleTreeNode2     {         public String name;         private SimpleTreeNode2 parent;         private SimpleTreeNode2 child;          public SimpleTreeNode2() { this(null); }         public SimpleTreeNode2(String n) { name = n; }          @JsonBackReference         public SimpleTreeNode2 getParent() { return parent; }         public void setParent(SimpleTreeNode2 p) { parent = p; }          @JsonManagedReference         public SimpleTreeNode2 getChild() { return child; }         public void setChild(SimpleTreeNode2 c) { child = c; }     }          /**      * Then nodes with two separate linkages; parent/child      * and prev/next-sibling      */     static class FullTreeNode     {         public String name;          // parent-child links         @JsonBackReference("parent")         public FullTreeNode parent;         @JsonManagedReference("parent")         public FullTreeNode firstChild;          // sibling-links         @JsonManagedReference("sibling")         public FullTreeNode next;         @JsonBackReference("sibling")         protected FullTreeNode prev;                  public FullTreeNode() { this(null); }         public FullTreeNode(String name) {             this.name = name;         }     }      /**      * Class for testing managed references via arrays      */     static class NodeArray     {         @JsonManagedReference("arr")         public ArrayNode[] nodes;     }      static class ArrayNode     {         public String name;                  @JsonBackReference("arr")         public NodeArray parent;          public ArrayNode() { this(null); }         public ArrayNode(String n) { name = n; }     }          /**      * Class for testing managed references via Collections      */     static class NodeList     {         @JsonManagedReference         public List<NodeForList> nodes;     }      static class NodeForList     {         public String name;                  @JsonBackReference         public NodeList parent;          public NodeForList() { this(null); }         public NodeForList(String n) { name = n; }     }          static class NodeMap     {         @JsonManagedReference         public Map<String,NodeForMap> nodes;     }      static class NodeForMap     {         public String name;                  @JsonBackReference         public NodeMap parent;          public NodeForMap() { this(null); }         public NodeForMap(String n) { name = n; }     }      public static class Parent {         @JsonManagedReference         private final List<Child> children = new ArrayList<Child>();          public List<Child> getChildren() { return children; }          public void addChild(Child child) { children.add(child); child.setParent(this); }     }      public static class Child {         private Parent parent;         private final String value; // So that the bean is not empty of properties          public Child(@JsonProperty("value") String value) { this.value = value; }          public String getValue() { return value; }          @JsonBackReference         public Parent getParent() { return parent; }          public void setParent(Parent parent) { this.parent = parent; }     }          // [JACKSON-368]      @JsonTypeInfo(use=Id.NAME)     @JsonSubTypes({@JsonSubTypes.Type(ConcreteNode.class)})     static abstract class AbstractNode     {         public String id;                  @JsonManagedReference public AbstractNode next;         @JsonBackReference public AbstractNode prev;     }      @JsonTypeName("concrete")     static class ConcreteNode extends AbstractNode {         public ConcreteNode() { }         public ConcreteNode(String id) { this.id = id; }     }          // [JACKSON-708]     static class Model708 { }          static class Advertisement708 extends Model708 {         public String title;         @JsonManagedReference public List<Photo708> photos;     }      static class Photo708 extends Model708 {         public int id;         @JsonBackReference public Advertisement708 advertisement;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */          public void testSimpleRefs() throws Exception     {         SimpleTreeNode root = new SimpleTreeNode("root");         SimpleTreeNode child = new SimpleTreeNode("kid");         ObjectMapper mapper = new ObjectMapper();         root.child = child;         child.parent = root;                  String json = mapper.writeValueAsString(root);                  SimpleTreeNode resultNode = mapper.readValue(json, SimpleTreeNode.class);         assertEquals("root", resultNode.name);         SimpleTreeNode resultChild = resultNode.child;         assertNotNull(resultChild);         assertEquals("kid", resultChild.name);         assertSame(resultChild.parent, resultNode);     }      // [JACKSON-693]     public void testSimpleRefsWithGetter() throws Exception     {         SimpleTreeNode2 root = new SimpleTreeNode2("root");         SimpleTreeNode2 child = new SimpleTreeNode2("kid");         ObjectMapper mapper = new ObjectMapper();         root.child = child;         child.parent = root;                  String json = mapper.writeValueAsString(root);                  SimpleTreeNode2 resultNode = mapper.readValue(json, SimpleTreeNode2.class);         assertEquals("root", resultNode.name);         SimpleTreeNode2 resultChild = resultNode.child;         assertNotNull(resultChild);         assertEquals("kid", resultChild.name);         assertSame(resultChild.parent, resultNode);     }          public void testFullRefs() throws Exception     {         FullTreeNode root = new FullTreeNode("root");         FullTreeNode child1 = new FullTreeNode("kid1");         FullTreeNode child2 = new FullTreeNode("kid2");         ObjectMapper mapper = new ObjectMapper();         root.firstChild = child1;         child1.parent = root;         child1.next = child2;         child2.prev = child1;                  String json = mapper.writeValueAsString(root);                  FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class);         assertEquals("root", resultNode.name);         FullTreeNode resultChild = resultNode.firstChild;         assertNotNull(resultChild);         assertEquals("kid1", resultChild.name);         assertSame(resultChild.parent, resultNode);          // and then sibling linkage         assertNull(resultChild.prev);         FullTreeNode resultChild2 = resultChild.next;         assertNotNull(resultChild2);         assertEquals("kid2", resultChild2.name);         assertSame(resultChild, resultChild2.prev);         assertNull(resultChild2.next);     }      public void testArrayOfRefs() throws Exception     {         NodeArray root = new NodeArray();         ArrayNode node1 = new ArrayNode("a");         ArrayNode node2 = new ArrayNode("b");         root.nodes = new ArrayNode[] { node1, node2 };         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(root);                  NodeArray result = mapper.readValue(json, NodeArray.class);         ArrayNode[] kids = result.nodes;         assertNotNull(kids);         assertEquals(2, kids.length);         assertEquals("a", kids[0].name);         assertEquals("b", kids[1].name);         assertSame(result, kids[0].parent);         assertSame(result, kids[1].parent);     }      public void testListOfRefs() throws Exception     {         NodeList root = new NodeList();         NodeForList node1 = new NodeForList("a");         NodeForList node2 = new NodeForList("b");         root.nodes = Arrays.asList(node1, node2);         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(root);                  NodeList result = mapper.readValue(json, NodeList.class);         List<NodeForList> kids = result.nodes;         assertNotNull(kids);         assertEquals(2, kids.size());         assertEquals("a", kids.get(0).name);         assertEquals("b", kids.get(1).name);         assertSame(result, kids.get(0).parent);         assertSame(result, kids.get(1).parent);     }      public void testMapOfRefs() throws Exception     {         NodeMap root = new NodeMap();         NodeForMap node1 = new NodeForMap("a");         NodeForMap node2 = new NodeForMap("b");         Map<String,NodeForMap> nodes = new HashMap<String, NodeForMap>();         nodes.put("a1", node1);         nodes.put("b2", node2);         root.nodes = nodes;         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(root);                  NodeMap result = mapper.readValue(json, NodeMap.class);         Map<String,NodeForMap> kids = result.nodes;         assertNotNull(kids);         assertEquals(2, kids.size());         assertNotNull(kids.get("a1"));         assertNotNull(kids.get("b2"));         assertEquals("a", kids.get("a1").name);         assertEquals("b", kids.get("b2").name);         assertSame(result, kids.get("a1").parent);         assertSame(result, kids.get("b2").parent);     }      // for [JACKSON-368]     public void testAbstract368() throws Exception     {         AbstractNode parent = new ConcreteNode("p");         AbstractNode child = new ConcreteNode("c");         parent.next = child;         child.prev = parent;          // serialization ought to be ok         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(parent);          AbstractNode root = mapper.readValue(json, AbstractNode.class);          assertEquals(ConcreteNode.class, root.getClass());         assertEquals("p", root.id);         assertNull(root.prev);         AbstractNode leaf = root.next;         assertNotNull(leaf);         assertEquals("c", leaf.id);         assertSame(root, leaf.prev);     }          public void testIssue693() throws Exception     {         Parent parent = new Parent();         parent.addChild(new Child("foo"));         parent.addChild(new Child("bar"));         ObjectMapper mapper = new ObjectMapper();         byte[] bytes = mapper.writeValueAsBytes(parent);         Parent value = mapper.readValue(bytes, Parent.class);          for (Child child : value.children) {             assertEquals(value, child.getParent());         }     }      public void testIssue708() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         Advertisement708 ad = mapper.readValue("{\"title\":\"Hroch\",\"photos\":[{\"id\":3}]}", Advertisement708.class);               assertNotNull(ad);     }    } 
package com.fasterxml.jackson.databind.deser;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying that feature requested  * via [JACKSON-88] ("setterless collections") work as  * expected, similar to how Collections and Maps work  * with JAXB.  */ public class TestSetterlessProperties     extends BaseMapTest {     /*     /**********************************************************     /* Helper beans     /**********************************************************      */      static class CollectionBean     {         List<String> _values = new ArrayList<String>();          public List<String> getValues() { return _values; }     }      static class MapBean     {         Map<String,Integer> _values = new HashMap<String,Integer>();          public Map<String,Integer> getValues() { return _values; }     }      // testing to verify that field has precedence over getter, for lists     static class Dual     {         @JsonProperty("list") protected List<Integer> values = new ArrayList<Integer>();          public Dual() { }                  public List<Integer> getList() {             throw new IllegalStateException("Should not get called");         }     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testSimpleSetterlessCollectionOk()         throws Exception     {         CollectionBean result = new ObjectMapper().readValue             ("{\"values\":[ \"abc\", \"def\" ]}", CollectionBean.class);         List<String> l = result._values;         assertEquals(2, l.size());         assertEquals("abc", l.get(0));         assertEquals("def", l.get(1));     }      /**      * Let's also verify that disabling the feature makes      * deserialization fail for setterless bean      */     public void testSimpleSetterlessCollectionFailure()         throws Exception     {         ObjectMapper m = new ObjectMapper();         // by default, it should be enabled         assertTrue(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS));         m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);         assertFalse(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS));          // and now this should fail         try {             m.readValue                 ("{\"values\":[ \"abc\", \"def\" ]}", CollectionBean.class);             fail("Expected an exception");         } catch (JsonMappingException e) {             /* Not a good exception, ideally could suggest a need for              * a setter...?              */             verifyException(e, "Unrecognized field");         }     }      public void testSimpleSetterlessMapOk()         throws Exception     {         MapBean result = new ObjectMapper().readValue             ("{\"values\":{ \"a\": 15, \"b\" : -3 }}", MapBean.class);         Map<String,Integer> m = result._values;         assertEquals(2, m.size());         assertEquals(Integer.valueOf(15), m.get("a"));         assertEquals(Integer.valueOf(-3), m.get("b"));     }      public void testSimpleSetterlessMapFailure()         throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);         // so this should fail now without a setter         try {             m.readValue                 ("{\"values\":{ \"a\":3 }}", MapBean.class);             fail("Expected an exception");         } catch (JsonMappingException e) {             verifyException(e, "Unrecognized field");         }     }      /* Test for [JACKSON-328], precedence of "getter-as-setter" (for Lists) versus      * field for same property.      */     public void testSetterlessPrecedence() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, true);         Dual value = m.readValue("{\"list\":[1,2,3]}, valueType)", Dual.class);         assertNotNull(value);         assertEquals(3, value.values.size());     } } 
package com.fasterxml.jackson.databind.deser;  import java.util.concurrent.atomic.*;  import com.fasterxml.jackson.databind.ObjectMapper;  public class TestSimpleAtomicTypes     extends com.fasterxml.jackson.databind.BaseMapTest {     public void testAtomicBoolean() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AtomicBoolean b = mapper.readValue("true", AtomicBoolean.class);         assertTrue(b.get());     }      public void testAtomicInt() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AtomicInteger value = mapper.readValue("13", AtomicInteger.class);         assertEquals(13, value.get());     }      public void testAtomicLong() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AtomicLong value = mapper.readValue("12345678901", AtomicLong.class);         assertEquals(12345678901L, value.get());     }      public void testAtomicReference() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         AtomicReference<long[]> value = mapper.readValue("[1,2]",                 new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { });         Object ob = value.get();         assertNotNull(ob);         assertEquals(long[].class, ob.getClass());         long[] longs = (long[]) ob;         assertNotNull(longs);         assertEquals(2, longs.length);         assertEquals(1, longs[0]);         assertEquals(2, longs[1]);     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.*; import java.math.BigDecimal; import java.math.BigInteger; import java.net.URL; import java.net.URI; import java.util.*;  import org.junit.Assert;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.util.TokenBuffer;  /**  * Unit tests for verifying handling of simple basic non-structured  * types; primitives (and/or their wrappers), Strings.  */ public class TestSimpleTypes     extends BaseMapTest {     final static String NAN_STRING = "NaN";      final static class BooleanBean {         boolean _v;         void setV(boolean v) { _v = v; }     }      static class IntBean {         int _v;         void setV(int v) { _v = v; }     }      final static class DoubleBean {         double _v;         void setV(double v) { _v = v; }     }      final static class FloatBean {         float _v;         void setV(float v) { _v = v; }     }      /**      * Also, let's ensure that it's ok to override methods.      */     static class IntBean2         extends IntBean     {         @Override         void setV(int v2) { super.setV(v2+1); }     }      /*     /**********************************************************     /* Then tests for primitives     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();      public void testBooleanPrimitive() throws Exception     {         // first, simple case:         BooleanBean result = MAPPER.readValue(new StringReader("{\"v\":true}"), BooleanBean.class);         assertTrue(result._v);         // then [JACKSON-79]:         result = MAPPER.readValue(new StringReader("{\"v\":null}"), BooleanBean.class);         assertNotNull(result);         assertFalse(result._v);          // should work with arrays too..         boolean[] array = MAPPER.readValue(new StringReader("[ null ]"), boolean[].class);         assertNotNull(array);         assertEquals(1, array.length);         assertFalse(array[0]);     }      public void testIntPrimitive() throws Exception     {         // first, simple case:         IntBean result = MAPPER.readValue(new StringReader("{\"v\":3}"), IntBean.class);         assertEquals(3, result._v);         // then [JACKSON-79]:         result = MAPPER.readValue(new StringReader("{\"v\":null}"), IntBean.class);         assertNotNull(result);         assertEquals(0, result._v);          // should work with arrays too..         int[] array = MAPPER.readValue(new StringReader("[ null ]"), int[].class);         assertNotNull(array);         assertEquals(1, array.length);         assertEquals(0, array[0]);     }      public void testDoublePrimitive() throws Exception     {         // first, simple case:         // bit tricky with binary fps but...         double value = 0.016;         DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":"+value+"}"), DoubleBean.class);         assertEquals(value, result._v);         // then [JACKSON-79]:         result = MAPPER.readValue(new StringReader("{\"v\":null}"), DoubleBean.class);         assertNotNull(result);         assertEquals(0.0, result._v);          // should work with arrays too..         double[] array = MAPPER.readValue(new StringReader("[ null ]"), double[].class);         assertNotNull(array);         assertEquals(1, array.length);         assertEquals(0.0, array[0]);     }      public void testDoublePrimitiveNonNumeric() throws Exception     {         // first, simple case:         // bit tricky with binary fps but...         double value = Double.POSITIVE_INFINITY;         DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\""+value+"\"}"), DoubleBean.class);         assertEquals(value, result._v);                  // should work with arrays too..         double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class);         assertNotNull(array);         assertEquals(1, array.length);         assertEquals(Double.POSITIVE_INFINITY, array[0]);     }          public void testFloatPrimitiveNonNumeric() throws Exception     {         // bit tricky with binary fps but...         float value = Float.POSITIVE_INFINITY;         FloatBean result = MAPPER.readValue(new StringReader("{\"v\":\""+value+"\"}"), FloatBean.class);         assertEquals(value, result._v);                  // should work with arrays too..         float[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), float[].class);         assertNotNull(array);         assertEquals(1, array.length);         assertEquals(Float.POSITIVE_INFINITY, array[0]);     }          /**      * Beyond simple case, let's also ensure that method overriding works as      * expected.      */     public void testIntWithOverride() throws Exception     {         IntBean2 result = MAPPER.readValue(new StringReader("{\"v\":8}"), IntBean2.class);         assertEquals(9, result._v);     }      /*     /**********************************************************     /* Then tests for wrappers     /**********************************************************      */      /**      * Simple unit test to verify that we can map boolean values to      * java.lang.Boolean.      */     public void testBooleanWrapper() throws Exception     {         Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class);         assertEquals(Boolean.TRUE, result);         result = MAPPER.readValue(new StringReader("false"), Boolean.class);         assertEquals(Boolean.FALSE, result);          // [JACKSON-78]: should accept ints too, (0 == false, otherwise true)         result = MAPPER.readValue(new StringReader("0"), Boolean.class);         assertEquals(Boolean.FALSE, result);         result = MAPPER.readValue(new StringReader("1"), Boolean.class);         assertEquals(Boolean.TRUE, result);     }      public void testByteWrapper() throws Exception     {         Byte result = MAPPER.readValue(new StringReader("   -42\t"), Byte.class);         assertEquals(Byte.valueOf((byte)-42), result);          // Also: should be able to coerce floats, strings:         result = MAPPER.readValue(new StringReader(" \"-12\""), Byte.class);         assertEquals(Byte.valueOf((byte)-12), result);          result = MAPPER.readValue(new StringReader(" 39.07"), Byte.class);         assertEquals(Byte.valueOf((byte)39), result);     }      public void testShortWrapper() throws Exception     {         Short result = MAPPER.readValue(new StringReader("37"), Short.class);         assertEquals(Short.valueOf((short)37), result);          // Also: should be able to coerce floats, strings:         result = MAPPER.readValue(new StringReader(" \"-1009\""), Short.class);         assertEquals(Short.valueOf((short)-1009), result);          result = MAPPER.readValue(new StringReader("-12.9"), Short.class);         assertEquals(Short.valueOf((short)-12), result);     }      public void testCharacterWrapper() throws Exception     {         // First: canonical value is 1-char string         Character result = MAPPER.readValue(new StringReader("\"a\""), Character.class);         assertEquals(Character.valueOf('a'), result);          // But can also pass in ascii code         result = MAPPER.readValue(new StringReader(" "+((int) 'X')), Character.class);         assertEquals(Character.valueOf('X'), result);     }      public void testIntWrapper() throws Exception     {         Integer result = MAPPER.readValue(new StringReader("   -42\t"), Integer.class);         assertEquals(Integer.valueOf(-42), result);          // Also: should be able to coerce floats, strings:         result = MAPPER.readValue(new StringReader(" \"-1200\""), Integer.class);         assertEquals(Integer.valueOf(-1200), result);          result = MAPPER.readValue(new StringReader(" 39.07"), Integer.class);         assertEquals(Integer.valueOf(39), result);     }      public void testLongWrapper() throws Exception     {         Long result = MAPPER.readValue(new StringReader("12345678901"), Long.class);         assertEquals(Long.valueOf(12345678901L), result);          // Also: should be able to coerce floats, strings:         result = MAPPER.readValue(new StringReader(" \"-9876\""), Long.class);         assertEquals(Long.valueOf(-9876), result);          result = MAPPER.readValue(new StringReader("1918.3"), Long.class);         assertEquals(Long.valueOf(1918), result);     }      /* Note: dealing with floating-point values is tricky; not sure if      * we can really use equality tests here... JDK does have decent      * conversions though, to retain accuracy and round-trippability.      * But still...      */     public void testFloatWrapper() throws Exception     {         // Also: should be able to coerce floats, strings:         String[] STRS = new String[] {             "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING         };          for (String str : STRS) {             Float exp = Float.valueOf(str);             Float result;              if (NAN_STRING != str) {                 // First, as regular floating point value                 result = MAPPER.readValue(new StringReader(str), Float.class);                 assertEquals(exp, result);             }              // and then as coerced String:             result = MAPPER.readValue(new StringReader(" \""+str+"\""), Float.class);             assertEquals(exp, result);         }     }      public void testDoubleWrapper() throws Exception     {         // Also: should be able to coerce doubles, strings:         String[] STRS = new String[] {             "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING         };          for (String str : STRS) {             Double exp = Double.valueOf(str);             Double result;              // First, as regular double value             if (NAN_STRING != str) {             	result = MAPPER.readValue(new StringReader(str), Double.class);             	assertEquals(exp, result);             }             // and then as coerced String:             result = MAPPER.readValue(new StringReader(" \""+str+"\""), Double.class);             assertEquals(exp, result);         }     }      // as per [Issue#42], allow Base64 variant use as well     public void testBase64Variants() throws Exception     {         final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8");                  // default encoding is "MIME, no linefeeds", so:         Assert.assertArrayEquals(INPUT, MAPPER.readValue(                 quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="),                 byte[].class));         ObjectReader reader = MAPPER.reader(byte[].class);         Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(                 quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="         )));          // but others should be slightly different         Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(                 quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="         )));         Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(                 quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"         )));         // PEM mandates 64 char lines:         Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(                 quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="         )));     }         /*     /**********************************************************     /* Simple non-primitive types     /**********************************************************      */      public void testSingleString() throws Exception     {         String value = "FOO!";         String result = MAPPER.readValue(new StringReader("\""+value+"\""), String.class);         assertEquals(value, result);     }      public void testNull() throws Exception     {         // null doesn't really have a type, fake by assuming Object         Object result = MAPPER.readValue("   null", Object.class);         assertNull(result);     }      public void testClass() throws Exception     {         Class<?> result = MAPPER.readValue("\"java.lang.String\"", Class.class);         assertEquals(String.class, result);     }      public void testBigDecimal() throws Exception     {         BigDecimal value = new BigDecimal("0.001");         BigDecimal result = MAPPER.readValue(new StringReader(value.toString()), BigDecimal.class);         assertEquals(value, result);     }      public void testBigInteger() throws Exception     {         BigInteger value = new BigInteger("-1234567890123456789012345567809");         BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class);         assertEquals(value, result);     }      public void testUUID() throws Exception     {         UUID value = UUID.fromString("76e6d183-5f68-4afa-b94a-922c1fdb83f8");         assertEquals(value, MAPPER.readValue("\""+value.toString()+"\"", UUID.class));          // [JACKSON-393] fix:          // first, null should come as null         TokenBuffer buf = new TokenBuffer(null);         buf.writeObject(null);         assertNull(MAPPER.readValue(buf.asParser(), UUID.class));         buf.close();          // then, UUID itself come as is:         buf = new TokenBuffer(null);         buf.writeObject(value);         assertSame(value, MAPPER.readValue(buf.asParser(), UUID.class));          // and finally from byte[]         // oh crap; JDK UUID just... sucks. Not even byte[] accessors or constructors? Huh?         ByteArrayOutputStream bytes = new ByteArrayOutputStream();         DataOutputStream out = new DataOutputStream(bytes);         out.writeLong(value.getMostSignificantBits());         out.writeLong(value.getLeastSignificantBits());         byte[] data = bytes.toByteArray();         assertEquals(16, data.length);                  buf.writeObject(data);          UUID value2 = MAPPER.readValue(buf.asParser(), UUID.class);                  assertEquals(value, value2);         buf.close();     }      public void testURL() throws Exception     {         URL value = new URL("http://foo.com");         assertEquals(value, MAPPER.readValue("\""+value.toString()+"\"", URL.class));          // trivial case; null to null, embedded URL to URL         TokenBuffer buf = new TokenBuffer(null);         buf.writeObject(null);         assertNull(MAPPER.readValue(buf.asParser(), URL.class));         buf.close();          // then, UUID itself come as is:         buf = new TokenBuffer(null);         buf.writeObject(value);         assertSame(value, MAPPER.readValue(buf.asParser(), URL.class));         buf.close();     }      public void testURI() throws Exception     {         URI value = new URI("http://foo.com");         assertEquals(value, MAPPER.readValue("\""+value.toString()+"\"", URI.class));     }      /*     /**********************************************************     /* Sequence tests     /**********************************************************      */      /**      * Then a unit test to verify that we can conveniently bind sequence of      * space-separate simple values      */     public void testSequenceOfInts() throws Exception     {         final int NR_OF_INTS = 100;          StringBuilder sb = new StringBuilder();         for (int i = 0; i < NR_OF_INTS; ++i) {             sb.append(" ");             sb.append(i);         }         JsonParser jp = MAPPER.getFactory().createParser(sb.toString());         for (int i = 0; i < NR_OF_INTS; ++i) {             Integer result = MAPPER.readValue(jp, Integer.class);             assertEquals(Integer.valueOf(i), result);         }     } }  
package com.fasterxml.jackson.databind.deser;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Tests for checking that static methods are not recognized as accessors  * for properties  */ public class TestStatics     extends BaseMapTest {     static class Bean     {         int _x;          public static void setX(int value) { throw new Error("Should NOT call static method"); }                  @JsonProperty("x") public void assignX(int x) { _x = x; }     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */      public void testSimpleIgnore() throws Exception     {         ObjectMapper m = new ObjectMapper();         // should not care about static setter...         Bean result = m.readValue("{ \"x\":3}", Bean.class);         assertEquals(3, result._x);     } } 
package com.fasterxml.jackson.databind.deser;  import java.text.DateFormat; import java.text.SimpleDateFormat;   import com.fasterxml.jackson.databind.*;  public class TestTimestampDeserialization     extends BaseMapTest {     // As for TestDateDeserialization except we don't need to test date conversion routines, so     // just check we pick up timestamp class      public void testTimestampUtil() throws Exception     {         long now = 123456789L;         java.sql.Timestamp value = new java.sql.Timestamp(now);          // First from long         assertEquals(value, new ObjectMapper().readValue(""+now, java.sql.Timestamp.class));          String dateStr = serializeTimestampAsString(value);         java.sql.Timestamp result = new ObjectMapper().readValue("\""+dateStr+"\"", java.sql.Timestamp.class);          assertEquals("Date: expect "+value+" ("+value.getTime()+"), got "+result+" ("+result.getTime()+")", value.getTime(), result.getTime());     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */      private String serializeTimestampAsString(java.sql.Timestamp value)     {         /* Then from String. This is bit tricky, since JDK does not really          * suggest a 'standard' format. So let's try using something...          */         DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");         return df.format(value);     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;  /**  * Unit tests for verifying "old" data binding from JSON to JDK objects;  * one that only uses core JDK types; wrappers, Maps and Lists.  */ public class TestUntypedDeserialization     extends com.fasterxml.jackson.test.BaseTest {     @SuppressWarnings("unchecked")     public void testSampleDoc()         throws Exception     {         final String JSON = SAMPLE_DOC_JSON_SPEC;          JsonFactory jf = new JsonFactory();          /* To get "untyped" Mapping (to Maps, Lists, instead of beans etc),          * we'll specify plain old Object.class as the target.          */         Object root = new ObjectMapper().readValue(jf.createParser(new StringReader(JSON)), Object.class);          assertType(root, Map.class);         Map<?,?> rootMap = (Map<?,?>) root;         assertEquals(1, rootMap.size());         Map.Entry<?,?> rootEntry =  rootMap.entrySet().iterator().next();         assertEquals("Image", rootEntry.getKey());         Object image = rootEntry.getValue();         assertType(image, Map.class);         Map<?,?> imageMap = (Map<?,?>) image;         assertEquals(5, imageMap.size());          Object value = imageMap.get("Width");         assertType(value, Integer.class);         assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_WIDTH), value);          value = imageMap.get("Height");         assertType(value, Integer.class);         assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), value);          assertEquals(SAMPLE_SPEC_VALUE_TITLE, imageMap.get("Title"));          // Another Object, "thumbnail"         value = imageMap.get("Thumbnail");         assertType(value, Map.class);         Map<?,?> tnMap = (Map<?,?>) value;         assertEquals(3, tnMap.size());          assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), tnMap.get("Height"));         // for some reason, width is textual, not numeric...         assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, tnMap.get("Width"));         assertEquals(SAMPLE_SPEC_VALUE_TN_URL, tnMap.get("Url"));          // And then number list, "IDs"         value = imageMap.get("IDs");         assertType(value, List.class);         List<Object> ids = (List<Object>) value;         assertEquals(4, ids.size());         assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), ids.get(0));         assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), ids.get(1));         assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), ids.get(2));         assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), ids.get(3));          // and that's all folks!     }      // [JACKSON-839]: allow 'upgrade' of big integers into Long, BigInteger     public void testObjectSerializeWithLong() throws IOException     {         final ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping(DefaultTyping.JAVA_LANG_OBJECT, As.PROPERTY);         final long VALUE = 1337800584532L;          String serialized = "{\"timestamp\":"+VALUE+"}";         // works fine as node         JsonNode deserialized = mapper.readTree(serialized);         assertEquals(VALUE, deserialized.get("timestamp").asLong());         // and actually should work in Maps too         Map<?,?> deserMap = mapper.readValue(serialized, Map.class);         Number n = (Number) deserMap.get("timestamp");         assertNotNull(n);         assertSame(Long.class, n.getClass());         assertEquals(Long.valueOf(VALUE), n);     } } 
package com.fasterxml.jackson.databind.deser;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.deser.std.StdDeserializer; import com.fasterxml.jackson.test.BaseTest;  /**  * This unit test suite tests use of "value" Annotations;  * annotations that define actual type (Class) to use for  * deserialization.  */ public class TestValueAnnotations     extends BaseTest {     /*     /**********************************************************     /* Annotated root classes for @JsonDeserialize#as     /**********************************************************      */      @JsonDeserialize(using=RootStringDeserializer.class)     interface RootString {         public String contents();     }      static class RootStringImpl implements RootString     {         final String _contents;          public RootStringImpl(String x) { _contents = x; }          @Override         public String contents() { return _contents; }         public String contents2() { return _contents; }     }      @JsonDeserialize(as=RootInterfaceImpl.class)     interface RootInterface {         public String getA();     }      static class RootInterfaceImpl implements RootInterface {         public String a;          public RootInterfaceImpl() { }          @Override         public String getA() { return a; }     }      @SuppressWarnings("serial")     @JsonDeserialize(contentAs=RootStringImpl.class)     static class RootMap extends HashMap<String,RootStringImpl> { }      @SuppressWarnings("serial")     @JsonDeserialize(contentAs=RootStringImpl.class)     static class RootList extends LinkedList<RootStringImpl> { }      @SuppressWarnings("serial")     static class RootStringDeserializer         extends StdDeserializer<RootString>     {         public RootStringDeserializer() { super(RootString.class); }          @Override         public RootString deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException, JsonProcessingException         {             if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {                 return new RootStringImpl(jp.getText());             }             throw ctxt.mappingException(_valueClass);         }     }      /*     /**********************************************************     /* Annotated helper classes for @JsonDeserialize#as     /**********************************************************      */      /* Class for testing valid {@link JsonDeserialize} annotation      * with 'as' parameter to define concrete class to deserialize to      */     final static class CollectionHolder     {         Collection<String> _strings;          /* Default for 'Collection' would probably be ArrayList or so;          * let's try to make it a TreeSet instead.          */         @JsonDeserialize(as=TreeSet.class)         public void setStrings(Collection<String> s)         {             _strings = s;         }     }      /* Another class for testing valid {@link JsonDeserialize} annotation      * with 'as' parameter to define concrete class to deserialize to      */     final static class MapHolder     {         // Let's also coerce numbers into Strings here         Map<String,String> _data;          /* Default for 'Collection' would be HashMap,          * let's try to make it a TreeMap instead.          */         @JsonDeserialize(as=TreeMap.class)         public void setStrings(Map<String,String> s)         {             _data = s;         }     }      /* Another class for testing valid {@link JsonDeserialize} annotation      * with 'as' parameter, but with array      */     final static class ArrayHolder     {         String[] _strings;          @JsonDeserialize(as=String[].class)         public void setStrings(Object[] o)         {             // should be passed instances of proper type, as per annotation             _strings = (String[]) o;         }     }      /* Another class for testing broken {@link JsonDeserialize} annotation      * with 'as' parameter; one with incompatible type      */     final static class BrokenCollectionHolder     {         @JsonDeserialize(as=String.class) // not assignable to Collection         public void setStrings(Collection<String> s) { }     }      /*     /**********************************************************     /* Annotated helper classes for @JsonDeserialize.keyAs     /**********************************************************      */      final static class StringWrapper     {         final String _string;          public StringWrapper(String s) { _string = s; }     }      final static class MapKeyHolder     {         Map<Object, String> _map;          @JsonDeserialize(keyAs=StringWrapper.class)         public void setMap(Map<Object,String> m)         {             // type should be ok, but no need to cast here (won't matter)             _map = m;         }     }      final static class BrokenMapKeyHolder     {         // Invalid: Integer not a sub-class of String         @JsonDeserialize(keyAs=Integer.class)             public void setStrings(Map<String,String> m) { }     }      /*     /**********************************************************     /* Annotated helper classes for @JsonDeserialize#contentAs     /**********************************************************      */      final static class ListContentHolder     {         List<?> _list;          @JsonDeserialize(contentAs=StringWrapper.class)         public void setList(List<?> l) {             _list = l;         }     }      final static class InvalidContentClass     {         /* Such annotation not allowed, since it makes no sense;          * non-container classes have no contents to annotate (but          * note that it is possible to first use @JsonDesiarialize.as          * to mark Object as, say, a List, and THEN use          * @JsonDeserialize.contentAs!)          */         @JsonDeserialize(contentAs=String.class)             public void setValue(Object x) { }     }      final static class ArrayContentHolder     {         Object[] _data;          @JsonDeserialize(contentAs=Long.class)         public void setData(Object[] o)         { // should have proper type, but no need to coerce here             _data = o;         }     }      final static class MapContentHolder     {         Map<Object,Object> _map;          @JsonDeserialize(contentAs=Integer.class)         public void setMap(Map<Object,Object> m)         {             _map = m;         }     }      /*     /**********************************************************     /* Test methods for @JsonDeserialize#as     /**********************************************************      */      public void testOverrideClassValid() throws Exception     {         ObjectMapper m = new ObjectMapper();         CollectionHolder result = m.readValue             ("{ \"strings\" : [ \"test\" ] }", CollectionHolder.class);          Collection<String> strs = result._strings;         assertEquals(1, strs.size());         assertEquals(TreeSet.class, strs.getClass());         assertEquals("test", strs.iterator().next());     }      public void testOverrideMapValid() throws Exception     {         ObjectMapper m = new ObjectMapper();         // note: expecting conversion from number to String, as well         MapHolder result = m.readValue             ("{ \"strings\" :  { \"a\" : 3 } }", MapHolder.class);          Map<String,String> strs = result._data;         assertEquals(1, strs.size());         assertEquals(TreeMap.class, strs.getClass());         String value = strs.get("a");         assertEquals("3", value);     }      public void testOverrideArrayClass() throws Exception     {         ObjectMapper m = new ObjectMapper();         ArrayHolder result = m.readValue             ("{ \"strings\" : [ \"test\" ] }", ArrayHolder.class);          String[] strs = result._strings;         assertEquals(1, strs.length);         assertEquals(String[].class, strs.getClass());         assertEquals("test", strs[0]);     }      public void testOverrideClassInvalid() throws Exception     {         // should fail due to incompatible Annotation         try {             BrokenCollectionHolder result = new ObjectMapper().readValue                 ("{ \"strings\" : [ ] }", BrokenCollectionHolder.class);             fail("Expected a failure, but got results: "+result);         } catch (JsonMappingException jme) {             verifyException(jme, "is not assignable to");         }     }      /*     /**********************************************************     /* Test methods for @JsonDeserialize#as used for root values     /**********************************************************      */      public void testRootInterfaceAs() throws Exception     {         RootInterface value = new ObjectMapper().readValue("{\"a\":\"abc\" }", RootInterface.class);         assertTrue(value instanceof RootInterfaceImpl);         assertEquals("abc", value.getA());     }      public void testRootInterfaceUsing() throws Exception     {         RootString value = new ObjectMapper().readValue("\"xxx\"", RootString.class);         assertTrue(value instanceof RootString);         assertEquals("xxx", value.contents());     }      public void testRootListAs() throws Exception     {         RootMap value = new ObjectMapper().readValue("{\"a\":\"b\"}", RootMap.class);         assertEquals(1, value.size());         Object v2 = value.get("a");         assertEquals(RootStringImpl.class, v2.getClass());         assertEquals("b", ((RootString) v2).contents());     }      public void testRootMapAs() throws Exception     {         RootList value = new ObjectMapper().readValue("[ \"c\" ]", RootList.class);         assertEquals(1, value.size());         Object v2 = value.get(0);         assertEquals(RootStringImpl.class, v2.getClass());         assertEquals("c", ((RootString) v2).contents());     }      /*     /**********************************************************     /* Test methods for @JsonDeserialize#keyAs     /**********************************************************      */      @SuppressWarnings("unchecked") 	public void testOverrideKeyClassValid() throws Exception     {         ObjectMapper m = new ObjectMapper();         MapKeyHolder result = m.readValue("{ \"map\" : { \"xxx\" : \"yyy\" } }", MapKeyHolder.class);         Map<StringWrapper, String> map = (Map<StringWrapper,String>)(Map<?,?>)result._map;         assertEquals(1, map.size());         Map.Entry<StringWrapper, String> en = map.entrySet().iterator().next();          StringWrapper key = en.getKey();         assertEquals(StringWrapper.class, key.getClass());         assertEquals("xxx", key._string);         assertEquals("yyy", en.getValue());     }      public void testOverrideKeyClassInvalid() throws Exception     {         // should fail due to incompatible Annotation         try {             BrokenMapKeyHolder result = new ObjectMapper().readValue                 ("{ \"123\" : \"xxx\" }", BrokenMapKeyHolder.class);             fail("Expected a failure, but got results: "+result);         } catch (JsonMappingException jme) {             verifyException(jme, "is not assignable to");         }     }      /*     /**********************************************************     /* Test methods for @JsonDeserialize#contentAs     /**********************************************************      */      @SuppressWarnings("unchecked") 	public void testOverrideContentClassValid() throws Exception     {         ObjectMapper m = new ObjectMapper();         ListContentHolder result = m.readValue("{ \"list\" : [ \"abc\" ] }", ListContentHolder.class);         List<StringWrapper> list = (List<StringWrapper>)result._list;         assertEquals(1, list.size());         Object value = list.get(0);         assertEquals(StringWrapper.class, value.getClass());         assertEquals("abc", ((StringWrapper) value)._string);     }      public void testOverrideArrayContents() throws Exception     {         ObjectMapper m = new ObjectMapper();         ArrayContentHolder result = m.readValue("{ \"data\" : [ 1, 2, 3 ] }",                                                 ArrayContentHolder.class);         Object[] data = result._data;         assertEquals(3, data.length);         assertEquals(Long[].class, data.getClass());         assertEquals(1L, data[0]);         assertEquals(2L, data[1]);         assertEquals(3L, data[2]);     }      public void testOverrideMapContents() throws Exception     {         ObjectMapper m = new ObjectMapper();         MapContentHolder result = m.readValue("{ \"map\" : { \"a\" : 9 } }",                                                 MapContentHolder.class);         Map<Object,Object> map = result._map;         assertEquals(1, map.size());         Object ob = map.values().iterator().next();         assertEquals(Integer.class, ob.getClass());         assertEquals(Integer.valueOf(9), ob);     } } 
package com.fasterxml.jackson.databind.ext;  import javax.xml.datatype.*; import javax.xml.namespace.QName;   import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ext.CoreXMLDeserializers;  /**  * Core XML types (javax.xml) are considered "external" (or more precisely "optional")  * since some Java(-like) platforms do not include them: specifically, Google AppEngine  * and Android seem to skimp on their inclusion. As such, they are dynamically loaded  * only as needed, and need bit special handling.  *   * @author tatu  */ public class TestCoreXMLTypes     extends BaseMapTest {     /*     /**********************************************************     /* Serializer tests     /**********************************************************      */      public void testQNameSer() throws Exception     {         QName qn = new QName("http://abc", "tag", "prefix");         assertEquals(quote(qn.toString()), serializeAsString(qn));     }      public void testDurationSer() throws Exception     {         DatatypeFactory dtf = DatatypeFactory.newInstance();         // arbitrary value         Duration dur = dtf.newDurationDayTime(false, 15, 19, 58, 1);         assertEquals(quote(dur.toString()), serializeAsString(dur));     }      public void testXMLGregorianCalendarSerAndDeser() throws Exception     {         DatatypeFactory dtf = DatatypeFactory.newInstance();         XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar             (1974, 10, 10, 18, 15, 17, 123, 0);         /* Due to [JACKSON-308], 1.6 will use configurable Date serialization;          * and it defaults to using timestamp. So let's try couple of combinations.          */         ObjectMapper mapper = new ObjectMapper();         long timestamp = cal.toGregorianCalendar().getTimeInMillis();         String numStr = String.valueOf(timestamp);         assertEquals(numStr, mapper.writeValueAsString(cal));          // [JACKSON-403] Needs to come back ok as well:         XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class);         assertNotNull(calOut);         assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis());          // and then textual variant         mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);         // this is ALMOST same as default for XMLGregorianCalendar... just need to unify Z/+0000         String exp = cal.toXMLFormat();         String act = mapper.writeValueAsString(cal);         act = act.substring(1, act.length() - 1); // remove quotes         exp = removeZ(exp);         act = removeZ(act);         assertEquals(exp, act);     }      private String removeZ(String dateStr) {         if (dateStr.endsWith("Z")) {             return dateStr.substring(0, dateStr.length()-1);         }         if (dateStr.endsWith("+0000")) {             return dateStr.substring(0, dateStr.length()-5);         }         return dateStr;     }          /*     /**********************************************************     /* Deserializer tests     /**********************************************************      */          // First things first: must be able to load the deserializers...     public void testDeserializerLoading()     {         new CoreXMLDeserializers.DurationDeserializer();         new CoreXMLDeserializers.GregorianCalendarDeserializer();         new CoreXMLDeserializers.QNameDeserializer();     }      public void testQNameDeser() throws Exception     {         QName qn = new QName("http://abc", "tag", "prefix");         String qstr = qn.toString();         ObjectMapper mapper = new ObjectMapper();         assertEquals("Should deserialize to equal QName (exp serialization: '"+qstr+"')",                      qn, mapper.readValue(quote(qstr), QName.class));     }      public void testCalendarDeser() throws Exception     {         DatatypeFactory dtf = DatatypeFactory.newInstance();         XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar             (1974, 10, 10, 18, 15, 17, 123, 0);         String exp = cal.toXMLFormat();         assertEquals("Should deserialize to equal XMLGregorianCalendar ('"+exp+"')", cal,                 new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class));     }      public void testDurationDeser() throws Exception     {         DatatypeFactory dtf = DatatypeFactory.newInstance();         // arbitrary value, like... say, 27d5h15m59s         Duration dur = dtf.newDurationDayTime(true, 27, 5, 15, 59);         String exp = dur.toString();         assertEquals("Should deserialize to equal Duration ('"+exp+"')", dur,                 new ObjectMapper().readValue(quote(exp), Duration.class));     } } 
package com.fasterxml.jackson.databind.ext;  import java.io.StringReader; import javax.xml.parsers.DocumentBuilderFactory;  import org.xml.sax.InputSource; import org.w3c.dom.*;  import com.fasterxml.jackson.databind.ObjectMapper;  public class TestDOM extends com.fasterxml.jackson.databind.BaseMapTest {     final static String SIMPLE_XML =         "<root attr='3'><leaf>Rock &amp; Roll!</leaf><?proc instr?></root>";     final static String SIMPLE_XML_NS =         "<root ns:attr='abc' xmlns:ns='http://foo' />";          public void testSerializeSimpleNonNS() throws Exception     {         // Let's just parse first, easiest         Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse             (new InputSource(new StringReader(SIMPLE_XML)));         assertNotNull(doc);         ObjectMapper mapper = new ObjectMapper();         // need to strip xml declaration, if any         String outputRaw = mapper.writeValueAsString(doc);         // And re-parse as String, since JSON has quotes...         String output = mapper.readValue(outputRaw, String.class);         /* ... and finally, normalize to (close to) canonical XML          * output (single vs double quotes, xml declaration etc)          */         assertEquals(SIMPLE_XML, normalizeOutput(output));     }      public void testDeserializeNonNS() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         for (int i = 0; i < 2; ++i) {             Document doc;              if (i == 0) {                 // First, as Document:                 doc = mapper.readValue(quote(SIMPLE_XML), Document.class);             } else {                 // and then as plain Node (no difference)                 Node node = mapper.readValue(quote(SIMPLE_XML), Node.class);                 doc = (Document) node;             }             Element root = doc.getDocumentElement();             assertNotNull(root);             // non-ns, simple...             assertEquals("root", root.getTagName());             assertEquals("3", root.getAttribute("attr"));             assertEquals(1, root.getAttributes().getLength());             NodeList nodes = root.getChildNodes();             assertEquals(2, nodes.getLength());             Element leaf = (Element) nodes.item(0);             assertEquals("leaf", leaf.getTagName());             assertEquals(0, leaf.getAttributes().getLength());             //"<root attr='3'><leaf>Rock &amp; Roll!</leaf><?proc instr?></root>";             ProcessingInstruction pi = (ProcessingInstruction) nodes.item(1);             assertEquals("proc", pi.getTarget());             assertEquals("instr", pi.getData());         }     }          public void testDeserializeNS() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         Document doc = mapper.readValue(quote(SIMPLE_XML_NS), Document.class);         Element root = doc.getDocumentElement();         assertNotNull(root);         assertEquals("root", root.getTagName());         // Not sure if it ought to be "" or null...         String uri = root.getNamespaceURI();         assertTrue((uri == null) || "".equals(uri));         // no child nodes:         assertEquals(0, root.getChildNodes().getLength());         // DOM is weird, includes ns decls as attributes...         assertEquals(2, root.getAttributes().getLength());         assertEquals("abc", root.getAttributeNS("http://foo", "attr"));     }      /*      **********************************************************      * Helper methods      **********************************************************      */      protected static String normalizeOutput(String output)     {         // XML declaration to get rid of?         output = output.trim();         if (output.startsWith("<?xml")) {             // can find closing '>' of xml decl...             output = output.substring(output.indexOf('>')+1).trim();         }         // And replace double quotes with single-quotes...         return output.replace('"', '\'');     } } 
package com.fasterxml.jackson.databind.filter;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  public class TestIgnorePropsForSerialization     extends BaseMapTest {     /*     /****************************************************************     /* Helper classes     /****************************************************************      */      @JsonIgnoreProperties({"b", "c"})     static class IgnoreSome     {         public int a = 3;         public String b = "x";          public int getC() { return -6; }         public String getD() { return "abc"; }     }      @SuppressWarnings("serial")     @JsonIgnoreProperties({"@class"})     static class MyMap extends HashMap<String,String> { }      // [JACKSON-787]: allow use of @JsonIgnoreProperties for properties     static class WrapperWithPropIgnore     {         @JsonIgnoreProperties("y")         public XY value = new XY();     }      static class XY {         public int x = 1;         public int y = 2;     }      static class WrapperWithPropIgnore2     {         @JsonIgnoreProperties("z")         public XYZ value = new XYZ();     }      @JsonIgnoreProperties({"x"})     static class XYZ {         public int x = 1;         public int y = 2;         public int z = 3;     }      static class MapWrapper {         @JsonIgnoreProperties({"a"})         public final HashMap<String,Integer> value = new HashMap<String,Integer>();         {             value.put("a", 1);             value.put("b", 2);         }     }          /*     /****************************************************************     /* Unit tests     /****************************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testExplicitIgnoralWithBean() throws Exception     {         IgnoreSome value = new IgnoreSome();         Map<String,Object> result = writeAndMap(MAPPER, value);         assertEquals(2, result.size());         // verify that specified fields are ignored         assertFalse(result.containsKey("b"));         assertFalse(result.containsKey("c"));         // and that others are not         assertEquals(Integer.valueOf(value.a), result.get("a"));         assertEquals(value.getD(), result.get("d"));     }      public void testExplicitIgnoralWithMap() throws Exception     {         // test simulating need to filter out metadata like class name         MyMap value = new MyMap();         value.put("a", "b");         value.put("@class", MyMap.class.getName());         Map<String,Object> result = writeAndMap(MAPPER, value);         assertEquals(1, result.size());         // verify that specified field is ignored         assertFalse(result.containsKey("@class"));         // and that others are not         assertEquals(value.get("a"), result.get("a"));     }      public void testIgnoreViaOnlyProps() throws Exception     {         assertEquals("{\"value\":{\"x\":1}}",                 MAPPER.writeValueAsString(new WrapperWithPropIgnore()));     }      public void testIgnoreWithMapProperty() throws Exception     {         assertEquals("{\"value\":{\"b\":2}}", MAPPER.writeValueAsString(new MapWrapper()));     }          public void testIgnoreViaPropsAndClass() throws Exception     {         assertEquals("{\"value\":{\"y\":2}}",                 MAPPER.writeValueAsString(new WrapperWithPropIgnore2()));     } } 
package com.fasterxml.jackson.databind.filter;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * This unit test suite tests use of {@link JsonIgnore} annotations  * with  bean serialization; as well as (since 1.7)  * {@link JsonIgnoreType}.  */ public class TestSimpleSerializationIgnore     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      /// Class for testing enabled {@link JsonIgnore} annotation     final static class SizeClassEnabledIgnore     {         @JsonIgnore public int getY() { return 9; }          // note: must be public to be seen         public int getX() { return 1; }          @JsonIgnore public int getY2() { return 1; }         @JsonIgnore public int getY3() { return 2; }     }      /// Class for testing disabled {@link JsonIgnore} annotation     final static class SizeClassDisabledIgnore     {         // note: must be public to be seen         public int getX() { return 3; }         @JsonIgnore(false) public int getY() { return 4; }     }      static class BaseClassIgnore     {         @JsonProperty("x")         @JsonIgnore         public int x() { return 1; }          public int getY() { return 2; }     }      static class SubClassNonIgnore         extends BaseClassIgnore     {         /* Annotations to disable ignorance, in sub-class; note that          * we must still get "JsonProperty" fro super class          */         @Override         @JsonIgnore(false)         public int x() { return 3; }     }      @JsonIgnoreType     static class IgnoredType { }      @JsonIgnoreType(false)     static class NonIgnoredType     {         public int value = 13;                  public IgnoredType ignored = new IgnoredType();     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testSimpleIgnore() throws Exception     {         ObjectMapper m = new ObjectMapper();         // Should see "x", not "y"         Map<String,Object> result = writeAndMap(m, new SizeClassEnabledIgnore());         assertEquals(1, result.size());         assertEquals(Integer.valueOf(1), result.get("x"));         assertNull(result.get("y"));     }      public void testDisabledIgnore() throws Exception     {         ObjectMapper m = new ObjectMapper();         // Should see "x" and "y"         Map<String,Object> result = writeAndMap(m, new SizeClassDisabledIgnore());         assertEquals(2, result.size());         assertEquals(Integer.valueOf(3), result.get("x"));         assertEquals(Integer.valueOf(4), result.get("y"));     }      /**      * Test case to verify that ignore tag can also be disabled      * via inheritance      */     public void testIgnoreOver() throws Exception     {         ObjectMapper m = new ObjectMapper();          // should only see "y"         Map<String,Object> result = writeAndMap(m, new BaseClassIgnore());         assertEquals(1, result.size());         assertEquals(Integer.valueOf(2), result.get("y"));          // Should see "x" and "y"         result = writeAndMap(m, new SubClassNonIgnore());         assertEquals(2, result.size());         assertEquals(Integer.valueOf(3), result.get("x"));         assertEquals(Integer.valueOf(2), result.get("y"));     }      /**      * @since 1.7      */     public void testIgnoreType() throws Exception     {         ObjectMapper m = new ObjectMapper();         assertEquals("{\"value\":13}", m.writeValueAsString(new NonIgnoredType()));     } } 
package com.fasterxml.jackson.databind.filter;  import java.io.*; import java.util.HashMap; import java.util.Map;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.core.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;  /**  * Unit tests for checking handling of unknown properties  */ public class TestUnknownPropertyDeserialization     extends BaseMapTest {     final static String JSON_UNKNOWN_FIELD = "{ \"a\" : 1, \"foo\" : [ 1, 2, 3], \"b\" : -1 }";      /*     /**********************************************************     /* Helper classes     /**********************************************************      */      final static class TestBean     {         String _unknown;          int _a, _b;          public TestBean() { }          public void setA(int a) { _a = a; }         public void setB(int b) { _b = b; }          public void markUnknown(String unk) { _unknown = unk; }     }      /**      * Simple {@link DeserializationProblemHandler} sub-class that      * just marks unknown property/ies when encountered, along with      * Json value of the property.      */     final static class MyHandler         extends DeserializationProblemHandler     {         @Override         public boolean handleUnknownProperty(DeserializationContext ctxt,                 JsonParser jp, JsonDeserializer<?> deserializer,                 Object bean, String propertyName)             throws IOException, JsonProcessingException         {             // very simple, just to verify that we do see correct token type             ((TestBean) bean).markUnknown(propertyName+":"+jp.getCurrentToken().toString());             // Yup, we are good to go; must skip whatever value we'd have:             jp.skipChildren();             return true;         }     }      @JsonIgnoreProperties({"b", "c"})     static class IgnoreSome     {         public int a, b;         private String c, d;          public IgnoreSome() { }          public String c() { return c; }         public void setC(String value) { c = value; }         public String d() { return d; }         public void setD(String value) { d = value; }     }      @JsonIgnoreProperties(ignoreUnknown=true)     static class IgnoreUnknown {         public int a;     }      @SuppressWarnings("serial")     @JsonIgnoreProperties({"a", "d"})     static class IgnoreMap extends HashMap<String,Object> { }      static class ImplicitIgnores {         @JsonIgnore public int a;         @JsonIgnore public void setB(int b) { }         public int c;     }      // // Ignored as per [JACKSON-787]      static class XYZWrapper1 {         @JsonIgnoreProperties({"x"})         public YZ value;     }      static class YZ {         public int y, z;     }      static class XYZWrapper2 {         @JsonIgnoreProperties({"y"})         public X value;     }      @JsonIgnoreProperties({"z"})     static class X {         public int x;     }      static class MapWithoutX {         @JsonIgnoreProperties("x")         public Map<String,Integer> values;     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          /**      * By default we should just get an exception if an unknown property      * is encountered      */     public void testUnknownHandlingDefault()         throws Exception     {         try {             MAPPER.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);         } catch (JsonMappingException jex) {             verifyException(jex, "Unrecognized field \"foo\"");         }     }      /**      * Test that verifies that it is possible to ignore unknown properties using      * {@link DeserializationProblemHandler}.      */     public void testUnknownHandlingIgnoreWithHandler()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.clearProblemHandlers();         mapper.addHandler(new MyHandler());         TestBean result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);         assertNotNull(result);         assertEquals(1, result._a);         assertEquals(-1, result._b);         assertEquals("foo:START_ARRAY", result._unknown);     }      /**      * Test that verifies that it is possible to ignore unknown properties using      * {@link DeserializationProblemHandler} and an ObjectReader.      */     public void testUnknownHandlingIgnoreWithHandlerAndObjectReader()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.clearProblemHandlers();         TestBean result = mapper.reader(TestBean.class).withHandler(new MyHandler()).readValue(new StringReader(JSON_UNKNOWN_FIELD));         assertNotNull(result);         assertEquals(1, result._a);         assertEquals(-1, result._b);         assertEquals("foo:START_ARRAY", result._unknown);     }      /**      * Test for checking that it is also possible to simply suppress      * error reporting for unknown properties.      */     public void testUnknownHandlingIgnoreWithFeature()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);         TestBean result = null;         try {             result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);         } catch (JsonMappingException jex) {             fail("Did not expect a problem, got: "+jex.getMessage());         }         assertNotNull(result);         assertEquals(1, result._a);         assertNull(result._unknown);         assertEquals(-1, result._b);     }      public void testWithClassIgnore()         throws Exception     {         IgnoreSome result = MAPPER.readValue("{ \"a\":1,\"b\":2,\"c\":\"x\",\"d\":\"y\"}",                 IgnoreSome.class);         // first: should deserialize 2 of properties normally         assertEquals(1, result.a);         assertEquals("y", result.d());         // and not take other 2         assertEquals(0, result.b);         assertNull(result.c());     }      /// @since 1.4     public void testClassIgnoreWithMap() throws Exception     {         // Let's actually use incompatible types for "a" and "d"; should not matter when ignored         IgnoreMap result = MAPPER.readValue             ("{ \"a\":[ 1],\n"                 +"\"b\":2,\n"                 +"\"c\": \"x\",\n"                 +"\"d\":false }", IgnoreMap.class);         assertEquals(2, result.size());         Object ob = result.get("b");         assertEquals(Integer.class, ob.getClass());         assertEquals(Integer.valueOf(2), ob);         assertEquals("x", result.get("c"));         assertFalse(result.containsKey("a"));         assertFalse(result.containsKey("d"));     }      public void testClassWithIgnoreUnknown() throws Exception     {         IgnoreUnknown result = MAPPER.readValue             ("{\"b\":3,\"c\":[1,2],\"x\":{ },\"a\":-3}", IgnoreUnknown.class);         assertEquals(-3, result.a);     }      /**      * Test that verifies that use of {@link JsonIgnore} will add implicit      * skipping of matching properties.      */     public void testClassWithUnknownAndIgnore() throws Exception     {         // should be ok: "a" and "b" ignored, "c" mapped:         ImplicitIgnores result = MAPPER.readValue             ("{\"a\":1,\"b\":2,\"c\":3 }", ImplicitIgnores.class);         assertEquals(3, result.c);          // but "d" is not defined, so should still error         try {             MAPPER.readValue("{\"a\":1,\"b\":2,\"c\":3,\"d\":4 }", ImplicitIgnores.class);                     } catch (JsonMappingException e) {             verifyException(e, "Unrecognized field \"d\"");         }     }      public void testPropertyIgnoral() throws Exception     {         XYZWrapper1 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper1.class);         assertEquals(2, result.value.y);         assertEquals(3, result.value.z);     }      public void testPropertyIgnoralWithClass() throws Exception     {         XYZWrapper2 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper2.class);         assertEquals(1, result.value.x);     }      public void testPropertyIgnoralForMap() throws Exception     {         MapWithoutX result = MAPPER.readValue("{\"values\":{\"x\":1,\"y\":2}}", MapWithoutX.class);         assertNotNull(result.values);         assertEquals(1, result.values.size());         assertEquals(Integer.valueOf(2), result.values.get("y"));     } }  
package com.fasterxml.jackson.databind.interop;   import java.io.*; import java.lang.reflect.Method; import java.util.*;  import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.test.BaseTest;  /**  * Unit test for checking that we can serialize CGLib generated proxies.  */ public class TestCglibUsage     extends BaseTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      interface BeanInterface {         public int getX();     }      /*     /**********************************************************     /* Tests     /**********************************************************      */      public void testSimpleProxied() throws Exception     {         Enhancer enh = new Enhancer();         enh.setInterfaces(new Class[] { BeanInterface.class });         enh.setCallback(new MethodInterceptor() {             @Override             public Object intercept(Object obj, Method method,                                         Object[] args, MethodProxy proxy)                     throws Throwable                 {                     if ("getX".equals(method.getName ())) {                         return Integer.valueOf(13);                     }                     return proxy.invokeSuper(obj, args);                 }             });         BeanInterface bean = (BeanInterface) enh.create();         ObjectMapper mapper = new ObjectMapper();         Map<String,Object> result = writeAndMap(mapper, bean);         assertEquals(1, result.size());         assertEquals(Integer.valueOf(13), result.get("x"));     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */      @SuppressWarnings("unchecked") 	private Map<String,Object> writeAndMap(ObjectMapper m, Object value)         throws IOException     {         StringWriter sw = new StringWriter();         m.writeValue(sw, value);         return (Map<String,Object>) m.readValue(sw.toString(), Object.class);     } }  
package com.fasterxml.jackson.databind.interop;  import java.io.*;  import com.fasterxml.jackson.databind.*;  /**  * Simple test to ensure that we can make POJOs use Jackson  * for JDK serialization, via {@link Externalizable}  *   * @since 2.1  */ public class TestExternalizable extends BaseMapTest {     /* Not pretty, but needed to make ObjectMapper accessible from      * static context (alternatively could use ThreadLocal).      */     static class MapperHolder {         private final ObjectMapper mapper = new ObjectMapper();         private final static MapperHolder instance = new MapperHolder();         public static ObjectMapper mapper() { return instance.mapper; }     }      /**      * Helper class we need to adapt {@link ObjectOutput} as      * {@link OutputStream}      */     final static class ExternalizableInput extends InputStream     {         private final ObjectInput in;          public ExternalizableInput(ObjectInput in) {             this.in = in;         }          @Override         public int available() throws IOException {             return in.available();         }                  @Override         public void close() throws IOException {             in.close();         }                  @Override         public boolean  markSupported() {             return false;         }          @Override         public int read() throws IOException {             return in.read();         }          @Override         public int read(byte[] buffer) throws IOException {             return in.read(buffer);         }          @Override         public int read(byte[] buffer, int offset, int len) throws IOException {             return in.read(buffer, offset, len);         }                  @Override         public long skip(long n) throws IOException {             return in.skip(n);         }     }              /**      * Helper class we need to adapt {@link ObjectOutput} as      * {@link OutputStream}      */     final static class ExternalizableOutput extends OutputStream     {         private final ObjectOutput out;          public ExternalizableOutput(ObjectOutput out) {             this.out = out;         }                  @Override         public void flush() throws IOException {             out.flush();         }          @Override         public void close() throws IOException {             out.close();         }                  @Override         public void write(int ch) throws IOException {             out.write(ch);         }          @Override         public void write(byte[] data) throws IOException {             out.write(data);         }                  @Override         public void write(byte[] data, int offset, int len) throws IOException {             out.write(data, offset, len);         }     }      //    @com.fasterxml.jackson.annotation.JsonFormat(shape=com.fasterxml.jackson.annotation.JsonFormat.Shape.ARRAY)     static class MyPojo implements Externalizable     {         public int id;         public String name;         public int[] values;          public MyPojo() { } // for deserialization         public MyPojo(int id, String name, int[] values)         {             this.id = id;             this.name = name;             this.values = values;         }          @Override         public void readExternal(ObjectInput in) throws IOException         { //            MapperHolder.mapper().readValue(             MapperHolder.mapper().readerForUpdating(this).readValue(new ExternalizableInput(in));         }          @Override         public void writeExternal(ObjectOutput oo) throws IOException         {             MapperHolder.mapper().writeValue(new ExternalizableOutput(oo), this);         }          @Override         public boolean equals(Object o)         {             if (o == this) return true;             if (o == null) return false;             if (o.getClass() != getClass()) return false;                          MyPojo other = (MyPojo) o;                          if (other.id != id) return false;             if (!other.name.equals(name)) return false;                          if (other.values.length != values.length) return false;             for (int i = 0, end = values.length; i < end; ++i) {                 if (values[i] != other.values[i]) return false;             }             return true;         }     }      /*     /**********************************************************     /* Actual tests     /**********************************************************      */      // Comparison, using JDK native     static class MyPojoNative implements Serializable     {         private static final long serialVersionUID = 1L;          public int id;         public String name;         public int[] values;          public MyPojoNative(int id, String name, int[] values)         {             this.id = id;             this.name = name;             this.values = values;         }     }          @SuppressWarnings("unused")     public void testSerializeAsExternalizable() throws Exception     {         ByteArrayOutputStream bytes = new ByteArrayOutputStream();         ObjectOutputStream obs = new ObjectOutputStream(bytes);         final MyPojo input = new MyPojo(13, "Foobar", new int[] { 1, 2, 3 } );         obs.writeObject(input);         obs.close();         byte[] ser = bytes.toByteArray();          // Ok: just verify it contains stuff it should         byte[] json = MapperHolder.mapper().writeValueAsBytes(input);          int ix = indexOf(ser, json);         if (ix < 0) {             fail("Serialization ("+ser.length+") does NOT contain JSON (of "+json.length+")");         }                  // Sanity check:         if (false) {             bytes = new ByteArrayOutputStream();             obs = new ObjectOutputStream(bytes);             MyPojoNative p = new MyPojoNative(13, "Foobar", new int[] { 1, 2, 3 } );             obs.writeObject(p);             obs.close();             System.out.println("Native size: "+bytes.size()+", vs JSON: "+ser.length);         }                  // then read back!         ObjectInputStream ins = new ObjectInputStream(new ByteArrayInputStream(ser));         MyPojo output = (MyPojo) ins.readObject();         ins.close();         assertNotNull(output);                  assertEquals(input, output);     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */      private int indexOf(byte[] full, byte[] fragment)     {         final byte first = fragment[0];         for (int i = 0, end = full.length-fragment.length; i < end; ++i) {             if (full[i] != first) continue;             if (matches(full, i, fragment)) {                 return i;             }         }         return -1;     }      private boolean matches(byte[] full, int index, byte[] fragment)     {         for (int i = 1, end = fragment.length; i < end; ++i) {             if (fragment[i] != full[index+i]) {                 return false;             }         }         return true;     } } 
package com.fasterxml.jackson.databind.interop;  import com.fasterxml.jackson.core.JsonProcessingException;  import com.fasterxml.jackson.databind.*;  public class TestFormatDetection extends BaseMapTest {     private final ObjectReader READER = objectReader();      static class POJO {         public int x, y;                  public POJO() { }         public POJO(int x, int y) {             this.x = x;             this.y = y;         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */          public void testSimpleWithJSON() throws Exception     {         ObjectReader detecting = READER.withType(POJO.class);         detecting = detecting.withFormatDetection(detecting);         POJO pojo = detecting.readValue(utf8Bytes("{\"x\":1}"));         assertNotNull(pojo);         assertEquals(1, pojo.x);     }      public void testInvalid() throws Exception     {         ObjectReader detecting = READER.withType(POJO.class);         detecting = detecting.withFormatDetection(detecting);         try {             detecting.readValue(utf8Bytes("<POJO><x>1</x></POJO>"));             fail("Should have failed");         } catch (JsonProcessingException e) {             verifyException(e, "Can not detect format from input");         }     } } 
package com.fasterxml.jackson.databind.interop;  import java.util.*;  import groovy.lang.GroovyClassLoader;  import com.fasterxml.jackson.databind.*;  /**  * Basic tests to see that simple Groovy beans can be serialized  * and deserialized  */ public class TestGroovyBeans     extends com.fasterxml.jackson.databind.BaseMapTest {     final static String SIMPLE_POGO =          "public class GBean {\n"         +"long id = 3;\n"         +"String name = \"whome\";\n"         +"}";      private final ObjectMapper MAPPER = new ObjectMapper();      public void testSimpleSerialization() throws Exception     {         Object ob = newGroovyObject(SIMPLE_POGO);         Map<String,Object> result = writeAndMap(MAPPER, ob);         assertEquals(2, result.size());         assertEquals("whome", result.get("name"));         /* 26-Nov-2009, tatu: Strange... Groovy seems to decide          *    'long' means 'int'... Oh well.          */         Object num = result.get("id");         assertNotNull(num);         assertTrue(num instanceof Number);         assertEquals(3, ((Number) num).intValue());     }      public void testSimpleDeserialization() throws Exception     {         Class<?> cls = defineGroovyClass(SIMPLE_POGO);         // First: deserialize from data         Object pogo = MAPPER.readValue("{\"id\":9,\"name\":\"Bob\"}", cls);         assertNotNull(pogo);         /* Hmmh. Could try to access using Reflection, or by defining          * a Java interface it implements. Or, maybe simplest, just          * re-serialize and see what we got.          */         Map<String,Object> result = writeAndMap(MAPPER, pogo);         assertEquals(2, result.size());         assertEquals("Bob", result.get("name"));         // as per earlier, we just get a number...         Object num = result.get("id");         assertNotNull(num);         assertTrue(num instanceof Number);         assertEquals(9, ((Number) num).intValue());     }      /*     *************************************************     * Helper methods     *************************************************     */      protected Class<?> defineGroovyClass(String src) throws Exception     {         return new GroovyClassLoader(getClass().getClassLoader()).parseClass(src);      }      protected Object newGroovyObject(String src) throws Exception     {         Class<?> cls = defineGroovyClass(src);         return cls.newInstance();     } } 
package com.fasterxml.jackson.databind.interop;   import java.io.*; import java.lang.reflect.Method; import java.util.*;  import org.hibernate.repackage.cglib.proxy.Enhancer; import org.hibernate.repackage.cglib.proxy.MethodInterceptor; import org.hibernate.repackage.cglib.proxy.MethodProxy;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.test.BaseTest;  /**  * Basic tests covering Hibernate-compatibility features.  */ public class TestHibernate     extends BaseTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      interface BeanInterfaceHib {         public int getX();     }      /*     /**********************************************************     /* Tests     /**********************************************************      */      /*      * Unit test to test [JACKSON-177]      */     public void testHibernateCglib() throws Exception     {         /* 03-Sep-2010, tatu: This often fails form Eclipse (on some platforms like Mac OS X),          *   so let's only run it from Ant/CLI          */         if (!runsFromAnt()) {             return;         }          Enhancer enh = new Enhancer();         enh.setInterfaces(new Class[] { BeanInterfaceHib.class });         enh.setCallback(new MethodInterceptor() {             @Override             public Object intercept(Object obj, Method method,                     Object[] args, MethodProxy proxy)                             throws Throwable             {                 if ("getX".equals(method.getName ())) {                     return Integer.valueOf(13);                 }                 return proxy.invokeSuper(obj, args);             }         });         BeanInterfaceHib bean = (BeanInterfaceHib) enh.create();         ObjectMapper mapper = new ObjectMapper();         Map<String,Object> result = writeAndMap(mapper, bean);         assertEquals(1, result.size());         assertEquals(Integer.valueOf(13), result.get("x"));     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */      @SuppressWarnings("unchecked")     private Map<String,Object> writeAndMap(ObjectMapper m, Object value)         throws IOException     {         StringWriter sw = new StringWriter();         m.writeValue(sw, value);         return (Map<String,Object>) m.readValue(sw.toString(), Object.class);     } }  
package com.fasterxml.jackson.databind.interop;  import java.lang.reflect.*;  import com.fasterxml.jackson.databind.*;  // mostly for [Issue#57] public class TestJDKProxy extends BaseMapTest {     final ObjectMapper MAPPER = new ObjectMapper();      public interface IPlanet {         String getName();         String setName(String s);     }      // bit silly example; usually wouldn't implement interface (no need to proxy if it did)     static class Planet implements IPlanet {         private String name;          public Planet() { }         public Planet(String s) { name = s; }                  @Override         public String getName(){return name;}         @Override         public String setName(String iName) {name = iName;             return name;         }     }              /*     /********************************************************     /* Test methods     /********************************************************      */          public void testSimple() throws Exception     {         IPlanet input = getProxy(IPlanet.class, new Planet("Foo"));         String json = MAPPER.writeValueAsString(input);         assertEquals("{\"name\":\"Foo\"}", json);                  // and just for good measure         Planet output = MAPPER.readValue(json, Planet.class);         assertEquals("Foo", output.getName());     }      /*     /********************************************************     /* Helper methods     /********************************************************      */      public static <T> T getProxy(Class<T> type, Object obj) {         class ProxyUtil implements InvocationHandler {             Object obj;             public ProxyUtil(Object o) {                 obj = o;             }             @Override             public Object invoke(Object proxy, Method m, Object[] args) throws Throwable {                 Object result = null;                 result = m.invoke(obj, args);                 return result;             }         }         @SuppressWarnings("unchecked")         T proxy = (T) Proxy.newProxyInstance(type.getClassLoader(), new Class[] { type },                 new ProxyUtil(obj));         return proxy;     } } 
package com.fasterxml.jackson.databind.introspect;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  /**  * Tests to verify that annotations are shared and merged between members  * of a property (getter and setter and so on)  */ public class TestAnnotationMerging extends BaseMapTest {     static class Wrapper     {         protected Object value;          public Wrapper() { }         public Wrapper(Object o) { value = o; }                  @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)         public Object getValue() { return value; }          public void setValue(Object o) { value = o; }     }      static class SharedName {         @JsonProperty("x")         protected int value;          public SharedName(int v) { value = v; }                  public int getValue() { return value; }     }      static class SharedName2     {         @JsonProperty("x")         public int getValue() { return 1; }         public void setValue(int x) { }     }      // Testing to ensure that ctor param and getter can "share" @JsonTypeInfo stuff     static class TypeWrapper     {         protected Object value;          @JsonCreator         public TypeWrapper(                 @JsonProperty("value")                 @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) Object o) {             value = o;         }         public Object getValue() { return value; }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testSharedNames() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         assertEquals("{\"x\":6}", mapper.writeValueAsString(new SharedName(6)));     }      public void testSharedNamesFromGetterToSetter() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(new SharedName2());         assertEquals("{\"x\":1}", json);         SharedName2 result = mapper.readValue(json, SharedName2.class);         assertNotNull(result);     }          public void testSharedTypeInfo() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(new Wrapper(13L));         Wrapper result = mapper.readValue(json, Wrapper.class);         assertEquals(Long.class, result.value.getClass());     }      public void testSharedTypeInfoWithCtor() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(new TypeWrapper(13L));         TypeWrapper result = mapper.readValue(json, TypeWrapper.class);         assertEquals(Long.class, result.value.getClass());     } } 
package com.fasterxml.jackson.databind.introspect;  import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility; import com.fasterxml.jackson.databind.ObjectMapper;  /* Tests mostly for [JACKSON-754]: ability to create "annotation bundles"  */ public class TestAnnotionBundles extends com.fasterxml.jackson.databind.BaseMapTest {     @Retention(RetentionPolicy.RUNTIME)     @JacksonAnnotationsInside     @JsonIgnore     private @interface MyIgnoral { }      @Retention(RetentionPolicy.RUNTIME)     @JacksonAnnotationsInside     @JsonProperty("foobar")     private @interface MyRename { }      protected final static class Bean {         @MyIgnoral         public String getIgnored() { return "foo"; }           @MyRename         public int renamed = 13;     }      @Retention(RetentionPolicy.RUNTIME)     @JsonAutoDetect(fieldVisibility=Visibility.NONE,             getterVisibility=Visibility.NONE, isGetterVisibility=Visibility.NONE)     @JacksonAnnotationsInside     public @interface JsonAutoDetectOff {}      @JsonAutoDetectOff     public class NoAutoDetect {       public int getA() { return 13; }              @JsonProperty       public int getB() { return 5; }     }      @Retention(RetentionPolicy.RUNTIME)     @JacksonAnnotationsInside     @JsonProperty("_id")     public @interface Bundle92 {}      public class Bean92 {         @Bundle92         protected String id = "abc";     }         /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testBundledIgnore() throws Exception     {         assertEquals("{\"foobar\":13}", MAPPER.writeValueAsString(new Bean()));     }      public void testVisibilityBundle() throws Exception     {         assertEquals("{\"b\":5}", MAPPER.writeValueAsString(new NoAutoDetect()));     }          public void testIssue92() throws Exception     {         assertEquals("{\"_id\":\"abc\"}", MAPPER.writeValueAsString(new Bean92()));     } } 
package com.fasterxml.jackson.databind.introspect;  import java.util.Map;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector; import com.fasterxml.jackson.databind.introspect.POJOPropertiesCollector; import com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder;  public class TestBuilderMethods extends BaseMapTest {     static class SimpleBuilder     {     	public int x;     	     	public SimpleBuilder withX(int x) {     		this.x = x;     		return this;     	}     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      private final ObjectMapper mapper = new ObjectMapper();          public void testSimple()     {         POJOPropertiesCollector coll = collector(SimpleBuilder.class, "with");         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         POJOPropertyBuilder prop = props.get("x");         assertNotNull(prop);         assertTrue(prop.hasField());         assertFalse(prop.hasGetter());         assertTrue(prop.hasSetter());     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */      protected POJOPropertiesCollector collector(Class<?> cls, String prefix)     {         BasicClassIntrospector bci = new BasicClassIntrospector();         // no real difference between serialization, deserialization, at least here         return bci.collectProperties(mapper.getSerializationConfig(),                 mapper.constructType(cls), null, false, prefix);     }      } 
package com.fasterxml.jackson.databind.introspect;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.JsonMappingException; import com.fasterxml.jackson.databind.MapperFeature; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestInferredMutators extends BaseMapTest {     public static class Point {         private int x;                  public int getX() { return x; }     }      public static class FixedPoint {         private final int x;          public FixedPoint() { x = 0; }          public int getX() { return x; }     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      // for #190     public void testFinalFieldIgnoral() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         // default value is 'enabled', for backwards compatibility         assertTrue(mapper.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS));         mapper.disable(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS);         try {             /*p =*/ mapper.readValue("{\"x\":2}", FixedPoint.class);             fail("Should not try to use final field");         } catch (JsonMappingException e) {             verifyException(e, "unrecognized field \"x\"");         }     }          // for #195     public void testDeserializationInference() throws Exception     {         final String JSON = "{\"x\":2}";         ObjectMapper mapper = new ObjectMapper();         // First: default case, inference enabled:         assertTrue(mapper.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS));         Point p = mapper.readValue(JSON,  Point.class);         assertEquals(2, p.x);          // but without it, should fail:         mapper = new ObjectMapper();         mapper.disable(MapperFeature.INFER_PROPERTY_MUTATORS);         try {             p = mapper.readValue(JSON,  Point.class);             fail("Should not succeeed");         } catch (JsonMappingException e) {             verifyException(e, "unrecognized field \"x\"");         }     } } 
package com.fasterxml.jackson.databind.introspect;  import java.io.IOException; import java.io.StringWriter; import java.util.*; import javax.xml.namespace.QName;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonProcessingException; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.*; import com.fasterxml.jackson.databind.deser.std.StdDeserializer; import com.fasterxml.jackson.databind.introspect.AnnotatedClass; import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder; import com.fasterxml.jackson.databind.type.TypeFactory;  @SuppressWarnings("serial") public class TestJacksonAnnotationIntrospector     extends BaseMapTest {     public static enum EnumExample {         VALUE1;     }      public static class JacksonExample     {         private String attributeProperty;         private String elementProperty;         private List<String> wrappedElementProperty;         private EnumExample enumProperty;         private QName qname;          @JsonSerialize(using=QNameSerializer.class)         public QName getQname()         {             return qname;         }          @JsonDeserialize(using=QNameDeserializer.class)         public void setQname(QName qname)         {             this.qname = qname;         }          @JsonProperty("myattribute")         public String getAttributeProperty()         {             return attributeProperty;         }          @JsonProperty("myattribute")         public void setAttributeProperty(String attributeProperty)         {             this.attributeProperty = attributeProperty;         }          @JsonProperty("myelement")         public String getElementProperty()         {             return elementProperty;         }          @JsonProperty("myelement")         public void setElementProperty(String elementProperty)         {             this.elementProperty = elementProperty;         }          @JsonProperty("mywrapped")         public List<String> getWrappedElementProperty()         {             return wrappedElementProperty;         }          @JsonProperty("mywrapped")         public void setWrappedElementProperty(List<String> wrappedElementProperty)         {             this.wrappedElementProperty = wrappedElementProperty;         }          public EnumExample getEnumProperty()         {             return enumProperty;         }          public void setEnumProperty(EnumExample enumProperty)         {             this.enumProperty = enumProperty;         }     }      public static class QNameSerializer extends JsonSerializer<QName> {          @Override         public void serialize(QName value, JsonGenerator jgen, SerializerProvider provider)                 throws IOException, JsonProcessingException         {             jgen.writeString(value.toString());         }     }       public static class QNameDeserializer extends StdDeserializer<QName>     {         public QNameDeserializer() { super(QName.class); }         @Override         public QName deserialize(JsonParser jp, DeserializationContext ctxt)                 throws IOException, JsonProcessingException         {             return QName.valueOf(jp.readValueAs(String.class));         }     }      public static class DummyBuilder extends StdTypeResolverBuilder     //<DummyBuilder>     {     }      @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS)     @JsonTypeResolver(DummyBuilder.class)     static class TypeResolverBean { }      // @since 1.7     @JsonIgnoreType     static class IgnoredType { }      static class IgnoredSubType extends IgnoredType { }      // Test to ensure we can override enum settings     static class LcEnumIntrospector extends JacksonAnnotationIntrospector     {         private static final long serialVersionUID = 1L;         @Override         public String findEnumValue(Enum<?> value)         {             return value.name().toLowerCase();         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */          /**      * tests getting serializer/deserializer instances.      */     public void testSerializeDeserializeWithJaxbAnnotations() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enable(SerializationFeature.INDENT_OUTPUT);         JacksonExample ex = new JacksonExample();         QName qname = new QName("urn:hi", "hello");         ex.setQname(qname);         ex.setAttributeProperty("attributeValue");         ex.setElementProperty("elementValue");         ex.setWrappedElementProperty(Arrays.asList("wrappedElementValue"));         ex.setEnumProperty(EnumExample.VALUE1);         StringWriter writer = new StringWriter();         mapper.writeValue(writer, ex);         writer.flush();         writer.close();          String json = writer.toString();         JacksonExample readEx = mapper.readValue(json, JacksonExample.class);          assertEquals(ex.qname, readEx.qname);         assertEquals(ex.attributeProperty, readEx.attributeProperty);         assertEquals(ex.elementProperty, readEx.elementProperty);         assertEquals(ex.wrappedElementProperty, readEx.wrappedElementProperty);         assertEquals(ex.enumProperty, readEx.enumProperty);     }      public void testJsonTypeResolver() throws Exception     {         JacksonAnnotationIntrospector ai = new JacksonAnnotationIntrospector();         AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(TypeResolverBean.class, ai, null);         JavaType baseType = TypeFactory.defaultInstance().constructType(TypeResolverBean.class);         ObjectMapper mapper = new ObjectMapper();         TypeResolverBuilder<?> rb = ai.findTypeResolver(mapper.getDeserializationConfig(), ac, baseType);         assertNotNull(rb);         assertSame(DummyBuilder.class, rb.getClass());     }          /**      * Tests to ensure that {@link JsonIgnoreType} is detected as expected      * by the standard introspector.      *       * @since 1.7      */     public void testIgnoredType() throws Exception     {         JacksonAnnotationIntrospector ai = new JacksonAnnotationIntrospector();         AnnotatedClass ac = AnnotatedClass.construct(IgnoredType.class, ai, null);         assertEquals(Boolean.TRUE, ai.isIgnorableType(ac));          // also, should inherit as expected         ac = AnnotatedClass.construct(IgnoredSubType.class, ai, null);         assertEquals(Boolean.TRUE, ai.isIgnorableType(ac));     }      public void testEnumHandling() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setAnnotationIntrospector(new LcEnumIntrospector());         assertEquals("\"value1\"", mapper.writeValueAsString(EnumExample.VALUE1));         EnumExample result = mapper.readValue(quote("value1"), EnumExample.class);         assertEquals(EnumExample.VALUE1, result);     } }
package com.fasterxml.jackson.databind.introspect;  import java.math.BigDecimal; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize;  public class TestPOJOPropertiesCollector     extends BaseMapTest {     static class Simple {         public int value;                  @JsonProperty("value")         public void valueSetter(int v) { value = v; }          @JsonProperty("value")         public int getFoobar() { return value; }     }      static class SimpleFieldDeser     {         @JsonDeserialize String[] values;     }          static class SimpleGetterVisibility {         public int getA() { return 0; }         protected int getB() { return 1; }         @SuppressWarnings("unused")         private int getC() { return 2; }     }          // Class for testing 'shared ignore'     static class Empty {         public int value;                  public void setValue(int v) { value = v; }          @JsonIgnore         public int getValue() { return value; }     }      static class IgnoredSetter {         @JsonProperty         public int value;                  @JsonIgnore         public void setValue(int v) { value = v; }          public int getValue() { return value; }     }      static class ImplicitIgnores {         @JsonIgnore public int a;         @JsonIgnore public void setB(int b) { }         public int c;     }          // Should find just one setter for "y", due to partial ignore     static class IgnoredRenamedSetter {         @JsonIgnore public void setY(int value) { }         @JsonProperty("y") void foobar(int value) { }     }          // should produce a single property, "x"     static class RenamedProperties {         @JsonProperty("x")         public int value;                  public void setValue(int v) { value = v; }          public int getX() { return value; }     }      static class RenamedProperties2     {         @JsonProperty("renamed")         public int getValue() { return 1; }         public void setValue(int x) { }     }          // Testing that we can "merge" properties with renaming     static class MergedProperties {         public int x;                  @JsonProperty("x")         public void setFoobar(int v) { x = v; }     }      // Testing that property order is obeyed, even for deserialization purposes     @JsonPropertyOrder({"a", "b", "c", "d"})     static class SortedProperties     {         public int b;         public int c;                  public void setD(int value) { }         public void setA(int value) { }     }      // [JACKSON-700]: test property type detection, selection     static class TypeTestBean     {         protected Long value;          @JsonCreator         public TypeTestBean(@JsonProperty("value") String value) { }          // If you remove this method, the test will pass         public Integer getValue() { return 0; }     }      static class Jackson703     {         private List<FoodOrgLocation> location = new ArrayList<FoodOrgLocation>();          {             location.add(new FoodOrgLocation());         }          public List<FoodOrgLocation> getLocation() { return location; }      }          static class FoodOrgLocation     {         protected Long id;         public String name;         protected Location location;          public FoodOrgLocation() {             location = new Location();         }          public FoodOrgLocation(final Location foodOrg) { }                          public FoodOrgLocation(final Long id, final String name, final Location location) { }          public Location getLocation() { return location; }     }      static class Location {         public BigDecimal lattitude;         public BigDecimal longitude;          public Location() { }          public Location(final BigDecimal lattitude, final BigDecimal longitude) { }     }      class Issue701Bean { // important: non-static!         private int i;          // annotation does not matter -- just need one on the last argument         public Issue701Bean(@JsonProperty int i) { this.i = i; }          public int getX() { return i; }     }      static class Issue744Bean     {         protected Map<String,Object> additionalProperties;                  @JsonAnySetter         public void addAdditionalProperty(String key, Object value) {             if (additionalProperties == null) additionalProperties = new HashMap<String, Object>();             additionalProperties.put(key,value);         }                  public void setAdditionalProperties(Map<String, Object> additionalProperties) {             this.additionalProperties = additionalProperties;         }          @JsonAnyGetter         public Map<String,Object> getAdditionalProperties() { return additionalProperties; }          @JsonIgnore         public String getName() {            return (String) additionalProperties.get("name");         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      private final ObjectMapper mapper = new ObjectMapper();          public void testSimple()     {         POJOPropertiesCollector coll = collector(mapper,         		Simple.class, true);         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         POJOPropertyBuilder prop = props.get("value");         assertNotNull(prop);         assertTrue(prop.hasSetter());         assertTrue(prop.hasGetter());         assertTrue(prop.hasField());     }      public void testSimpleFieldVisibility()     {         // false -> deserialization         POJOPropertiesCollector coll = collector(mapper,         		SimpleFieldDeser.class, false);         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         POJOPropertyBuilder prop = props.get("values");         assertNotNull(prop);         assertFalse(prop.hasSetter());         assertFalse(prop.hasGetter());         assertTrue(prop.hasField());     }      public void testSimpleGetterVisibility()     {         POJOPropertiesCollector coll = collector(mapper,         		SimpleGetterVisibility.class, true);         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         POJOPropertyBuilder prop = props.get("a");         assertNotNull(prop);         assertFalse(prop.hasSetter());         assertTrue(prop.hasGetter());         assertFalse(prop.hasField());     }          // Unit test for verifying that a single @JsonIgnore can remove the     // whole property, unless explicit property marker exists     public void testEmpty()     {         POJOPropertiesCollector coll = collector(mapper,         		Empty.class, true);         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(0, props.size());     }      // Unit test for verifying handling of 'partial' @JsonIgnore; that is,     // if there is at least one explicit annotation to indicate property,     // only parts that are ignored are, well, ignored     public void testPartialIgnore()     {         POJOPropertiesCollector coll = collector(mapper,         		IgnoredSetter.class, true);         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         POJOPropertyBuilder prop = props.get("value");         assertNotNull(prop);         assertFalse(prop.hasSetter());         assertTrue(prop.hasGetter());         assertTrue(prop.hasField());     }      public void testSimpleRenamed()     {         POJOPropertiesCollector coll = collector(mapper,         		RenamedProperties.class, true);         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         POJOPropertyBuilder prop = props.get("x");         assertNotNull(prop);         assertTrue(prop.hasSetter());         assertTrue(prop.hasGetter());         assertTrue(prop.hasField());     }      public void testSimpleRenamed2()     {         POJOPropertiesCollector coll = collector(mapper,         		RenamedProperties2.class, true);         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         POJOPropertyBuilder prop = props.get("renamed");         assertNotNull(prop);         assertTrue(prop.hasSetter());         assertTrue(prop.hasGetter());         assertFalse(prop.hasField());     }      public void testMergeWithRename()     {         POJOPropertiesCollector coll = collector(mapper,         		MergedProperties.class, true);         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         POJOPropertyBuilder prop = props.get("x");         assertNotNull(prop);         assertTrue(prop.hasSetter());         assertFalse(prop.hasGetter());         assertTrue(prop.hasField());     }          public void testSimpleIgnoreAndRename()     {         POJOPropertiesCollector coll = collector(mapper,         		IgnoredRenamedSetter.class, true);         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         POJOPropertyBuilder prop = props.get("y");         assertNotNull(prop);         assertTrue(prop.hasSetter());         assertFalse(prop.hasGetter());         assertFalse(prop.hasField());     }      public void testGlobalVisibilityForGetters()     {         ObjectMapper m = new ObjectMapper();         m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);         POJOPropertiesCollector coll = collector(m, SimpleGetterVisibility.class, true);         // should be 1, expect that we disabled getter auto-detection, so         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(0, props.size());     }      public void testCollectionOfIgnored()     {         POJOPropertiesCollector coll = collector(mapper, ImplicitIgnores.class, false);         // should be 1, due to ignorals         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();         assertEquals(1, props.size());         // but also have 2 ignored properties         Collection<String> ign = coll.getIgnoredPropertyNames();         assertEquals(2, ign.size());         assertTrue(ign.contains("a"));         assertTrue(ign.contains("b"));     }      public void testSimpleOrderingForDeserialization()     {         POJOPropertiesCollector coll = collector(mapper, SortedProperties.class, false);         List<BeanPropertyDefinition> props = coll.getProperties();         assertEquals(4, props.size());         assertEquals("a", props.get(0).getName());         assertEquals("b", props.get(1).getName());         assertEquals("c", props.get(2).getName());         assertEquals("d", props.get(3).getName());     }      public void testSimpleWithType()     {         // first for serialization; should base choice on getter         POJOPropertiesCollector coll = collector(mapper, TypeTestBean.class, true);         List<BeanPropertyDefinition> props = coll.getProperties();         assertEquals(1, props.size());         assertEquals("value", props.get(0).getName());         AnnotatedMember m = props.get(0).getAccessor();         assertTrue(m instanceof AnnotatedMethod);         assertEquals(Integer.class, m.getRawType());          // then for deserialization; prefer ctor param         coll = collector(mapper, TypeTestBean.class, false);         props = coll.getProperties();         assertEquals(1, props.size());         assertEquals("value", props.get(0).getName());         m = props.get(0).getMutator();         assertEquals(AnnotatedParameter.class, m.getClass());         assertEquals(String.class, m.getRawType());     }      // for [JACKSON-701]     public void testInnerClassWithAnnotationsInCreator() throws Exception     {         BasicBeanDescription beanDesc;         // first with serialization         beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Issue701Bean.class));         assertNotNull(beanDesc);         // then with deserialization         beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(Issue701Bean.class));         assertNotNull(beanDesc);     }      public void testJackson703() throws Exception     {     	// note: need a separate mapper, need to reconfigure         ObjectMapper mapper = new ObjectMapper();         mapper.configure(MapperFeature.USE_ANNOTATIONS, false);         BasicBeanDescription beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Jackson703.class));         assertNotNull(beanDesc);          Jackson703 bean = new Jackson703();         String json = mapper.writeValueAsString(bean);         assertNotNull(json);     }      public void testJackson744() throws Exception     {         BasicBeanDescription beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(Issue744Bean.class));         assertNotNull(beanDesc);         AnnotatedMethod setter = beanDesc.findAnySetter();         assertNotNull(setter);     }          /*     /**********************************************************     /* Helper methods     /**********************************************************      */      protected POJOPropertiesCollector collector(ObjectMapper mapper,             Class<?> cls, boolean forSerialization)     {         BasicClassIntrospector bci = new BasicClassIntrospector();         // no real difference between serialization, deserialization, at least here         if (forSerialization) {             return bci.collectProperties(mapper.getSerializationConfig(),                     mapper.constructType(cls), null, true, "set");         }         return bci.collectProperties(mapper.getDeserializationConfig(),                 mapper.constructType(cls), null, false, "set");     } } 
package com.fasterxml.jackson.databind.jsonschema;  import java.util.Collection; import java.util.Map;  import com.fasterxml.jackson.annotation.JsonFilter; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode; import com.fasterxml.jackson.databind.ser.FilterProvider; import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter; import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;  /**  * @author Ryan Heaton  */ @SuppressWarnings("deprecation") public class TestGenerateJsonSchema     extends com.fasterxml.jackson.databind.BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      public static class SimpleBean     {         private int property1;         private String property2;         private String[] property3;         private Collection<Float> property4;         @JsonProperty(required=true)         private String property5;                  public int getProperty1()         {             return property1;         }          public void setProperty1(int property1)         {             this.property1 = property1;         }          public String getProperty2()         {             return property2;         }          public void setProperty2(String property2)         {             this.property2 = property2;         }          public String[] getProperty3()         {             return property3;         }          public void setProperty3(String[] property3)         {             this.property3 = property3;         }          public Collection<Float> getProperty4()         {             return property4;         }          public void setProperty4(Collection<Float> property4)         {             this.property4 = property4;         }                  public String getProperty5()         {             return property5;         }          public void setProperty5(String property5)         {             this.property5 = property5;         }     }      public class TrivialBean {         public String name;     }      @JsonSerializableSchema(id="myType")     public class BeanWithId {         public String value;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          /**      * tests generating json-schema stuff.      */     public void testGeneratingJsonSchema()         throws Exception     {         JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);                  assertNotNull(jsonSchema);          // test basic equality, and that equals() handles null, other obs         assertTrue(jsonSchema.equals(jsonSchema));         assertFalse(jsonSchema.equals(null));         assertFalse(jsonSchema.equals("foo"));          // other basic things         assertNotNull(jsonSchema.toString());         assertNotNull(JsonSchema.getDefaultSchemaNode());  	ObjectNode root = jsonSchema.getSchemaNode();         assertEquals("object", root.get("type").asText());         assertEquals(false, root.path("required").booleanValue());         JsonNode propertiesSchema = root.get("properties");         assertNotNull(propertiesSchema);         JsonNode property1Schema = propertiesSchema.get("property1");         assertNotNull(property1Schema);         assertEquals("integer", property1Schema.get("type").asText());         assertEquals(false, property1Schema.path("required").booleanValue());         JsonNode property2Schema = propertiesSchema.get("property2");         assertNotNull(property2Schema);         assertEquals("string", property2Schema.get("type").asText());         assertEquals(false, property2Schema.path("required").booleanValue());         JsonNode property3Schema = propertiesSchema.get("property3");         assertNotNull(property3Schema);         assertEquals("array", property3Schema.get("type").asText());         assertEquals(false, property3Schema.path("required").booleanValue());         assertEquals("string", property3Schema.get("items").get("type").asText());         JsonNode property4Schema = propertiesSchema.get("property4");         assertNotNull(property4Schema);         assertEquals("array", property4Schema.get("type").asText());         assertEquals(false, property4Schema.path("required").booleanValue());         assertEquals("number", property4Schema.get("items").get("type").asText());     }          @JsonFilter("filteredBean")     protected static class FilteredBean {     	     	@JsonProperty     	private String secret = "secret";     	     	@JsonProperty     	private String obvious = "obvious";     	     	public String getSecret() { return secret; }     	public void setSecret(String s) { secret = s; }     	     	public String getObvious() { return obvious; }     	public void setObvious(String s) {obvious = s; }     }          public static FilterProvider secretFilterProvider = new SimpleFilterProvider()         .addFilter("filteredBean", SimpleBeanPropertyFilter.filterOutAllExcept(new String[]{"obvious"}));      public void testGeneratingJsonSchemaWithFilters() throws Exception {     	ObjectMapper mapper = new ObjectMapper();     	mapper.setFilters(secretFilterProvider);     	JsonSchema schema = mapper.generateJsonSchema(FilteredBean.class);     	JsonNode node = schema.getSchemaNode().get("properties");     	assertTrue(node.has("obvious"));     	assertFalse(node.has("secret"));     }      /**      * Additional unit test for verifying that schema object itself      * can be properly serialized      */     public void testSchemaSerialization()             throws Exception     {         JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); 	Map<String,Object> result = writeAndMap(MAPPER, jsonSchema); 	assertNotNull(result); 	// no need to check out full structure, just basics... 	assertEquals("object", result.get("type")); 	// only add 'required' if it is true... 	assertNull(result.get("required")); 	assertNotNull(result.get("properties"));     }      public void testInvalidCall()         throws Exception     {         // not ok to pass null         try {             MAPPER.generateJsonSchema(null);             fail("Should have failed");         } catch (IllegalArgumentException iae) {             verifyException(iae, "class must be provided");         }     }      /**      * Test for [JACKSON-454]      */     public void testThatObjectsHaveNoItems() throws Exception     {         JsonSchema jsonSchema = MAPPER.generateJsonSchema(TrivialBean.class);         String json = jsonSchema.toString().replaceAll("\"", "'");         // can we count on ordering being stable? I think this is true with current ObjectNode impl         // as perh [JACKSON-563]; 'required' is only included if true         assertEquals("{'type':'object','properties':{'name':{'type':'string'}}}",                 json);     }      public void testSchemaId() throws Exception     {         JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class);         String json = jsonSchema.toString().replaceAll("\"", "'");         assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}",                 json);     } } 
package com.fasterxml.jackson.databind.jsonschema;  import java.util.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.jsonschema.JsonSchema;  /**  * Trivial test to ensure {@link JsonSchema} can be also deserialized  */ @SuppressWarnings("deprecation") public class TestReadJsonSchema     extends com.fasterxml.jackson.databind.BaseMapTest {     enum SchemaEnum { YES, NO; }      static class Schemable {         public String name;         public char[] nameBuffer;          // We'll include tons of stuff, just to force generation of schema         public boolean[] states;         public byte[] binaryData;         public short[] shorts;         public int[] ints;         public long[] longs;          public float[] floats;         public double[] doubles;          public Object[] objects;         public JsonSerializable someSerializable;          public Iterable<Object> iterableOhYeahBaby;          public List<String> extra;         public ArrayList<String> extra2;         public Iterator<String[]> extra3;          public Map<String,Double> sizes;         public EnumMap<SchemaEnum,List<String>> whatever;          SchemaEnum testEnum;         public EnumSet<SchemaEnum> testEnums;     }      /**      * Verifies that a simple schema that is serialized can be      * deserialized back to equal schema instance      */     public void testDeserializeSimple() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         JsonSchema schema = mapper.generateJsonSchema(Schemable.class);         assertNotNull(schema);          String schemaStr = mapper.writeValueAsString(schema);         assertNotNull(schemaStr);         JsonSchema result = mapper.readValue(schemaStr, JsonSchema.class);         assertEquals("Trying to read from '"+schemaStr+"'", schema, result);     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.ArrayList; import java.util.List;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;  /**  * Unit tests for checking how combination of interfaces, implementation  * classes are handled, with respect to type names.  */ public class TestAbstractTypeNames  extends BaseMapTest {     @JsonTypeName("Employee")     public interface Employee extends User {         public abstract String getEmployer();     }      @JsonTypeInfo(use=Id.NAME, include=As.PROPERTY, property="userType")     @JsonTypeName("User")     @JsonSubTypes({ @JsonSubTypes.Type(value=Employee.class,name="Employee") })     public interface User {             public abstract String getName();             public abstract List<User> getFriends();     }      @JsonTypeName("Employee")     static class DefaultEmployee extends DefaultUser implements Employee     {         private String _employer;          @JsonCreator         public DefaultEmployee(@JsonProperty("name") String name,                 @JsonProperty("friends") List<User> friends,                 @JsonProperty("employer") String employer) {             super(name, friends);             _employer = employer;         }          @Override         public String getEmployer() {             return _employer;         }     }      @JsonTypeInfo(use=Id.NAME, include=As.PROPERTY, property="userType")     @JsonTypeName("User")     @JsonSubTypes({ @JsonSubTypes.Type(value=DefaultEmployee.class,name="Employee") })     static class DefaultUser implements User     {         private String _name;         private List<User> _friends;          @JsonCreator         public DefaultUser(@JsonProperty("name") String name,                 @JsonProperty("friends") List<User> friends)         {             super();             _name = name;             _friends = friends;         }          @Override         public String getName() {             return _name;         }          @Override         public List<User> getFriends() {             return _friends;         }     }      static class BaseValue {         public int value = 42;          public int getValue() { return value; }     }      final static class BeanWithAnon {         public BaseValue bean = new BaseValue() {             @Override             public String toString() { return "sub!"; }         };     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      // Testing [JACKSON-498], partial fix     public void testEmptyCollection() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.INDENT_OUTPUT, true);         List<User>friends = new ArrayList<User>();         friends.add(new DefaultUser("Joe Hildebrandt", null));         friends.add(new DefaultEmployee("Richard Nasr",null,"MDA"));          User user = new DefaultEmployee("John Vanspronssen", friends, "MDA");         String json = mapper.writeValueAsString(user);          /* 24-Feb-2011, tatu: For now let's simply require registration of          *   concrete subtypes; can't think of a way to avoid that for now          */         mapper = new ObjectMapper();         mapper.registerSubtypes(DefaultEmployee.class);         mapper.registerSubtypes(DefaultUser.class);                  User result = mapper.readValue(json, User.class);         assertNotNull(result);         assertEquals(DefaultEmployee.class, result.getClass());          friends = result.getFriends();         assertEquals(2, friends.size());         assertEquals(DefaultUser.class, friends.get(0).getClass());         assertEquals(DefaultEmployee.class, friends.get(1).getClass());     }          // [JACKSON-584]: change anonymous non-static inner type into static type:     public void testInnerClassWithType() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping(DefaultTyping.NON_FINAL);         String json = mapper.writeValueAsString(new BeanWithAnon());         BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class);         assertEquals(BeanWithAnon.class, result.getClass());     } } 
package com.fasterxml.jackson.databind.jsontype;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.*;  import java.util.*;  public class TestAbstractWithObjectId extends BaseMapTest {     interface BaseInterface { }      @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class, property = "@id")     static class BaseInterfaceImpl implements BaseInterface {          @JsonProperty         private List<BaseInterfaceImpl> myInstances = new ArrayList<BaseInterfaceImpl>();          void addInstance(BaseInterfaceImpl instance) {             myInstances.add(instance);         }     }      static class ListWrapper<T extends BaseInterface> {          @JsonProperty         private List<T> myList = new ArrayList<T>();          void add(T t) {             myList.add(t);         }          int size() {             return myList.size();         }     }      public void testIssue877() throws Exception     {         // make two instances         BaseInterfaceImpl one = new BaseInterfaceImpl();         BaseInterfaceImpl two = new BaseInterfaceImpl();          // add them to each other's list to show identify info being used         one.addInstance(two);         two.addInstance(one);          // make a typed version of the list and add the 2 instances to it         ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>();         myList.add(one);         myList.add(two);          // make an object mapper that will add class info in so deserialisation works         ObjectMapper om = new ObjectMapper();         om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class");          // write and print the JSON         String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList);         ListWrapper<BaseInterfaceImpl> result;                  result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { });          assertNotNull(result);         // see what we get back         System.out.println("deserialised list size = " + result.size());     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver; import com.fasterxml.jackson.databind.jsontype.TypeIdResolver; import com.fasterxml.jackson.databind.type.TypeFactory;  public class TestCustomTypeIdResolver extends BaseMapTest {     @JsonTypeInfo(use=Id.CUSTOM, include=As.WRAPPER_OBJECT)     @JsonTypeIdResolver(CustomResolver.class)     static class CustomBean {         public int x;                  public CustomBean() { }         public CustomBean(int x) { this.x = x; }     }          static class CustomResolver implements TypeIdResolver     {         static List<JavaType> initTypes;          public CustomResolver() { }                  @Override         public Id getMechanism() {             return Id.CUSTOM;         }          @Override         public String idFromValue(Object value)         {             if (value.getClass() == CustomBean.class) {                 return "*";             }             return "unknown";         }          @Override         public String idFromValueAndType(Object value, Class<?> type) {             return idFromValue(value);         }          @Override         public void init(JavaType baseType) {             if (initTypes != null) {                 initTypes.add(baseType);             }         }          @Override         public JavaType typeFromId(String id)         {             if ("*".equals(id)) {                 return TypeFactory.defaultInstance().constructType(CustomBean.class);             }             return null;         }          @Override         public String idFromBaseType() {             return "xxx";         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      // for [JACKSON-359]     public void testCustomTypeIdResolver() throws Exception     {         ObjectMapper m = new ObjectMapper();         List<JavaType> types = new ArrayList<JavaType>();         CustomResolver.initTypes = types;         String json = m.writeValueAsString(new CustomBean[] { new CustomBean(28) });         assertEquals("[{\"*\":{\"x\":28}}]", json);         assertEquals(1, types.size());         assertEquals(CustomBean.class, types.get(0).getRawClass());          types = new ArrayList<JavaType>();         CustomResolver.initTypes = types;         CustomBean[] result = m.readValue(json, CustomBean[].class);         assertNotNull(result);         assertEquals(1, result.length);         assertEquals(28, result[0].x);         assertEquals(1, types.size());         assertEquals(CustomBean.class, types.get(0).getRawClass());     } } 
package com.fasterxml.jackson.databind.jsontype;  import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;  public class TestDefaultForArrays extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      static class ArrayBean {         public Object[] values;          public ArrayBean() { this(null); }         public ArrayBean(Object[] v) { values = v; }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      /**      * Simple unit test for verifying that we get String array      * back, even though declared type is Object array      */     public void testArrayTypingSimple() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS);         ArrayBean bean = new ArrayBean(new String[0]);         String json = m.writeValueAsString(bean);         ArrayBean result = m.readValue(json, ArrayBean.class);         assertNotNull(result.values);         assertEquals(String[].class, result.values.getClass());     }      // And let's try it with deeper array as well     public void testArrayTypingNested() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS);         ArrayBean bean = new ArrayBean(new String[0][0]);         String json = m.writeValueAsString(bean);         ArrayBean result = m.readValue(json, ArrayBean.class);         assertNotNull(result.values);         assertEquals(String[][].class, result.values.getClass());     }      // @since 1.8     public void testNodeInArray() throws Exception     {         JsonNode node = new ObjectMapper().readTree("{\"a\":3}");          ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping(DefaultTyping.JAVA_LANG_OBJECT);         Object[] obs = new Object[] { node };         String json = m.writeValueAsString(obs);         Object[] result = m.readValue(json, Object[].class);         assertEquals(1, result.length);         Object ob = result[0];         assertTrue(ob instanceof JsonNode);     }      // test for [JACKSON-845]     public void testArraysOfArrays() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);          Object value = new Object[][] { new Object[] {} };         String json = mapper.writeValueAsString(value);          // try with different (but valid) nominal types:         _testArraysAs(mapper, json, Object[][].class);         _testArraysAs(mapper, json, Object[].class);         _testArraysAs(mapper, json, Object.class);     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */          protected void _testArraysAs(ObjectMapper mapper, String json, Class<?> type)         throws Exception     {         Object o = mapper.readValue(json, type);         assertNotNull(o);         assertTrue(o instanceof Object[]);         Object[] main = (Object[]) o;         assertEquals(1, main.length);         Object element = main[0];         assertNotNull(element);         assertTrue(element instanceof Object[]);         assertEquals(0, ((Object[]) element).length);     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.concurrent.TimeUnit;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestDefaultForEnums     extends BaseMapTest {     public enum TestEnum {         A, B;     }      static final class EnumHolder     {         public Object value; // "untyped"                  public EnumHolder() { }         public EnumHolder(TestEnum e) { value = e; }     }      protected static class TimeUnitBean {         public TimeUnit timeUnit;     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      public void testSimpleEnumBean() throws Exception     {         TimeUnitBean bean = new TimeUnitBean();         bean.timeUnit = TimeUnit.SECONDS;                  // First, without type info         ObjectMapper m = new ObjectMapper();         String json = m.writeValueAsString(bean);         TimeUnitBean result = m.readValue(json, TimeUnitBean.class);         assertEquals(TimeUnit.SECONDS, result.timeUnit);                  // then with type info         m = new ObjectMapper();         m.enableDefaultTyping();         json = m.writeValueAsString(bean);         result = m.readValue(json, TimeUnitBean.class);          assertEquals(TimeUnit.SECONDS, result.timeUnit);     }          public void testSimpleEnumsInObjectArray() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();                  // Typing is needed for enums         String json = m.writeValueAsString(new Object[] { TestEnum.A });         assertEquals("[[\"com.fasterxml.jackson.databind.jsontype.TestDefaultForEnums$TestEnum\",\"A\"]]", json);          // and let's verify we get it back ok as well:         Object[] value = m.readValue(json, Object[].class);         assertEquals(1, value.length);         assertSame(TestEnum.A, value[0]);     }      public void testSimpleEnumsAsField() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();         String json = m.writeValueAsString(new EnumHolder(TestEnum.B));         assertEquals("{\"value\":[\"com.fasterxml.jackson.databind.jsontype.TestDefaultForEnums$TestEnum\",\"B\"]}", json);         EnumHolder holder = m.readValue(json, EnumHolder.class);         assertSame(TestEnum.B, holder.value);     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;  public class TestDefaultForLists     extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      /**      * Wrapper bean needed before there is a way to force      * type of the root value. Long is used because it is a final      * type, but not one of "untypeable" ones.      */     static class ListOfLongs {         public List<Long> longs;          public ListOfLongs() { }         public ListOfLongs(Long ... ls) {             longs = new ArrayList<Long>();             for (Long l: ls) {                 longs.add(l);             }         }     }      static class ListOfNumbers {         public List<Number> nums;          public ListOfNumbers() { }         public ListOfNumbers(Number ... numbers) {             nums = new ArrayList<Number>();             for (Number n : numbers) {                 nums.add(n);             }         }     }      static class ObjectListBean {         public List<Object> values;     }      interface Foo { }      static class SetBean {         public Set<String> names;                  public SetBean() { }         public SetBean(String str) {             names = new HashSet<String>();             names.add(str);         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */          public void testListOfLongs() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();         ListOfLongs input = new ListOfLongs(1L, 2L, 3L);         String json = m.writeValueAsString(input);         assertEquals("{\"longs\":[\"java.util.ArrayList\",[1,2,3]]}", json);         ListOfLongs output = m.readValue(json, ListOfLongs.class);          assertNotNull(output.longs);         assertEquals(3, output.longs.size());         assertEquals(Long.valueOf(1L), output.longs.get(0));         assertEquals(Long.valueOf(2L), output.longs.get(1));         assertEquals(Long.valueOf(3L), output.longs.get(2));     }      /**      * Then bit more heterogenous list; also tests mixing of      * regular scalar types, and non-typed ones (int and double      * will never have type info added; other numbers will if      * necessary)      */     public void testListOfNumbers() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();         ListOfNumbers input = new ListOfNumbers(Long.valueOf(1L), Integer.valueOf(2), Double.valueOf(3.0));         String json = m.writeValueAsString(input);         assertEquals("{\"nums\":[\"java.util.ArrayList\",[[\"java.lang.Long\",1],2,3.0]]}", json);         ListOfNumbers output = m.readValue(json, ListOfNumbers.class);          assertNotNull(output.nums);         assertEquals(3, output.nums.size());         assertEquals(Long.valueOf(1L), output.nums.get(0));         assertEquals(Integer.valueOf(2), output.nums.get(1));         assertEquals(Double.valueOf(3.0), output.nums.get(2));     }      public void testDateTypes() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();         ObjectListBean input = new ObjectListBean();         List<Object> inputList = new ArrayList<Object>();         inputList.add(TimeZone.getTimeZone("EST"));         inputList.add(Locale.CHINESE);         input.values = inputList;         String json = m.writeValueAsString(input);                  ObjectListBean output = m.readValue(json, ObjectListBean.class);         List<Object> outputList = output.values;         assertEquals(2, outputList.size());         assertTrue(outputList.get(0) instanceof TimeZone);         assertTrue(outputList.get(1) instanceof Locale);     }          public void testJackson628() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping(DefaultTyping.NON_FINAL);         ArrayList<Foo> data = new ArrayList<Foo>();         String json = mapper.writeValueAsString(data);         List<?> output = mapper.readValue(json, List.class);         assertTrue(output.isEmpty());     }      public void testJackson667() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL,                 JsonTypeInfo.As.PROPERTY);         String json = mapper.writeValueAsString(new SetBean("abc"));         SetBean bean = mapper.readValue(json, SetBean.class);         assertNotNull(bean);         assertTrue(bean.names instanceof HashSet);     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder; import com.fasterxml.jackson.databind.jsontype.impl.TypeNameIdResolver; import com.fasterxml.jackson.databind.type.TypeFactory;  public class TestDefaultForMaps      extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      static class MapKey {         public String key;          public MapKey(String k) { key = k; }          @Override public String toString() { return key; }     }      static class MapKeyDeserializer extends KeyDeserializer     {         @Override         public Object deserializeKey(String key, DeserializationContext ctxt) {             return new MapKey(key);         }     }          static class MapHolder     {         @JsonDeserialize(keyAs=MapKey.class, keyUsing=MapKeyDeserializer.class)         public Map<MapKey,List<Object>> map;     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */          public void testJackson428() throws Exception     {         ObjectMapper serMapper = new ObjectMapper();          TypeResolverBuilder<?> serializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL);         serializerTyper = serializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(true));         serializerTyper = serializerTyper.inclusion(JsonTypeInfo.As.PROPERTY);         serMapper.setDefaultTyping(serializerTyper);          // Let's start by constructing something to serialize first         MapHolder holder = new MapHolder();         holder.map = new HashMap<MapKey,List<Object>>();         List<Object> ints = new ArrayList<Object>();         ints.add(Integer.valueOf(3));         holder.map.put(new MapKey("key"), ints);         String json = serMapper.writeValueAsString(holder);          // Then deserialize: need separate mapper to initialize type id resolver appropriately         ObjectMapper deserMapper = new ObjectMapper();         TypeResolverBuilder<?> deserializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL);         deserializerTyper = deserializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(false));         deserializerTyper = deserializerTyper.inclusion(JsonTypeInfo.As.PROPERTY);         deserMapper.setDefaultTyping(deserializerTyper);          MapHolder result = deserMapper.readValue(json, MapHolder.class);         assertNotNull(result);         Map<?,?> map = result.map;         assertEquals(1, map.size());         Map.Entry<?,?> entry = map.entrySet().iterator().next();         Object key = entry.getKey();         assertEquals(MapKey.class, key.getClass());         Object value = entry.getValue();         assertTrue(value instanceof List<?>);         List<?> list = (List<?>) value;         assertEquals(1, list.size());         assertEquals(Integer.class, list.get(0).getClass());         assertEquals(Integer.valueOf(3), list.get(0));     }      protected TypeNameIdResolver createTypeNameIdResolver(boolean forSerialization)     {         Collection<NamedType> subtypes = new ArrayList<NamedType>();         subtypes.add(new NamedType(MapHolder.class, "mapHolder"));         subtypes.add(new NamedType(ArrayList.class, "AList"));         subtypes.add(new NamedType(HashMap.class, "HMap"));         ObjectMapper mapper = new ObjectMapper();         return TypeNameIdResolver.construct(mapper.getDeserializationConfig(),                 TypeFactory.defaultInstance().constructType(Object.class), subtypes, forSerialization, !forSerialization);     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.util.TokenBuffer;  public class TestDefaultForObject     extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      static abstract class AbstractBean { }          static class StringBean extends AbstractBean { // ha, punny!         public String name;          public StringBean() { this(null); }         protected StringBean(String n)  { name = n; }     }      enum Choice { YES, NO; }      /**      * Another enum type, but this time forcing sub-classing      */     enum ComplexChoice {     	MAYBE(true), PROBABLY_NOT(false);      	private boolean state;     	     	private ComplexChoice(boolean b) { state = b; }     	         @Override     	public String toString() { return String.valueOf(state); }     }      // [JACKSON-311]     static class PolymorphicType {         public String foo;         public Object bar;                  public PolymorphicType() { }         public PolymorphicType(String foo, int bar) {             this.foo = foo;             this.bar = bar;         }     }      final static class BeanHolder     {         public AbstractBean bean;                  public BeanHolder() { }         public BeanHolder(AbstractBean b) { bean = b; }     }      final static class ObjectHolder     {         public Object value;          public ObjectHolder() { }         public ObjectHolder(Object v) { value = v; }     }      // [JACKSON-352]     static class DomainBean {         public int weight;     }      static class DiscussBean extends DomainBean {         public String subject;     }      static public class DomainBeanWrapper {         public String name;         public Object myBean;     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      /**      * Unit test that verifies that a bean is stored with type information,      * when declared type is <code>Object.class</code> (since it is within      * Object[]), and default type information is enabled.      */     public void testBeanAsObject() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();         // note: need to wrap, to get declared as Object         String str = m.writeValueAsString(new Object[] { new StringBean("abc") });          _verifySerializationAsMap(str);                  // Ok: serialization seems to work as expected. Now deserialize:         Object ob = m.readValue(str, Object[].class);         assertNotNull(ob);         Object[] result = (Object[]) ob;         assertNotNull(result[0]);         assertEquals(StringBean.class, result[0].getClass());         assertEquals("abc", ((StringBean) result[0]).name);     }      /**      * Unit test that verifies that an abstract bean is stored with type information      * if default type information is enabled for non-concrete types.      */     public void testAbstractBean() throws Exception     {         // First, let's verify that we'd fail without enabling default type info         ObjectMapper m = new ObjectMapper();         AbstractBean[] input = new AbstractBean[] { new StringBean("xyz") };         String serial = m.writeValueAsString(input);         try {             m.readValue(serial, AbstractBean[].class);             fail("Should have failed");         } catch (JsonMappingException e) {             // let's use whatever is currently thrown exception... may change tho             verifyException(e, "can not construct");         }                  // and then that we will succeed with default type info         m = new ObjectMapper();         m.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);         serial = m.writeValueAsString(input);         AbstractBean[] beans = m.readValue(serial, AbstractBean[].class);         assertEquals(1, beans.length);         assertEquals(StringBean.class, beans[0].getClass());         assertEquals("xyz", ((StringBean) beans[0]).name);     }      /**      * Unit test to verify that type information is included for      * all non-final types, if default typing suitably configured      */     public void testNonFinalBean() throws Exception     {         ObjectMapper m = new ObjectMapper();         // first: use "object or abstract" typing: should produce no type info:                 m.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);         StringBean bean = new StringBean("x");         assertEquals("{\"name\":\"x\"}", m.writeValueAsString(bean));         // then non-final, and voila:         m = new ObjectMapper();         m.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);         assertEquals("[\""+StringBean.class.getName()+"\",{\"name\":\"x\"}]",             m.writeValueAsString(bean));     }      public void testNullValue() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);         BeanHolder h = new BeanHolder();         String json = m.writeValueAsString(h);         assertNotNull(json);         BeanHolder result = m.readValue(json, BeanHolder.class);         assertNotNull(result);         assertNull(result.bean);     }          public void testEnumAsObject() throws Exception     {         // wrapping to be declared as object         Object[] input = new Object[] { Choice.YES };         Object[] input2 = new Object[] { ComplexChoice.MAYBE};         // first, without type info:         assertEquals("[\"YES\"]", serializeAsString(input));         assertEquals("[\"MAYBE\"]", serializeAsString(input2));          // and then with it         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();          String json = m.writeValueAsString(input);         assertEquals("[[\""+Choice.class.getName()+"\",\"YES\"]]", json);          // which we should get back same way         Object[] output = m.readValue(json, Object[].class);         assertEquals(1, output.length);         assertEquals(Choice.YES, output[0]);          // ditto for more complicated enum         json = m.writeValueAsString(input2);         assertEquals("[[\""+ComplexChoice.class.getName()+"\",\"MAYBE\"]]", json);         output = m.readValue(json, Object[].class);         assertEquals(1, output.length);         assertEquals(ComplexChoice.MAYBE, output[0]);     }      @SuppressWarnings("unchecked")     public void testEnumSet() throws Exception     {         EnumSet<Choice> set = EnumSet.of(Choice.NO);         Object[] input = new Object[] { set };         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();         String json = m.writeValueAsString(input);         Object[] output = m.readValue(json, Object[].class);         assertEquals(1, output.length);         Object ob = output[0];         assertTrue(ob instanceof EnumSet<?>);         EnumSet<Choice> set2 = (EnumSet<Choice>) ob;         assertEquals(1, set2.size());         assertTrue(set2.contains(Choice.NO));         assertFalse(set2.contains(Choice.YES));     }      @SuppressWarnings("unchecked")     public void testEnumMap() throws Exception     {         EnumMap<Choice,String> map = new EnumMap<Choice,String>(Choice.class);         map.put(Choice.NO, "maybe");         Object[] input = new Object[] { map };         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();         String json = m.writeValueAsString(input);         Object[] output = m.readValue(json, Object[].class);         assertEquals(1, output.length);         Object ob = output[0];         assertTrue(ob instanceof EnumMap<?,?>);         EnumMap<Choice,String> map2 = (EnumMap<Choice,String>) ob;         assertEquals(1, map2.size());         assertEquals("maybe", map2.get(Choice.NO));         assertNull(map2.get(Choice.YES));     }      public void testJackson311() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);         String json = mapper.writeValueAsString(new PolymorphicType("hello", 2));         PolymorphicType value = mapper.readValue(json, PolymorphicType.class);         assertEquals("hello", value.foo);         assertEquals(Integer.valueOf(2), value.bar);     }      // Also, let's ensure TokenBuffer gets properly handled     public void testTokenBuffer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);          // Ok, first test JSON Object containing buffer:         TokenBuffer buf = new TokenBuffer(mapper);         buf.writeStartObject();         buf.writeNumberField("num", 42);         buf.writeEndObject();         String json = mapper.writeValueAsString(new ObjectHolder(buf));         ObjectHolder holder = mapper.readValue(json, ObjectHolder.class);         assertNotNull(holder.value);         assertSame(TokenBuffer.class, holder.value.getClass());         JsonParser jp = ((TokenBuffer) holder.value).asParser();         assertToken(JsonToken.START_OBJECT, jp.nextToken());         assertToken(JsonToken.FIELD_NAME, jp.nextToken());         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertToken(JsonToken.END_OBJECT, jp.nextToken());         assertNull(jp.nextToken());         jp.close();          // then as an array:         buf = new TokenBuffer(mapper);         buf.writeStartArray();         buf.writeBoolean(true);         buf.writeEndArray();         json = mapper.writeValueAsString(new ObjectHolder(buf));         holder = mapper.readValue(json, ObjectHolder.class);         assertNotNull(holder.value);         assertSame(TokenBuffer.class, holder.value.getClass());         jp = ((TokenBuffer) holder.value).asParser();         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.VALUE_TRUE, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertNull(jp.nextToken());         jp.close();          // and finally as scalar         buf = new TokenBuffer(mapper);         buf.writeNumber(321);         json = mapper.writeValueAsString(new ObjectHolder(buf));         holder = mapper.readValue(json, ObjectHolder.class);         assertNotNull(holder.value);         assertSame(TokenBuffer.class, holder.value.getClass());         jp = ((TokenBuffer) holder.value).asParser();         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertEquals(321, jp.getIntValue());         assertNull(jp.nextToken());         jp.close();     }      /**      * Test for [JACKSON-352]      */     public void testIssue352() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping (ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY);         DiscussBean d1 = new DiscussBean();         d1.subject = "mouse";         d1.weight=88;         DomainBeanWrapper wrapper = new DomainBeanWrapper();         wrapper.name = "mickey";         wrapper.myBean = d1;         String json = mapper.writeValueAsString(wrapper);         DomainBeanWrapper result = mapper.readValue(json, DomainBeanWrapper.class);         assertNotNull(result);         assertNotNull(wrapper.myBean);         assertSame(DiscussBean.class, wrapper.myBean.getClass());     }          // Test to ensure we can also use "As.PROPERTY" inclusion and custom property name     public void testFeature432() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, "*CLASS*");         String json = mapper.writeValueAsString(new BeanHolder(new StringBean("punny")));         assertEquals("{\"bean\":{\"*CLASS*\":\"com.fasterxml.jackson.databind.jsontype.TestDefaultForObject$StringBean\",\"name\":\"punny\"}}", json);     }          /*     /**********************************************************     /* Helper methods     /**********************************************************      */          @SuppressWarnings("unchecked")     private void _verifySerializationAsMap(String str) throws Exception     {         // First: validate that structure looks correct (as Map etc)         // note: should look something like:         // "[["org.codehaus.jackson.map.jsontype.TestDefaultForObject$StringBean",{"name":"abc"}]]")          // note: must have default mapper, default typer NOT enabled (to get 'plain' map)         ObjectMapper m = new ObjectMapper();         List<Object> list = m.readValue(str, List.class);         assertEquals(1, list.size()); // no type for main List, just single entry         Object entryOb = list.get(0);         assertTrue(entryOb instanceof List<?>);         // but then type wrapper for bean         List<?> entryList = (List<?>)entryOb;         assertEquals(2, entryList.size());         assertEquals(StringBean.class.getName(), entryList.get(0));         assertTrue(entryList.get(1) instanceof Map);         Map<?,?> map = (Map<?,?>) entryList.get(1);         assertEquals(1, map.size());         assertEquals("abc", map.get("name"));     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import static org.junit.Assert.*;   import com.fasterxml.jackson.databind.*;  /**  * Unit tests to verify that Java/JSON scalar values (non-structured values)  * are handled properly with respect to additional type information.  *   * @since 1.5  * @author tatu  */ public class TestDefaultForScalars     extends BaseMapTest {     static class Jackson417Bean {         public String foo = "bar";         public java.io.Serializable bar = new Integer(13);     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */          /**      * Unit test to verify that limited number of core types do NOT include      * type information, even if declared as Object. This is only done for types      * that JSON scalar values natively map to: String, Integer and Boolean (and      * nulls never have type information)      */     public void testNumericScalars() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();          // no typing for Integer, Double, yes for others         assertEquals("[123]", m.writeValueAsString(new Object[] { Integer.valueOf(123) }));         assertEquals("[[\"java.lang.Long\",37]]", m.writeValueAsString(new Object[] { Long.valueOf(37) }));         assertEquals("[0.25]", m.writeValueAsString(new Object[] { Double.valueOf(0.25) }));         assertEquals("[[\"java.lang.Float\",0.5]]", m.writeValueAsString(new Object[] { Float.valueOf(0.5f) }));     }      public void testDateScalars() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();          long ts = 12345678L;         assertEquals("[[\"java.util.Date\","+ts+"]]",                 m.writeValueAsString(new Object[] { new Date(ts) }));          // Calendar is trickier... hmmh. Need to ensure round-tripping         Calendar c = Calendar.getInstance();         c.setTimeInMillis(ts);         String json = m.writeValueAsString(new Object[] { c });         assertEquals("[[\""+c.getClass().getName()+"\","+ts+"]]", json);         // and let's make sure it also comes back same way:         Object[] result = m.readValue(json, Object[].class);         assertEquals(1, result.length);         assertTrue(result[0] instanceof Calendar);         assertEquals(ts, ((Calendar) result[0]).getTimeInMillis());     }      public void testMiscScalars() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();          // no typing for Strings, booleans         assertEquals("[\"abc\"]", m.writeValueAsString(new Object[] { "abc" }));         assertEquals("[true,null,false]", m.writeValueAsString(new Boolean[] { true, null, false }));     }      /**      * Test for verifying that contents of "untyped" homogenous arrays are properly      * handled,      */     public void testScalarArrays() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);         Object[] input = new Object[] {                 "abc", new Date(1234567), null, Integer.valueOf(456)         };         String json = m.writeValueAsString(input);         assertEquals("[\"abc\",[\"java.util.Date\",1234567],null,456]", json);          // and should deserialize back as well:         Object[] output = m.readValue(json, Object[].class);         assertArrayEquals(input, output);     }      /**      * Loosely scalar; for [JACKSON-417]      */     public void test417() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.enableDefaultTyping();         Jackson417Bean input = new Jackson417Bean();         String json = m.writeValueAsString(input);         Jackson417Bean result = m.readValue(json, Jackson417Bean.class);         assertEquals(input.foo, result.foo);         assertEquals(input.bar, result.bar);     } } 
package com.fasterxml.jackson.databind.jsontype;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestDefaultWithCreators     extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      static abstract class Job     {         public long id;     }      static class UrlJob extends Job     {         private final String url;         private final int count;                  @JsonCreator         public UrlJob(@JsonProperty("id") long id, @JsonProperty("url") String url,                 @JsonProperty("count") int count)         {             this.id = id;             this.url = url;             this.count = count;         }          public String getUrl() { return url; }         public int getCount() { return count; }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testWithCreators() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);         UrlJob input = new UrlJob(123L, "http://foo", 3);         String json = mapper.writeValueAsString(input);         assertNotNull(json);         Job output = mapper.readValue(json, Job.class);         assertNotNull(output);         assertSame(UrlJob.class, output.getClass());         UrlJob o2 = (UrlJob) output;         assertEquals(123L, o2.id);         assertEquals("http://foo", o2.getUrl());         assertEquals(3, o2.getCount());     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  @SuppressWarnings("serial") public class TestEnumTyping extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      // note: As.WRAPPER_ARRAY worked initially; but as per [JACKSON-485], As.PROPERTY had issues     @JsonTypeInfo(use=JsonTypeInfo.Id.MINIMAL_CLASS, include=JsonTypeInfo.As.PROPERTY)     public interface EnumInterface { }      public enum Tag implements EnumInterface     { A, B };          static class EnumInterfaceWrapper {         public EnumInterface value;     }          static class EnumInterfaceList extends ArrayList<EnumInterface> { }      static class TagList extends ArrayList<Tag> { }      static enum TestEnum { A, B, C; }          static class UntypedEnumBean     {        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="__type")         public Object value;          public UntypedEnumBean() { }         public UntypedEnumBean(TestEnum v) { value = v; }          @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="__type")         public void setValue(Object o) {             value = o;         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testTagList() throws Exception     {         ObjectMapper m = new ObjectMapper();         TagList list = new TagList();         list.add(Tag.A);         list.add(Tag.B);         String json = m.writeValueAsString(list);          TagList result = m.readValue(json, TagList.class);         assertEquals(2, result.size());         assertSame(Tag.A, result.get(0));         assertSame(Tag.B, result.get(1));     }      public void testEnumInterface() throws Exception     {         ObjectMapper m = new ObjectMapper();         String json = m.writeValueAsString(Tag.B);                  EnumInterface result = m.readValue(json, EnumInterface.class);         assertSame(Tag.B, result);     }      public void testEnumInterfaceList() throws Exception     {         ObjectMapper m = new ObjectMapper();         EnumInterfaceList list = new EnumInterfaceList();         list.add(Tag.A);         list.add(Tag.B);         String json = m.writeValueAsString(list);                  EnumInterfaceList result = m.readValue(json, EnumInterfaceList.class);         assertEquals(2, result.size());         assertSame(Tag.A, result.get(0));         assertSame(Tag.B, result.get(1));     }      public void testUntypedEnum() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String str = mapper.writeValueAsString(new UntypedEnumBean(TestEnum.B));         UntypedEnumBean result = mapper.readValue(str, UntypedEnumBean.class);         assertNotNull(result);         assertNotNull(result.value);         Object ob = result.value;         assertSame(TestEnum.class, ob.getClass());         assertEquals(TestEnum.B, result.value);     }      } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.Date;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  // Tests for [JACKSON-453] public class TestExternalId extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */          static class ExternalBean     {         @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property="extType")         public Object bean;          public ExternalBean() { }         public ExternalBean(int v) {             bean = new ValueBean(v);         }     }      // for [Issue#96]     static class ExternalBeanWithDefault     {         @JsonTypeInfo(use=Id.CLASS, include=As.EXTERNAL_PROPERTY, property="extType",                 defaultImpl=ValueBean.class)         public Object bean;          public ExternalBeanWithDefault() { }         public ExternalBeanWithDefault(int v) {             bean = new ValueBean(v);         }     }      static class ExternalBean3     {         @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property="extType1")         public Object value1;                  @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property="extType2")         public Object value2;          public int foo;                  @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property="extType3")         public Object value3;                  public ExternalBean3() { }         public ExternalBean3(int v) {             value1 = new ValueBean(v);             value2 = new ValueBean(v+1);             value3 = new ValueBean(v+2);             foo = v;         }     }      static class ExternalBeanWithCreator     {         @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property="extType")         public Object value;          public int foo;                  @JsonCreator         public ExternalBeanWithCreator(@JsonProperty("foo") int f)         {             foo = f;             value = new ValueBean(f);         }     }          @JsonTypeName("vbean")     static class ValueBean {         public int value;                  public ValueBean() { }         public ValueBean(int v) { value = v; }     }      @JsonTypeName("funk")     @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property="extType")     static class FunkyExternalBean {         public int i = 3;     }      // [JACKSON-798]: problems with polymorphic types, external prop      @JsonSubTypes(value= { @JsonSubTypes.Type(value=Derived1.class, name="d1"),             @JsonSubTypes.Type(value=Derived2.class, name="d2") })     interface Base {         String getBaseProperty();     }        static class Derived1 implements Base {         private String derived1Property;         private String baseProperty;         protected  Derived1() { throw new IllegalStateException("wrong constructor called"); }                  @JsonCreator         public Derived1(@JsonProperty("derived1Property") String d1p,                         @JsonProperty("baseProperty") String bp) {             derived1Property = d1p;             baseProperty = bp;         }          @Override         @JsonProperty public String getBaseProperty() {             return baseProperty;         }          @JsonProperty public String getDerived1Property() {             return derived1Property;         }     }      static class Derived2 implements Base {         private String derived2Property;         private String baseProperty;         protected  Derived2() { throw new IllegalStateException("wrong constructor called"); }          @JsonCreator         public Derived2(@JsonProperty("derived2Property") String d2p,                         @JsonProperty("baseProperty") String bp) {             derived2Property = d2p;             baseProperty = bp;         }          @Override         @JsonProperty public String getBaseProperty() {             return baseProperty;         }          @JsonProperty public String getDerived2Property() {             return derived2Property;         }     }          static class BaseContainer {         protected final Base base;         protected final String baseContainerProperty;         protected BaseContainer() { throw new IllegalStateException("wrong constructor called"); }          @JsonCreator         public BaseContainer(@JsonProperty("baseContainerProperty") String bcp, @JsonProperty("base") Base b) {             baseContainerProperty = bcp;             base = b;         }          @JsonProperty         public String getBaseContainerProperty() { return baseContainerProperty; }          @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY, property="type")         @JsonProperty         public Base getBase() { return base; }     }      // [JACKSON-831]: should allow a property to map id to as well          interface Pet {}      static class Dog implements Pet {         public String name;     }      static class House831 {         protected String petType;          @JsonTypeInfo(use = Id.NAME, include = As.EXTERNAL_PROPERTY, property = "petType")         @JsonSubTypes({@JsonSubTypes.Type(name = "dog", value = Dog.class)})         public Pet pet;          public String getPetType() {             return petType;         }          public void setPetType(String petType) {             this.petType = petType;         }     }          // for [Issue#118]     static class ExternalTypeWithNonPOJO {         @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,                 property = "type",                 visible = true,                 include = JsonTypeInfo.As.EXTERNAL_PROPERTY,                 defaultImpl = String.class)         @JsonSubTypes({             @JsonSubTypes.Type(value = Date.class, name = "date"),             @JsonSubTypes.Type(value = AsValueThingy.class, name = "thingy")         })         public Object value;          public ExternalTypeWithNonPOJO() { }         public ExternalTypeWithNonPOJO(Object o) { value = o; }     }          // for [Issue#119]     static class AsValueThingy {         public long rawDate;          public AsValueThingy(long l) { rawDate = l; }         public AsValueThingy() { }                  @JsonValue public Date serialization() {             return new Date(rawDate);         }     }          /*     /**********************************************************     /* Unit tests, serialization     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testSimpleSerialization() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerSubtypes(ValueBean.class);         // This may look odd, but one implementation nastiness is the fact         // that we can not properly serialize type id before the object,         // because call is made after property name (for object) has already         // been written out. So we'll write it after...         // Deserializer will work either way as it can not rely on ordering         // anyway.         assertEquals("{\"bean\":{\"value\":11},\"extType\":\"vbean\"}",                 mapper.writeValueAsString(new ExternalBean(11)));     }      // If trying to use with Class, should just become "PROPERTY" instead:     public void testImproperExternalIdSerialization() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         assertEquals("{\"extType\":\"funk\",\"i\":3}",                 mapper.writeValueAsString(new FunkyExternalBean()));     }      /*     /**********************************************************     /* Unit tests, deserialization     /**********************************************************      */          public void testSimpleDeserialization() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerSubtypes(ValueBean.class);         ExternalBean result = mapper.readValue("{\"bean\":{\"value\":11},\"extType\":\"vbean\"}", ExternalBean.class);         assertNotNull(result);         assertNotNull(result.bean);         ValueBean vb = (ValueBean) result.bean;         assertEquals(11, vb.value);     }      // Test for verifying that it's ok to have multiple (say, 3)     // externally typed things, mixed with other stuff...     public void testMultipleTypeIdsDeserialization() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerSubtypes(ValueBean.class);         String json = mapper.writeValueAsString(new ExternalBean3(3));         ExternalBean3 result = mapper.readValue(json, ExternalBean3.class);         assertNotNull(result);         assertNotNull(result.value1);         assertNotNull(result.value2);         assertNotNull(result.value3);         assertEquals(3, ((ValueBean)result.value1).value);         assertEquals(4, ((ValueBean)result.value2).value);         assertEquals(5, ((ValueBean)result.value3).value);         assertEquals(3, result.foo);     }      // Also, it should be ok to use @JsonCreator as well...     public void testExternalTypeWithCreator() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerSubtypes(ValueBean.class);         String json = mapper.writeValueAsString(new ExternalBeanWithCreator(7));         ExternalBeanWithCreator result = mapper.readValue(json, ExternalBeanWithCreator.class);         assertNotNull(result);         assertNotNull(result.value);         assertEquals(7, ((ValueBean)result.value).value);         assertEquals(7, result.foo);     }          // If trying to use with Class, should just become "PROPERTY" instead:     public void testImproperExternalIdDeserialization() throws Exception     {         FunkyExternalBean result = MAPPER.readValue("{\"extType\":\"funk\",\"i\":3}",                 FunkyExternalBean.class);         assertNotNull(result);         assertEquals(3, result.i);     }      public void testIssue798() throws Exception     {         Base base = new Derived1("derived1 prop val", "base prop val");         BaseContainer baseContainer = new BaseContainer("bc prop val", base);         String generatedJson = MAPPER.writeValueAsString(baseContainer);         BaseContainer baseContainer2 = MAPPER.readValue(generatedJson,BaseContainer.class);         assertEquals("bc prop val", baseContainer.getBaseContainerProperty());          Base b = baseContainer2.getBase();         assertNotNull(b);         if (b.getClass() != Derived1.class) {             fail("Should have type Derived1, was "+b.getClass().getName());         }          Derived1 derived1 = (Derived1) b;         assertEquals("base prop val", derived1.getBaseProperty());         assertEquals("derived1 prop val", derived1.getDerived1Property());     }      // There seems to be some problems if type is also visible...     public void testIssue831() throws Exception     {         final String JSON = "{ \"petType\": \"dog\",\n"                 +"\"pet\": { \"name\": \"Pluto\" }\n}";         House831 result = MAPPER.readValue(JSON, House831.class);         assertNotNull(result);         assertNotNull(result.pet);         assertSame(Dog.class, result.pet.getClass());         assertEquals("dog", result.petType);     }      // For [Issue#96]: should allow use of default impl, if property missing     /* 18-Jan-2013, tatu: Unfortunately this collides with [Issue#118], and I don't      *   know what the best resolution is. For now at least       */     /*     public void testWithDefaultAndMissing() throws Exception     {         ExternalBeanWithDefault input = new ExternalBeanWithDefault(13);         // baseline: include type, verify things work:         String fullJson = MAPPER.writeValueAsString(input);         ExternalBeanWithDefault output = MAPPER.readValue(fullJson, ExternalBeanWithDefault.class);         assertNotNull(output);         assertNotNull(output.bean);         // and then try without type info...         ExternalBeanWithDefault defaulted = MAPPER.readValue("{\"bean\":{\"value\":13}}",                 ExternalBeanWithDefault.class);         assertNotNull(defaulted);         assertNotNull(defaulted.bean);         assertSame(ValueBean.class, defaulted.bean.getClass());     }     */      // For [Issue#118]     // Note: String works fine, since no type id will used; other scalar types have issues     public void testWithScalar118() throws Exception     {         ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new java.util.Date(123L));         String json = MAPPER.writeValueAsString(input);         assertNotNull(json);          // and back just to be sure:         ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);         assertNotNull(result.value);         assertTrue(result.value instanceof java.util.Date);     }      // For [Issue#118] using "natural" type(s)     public void testWithNaturalScalar118() throws Exception     {         ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13));         String json = MAPPER.writeValueAsString(input);         assertNotNull(json);         // and back just to be sure:         ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);         assertNotNull(result.value);         assertTrue(result.value instanceof Integer);          // ditto with others types         input = new ExternalTypeWithNonPOJO(Boolean.TRUE);         json = MAPPER.writeValueAsString(input);         assertNotNull(json);         result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);         assertNotNull(result.value);         assertTrue(result.value instanceof Boolean);          input = new ExternalTypeWithNonPOJO("foobar");         json = MAPPER.writeValueAsString(input);         assertNotNull(json);         result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);         assertNotNull(result.value);         assertTrue(result.value instanceof String);         assertEquals("foobar", result.value);     }          // For [Issue#119]... and bit of [#167] as well     public void testWithAsValue() throws Exception     {         ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));         String json = MAPPER.writeValueAsString(input);         assertNotNull(json);         assertEquals("{\"value\":12345,\"type\":\"date\"}", json);          // and get it back too:         ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);         assertNotNull(result);         assertNotNull(result.value);         /* 13-Feb-2013, tatu: Urgh. I don't think this can work quite as intended...          *   since POJO type, and type of thing @JsonValue annotated method returns          *   are not related. Best we can do is thus this:          */         /*         assertEquals(AsValueThingy.class, result.value.getClass());         assertEquals(12345L, ((AsValueThingy) result.value).rawDate);         */         assertEquals(Date.class, result.value.getClass());         assertEquals(12345L, ((Date) result.value).getTime());     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.ArrayList; import java.util.List;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.core.type.TypeReference;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.type.TypeFactory;  public class TestGenericListSerialization     extends BaseMapTest {     // [JACKSON-356]     public static class JSONResponse<T> {          private T result;          public T getResult() {             return result;         }          public void setResult(T result) {             this.result = result;         }     }       @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")     public static class Parent {         public String parentContent = "PARENT";     }      public static class Child1 extends Parent {         public String childContent1 = "CHILD1";     }      public static class Child2 extends Parent {         public String childContent2 = "CHILD2";     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testSubTypesFor356() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         /* 06-Sep-2010, tatus: This was not fixed for 1.6; and to keep junit test          *   suite green, let's not run it for versions prior to 1.7...          */         Version v = mapper.version();         if (v.getMajorVersion() == 1 && v.getMinorVersion() == 6) {             System.err.println("Note: skipping test for Jackson 1.6");             return;         }                  JSONResponse<List<Parent>> input = new JSONResponse<List<Parent>>();          List<Parent> embedded = new ArrayList<Parent>();         embedded.add(new Child1());         embedded.add(new Child2());         input.setResult(embedded);         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);          JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });         byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input); //        byte[] json = mapper.writeValueAsBytes(input);  //        System.out.println("After Serialization: " + new String(json));                  JSONResponse<List<Parent>> out = mapper.readValue(json, 0, json.length, rootType);          List<Parent> deserializedContent = (List<Parent>) out.getResult();          assertEquals(2, deserializedContent.size());         assertTrue(deserializedContent.get(0) instanceof Parent);         assertTrue(deserializedContent.get(0) instanceof Child1);         assertFalse(deserializedContent.get(0) instanceof Child2);         assertTrue(deserializedContent.get(1) instanceof Child2);         assertFalse(deserializedContent.get(1) instanceof Child1);          assertEquals("PARENT", ((Child1) deserializedContent.get(0)).parentContent);         assertEquals("PARENT", ((Child2) deserializedContent.get(1)).parentContent);         assertEquals("CHILD1", ((Child1) deserializedContent.get(0)).childContent1);         assertEquals("CHILD2", ((Child2) deserializedContent.get(1)).childContent2);     }      } 
package com.fasterxml.jackson.databind.jsontype;  import com.fasterxml.jackson.annotation.JsonTypeInfo;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize;  public class TestNoTypeInfo extends BaseMapTest {     @JsonTypeInfo(use=JsonTypeInfo.Id.NONE)     @JsonDeserialize(as=NoType.class)     private static interface NoTypeInterface {     }          private final static class NoType implements NoTypeInterface {         public int a = 3;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      // for [JACKSON-746]     public void testWithIdNone() throws Exception     {         final ObjectMapper mapper = new ObjectMapper();         mapper.enableDefaultTyping();         // serialize without type info         String json = mapper.writeValueAsString(new NoType());         assertEquals("{\"a\":3}", json);          // and deserialize successfully         NoTypeInterface bean = mapper.readValue("{\"a\":6}", NoTypeInterface.class);         assertNotNull(bean);         NoType impl = (NoType) bean;         assertEquals(6, impl.a);     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  /**  * Testing to verify that {@link JsonTypeInfo} works  * for properties as well as types (see [JACKSON-280] for details)  */ @SuppressWarnings("serial") public class TestPropertyTypeInfo extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      static class FieldWrapperBean     {         @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)         public Object value;          public FieldWrapperBean() { }         public FieldWrapperBean(Object o) { value = o; }     }      static class FieldWrapperBeanList extends ArrayList<FieldWrapperBean> { }     static class FieldWrapperBeanMap extends HashMap<String,FieldWrapperBean> { }     static class FieldWrapperBeanArray {         @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)         public FieldWrapperBean[] beans;          public FieldWrapperBeanArray() { }         public FieldWrapperBeanArray(FieldWrapperBean[] beans) { this.beans = beans; }     }          static class MethodWrapperBean     {         private Object value;                  @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)         public Object getValue() { return value; }          @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)         public void setValue(Object v) { value = v; }                  public MethodWrapperBean() { }         public MethodWrapperBean(Object o) { value = o; }     }          static class MethodWrapperBeanList extends ArrayList<MethodWrapperBean> { }     static class MethodWrapperBeanMap extends HashMap<String,MethodWrapperBean> { }     static class MethodWrapperBeanArray {         protected MethodWrapperBean[] beans;          @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)         public MethodWrapperBean[] getValue() { return beans; }          @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)         public void setValue(MethodWrapperBean[] v) { beans = v; }                  public MethodWrapperBeanArray() { }         public MethodWrapperBeanArray(MethodWrapperBean[] beans) { this.beans = beans; }     }      static class OtherBean {         public int x = 1, y = 1;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testSimpleField() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(new FieldWrapperBean(new StringWrapper("foo"))); //System.out.println("JSON/field+object == "+json);         FieldWrapperBean bean = mapper.readValue(json, FieldWrapperBean.class);         assertNotNull(bean.value);         assertEquals(StringWrapper.class, bean.value.getClass());         assertEquals(((StringWrapper) bean.value).str, "foo");     }      public void testSimpleMethod() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(new FieldWrapperBean(new IntWrapper(37))); //System.out.println("JSON/method+object == "+json);         FieldWrapperBean bean = mapper.readValue(json, FieldWrapperBean.class);         assertNotNull(bean.value);         assertEquals(IntWrapper.class, bean.value.getClass());         assertEquals(((IntWrapper) bean.value).i, 37);     }      public void testSimpleListField() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         FieldWrapperBeanList list = new FieldWrapperBeanList();         list.add(new FieldWrapperBean(new OtherBean()));         String json = mapper.writeValueAsString(list); //System.out.println("JSON/field+list == "+json);         FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class);         assertNotNull(result);         assertEquals(1, result.size());         FieldWrapperBean bean = list.get(0);         assertEquals(OtherBean.class, bean.value.getClass());         assertEquals(((OtherBean) bean.value).x, 1);         assertEquals(((OtherBean) bean.value).y, 1);     }      public void testSimpleListMethod() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         MethodWrapperBeanList list = new MethodWrapperBeanList();         list.add(new MethodWrapperBean(new BooleanWrapper(true)));         list.add(new MethodWrapperBean(new StringWrapper("x")));         list.add(new MethodWrapperBean(new OtherBean()));         String json = mapper.writeValueAsString(list);         MethodWrapperBeanList result = mapper.readValue(json, MethodWrapperBeanList.class);         assertNotNull(result);         assertEquals(3, result.size());         MethodWrapperBean bean = result.get(0);         assertEquals(BooleanWrapper.class, bean.value.getClass());         assertEquals(((BooleanWrapper) bean.value).b, Boolean.TRUE);         bean = result.get(1);         assertEquals(StringWrapper.class, bean.value.getClass());         assertEquals(((StringWrapper) bean.value).str, "x");         bean = result.get(2);         assertEquals(OtherBean.class, bean.value.getClass());     }      public void testSimpleArrayField() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         FieldWrapperBeanArray array = new FieldWrapperBeanArray(new                 FieldWrapperBean[] { new FieldWrapperBean(new BooleanWrapper(true)) });         String json = mapper.writeValueAsString(array);         FieldWrapperBeanArray result = mapper.readValue(json, FieldWrapperBeanArray.class);         assertNotNull(result);         FieldWrapperBean[] beans = result.beans;         assertEquals(1, beans.length);         FieldWrapperBean bean = beans[0];         assertEquals(BooleanWrapper.class, bean.value.getClass());         assertEquals(((BooleanWrapper) bean.value).b, Boolean.TRUE);     }      public void testSimpleArrayMethod() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         MethodWrapperBeanArray array = new MethodWrapperBeanArray(new                 MethodWrapperBean[] { new MethodWrapperBean(new StringWrapper("A")) });         String json = mapper.writeValueAsString(array);         MethodWrapperBeanArray result = mapper.readValue(json, MethodWrapperBeanArray.class);         assertNotNull(result);         MethodWrapperBean[] beans = result.beans;         assertEquals(1, beans.length);         MethodWrapperBean bean = beans[0];         assertEquals(StringWrapper.class, bean.value.getClass());         assertEquals(((StringWrapper) bean.value).str, "A");     }          public void testSimpleMapField() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         FieldWrapperBeanMap map = new FieldWrapperBeanMap();         map.put("foop", new FieldWrapperBean(new IntWrapper(13)));         String json = mapper.writeValueAsString(map);         FieldWrapperBeanMap result = mapper.readValue(json, FieldWrapperBeanMap.class);         assertNotNull(result);         assertEquals(1, result.size());         FieldWrapperBean bean = result.get("foop");         assertNotNull(bean);         Object ob = bean.value;         assertEquals(IntWrapper.class, ob.getClass());         assertEquals(((IntWrapper) ob).i, 13);     }      public void testSimpleMapMethod() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         MethodWrapperBeanMap map = new MethodWrapperBeanMap();         map.put("xyz", new MethodWrapperBean(new BooleanWrapper(true)));         String json = mapper.writeValueAsString(map);         MethodWrapperBeanMap result = mapper.readValue(json, MethodWrapperBeanMap.class);         assertNotNull(result);         assertEquals(1, result.size());         MethodWrapperBean bean = result.get("xyz");         assertNotNull(bean);         Object ob = bean.value;         assertEquals(BooleanWrapper.class, ob.getClass());         assertEquals(((BooleanWrapper) ob).b, Boolean.TRUE);     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.io.Serializable;  import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestScalars extends BaseMapTest {     private static class DynamicWrapper {         @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)         public Object value;                  @SuppressWarnings("unused")         public DynamicWrapper() { }         public DynamicWrapper(Object v) { value = v; }     }      static enum TestEnum { A, B; }      private static class AbstractWrapper {         @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)         public Serializable value;                  @SuppressWarnings("unused")         public AbstractWrapper() { }         public AbstractWrapper(Serializable v) { value = v; }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */          /**      * Ensure that per-property dynamic types work, both for "native" types      * and others      */     public void testScalarsWithTyping() throws Exception     {         ObjectMapper m = new ObjectMapper();         String json;         DynamicWrapper result;          // first, check "native" types         json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3)));         result = m.readValue(json, DynamicWrapper.class);         assertEquals(Integer.valueOf(3), result.value);          json = m.writeValueAsString(new DynamicWrapper("abc"));         result = m.readValue(json, DynamicWrapper.class);         assertEquals("abc", result.value);          json = m.writeValueAsString(new DynamicWrapper("abc"));         result = m.readValue(json, DynamicWrapper.class);         assertEquals("abc", result.value);          json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE));         result = m.readValue(json, DynamicWrapper.class);         assertEquals(Boolean.TRUE, result.value);                  // then verify other scalars         json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L)));         result = m.readValue(json, DynamicWrapper.class);         assertEquals(Long.valueOf(7), result.value);          json = m.writeValueAsString(new DynamicWrapper(TestEnum.B));         result = m.readValue(json, DynamicWrapper.class);         assertEquals(TestEnum.B, result.value);     }      public void testScalarsViaAbstractType() throws Exception     {         ObjectMapper m = new ObjectMapper();         String json;         AbstractWrapper result;          // first, check "native" types         json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3)));         result = m.readValue(json, AbstractWrapper.class);         assertEquals(Integer.valueOf(3), result.value);          json = m.writeValueAsString(new AbstractWrapper("abc"));         result = m.readValue(json, AbstractWrapper.class);         assertEquals("abc", result.value);          json = m.writeValueAsString(new AbstractWrapper("abc"));         result = m.readValue(json, AbstractWrapper.class);         assertEquals("abc", result.value);          json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE));         result = m.readValue(json, AbstractWrapper.class);         assertEquals(Boolean.TRUE, result.value);                  // then verify other scalars         json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L)));         result = m.readValue(json, AbstractWrapper.class);         assertEquals(Long.valueOf(7), result.value);          json = m.writeValueAsString(new AbstractWrapper(TestEnum.B));         result = m.readValue(json, AbstractWrapper.class);         assertEquals(TestEnum.B, result.value);     } } 
package com.fasterxml.jackson.databind.jsontype;   import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.annotation.JsonTypeName; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.databind.JsonMappingException; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import com.fasterxml.jackson.databind.jsontype.NamedType; import com.fasterxml.jackson.databind.module.SimpleModule;  public class TestSubtypes extends com.fasterxml.jackson.databind.BaseMapTest {     @JsonTypeInfo(use=JsonTypeInfo.Id.NAME)     static abstract class SuperType {     }      @JsonTypeName("TypeB")     static class SubB extends SuperType {         public int b = 1;     }      static class SubC extends SuperType {         public int c = 2;     }      static class SubD extends SuperType {         public int d;     }      // "Empty" bean, to test [JACKSON-366]     @JsonTypeInfo(use=JsonTypeInfo.Id.NAME)     static abstract class BaseBean { }          static class EmptyBean extends BaseBean { }      static class EmptyNonFinal { }      // Verify combinations with [JACKSON-510]      static class PropertyBean     {         @JsonTypeInfo(use=JsonTypeInfo.Id.NAME)         public SuperType value;                  public PropertyBean() { this(null); }         public PropertyBean(SuperType v) { value = v; }     }      // And then [JACKSON-614]     @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=As.PROPERTY,             property="#type",             defaultImpl=DefaultImpl.class)     static abstract class SuperTypeWithDefault { }      static class DefaultImpl extends SuperTypeWithDefault {         public int a;     }      @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=As.PROPERTY, property="#type")     static abstract class SuperTypeWithoutDefault { }      static class DefaultImpl505 extends SuperTypeWithoutDefault {         public int a;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      // JACKSON-510     public void testPropertyWithSubtypes() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         // must register subtypes         mapper.registerSubtypes(SubB.class, SubC.class, SubD.class);         String json = mapper.writeValueAsString(new PropertyBean(new SubC()));         PropertyBean result = mapper.readValue(json, PropertyBean.class);         assertSame(SubC.class, result.value.getClass());     }      // [JACKSON-748]: also works via modules     public void testSubtypesViaModule() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule();         module.registerSubtypes(SubB.class, SubC.class, SubD.class);         mapper.registerModule(module);         String json = mapper.writeValueAsString(new PropertyBean(new SubC()));         PropertyBean result = mapper.readValue(json, PropertyBean.class);         assertSame(SubC.class, result.value.getClass());     }          public void testSerialization() throws Exception     {         // serialization can detect type name ok without anything extra:         SubB bean = new SubB();         ObjectMapper mapper = new ObjectMapper();         assertEquals("{\"@type\":\"TypeB\",\"b\":1}", mapper.writeValueAsString(bean));          // but we can override type name here too         mapper = new ObjectMapper();         mapper.registerSubtypes(new NamedType(SubB.class, "typeB"));         assertEquals("{\"@type\":\"typeB\",\"b\":1}", mapper.writeValueAsString(bean));          // and default name ought to be simple class name; with context         assertEquals("{\"@type\":\"TestSubtypes$SubD\",\"d\":0}", mapper.writeValueAsString(new SubD()));       }      public void testDeserializationNonNamed() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerSubtypes(SubC.class);          // default name should be unqualified class name         SuperType bean = mapper.readValue("{\"@type\":\"TestSubtypes$SubC\", \"c\":1}", SuperType.class);         assertSame(SubC.class, bean.getClass());         assertEquals(1, ((SubC) bean).c);     }      public void testDeserializatioNamed() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerSubtypes(SubB.class);         mapper.registerSubtypes(new NamedType(SubD.class, "TypeD"));          SuperType bean = mapper.readValue("{\"@type\":\"TypeB\", \"b\":13}", SuperType.class);         assertSame(SubB.class, bean.getClass());         assertEquals(13, ((SubB) bean).b);          // but we can also explicitly register name too         bean = mapper.readValue("{\"@type\":\"TypeD\", \"d\":-4}", SuperType.class);         assertSame(SubD.class, bean.getClass());         assertEquals(-4, ((SubD) bean).d);     }      // Trying to reproduce [JACKSON-366]     public void testEmptyBean() throws Exception     {         // First, with annotations         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, true);         String json = mapper.writeValueAsString(new EmptyBean());         assertEquals("{\"@type\":\"TestSubtypes$EmptyBean\"}", json);          mapper = new ObjectMapper();         mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);         json = mapper.writeValueAsString(new EmptyBean());         assertEquals("{\"@type\":\"TestSubtypes$EmptyBean\"}", json);          // and then with defaults         mapper = new ObjectMapper();         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);         mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);         json = mapper.writeValueAsString(new EmptyNonFinal());         assertEquals("[\"com.fasterxml.jackson.databind.jsontype.TestSubtypes$EmptyNonFinal\",{}]", json);     }      public void testDefaultImpl() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         // first, test with no type information         SuperTypeWithDefault bean = mapper.readValue("{\"a\":13}", SuperTypeWithDefault.class);         assertEquals(DefaultImpl.class, bean.getClass());         assertEquals(13, ((DefaultImpl) bean).a);          // and then with unmapped info         bean = mapper.readValue("{\"a\":14,\"#type\":\"foobar\"}", SuperTypeWithDefault.class);         assertEquals(DefaultImpl.class, bean.getClass());         assertEquals(14, ((DefaultImpl) bean).a);          bean = mapper.readValue("{\"#type\":\"foobar\",\"a\":15}", SuperTypeWithDefault.class);         assertEquals(DefaultImpl.class, bean.getClass());         assertEquals(15, ((DefaultImpl) bean).a);          bean = mapper.readValue("{\"#type\":\"foobar\"}", SuperTypeWithDefault.class);         assertEquals(DefaultImpl.class, bean.getClass());         assertEquals(0, ((DefaultImpl) bean).a);     }      // [JACKSON-505]: ok to also default to mapping there might be for base type     public void testDefaultImplViaModule() throws Exception     {         final String JSON = "{\"a\":123}";                  // first: without registration etc, epic fail:         ObjectMapper mapper = new ObjectMapper();         try {             mapper.readValue(JSON, SuperTypeWithoutDefault.class);             fail("Expected an exception");         } catch (JsonMappingException e) {             verifyException(e, "missing property");         }          // but then succeed when we register default impl         mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addAbstractTypeMapping(SuperTypeWithoutDefault.class, DefaultImpl505.class);         mapper.registerModule(module);         SuperTypeWithoutDefault bean = mapper.readValue(JSON, SuperTypeWithoutDefault.class);         assertNotNull(bean);         assertEquals(DefaultImpl505.class, bean.getClass());         assertEquals(123, ((DefaultImpl505) bean).a);          bean = mapper.readValue("{\"#type\":\"foobar\"}", SuperTypeWithoutDefault.class);         assertEquals(DefaultImpl505.class, bean.getClass());         assertEquals(0, ((DefaultImpl505) bean).a);          } }  
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;   import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id; import com.fasterxml.jackson.annotation.JsonSubTypes.Type; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.type.TypeFactory;  /**  * Separate tests for verifying that "type name" type id mechanism  * works.  *   * @author tatu  */ public class TestTypeNames extends BaseMapTest {     @SuppressWarnings("serial")     static class AnimalMap extends LinkedHashMap<String,Animal> { }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testSerialization() throws Exception     {         ObjectMapper m = new ObjectMapper();          // Note: need to use wrapper array just so that we can define         // static type on serialization. If we had root static types,         // could use those; but at the moment root type is dynamic                  assertEquals("[{\"doggy\":{\"name\":\"Spot\",\"ageInYears\":3}}]",                 m.writeValueAsString(new Animal[] { new Dog("Spot", 3) }));         assertEquals("[{\"MaineCoon\":{\"name\":\"Belzebub\",\"purrs\":true}}]",                 m.writeValueAsString(new Animal[] { new MaineCoon("Belzebub", true)}));     }      public void testRoundTrip() throws Exception     {         ObjectMapper m = new ObjectMapper();         Animal[] input = new Animal[] {                 new Dog("Odie", 7),                 null,                 new MaineCoon("Piru", false),                 new Persian("Khomeini", true)         };         String json = m.writeValueAsString(input);         List<Animal> output = m.readValue(json,                 TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, Animal.class));         assertEquals(input.length, output.size());         for (int i = 0, len = input.length; i < len; ++i) {             assertEquals("Entry #"+i+" differs, input = '"+json+"'",                 input[i], output.get(i));         }     }      public void testRoundTripMap() throws Exception     {         ObjectMapper m = new ObjectMapper();         AnimalMap input = new AnimalMap();         input.put("venla", new MaineCoon("Venla", true));         input.put("ama", new Dog("Amadeus", 13));         String json = m.writeValueAsString(input);         AnimalMap output = m.readValue(json, AnimalMap.class);         assertEquals(input, output);     } }  /* /********************************************************** /* Helper types /**********************************************************  */  @JsonTypeInfo(use=Id.NAME, include=As.WRAPPER_OBJECT) @JsonSubTypes({     @Type(value=Dog.class, name="doggy"),     @Type(Cat.class) /* defaults to "TestTypedNames$Cat" then */ }) class Animal {     public String name;       @Override     public boolean equals(Object o) {         if (o == this) return true;         if (o == null) return false;         if (o.getClass() != getClass()) return false;         return name.equals(((Animal) o).name);     }  }  class Dog extends Animal {     public int ageInYears;      public Dog() { }     public Dog(String n, int y) {         name = n;         ageInYears = y;     }      @Override     public boolean equals(Object o) {         return super.equals(o)             && ((Dog) o).ageInYears == ageInYears;     } }  @JsonSubTypes({     @Type(MaineCoon.class),     @Type(Persian.class) }) abstract class Cat extends Animal {     public boolean purrs;     public Cat() { }     public Cat(String n, boolean p) {         name = n;         purrs = p;     }      @Override     public boolean equals(Object o) {         return super.equals(o) && ((Cat) o).purrs == purrs;     } }  /* uses default name ("MaineCoon") since there's no @JsonTypeName,  * nor did supertype specify name  */ class MaineCoon extends Cat {     public MaineCoon() { super(); }     public MaineCoon(String n, boolean p) {         super(n, p);     } }  @JsonTypeName("persialaisKissa") class Persian extends Cat {     public Persian() { super(); }     public Persian(String n, boolean p) {         super(n, p);     } }  
package com.fasterxml.jackson.databind.jsontype;  import java.util.ArrayList; import java.util.LinkedList;  import static org.junit.Assert.assertArrayEquals;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.type.TypeFactory;  public class TestTypedArrayDeserialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      /**      * Let's claim we need type here too (although we won't      * really use any sub-classes)      */     @SuppressWarnings("serial")     @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)     static class TypedList<T> extends ArrayList<T> { }      @SuppressWarnings("serial")     @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)     static class TypedListAsProp<T> extends ArrayList<T> { }          @SuppressWarnings("serial")     @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)     static class TypedListAsWrapper<T> extends LinkedList<T> { }          // Mix-in to force wrapper for things like primitive arrays     @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)     interface WrapperMixIn { }      /*     /**********************************************************     /* Unit tests, Lists     /**********************************************************      */          public void testIntList() throws Exception     {         ObjectMapper m = new ObjectMapper();         // uses WRAPPER_OBJECT inclusion         String JSON = "{\""+TypedListAsWrapper.class.getName()+"\":[4,5, 6]}";         JavaType type = TypeFactory.defaultInstance().constructCollectionType(TypedListAsWrapper.class, Integer.class);                 TypedListAsWrapper<Integer> result = m.readValue(JSON, type);         assertNotNull(result);         assertEquals(3, result.size());         assertEquals(Integer.valueOf(4), result.get(0));         assertEquals(Integer.valueOf(5), result.get(1));         assertEquals(Integer.valueOf(6), result.get(2));     }      /**      * Similar to above, but this time let's request adding type info      * as property. That would not work (since there's no JSON Object to      * add property in), so it will basically be same as using WRAPPER_ARRAY      */     public void testBooleanListAsProp() throws Exception     {         ObjectMapper m = new ObjectMapper();         // tries to use PROPERTY inclusion; but for ARRAYS (and scalars) will become ARRAY_WRAPPER         String JSON = "[\""+TypedListAsProp.class.getName()+"\",[true, false]]";         JavaType type = TypeFactory.defaultInstance().constructCollectionType(TypedListAsProp.class, Boolean.class);                 TypedListAsProp<Object> result = m.readValue(JSON, type);         assertNotNull(result);         assertEquals(2, result.size());         assertEquals(Boolean.TRUE, result.get(0));         assertEquals(Boolean.FALSE, result.get(1));     }      public void testLongListAsWrapper() throws Exception     {         ObjectMapper m = new ObjectMapper();         // uses OBJECT_ARRAY, works just fine                  String JSON = "{\""+TypedListAsWrapper.class.getName()+"\":[1, 3]}";         JavaType type = TypeFactory.defaultInstance().constructCollectionType(TypedListAsWrapper.class, Long.class);                 TypedListAsWrapper<Object> result = m.readValue(JSON, type);         assertNotNull(result);         assertEquals(2, result.size());          assertEquals(Long.class, result.get(0).getClass());         assertEquals(Long.valueOf(1), result.get(0));         assertEquals(Long.class, result.get(1).getClass());         assertEquals(Long.valueOf(3), result.get(1));     }      /*     /**********************************************************     /* Unit tests, primitive arrays     /**********************************************************      */      public void testLongArray() throws Exception     {         ObjectMapper m = new ObjectMapper();         // use class name, WRAPPER_OBJECT         m.addMixInAnnotations(long[].class, WrapperMixIn.class);         String JSON = "{\""+long[].class.getName()+"\":[5, 6, 7]}";         long[] value = m.readValue(JSON, long[].class);         assertNotNull(value);         assertEquals(3, value.length);         assertArrayEquals(new long[] { 5L, 6L, 7L} , value);     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying that types that serialize as JSON Arrays  * get properly serialized with types (esp. for contents, and  * gracefully handling Lists themselves too)  */ public class TestTypedArraySerialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      /**      * Let's claim we need type here too (although we won't      * really use any sub-classes)      */     @SuppressWarnings("serial")     @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)     static class TypedList<T> extends ArrayList<T> { }      @SuppressWarnings("serial")     @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)     static class TypedListAsProp<T> extends ArrayList<T> { }          @SuppressWarnings("serial")     @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_OBJECT)     static class TypedListAsWrapper<T> extends LinkedList<T> { }          // Mix-in to force wrapper for things like primitive arrays     @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)     interface WrapperMixIn { }      // for [JACKSON-341]     @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_OBJECT)     @JsonSubTypes({ @JsonSubTypes.Type(B.class) })     interface A { }      @JsonTypeName("BB")     static class B implements A {         public int value = 2;     }      @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY)     @JsonTypeName("bean")     static class Bean {         public int x = 0;     }      static class BeanListWrapper {         @JsonView({Object.class})         public List<Bean> beans = new ArrayList<Bean>();         {             beans.add(new Bean());         }     }      /*     /**********************************************************     /* Unit tests, Lists     /**********************************************************      */      public void testListWithPolymorphic() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         BeanListWrapper beans = new BeanListWrapper();         assertEquals("{\"beans\":[{\"@type\":\"bean\",\"x\":0}]}", mapper.writeValueAsString(beans));         // Related to [JACKSON-364]         ObjectWriter w = mapper.writerWithView(Object.class);         assertEquals("{\"beans\":[{\"@type\":\"bean\",\"x\":0}]}", w.writeValueAsString(beans));     }          public void testIntList() throws Exception     {         TypedList<Integer> input = new TypedList<Integer>();         input.add(5);         input.add(13);         // uses WRAPPER_ARRAY inclusion:         assertEquals("[\""+TypedList.class.getName()+"\",[5,13]]", serializeAsString(input));     }          // Similar to above, but this time let's request adding type info     // as property. That would not work (since there's no JSON Object to     // add property in), so it should revert to method used with     // ARRAY_WRAPPER method.     public void testStringListAsProp() throws Exception     {         TypedListAsProp<String> input = new TypedListAsProp<String>();         input.add("a");         input.add("b");         assertEquals("[\""+TypedListAsProp.class.getName()+"\",[\"a\",\"b\"]]",                 serializeAsString(input));     }      public void testStringListAsObjectWrapper() throws Exception     {         TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>();         input.add(true);         input.add(null);         input.add(false);         // Can wrap in JSON Object for wrapped style... also, will use         // non-qualified class name as type name, since there are no         // annotations         String expName = "TestTypedArraySerialization$TypedListAsWrapper";         assertEquals("{\""+expName+"\":[true,null,false]}",                 serializeAsString(input));     }      /*     /**********************************************************     /* Unit tests, primitive arrays     /**********************************************************      */      public void testIntArray() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(int[].class, WrapperMixIn.class);         int[] input = new int[] { 1, 2, 3 };         String clsName = int[].class.getName();         assertEquals("{\""+clsName+"\":[1,2,3]}", serializeAsString(m, input));     }      /*     /**********************************************************     /* Unit tests, generic arrays     /**********************************************************      */      public void testGenericArray() throws Exception     {         ObjectMapper m;         final A[] input = new A[] { new B() };         final String EXP = "[{\"BB\":{\"value\":2}}]";          // first, with defaults         m = new ObjectMapper();         assertEquals(EXP, m.writeValueAsString(input));          // then with static typing enabled:         m = new ObjectMapper();         m.configure(MapperFeature.USE_STATIC_TYPING, true);         assertEquals(EXP, m.writeValueAsString(input));     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import org.junit.Assert;   import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonSubTypes.Type; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.type.TypeFactory;  public class TestTypedContainerSerialization 	extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      @JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = "object-type")     @JsonSubTypes( { @Type(value = Dog.class, name = "doggy"),         @Type(value = Cat.class, name = "kitty") })     static abstract class Animal { 	    public String name;  	    protected Animal(String n) { 	        name = n; 	    } 	}  	@JsonTypeName("doggie") 	static class Dog extends Animal { 		public int boneCount;  		public Dog() { 			super(null); 		}  		@JsonCreator 		public Dog(@JsonProperty("name") String name) { 			super(name); 		}  		public void setBoneCount(int i) { 			boneCount = i; 		} 	}  	@JsonTypeName("kitty") 	static class Cat extends Animal { 		public String furColor;  		public Cat() { 			super(null); 		}  		@JsonCreator 		public Cat(@JsonProperty("furColor") String c) { 			super(null); 			furColor = c; 		}  		public void setName(String n) { 			name = n; 		} 	}  	static class Container1 { 		Animal animal;  		public Animal getAnimal() { 			return animal; 		}  		public void setAnimal(Animal animal) { 			this.animal = animal; 		} 	}  	static class Container2<T extends Animal> { 		@JsonSerialize 		T animal;  		public T getAnimal() { 			return animal; 		}  		public void setAnimal(T animal) { 			this.animal = animal; 		}  	}      @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@class")     static class Issue508A { }     static class Issue508B extends Issue508A { }      private final static ObjectMapper mapper = new ObjectMapper();      /*     /**********************************************************     /* Unit tests     /**********************************************************      */ 	     public void testIssue265() throws Exception     { 		Dog dog = new Dog("medor"); 		dog.setBoneCount(3); 		Container1 c1 = new Container1(); 		c1.setAnimal(dog); 		String s1 = mapper.writeValueAsString(c1); 		Assert.assertTrue("polymorphic type info is kept (1)", s1 				.indexOf("\"object-type\":\"doggy\"") >= 0); 		Container2<Animal> c2 = new Container2<Animal>(); 		c2.setAnimal(dog); 		String s2 = mapper.writeValueAsString(c2); 		Assert.assertTrue("polymorphic type info is kept (2)", s2 				.indexOf("\"object-type\":\"doggy\"") >= 0);     }      public void testIssue329() throws Exception     {             ArrayList<Animal> animals = new ArrayList<Animal>();             animals.add(new Dog("Spot"));             JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class);             String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator());             if (json.indexOf("\"object-type\":\"doggy\"") < 0) {                 fail("No polymorphic type retained, should be; JSON = '"+json+"'");             }     }      public void testIssue508() throws Exception     {             List<List<Issue508A>> l = new ArrayList<List<Issue508A>>();             List<Issue508A> l2 = new ArrayList<Issue508A>();             l2.add(new Issue508A());             l.add(l2);             TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() {};             String json = mapper.writerWithType(typeRef).writeValueAsString(l);              List<?> output = mapper.readValue(json, typeRef);             assertEquals(1, output.size());             Object ob = output.get(0);             assertTrue(ob instanceof List<?>);             List<?> list2 = (List<?>) ob;             assertEquals(1, list2.size());             ob = list2.get(0);             assertSame(Issue508A.class, ob.getClass());     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonSubTypes.Type; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.type.TypeFactory;  public class TestTypedDeserialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      /**      * Polymorphic base class      */     @JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY, property="@classy")     static abstract class Animal {         public String name;                  protected Animal(String n)  { name = n; }     }      @JsonTypeName("doggie")     static class Dog extends Animal     {         public int boneCount;                  @JsonCreator         public Dog(@JsonProperty("name") String name) {             super(name);         }          public void setBoneCount(int i) { boneCount = i; }     }          @JsonTypeName("kitty")     static class Cat extends Animal     {         public String furColor;          @JsonCreator         public Cat(@JsonProperty("furColor") String c) {             super(null);             furColor = c;         }          public void setName(String n) { name = n; }     }      // for [JACKSON-319] -- allow "empty" beans     @JsonTypeName("fishy")     static class Fish extends Animal     {         @JsonCreator         public Fish()         {             super(null);         }     }      static class AnimalContainer {         public Animal animal;     }      // base class with no useful info     @JsonTypeInfo(use=Id.CLASS, include=As.WRAPPER_ARRAY)     static abstract class DummyBase {         protected DummyBase(boolean foo) { }     }      static class DummyImpl extends DummyBase {         public int x;          public DummyImpl() { super(true); }     }          @JsonTypeInfo(use=Id.MINIMAL_CLASS, include=As.WRAPPER_OBJECT)     interface TypeWithWrapper { }      @JsonTypeInfo(use=Id.CLASS, include=As.WRAPPER_ARRAY)     interface TypeWithArray { }      static class Issue506DateBean {         @JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = "type2")         public Date date;     }              static class Issue506NumberBean     {         @JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = "type3")         @JsonSubTypes({ @Type(Long.class),             @Type(Integer.class) })         public Number number;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */          /**      * First things first, let's ensure we can serialize using      * class name, written as main-level property name      */     public void testSimpleClassAsProperty() throws Exception     {         ObjectMapper m = new ObjectMapper();         Animal a = m.readValue(asJSONObjectValueString("@classy", Cat.class.getName(),                 "furColor", "tabby", "name", "Garfield"), Animal.class);         assertNotNull(a);         assertEquals(Cat.class, a.getClass());         Cat c = (Cat) a;         assertEquals("Garfield", c.name);         assertEquals("tabby", c.furColor);     }      // Test inclusion using wrapper style     public void testTypeAsWrapper() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);         String JSON = "{\".TestTypedDeserialization$Dog\" : "             +asJSONObjectValueString(m, "name", "Scooby", "boneCount", "6")+" }";         Animal a = m.readValue(JSON, Animal.class);         assertTrue(a instanceof Animal);         assertEquals(Dog.class, a.getClass());         Dog d = (Dog) a;         assertEquals("Scooby", d.name);         assertEquals(6, d.boneCount);     }      // Test inclusion using 2-element array     public void testTypeAsArray() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(Animal.class, TypeWithArray.class);         // hmmh. Not good idea to rely on exact output, order may change. But...         String JSON = "[\""+Dog.class.getName()+"\", "             +asJSONObjectValueString(m, "name", "Martti", "boneCount", "11")+" ]";         Animal a = m.readValue(JSON, Animal.class);         assertEquals(Dog.class, a.getClass());         Dog d = (Dog) a;         assertEquals("Martti", d.name);         assertEquals(11, d.boneCount);     }      // Use basic Animal as contents of a regular List     public void testListAsArray() throws Exception     {         ObjectMapper m = new ObjectMapper();         // This time using PROPERTY style (default) again         String JSON = "[\n"             +asJSONObjectValueString(m, "@classy", Cat.class.getName(), "name", "Hello", "furColor", "white")             +",\n"             // let's shuffle doggy's fields a bit for testing             +asJSONObjectValueString(m,                                      "boneCount", Integer.valueOf(1),                                      "@classy", Dog.class.getName(),                                      "name", "Bob"                                      )             +",\n"             +asJSONObjectValueString(m, "@classy", Fish.class.getName())             +", null\n]";                  JavaType expType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, Animal.class);         List<Animal> animals = m.readValue(JSON, expType);         assertNotNull(animals);         assertEquals(4, animals.size());         Cat c = (Cat) animals.get(0);         assertEquals("Hello", c.name);         assertEquals("white", c.furColor);         Dog d = (Dog) animals.get(1);         assertEquals("Bob", d.name);         assertEquals(1, d.boneCount);         Fish f = (Fish) animals.get(2);         assertNotNull(f);         assertNull(animals.get(3));     }      public void testCagedAnimal() throws Exception     {         ObjectMapper m = new ObjectMapper();         String jsonCat = asJSONObjectValueString(m, "@classy", Cat.class.getName(), "name", "Nilson", "furColor", "black");         String JSON = "{\"animal\":"+jsonCat+"}";          AnimalContainer cont = m.readValue(JSON, AnimalContainer.class);         assertNotNull(cont);         Animal a = cont.animal;         assertNotNull(a);         Cat c = (Cat) a;         assertEquals("Nilson", c.name);         assertEquals("black", c.furColor);     }      /**      * Test that verifies that there are few limitations on polymorphic      * base class.      */     public void testAbstractEmptyBaseClass() throws Exception     {         DummyBase result = new ObjectMapper().readValue(                 "[\""+DummyImpl.class.getName()+"\",{\"x\":3}]", DummyBase.class);         assertNotNull(result);         assertEquals(DummyImpl.class, result.getClass());         assertEquals(3, ((DummyImpl) result).x);     }      // [JACKSON-506], wrt Date     public void testIssue506WithDate() throws Exception     {         Issue506DateBean input = new Issue506DateBean();         input.date = new Date(1234L);          ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(input);          Issue506DateBean output = mapper.readValue(json, Issue506DateBean.class);         assertEquals(input.date, output.date);     }          // [JACKSON-506], wrt Number     public void testIssue506WithNumber() throws Exception     {         Issue506NumberBean input = new Issue506NumberBean();         input.number = Long.valueOf(4567L);          ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(input);          Issue506NumberBean output = mapper.readValue(json, Issue506NumberBean.class);         assertEquals(input.number, output.number);     } }   
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.DeserializationFeature; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.annotation.NoClass;  /**  * Unit tests related to [JACKSON-712]; specialized handling of  * otherwise invalid type id embedding cases.  */ public class TestTypedDeserializationWithDefault extends BaseMapTest {     @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type", defaultImpl = LegacyInter.class)     @JsonSubTypes(value = {@JsonSubTypes.Type(name = "mine", value = MyInter.class)})     public static interface Inter { }      public static class MyInter implements Inter {         @JsonProperty("blah") public List<String> blah;     }      public static class LegacyInter extends MyInter     {         @JsonCreator         LegacyInter(Object obj)         {             if (obj instanceof List) {                 blah = new ArrayList<String>();                 for (Object o : (List<?>) obj) {                     blah.add(o.toString());                 }             }             else if (obj instanceof String) {                 blah = Arrays.asList(((String) obj).split(","));             }             else {                 throw new IllegalArgumentException("Unknown type: " + obj.getClass());             }         }     }      @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type",             defaultImpl = NoClass.class)     public static class DefaultWithNoClass { }      // and then one with no defaultImpl nor listed subtypes     @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")     abstract static class MysteryPolymorphic { }          /*     /**********************************************************     /* Unit tests, deserialization     /**********************************************************      */          public void testDeserializationWithObject() throws Exception     {         Inter inter = objectReader(Inter.class).readValue("{\"type\": \"mine\", \"blah\": [\"a\", \"b\", \"c\"]}");         assertTrue(inter instanceof MyInter);         assertFalse(inter instanceof LegacyInter);         assertEquals(Arrays.asList("a", "b", "c"), ((MyInter) inter).blah);     }      public void testDeserializationWithString() throws Exception     {         Inter inter = objectReader(Inter.class).readValue("\"a,b,c,d\"");         assertTrue(inter instanceof LegacyInter);         assertEquals(Arrays.asList("a", "b", "c", "d"), ((MyInter) inter).blah);     }      public void testDeserializationWithArray() throws Exception     {         Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\", \"c\", \"d\"]");         assertTrue(inter instanceof LegacyInter);         assertEquals(Arrays.asList("a", "b", "c", "d"), ((MyInter) inter).blah);     }      public void testDeserializationWithArrayOfSize2() throws Exception     {         Inter inter = objectReader(Inter.class).readValue("[\"a\", \"b\"]");         assertTrue(inter instanceof LegacyInter);         assertEquals(Arrays.asList("a", "b"), ((MyInter) inter).blah);     }      // [Issue#148]     public void testDefaultAsNoClass() throws Exception     {         Object ob = objectReader(DefaultWithNoClass.class).readValue("{ }");         assertNull(ob);         ob = objectReader(DefaultWithNoClass.class).readValue("{ \"bogus\":3 }");         assertNull(ob);     }      // [Issue#148]     public void testBadTypeAsNull() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);         Object ob = mapper.readValue("{}", MysteryPolymorphic.class);         assertNull(ob);         ob = mapper.readValue("{ \"whatever\":13}", MysteryPolymorphic.class);         assertNull(ob);     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.*;  import static com.fasterxml.jackson.annotation.JsonTypeInfo.*;  public class TestTypedSerialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      /**      * Polymorphic base class      */     @JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY)     static abstract class Animal {         public String name;                  protected Animal(String n)  { name = n; }     }      @JsonTypeName("doggie")     static class Dog extends Animal     {         public int boneCount;                  private Dog() { super(null); }         public Dog(String name, int b) {             super(name);             boneCount = b;         }     }          @JsonTypeName("kitty")     static class Cat extends Animal     {         public String furColor;                  private Cat() { super(null); }         public Cat(String name, String c) {             super(name);             furColor = c;         }     }      public class AnimalWrapper {         public Animal animal;                  public AnimalWrapper(Animal a) { animal = a; }     }      @JsonTypeInfo(use=Id.MINIMAL_CLASS, include=As.WRAPPER_OBJECT)     interface TypeWithWrapper { }      @JsonTypeInfo(use=Id.CLASS, include=As.WRAPPER_ARRAY)     interface TypeWithArray { }      @JsonTypeInfo(use=Id.NAME)     @JsonTypeName("empty")     public class Empty { }      @JsonTypeInfo(include=As.PROPERTY, use=Id.CLASS)     public class Super {}     public class A extends Super {}     public class B extends Super {}      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          /**      * First things first, let's ensure we can serialize using      * class name, written as main-level property name      */     public void testSimpleClassAsProperty() throws Exception     {         Map<String,Object> result = writeAndMap(MAPPER, new Cat("Beelzebub", "tabby"));         assertEquals(3, result.size());         assertEquals("Beelzebub", result.get("name"));         assertEquals("tabby", result.get("furColor"));         // should we try customized class name?         String classProp = Id.CLASS.getDefaultPropertyName();         assertEquals(Cat.class.getName(), result.get(classProp));     }      /**      * Test inclusion using wrapper style      */     public void testTypeAsWrapper() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);         Map<String,Object> result = writeAndMap(m, new Cat("Venla", "black"));         // should get a wrapper; keyed by minimal class name ("Cat" here)         assertEquals(1, result.size());         // minimal class name is prefixed by dot, and for inner classes it's bit longer         Map<?,?> cat = (Map<?,?>) result.get(".TestTypedSerialization$Cat");         assertNotNull(cat);         assertEquals(2, cat.size());         assertEquals("Venla", cat.get("name"));         assertEquals("black", cat.get("furColor"));     }      /**      * Test inclusion using 2-element array      */     public void testTypeAsArray() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(Animal.class, TypeWithArray.class);         // hmmh. Not good idea to rely on exact output, order may change. But...         Map<String,Object> result = writeAndMap(m, new AnimalWrapper(new Dog("Amadeus", 7)));         // First level, wrapper         assertEquals(1, result.size());         List<?> l = (List<?>) result.get("animal");         assertNotNull(l);         assertEquals(2, l.size());         assertEquals(Dog.class.getName(), l.get(0));         Map<?,?> doggie = (Map<?,?>) l.get(1);         assertNotNull(doggie);         assertEquals(2, doggie.size());         assertEquals("Amadeus", doggie.get("name"));         assertEquals(Integer.valueOf(7), doggie.get("boneCount"));     }      /* !!! 30-Jan-2010, tatus: I am not completely sure below works as it should      *    Problem is, context of "untyped" map should prevent type information      *    being added to Animal entries, because Object.class has no type.      *    If type information is included, it will not be useful for deserialization,      *    since static type does not carry through (unlike in serialization).      *          *    But it is not quite clear how type information should be pushed through      *    array types...      */     @SuppressWarnings("unchecked")     public void testInArray() throws Exception     {         // ensure we'll use mapper with default configs         ObjectMapper m = new ObjectMapper();         // ... so this should NOT be needed...         m.disableDefaultTyping();                  Animal[] animals = new Animal[] { new Cat("Miuku", "white"), new Dog("Murre", 9) };         Map<String,Object> map = new HashMap<String,Object>();         map.put("a", animals);         String json = m.writeValueAsString(map);         Map<String,Object> result = m.readValue(json, Map.class);         assertEquals(1, result.size());         Object ob = result.get("a");         if (!(ob instanceof List<?>)) {             // 03-Feb-2010, tatu: Weird; seems to fail sometimes...             fail("Did not map to entry with 'a' as List (but as "+ob.getClass().getName()+"): JSON == '"+json+"'");         }         List<?> l = (List<?>)ob;         assertNotNull(l);         assertEquals(2, l.size());         Map<?,?> a1 = (Map<?,?>) l.get(0);         assertEquals(3, a1.size());         String classProp = Id.CLASS.getDefaultPropertyName();         assertEquals(Cat.class.getName(), a1.get(classProp));         Map<?,?> a2 = (Map<?,?>) l.get(1);         assertEquals(3, a2.size());         assertEquals(Dog.class.getName(), a2.get(classProp));     }      /**      * Simple unit test to verify that serializing "empty" beans is ok      */     public void testEmptyBean() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);         assertEquals("{\"@type\":\"empty\"}", m.writeValueAsString(new Empty()));     }      /**      * Unit test for [JACKSON-543]      */     public void testTypedMaps() throws Exception     {         ObjectMapper mapper = new ObjectMapper();          Map<Long, Collection<Super>> map = new HashMap<Long, Collection<Super>>();         List<Super> list = new ArrayList<Super>();         list.add(new A());         map.put(1L, list);         String json = mapper.writerWithType(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);         assertTrue("JSON does not contain '@class': "+json, json.contains("@class"));     } }  
package com.fasterxml.jackson.databind.jsontype;  import com.fasterxml.jackson.annotation.JsonTypeId; import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.annotation.JsonTypeName;  import com.fasterxml.jackson.databind.*;  /**  * Tests to verify [JACKSON-437], [JACKSON-762]  */ public class TestVisibleTypeId extends BaseMapTest {     // type id as property, exposed     @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY,             property="type", visible=true)     @JsonTypeName("BaseType")     static class PropertyBean {         public int a = 3;          protected String type;          public void setType(String t) { type = t; }     }      // as wrapper-array     @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_ARRAY,             property="type", visible=true)     @JsonTypeName("ArrayType")     static class WrapperArrayBean {         public int a = 1;          protected String type;          public void setType(String t) { type = t; }     }      // as wrapper-object     @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_OBJECT,             property="type", visible=true)     @JsonTypeName("ObjectType")     static class WrapperObjectBean {         public int a = 2;          protected String type;          public void setType(String t) { type = t; }     }      // as external id, bit trickier     static class ExternalIdWrapper {         @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY,                 property="type", visible=true)         public ExternalIdBean bean = new ExternalIdBean();     }          @JsonTypeName("ExternalType")     static class ExternalIdBean {         public int a = 2;          protected String type;          public void setType(String t) { type = t; }     }      // // // [JACKSON-762]: type id from property          @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY,             property="type")     static class TypeIdFromFieldProperty {         public int a = 3;          @JsonTypeId         public String type = "SomeType";     }      @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_ARRAY,             property="type")     static class TypeIdFromFieldArray {         public int a = 3;         @JsonTypeId         public String type = "SomeType";     }      @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_OBJECT,             property="type")     static class TypeIdFromMethodObject {         public int a = 3;                  @JsonTypeId         public String getType() { return "SomeType"; }     }      static class ExternalIdWrapper2 {         @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY,                 property="type", visible=true)         public ExternalIdBean2 bean = new ExternalIdBean2();     }      static class ExternalIdBean2 {         public int a = 2;          /* Type id property itself can not be external, as it is conceptually          * part of the bean for which info is written:          */         @JsonTypeId         public String getType() { return "SomeType"; }     }      // Invalid definition: multiple type ids     static class MultipleIds {         @JsonTypeId         public String type1 = "type1";          @JsonTypeId         public String getType2() { return "type2"; };     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      private final ObjectMapper mapper = new ObjectMapper();          public void testVisibleWithProperty() throws Exception     {         String json = mapper.writeValueAsString(new PropertyBean());         // just default behavior:         assertEquals("{\"type\":\"BaseType\",\"a\":3}", json);         // but then expect to read it back         PropertyBean result = mapper.readValue(json, PropertyBean.class);         assertEquals("BaseType", result.type);          // also, should work with order reversed         result = mapper.readValue("{\"a\":7, \"type\":\"BaseType\"}", PropertyBean.class);         assertEquals(7, result.a);         assertEquals("BaseType", result.type);     }      public void testVisibleWithWrapperArray() throws Exception     {         String json = mapper.writeValueAsString(new WrapperArrayBean());         // just default behavior:         assertEquals("[\"ArrayType\",{\"a\":1}]", json);         // but then expect to read it back         WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class);         assertEquals("ArrayType", result.type);         assertEquals(1, result.a);     }      public void testVisibleWithWrapperObject() throws Exception     {         String json = mapper.writeValueAsString(new WrapperObjectBean());         assertEquals("{\"ObjectType\":{\"a\":2}}", json);         // but then expect to read it back         WrapperObjectBean result = mapper.readValue(json, WrapperObjectBean.class);         assertEquals("ObjectType", result.type);     }      public void testVisibleWithExternalId() throws Exception     {         String json = mapper.writeValueAsString(new ExternalIdWrapper());         // but then expect to read it back         ExternalIdWrapper result = mapper.readValue(json, ExternalIdWrapper.class);         assertEquals("ExternalType", result.bean.type);         assertEquals(2, result.bean.a);     }      // [JACKSON-762]      public void testTypeIdFromProperty() throws Exception     {         assertEquals("{\"type\":\"SomeType\",\"a\":3}",                 mapper.writeValueAsString(new TypeIdFromFieldProperty()));     }      public void testTypeIdFromArray() throws Exception     {         assertEquals("[\"SomeType\",{\"a\":3}]",                 mapper.writeValueAsString(new TypeIdFromFieldArray()));     }      public void testTypeIdFromObject() throws Exception     {         assertEquals("{\"SomeType\":{\"a\":3}}",                 mapper.writeValueAsString(new TypeIdFromMethodObject()));     }      public void testTypeIdFromExternal() throws Exception     {         String json = mapper.writeValueAsString(new ExternalIdWrapper2());         // Implementation detail: type id written AFTER value, due to constraints         assertEquals("{\"bean\":{\"a\":2},\"type\":\"SomeType\"}", json);              }      // Failing cases      public void testInvalidMultipleTypeIds() throws Exception     {         try {             mapper.writeValueAsString(new MultipleIds());             fail("Should have failed");         } catch (JsonMappingException e) {             verifyException(e, "multiple type ids");         }     } } 
package com.fasterxml.jackson.databind.jsontype;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonSubTypes.Type; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ser.BeanSerializerFactory; import com.fasterxml.jackson.databind.ser.ResolvableSerializer; import com.fasterxml.jackson.databind.type.TypeFactory;  public class TestWithGenerics extends BaseMapTest {     @JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = "object-type")     @JsonSubTypes( { @Type(value = Dog.class, name = "doggy") })     static abstract class Animal {         public String name;     }          static class Dog extends Animal {         public int boneCount;          public Dog(String name, int b) {             super();             this.name = name;             boneCount = b;         }     }      static class ContainerWithGetter<T extends Animal> {         private T animal;          public ContainerWithGetter(T a) { animal = a; }          public T getAnimal() { return animal; }     }      static class ContainerWithField<T extends Animal> {         public T animal;          public ContainerWithField(T a) { animal = a; }     }          // Beans for [JACKSON-387], [JACKSON-430]          @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@classAttr1")     static class MyClass {         public List<MyParam<?>> params = new ArrayList<MyParam<?>>();     }      @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property="@classAttr2")     static class MyParam<T>{         public T value;          public MyParam() { }         public MyParam(T v) { value = v; }     }      private static class SomeObject {         @SuppressWarnings("unused")         public String someValue = UUID.randomUUID().toString();     }          // Beans for [JACKSON-430]          static class CustomJsonSerializer extends JsonSerializer<Object>         implements ResolvableSerializer     {         private final JsonSerializer<Object> beanSerializer;              public CustomJsonSerializer( JsonSerializer<Object> beanSerializer ) { this.beanSerializer = beanSerializer; }              @Override         public void serialize( Object value, JsonGenerator jgen, SerializerProvider provider )             throws IOException, JsonProcessingException         {             beanSerializer.serialize( value, jgen, provider );         }              @Override         public Class<Object> handledType() { return beanSerializer.handledType(); }              @Override         public void serializeWithType( Object value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer )             throws IOException, JsonProcessingException         {             beanSerializer.serializeWithType( value, jgen, provider, typeSer );         }          @Override         public void resolve(SerializerProvider provider) throws JsonMappingException         {             if (beanSerializer instanceof ResolvableSerializer) {                 ((ResolvableSerializer) beanSerializer).resolve(provider);             }         }     }          @SuppressWarnings("serial")     protected static class CustomJsonSerializerFactory extends BeanSerializerFactory     {         public CustomJsonSerializerFactory() { super(null); }          @Override         protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov,                 BeanDescription beanDesc)             throws JsonMappingException         {                             return new CustomJsonSerializer(super.constructBeanSerializer(prov, beanDesc) );         }     }           /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testWrapperWithGetter() throws Exception     {         Dog dog = new Dog("Fluffy", 3);         String json = new ObjectMapper().writeValueAsString(new ContainerWithGetter<Animal>(dog));         if (json.indexOf("\"object-type\":\"doggy\"") < 0) {             fail("polymorphic type not kept, result == "+json+"; should contain 'object-type':'...'");         }     }      public void testWrapperWithField() throws Exception     {         Dog dog = new Dog("Fluffy", 3);         String json = new ObjectMapper().writeValueAsString(new ContainerWithField<Animal>(dog));         if (json.indexOf("\"object-type\":\"doggy\"") < 0) {             fail("polymorphic type not kept, result == "+json+"; should contain 'object-type':'...'");         }     }          public void testWrapperWithExplicitType() throws Exception     {         Dog dog = new Dog("Fluffy", 3);         ContainerWithGetter<Animal> c2 = new ContainerWithGetter<Animal>(dog);         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writerWithType(TypeFactory.defaultInstance().constructParametricType(ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);         if (json.indexOf("\"object-type\":\"doggy\"") < 0) {             fail("polymorphic type not kept, result == "+json+"; should contain 'object-type':'...'");         }     }          public void testJackson387() throws Exception     {         ObjectMapper om = new ObjectMapper();         om.enableDefaultTyping( ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY );         om.setSerializationInclusion(JsonInclude.Include.NON_NULL );         om.enable( SerializationFeature.INDENT_OUTPUT);          MyClass mc = new MyClass();          MyParam<Integer> moc1 = new MyParam<Integer>(1);         MyParam<String> moc2 = new MyParam<String>("valueX");          SomeObject so = new SomeObject();         so.someValue = "xxxxxx";          MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so);          List<SomeObject> colist = new ArrayList<SomeObject>();         colist.add( new SomeObject() );         colist.add( new SomeObject() );         colist.add( new SomeObject() );         MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist);          mc.params.add( moc1 );         mc.params.add( moc2 );         mc.params.add( moc3 );         mc.params.add( moc4 );          String json = om.writeValueAsString( mc );                  MyClass mc2 = om.readValue(json, MyClass.class );         assertNotNull(mc2);         assertNotNull(mc2.params);         assertEquals(4, mc2.params.size());     }      public void testJackson430() throws Exception     {         ObjectMapper om = new ObjectMapper(); //        om.getSerializationConfig().setSerializationInclusion( Inclusion.NON_NULL );         om.setSerializerFactory( new CustomJsonSerializerFactory() );         MyClass mc = new MyClass();         mc.params.add(new MyParam<Integer>(1));          String str = om.writeValueAsString( mc ); //        System.out.println( str );                  MyClass mc2 = om.readValue( str, MyClass.class );         assertNotNull(mc2);         assertNotNull(mc2.params);         assertEquals(1, mc2.params.size());     } } 
package com.fasterxml.jackson.databind.mixins;  import java.io.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;  import com.fasterxml.jackson.databind.*;  public class TestMixinDeserForClass     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      static class BaseClass     {         /* property that is always found; but has lower priority than          * setter method if both found          */         @JsonProperty         public String a;          // setter that may or may not be auto-detected         public void setA(String v) { a = "XXX"+v; }     }      @JsonAutoDetect(setterVisibility=Visibility.ANY, fieldVisibility=Visibility.ANY)     static class LeafClass         extends BaseClass { }      @JsonAutoDetect(setterVisibility=Visibility.NONE, fieldVisibility=Visibility.NONE)     interface MixIn { }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testClassMixInsTopLevel() throws IOException     {         ObjectMapper m = new ObjectMapper();         // First: test default behavior: should use setter         LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class);         assertEquals("XXXvalue", result.a);          /* Then with leaf-level mix-in; without (method) auto-detect, should          * use field          */         m = new ObjectMapper();         m.addMixInAnnotations(LeafClass.class, MixIn.class);         result = m.readValue("{\"a\":\"value\"}", LeafClass.class);         assertEquals("value", result.a);     }      /* and then a test for mid-level mixin; should have no effect      * when deserializing leaf (but will if deserializing base class)      */     public void testClassMixInsMidLevel() throws IOException     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(BaseClass.class, MixIn.class);         {             BaseClass result = m.readValue("{\"a\":\"value\"}", BaseClass.class);             assertEquals("value", result.a);         }          // whereas with leaf class, reverts to default         {             LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class);             assertEquals("XXXvalue", result.a);         }     }      /* Also: when mix-in attached to Object.class, will work, if      * visible (similar to mid-level, basically)      */     public void testClassMixInsForObjectClass() throws IOException     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(Object.class, MixIn.class);         // will be seen for BaseClass         {             BaseClass result = m.readValue("{\"a\":\"\"}", BaseClass.class);             assertEquals("", result.a);         }          // but LeafClass still overrides         {             LeafClass result = m.readValue("{\"a\":\"\"}", LeafClass.class);             assertEquals("XXX", result.a);         }     } } 
package com.fasterxml.jackson.databind.mixins;  import java.io.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  public class TestMixinDeserForCreators     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      static class BaseClass     {         protected String _a;          public BaseClass(String a) {             _a = a+"...";         }          private BaseClass(String value, boolean dummy) {             _a = value;         }          public static BaseClass myFactory(String a) {             return new BaseClass(a+"X", true);         }     }      static class BaseClassWithPrivateCtor     {         protected String _a;         private BaseClassWithPrivateCtor(String a) {             _a = a+"...";         }      }      /**      * Mix-in class that will effectively suppresses String constructor,      * and marks a non-auto-detectable static method as factory method      * as a creator.      *<p>      * Note that method implementations are not used for anything; but      * we have to a class: interface won't do, as they can't have      * constructors or static methods.      */     static class MixIn     {         @JsonIgnore protected MixIn(String s) { }          @JsonCreator         static BaseClass myFactory(String a) { return null; }     }      static class MixInForPrivate     {         @JsonCreator MixInForPrivate(String s) { }     }      static class StringWrapper {         String _value;         private StringWrapper(String s, boolean foo) { _value = s; }          @SuppressWarnings("unused") 		private static StringWrapper create(String str) {             return new StringWrapper(str, false);         }     }      abstract static class StringWrapperMixIn {         @JsonCreator static StringWrapper create(String str) { return null; }     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testForConstructor() throws IOException     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(BaseClassWithPrivateCtor.class, MixInForPrivate.class);         BaseClassWithPrivateCtor result = m.readValue("\"?\"", BaseClassWithPrivateCtor.class);         assertEquals("?...", result._a);     }      public void testForFactoryAndCtor() throws IOException     {         ObjectMapper m = new ObjectMapper();         BaseClass result;          // First: test default behavior: should use constructor         result = m.readValue("\"string\"", BaseClass.class);         assertEquals("string...", result._a);          // Then with simple mix-in: should change to use the factory method         m = new ObjectMapper();         m.addMixInAnnotations(BaseClass.class, MixIn.class);         result = m.readValue("\"string\"", BaseClass.class);         assertEquals("stringX", result._a);     }      public void testFactoryMixIn() throws IOException     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(StringWrapper.class, StringWrapperMixIn.class);         StringWrapper result = m.readValue("\"a\"", StringWrapper.class);         assertEquals("a", result._value);     } } 
package com.fasterxml.jackson.databind.mixins;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  public class TestMixinDeserForMethods     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      static class BaseClass     {         protected HashMap<String,Object> values = new HashMap<String,Object>();          public BaseClass() { }          protected void addValue(String key, Object value) {             values.put(key, value);         }     }      interface MixIn     {         @JsonAnySetter void addValue(String key, Object value);     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      /**      * Unit test that verifies that we can mix in @JsonAnySetter      * annotation, as expected.      */     public void testWithAnySetter() throws IOException     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(BaseClass.class, MixIn.class);         BaseClass result = m.readValue("{ \"a\" : 3, \"b\" : true }", BaseClass.class);         assertNotNull(result);         assertEquals(2, result.values.size());         assertEquals(Integer.valueOf(3), result.values.get("a"));         assertEquals(Boolean.TRUE, result.values.get("b"));     } } 
package com.fasterxml.jackson.databind.mixins;  import java.io.IOException; import java.util.Map;  import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestMixinInheritance     extends BaseMapTest {     // [Issue-14]     static class Beano {         public int ido = 42;         public String nameo = "Bob";     }      static class BeanoMixinSuper {         @JsonProperty("name")         public String nameo;     }      static class BeanoMixinSub extends BeanoMixinSuper {         @JsonProperty("id")         public int ido;     }      static class Beano2 {         public int getIdo() { return 13; }         public String getNameo() { return "Bill"; }     }      static abstract class BeanoMixinSuper2 extends Beano2 {         @Override         @JsonProperty("name")         public abstract String getNameo();     }      static abstract class BeanoMixinSub2 extends BeanoMixinSuper2 {         @Override         @JsonProperty("id")         public abstract int getIdo();     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */          public void testMixinFieldInheritance() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         mapper.addMixInAnnotations(Beano.class, BeanoMixinSub.class);         Map<String,Object> result;         result = writeAndMap(mapper, new Beano());         assertEquals(2, result.size());         assertTrue(result.containsKey("id"));         assertTrue(result.containsKey("name"));     }      public void testMixinMethodInheritance() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class);         Map<String,Object> result;         result = writeAndMap(mapper, new Beano2());         assertEquals(2, result.size());         assertTrue(result.containsKey("id"));         assertTrue(result.containsKey("name"));     } } 
package com.fasterxml.jackson.databind.mixins;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  public class TestMixinSerForClass     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      @JsonSerialize(include=JsonSerialize.Inclusion.ALWAYS)     static class BaseClass     {         protected String _a, _b;         protected String _c = "c";          protected BaseClass() { }          public BaseClass(String a) {             _a = a;         }          // will be auto-detectable unless disabled:         public String getA() { return _a; }          @JsonProperty         public String getB() { return _b; }          @JsonProperty         public String getC() { return _c; }     }      @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)     static class LeafClass         extends BaseClass     {         public LeafClass() { super(null); }          public LeafClass(String a) {             super(a);         }     }      /**      * This interface only exists to add "mix-in annotations": that is, any      * annotations it has can be virtually added to mask annotations      * of other classes      */     @JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)     interface MixIn { }      // test disabling of autodetect...     @JsonAutoDetect(getterVisibility=Visibility.NONE, fieldVisibility=Visibility.NONE)     interface MixInAutoDetect { }      /*     /**********************************************************     /( Unit tests     /**********************************************************      */      public void testClassMixInsTopLevel() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         Map<String,Object> result;          // first: with no mix-ins:         result = writeAndMap(mapper, new LeafClass("abc"));         assertEquals(1, result.size());         assertEquals("abc", result.get("a"));          // then with top-level override         mapper = new ObjectMapper();         mapper.addMixInAnnotations(LeafClass.class, MixIn.class);         result = writeAndMap(mapper, new LeafClass("abc"));         assertEquals(2, result.size());         assertEquals("abc", result.get("a"));         assertEquals("c", result.get("c"));          // mid-level override; should not have any effect         mapper = new ObjectMapper();         mapper.addMixInAnnotations(BaseClass.class, MixIn.class);         result = writeAndMap(mapper, new LeafClass("abc"));         assertEquals(1, result.size());         assertEquals("abc", result.get("a"));     }      public void testClassMixInsMidLevel() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         Map<String,Object> result;         LeafClass bean = new LeafClass("xyz");         bean._c = "c2";          // with no mix-ins first...         result = writeAndMap(mapper, bean);         assertEquals(2, result.size());         assertEquals("xyz", result.get("a"));         assertEquals("c2", result.get("c"));          // then with working mid-level override, which effectively suppresses 'a'         mapper = new ObjectMapper();         mapper.addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);         result = writeAndMap(mapper, bean);         assertEquals(1, result.size());         assertEquals("c2", result.get("c"));     } } 
package com.fasterxml.jackson.databind.mixins;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  public class TestMixinSerForFields     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      static class BaseClass     {         public String a;         protected String b;          public BaseClass(String a, String b) {             this.a = a;             this.b = b;         }     }      static class SubClass         extends BaseClass     {         public SubClass(String a, String b) {             super(a, b);         }     }      abstract class MixIn {         // Let's add 'b' as "banana"         @JsonProperty("banana")         public String b;     }      abstract class MixIn2 {         // Let's remove 'a'         @JsonIgnore         public String a;          // also: add a dummy field that is NOT to match anything         @JsonProperty public String xyz;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testFieldMixInsTopLevel() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         Map<String,Object> result;         BaseClass bean = new BaseClass("1", "2");          // first: with no mix-ins:         result = writeAndMap(mapper, bean);         assertEquals(1, result.size());         assertEquals("1", result.get("a"));          // and then with simple mix-in         mapper = new ObjectMapper();         mapper.addMixInAnnotations(BaseClass.class, MixIn.class);         result = writeAndMap(mapper, bean);         assertEquals(2, result.size());         assertEquals("1", result.get("a"));         assertEquals("2", result.get("banana"));     }      public void testMultipleFieldMixIns() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         // ordering here shouldn't matter really...         HashMap<Class<?>,Class<?>> mixins = new HashMap<Class<?>,Class<?>>();         mixins.put(SubClass.class, MixIn.class);         mixins.put(BaseClass.class, MixIn2.class);         mapper.setMixInAnnotations(mixins);          Map<String,Object> result;         result = writeAndMap(mapper, new SubClass("1", "2"));         assertEquals(1, result.size());         // 'a' should be suppressed; 'b' mapped to 'banana'         assertEquals("2", result.get("banana"));     } } 
package com.fasterxml.jackson.databind.mixins;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  public class TestMixinSerForMethods     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      // base class: just one visible property ('b')     static class BaseClass     {         @SuppressWarnings("unused") private String a;         private String b;          protected BaseClass() { }          public BaseClass(String a, String b) {             this.a = a;             this.b = b;         }          @JsonProperty("b")         public String takeB() { return b; }     }      /* extends, just for fun; and to show possible benefit of being      * able to declare that a method is overridden (compile-time check      * that our intended mix-in override will match a method)      */     abstract static class MixIn         extends BaseClass     {         // let's make 'a' visible         @JsonProperty String a;          @Override             @JsonProperty("b2")             public abstract String takeB();          // also: just for fun; add a "red herring"... unmatched method         @JsonProperty abstract String getFoobar();     }      static class LeafClass         extends BaseClass     {         public LeafClass(String a, String b) { super(a, b); }          @Override         @JsonIgnore         public String takeB() { return null; }     }                     interface ObjectMixIn     {         // and then ditto for hashCode..         @Override         @JsonProperty public int hashCode();     }      static class EmptyBean { }      static class SimpleBean extends EmptyBean     {         int x() { return 42; }     }      /**      * This mix-in is to be attached to EmptyBean, but really modify      * methods that its subclass, SimpleBean, has.      */     abstract class MixInForSimple     {         // This should apply to sub-class         @JsonProperty("x") abstract int x();          // and this matches nothing, should be ignored         @JsonProperty("notreally") public int xxx() { return 3; }          // nor this         public abstract int getIt();     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      /**      * Unit test for verifying that leaf-level mix-ins work ok;       * that is, any annotations added properly override all annotations      * that masked methods (fields etc) have.      */     public void testLeafMixin() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         Map<String,Object> result;         BaseClass bean = new BaseClass("a1", "b2");          // first: with no mix-ins:         result = writeAndMap(mapper, bean);         assertEquals(1, result.size());         assertEquals("b2", result.get("b"));          // then with leaf-level mix-in         mapper = new ObjectMapper();         mapper.addMixInAnnotations(BaseClass.class, MixIn.class);         result = writeAndMap(mapper, bean);         assertEquals(2, result.size());         assertEquals("b2", result.get("b2"));         assertEquals("a1", result.get("a"));     }      /**      * Unit test for verifying that having a mix-in "between" classes      * (overriding annotations of a base class, but being overridden      * further by a sub-class) works as expected      */     public void testIntermediateMixin() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         Map<String,Object> result;         LeafClass bean = new LeafClass("XXX", "b2");          mapper.addMixInAnnotations(BaseClass.class, MixIn.class);         result = writeAndMap(mapper, bean);         assertEquals(1, result.size());         assertEquals("XXX", result.get("a"));     }      /**      * Another intermediate mix-in, to verify that annotations      * properly "trickle up"      */     public void testIntermediateMixin2() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         mapper.addMixInAnnotations(EmptyBean.class, MixInForSimple.class);         Map<String,Object> result = writeAndMap(mapper, new SimpleBean());         assertEquals(1, result.size());         assertEquals(Integer.valueOf(42), result.get("x"));     }      /**      * Unit test for verifying that it is actually possible to attach      * mix-in annotations to basic <code>Object.class</code>. This      * will essentially apply to any and all Objects.      */     public void testObjectMixin() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         mapper.addMixInAnnotations(Object.class, ObjectMixIn.class);          // First, with our bean...         Map<String,Object> result = writeAndMap(mapper, new BaseClass("a", "b"));          assertEquals(2, result.size());         assertEquals("b", result.get("b"));         Object ob = result.get("hashCode");         assertNotNull(ob);         assertEquals(Integer.class, ob.getClass());          /* 15-Oct-2010, tatu: Actually, we now block serialization (attemps) of plain Objects, by default          *    (since generally that makes no sense -- may need to revisit). As such, need to comment out          *    this part of test          */         /* Hmmh. For plain Object.class... I suppose getClass() does          * get serialized (and can't really be blocked either).          * Fine.          */        /*         result = writeAndMap(mapper, new Object());         assertEquals(2, result.size());         ob = result.get("hashCode");         assertNotNull(ob);         assertEquals(Integer.class, ob.getClass());         assertEquals("java.lang.Object", result.get("class"));         */     } } 
package com.fasterxml.jackson.databind.mixins;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  public class TestMixinSerWithViews     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      static class SimpleTestData     {         private String name = "shown";         private String nameHidden = "hidden";          public String getName() { return name; }         public String getNameHidden( ) { return nameHidden; }        public void setName( String name ) {         this.name = name;       }        public void setNameHidden( String nameHidden ) {         this.nameHidden = nameHidden;       }     }      static class ComplexTestData     {       String nameNull = null;        String nameComplex = "complexValue";        String nameComplexHidden = "nameComplexHiddenValue";        SimpleTestData testData = new SimpleTestData( );        SimpleTestData[] testDataArray = new SimpleTestData[] { new SimpleTestData( ), null };        public String getNameNull()       {         return nameNull;       }        public void setNameNull( String nameNull )       {         this.nameNull = nameNull;       }        public String getNameComplex()       {         return nameComplex;       }        public void setNameComplex( String nameComplex )       {         this.nameComplex = nameComplex;       }        public String getNameComplexHidden()       {         return nameComplexHidden;       }        public void setNameComplexHidden( String nameComplexHidden )       {         this.nameComplexHidden = nameComplexHidden;       }        public SimpleTestData getTestData()       {         return testData;       }        public void setTestData( SimpleTestData testData )       {         this.testData = testData;       }        public SimpleTestData[] getTestDataArray()       {         return testDataArray;       }        public void setTestDataArray( SimpleTestData[] testDataArray )       {         this.testDataArray = testDataArray;       }     }          public interface TestDataJAXBMixin     {       @JsonView( Views.View.class )       String getName( );     }      public interface TestComplexDataJAXBMixin     {       @JsonView( Views.View.class )       String getNameNull();        @JsonView( Views.View.class )       String getNameComplex();        @JsonView( Views.View.class )       String getNameComplexHidden();        @JsonView( Views.View.class )       SimpleTestData getTestData();        @JsonView( Views.View.class )       SimpleTestData[] getTestDataArray( );     }      static class Views {         static class View { }     }          public class A {         private String name;         private int age;         private String surname;          public A(String name, int age, String surname) { super(); this.name = name; this.age = age; this.surname = surname; }          public String getName() { return name; }          public void setName(String name) { this.name = name; }          public int getAge() { return age; }          public void setAge(int age) { this.age = age; }          public String getSurname() { return surname; }          public void setSurname(String surname) { this.surname = surname; }     }      public interface AView { }      public abstract class AMixInAnnotation {         @JsonProperty("name")         @JsonView(AView.class)         abstract String getName();         @JsonProperty("age") @JsonView(AView.class)         abstract int getAge();     }      /*     /**********************************************************     /* Tests     /**********************************************************      */          public void testDataBindingUsage( ) throws Exception     {       ObjectMapper objectMapper = createObjectMapper();       ObjectWriter objectWriter = objectMapper.writerWithView(Views.View.class).withDefaultPrettyPrinter();       Object object = new ComplexTestData();       String json = objectWriter.writeValueAsString(object);       assertTrue( json.indexOf( "nameHidden" ) == -1 );       assertTrue( json.indexOf( "\"name\" : \"shown\"" ) > 0 );     }          public void testIssue560() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         A a = new A("myname", 29, "mysurname");          // Property SerializationConfig.SerializationFeature.DEFAULT_VIEW_INCLUSION set to false         mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);         mapper.addMixInAnnotations(A.class, AMixInAnnotation.class);         String json = mapper.writerWithView(AView.class).writeValueAsString(a);          assertTrue(json.indexOf("\"name\"") > 0);     }          /*     /**********************************************************     /* Helper methods     /**********************************************************      */          private ObjectMapper createObjectMapper( )     {       ObjectMapper objectMapper = new ObjectMapper( );       objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false );       objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL );       objectMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false );        Map<Class<?>, Class<?>> sourceMixins = new HashMap<Class<?>, Class<?>>( );       sourceMixins.put( SimpleTestData.class, TestDataJAXBMixin.class );       sourceMixins.put( ComplexTestData.class, TestComplexDataJAXBMixin.class );              objectMapper.setMixInAnnotations(sourceMixins);       return objectMapper;     } } 
package com.fasterxml.jackson.databind.module;  import java.util.*;   import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.module.SimpleModule;  public class TestAbstractTypes extends BaseMapTest {     /*     /**********************************************************     /* Helper classes; simple beans and their handlers     /**********************************************************      */      static class MyString implements CharSequence     {         protected String value;                  public MyString(String s) { value = s; }          @Override         public char charAt(int index) {             return value.charAt(index);         }          @Override         public int length() {             return value.length();         }          @Override         public CharSequence subSequence(int arg0, int arg1) { return this; }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testCollectionDefaulting() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule mod = new SimpleModule("test", Version.unknownVersion());         // let's ensure we get hierarchic mapping         mod.addAbstractTypeMapping(Collection.class, List.class);         mod.addAbstractTypeMapping(List.class, LinkedList.class);         mapper.registerModule(mod);         Collection<?> result = mapper.readValue("[]", Collection.class);         assertEquals(LinkedList.class, result.getClass());     }      public void testMapDefaulting() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule mod = new SimpleModule("test", Version.unknownVersion());         // default is HashMap, so:         mod.addAbstractTypeMapping(Map.class, TreeMap.class);         mapper.registerModule(mod);         Map<?,?> result = mapper.readValue("{}", Map.class);         assertEquals(TreeMap.class, result.getClass());     }          public void testInterfaceDefaulting() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule mod = new SimpleModule("test", Version.unknownVersion());         // let's ensure we get hierarchic mapping         mod.addAbstractTypeMapping(CharSequence.class, MyString.class);         mapper.registerModule(mod);         Object result = mapper.readValue(quote("abc"), CharSequence.class);         assertEquals(MyString.class, result.getClass());         assertEquals("abc", ((MyString) result).value);     } } 
package com.fasterxml.jackson.databind.module;  import java.util.Map;  import com.fasterxml.jackson.core.Version; import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.DeserializationContext; import com.fasterxml.jackson.databind.KeyDeserializer; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestKeyDeserializers extends BaseMapTest {     static class FooKeyDeserializer extends KeyDeserializer     {         @Override         public Foo deserializeKey(String key, DeserializationContext ctxt)         {             return new Foo(key);         }     }          static class Foo {         public String value;                  public Foo(String v) { value = v; }     }           /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testKeyDeserializers() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule mod = new SimpleModule("test", Version.unknownVersion());         mod.addKeyDeserializer(Foo.class, new FooKeyDeserializer());         mapper.registerModule(mod);         Map<Foo,Integer> map = mapper.readValue("{\"a\":3}",                 new TypeReference<Map<Foo,Integer>>() {} );         assertNotNull(map);         assertEquals(1, map.size());         Foo foo = map.keySet().iterator().next();         assertEquals("a", foo.value);     } } 
package com.fasterxml.jackson.databind.module;  import java.io.IOException; import java.lang.reflect.Type; import java.util.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.annotation.JsonPropertyOrder; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.module.SimpleDeserializers; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.module.SimpleSerializers; import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer; import com.fasterxml.jackson.databind.ser.std.StdSerializer;  @SuppressWarnings("serial") public class TestSimpleModule extends BaseMapTest {     /*     /**********************************************************     /* Helper classes; simple beans and their handlers     /**********************************************************      */          /**      * Trivial bean that requires custom serializer and deserializer      */     final static class CustomBean     {         protected String str;         protected int num;                  public CustomBean(String s, int i) {             str = s;             num = i;         }     }      static enum SimpleEnum { A, B; }          // Extend SerializerBase to get access to declared handledType     static class CustomBeanSerializer extends StdSerializer<CustomBean>     {         public CustomBeanSerializer() { super(CustomBean.class); }          @Override         public void serialize(CustomBean value, JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonProcessingException         {             // We will write it as a String, with '|' as delimiter             jgen.writeString(value.str + "|" + value.num);         }          @Override         public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {             return null;         }     }          static class CustomBeanDeserializer extends JsonDeserializer<CustomBean>     {         @Override         public CustomBean deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException, JsonProcessingException         {             String text = jp.getText();             int ix = text.indexOf('|');             if (ix < 0) {                 throw new IOException("Failed to parse String value of \""+text+"\"");             }             String str = text.substring(0, ix);             int num = Integer.parseInt(text.substring(ix+1));             return new CustomBean(str, num);         }     }      static class SimpleEnumSerializer extends StdSerializer<SimpleEnum>     {         public SimpleEnumSerializer() { super(SimpleEnum.class); }          @Override         public void serialize(SimpleEnum value, JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonProcessingException         {             jgen.writeString(value.name().toLowerCase());         }          @Override         public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {             return null;         }     }      static class SimpleEnumDeserializer extends JsonDeserializer<SimpleEnum>     {         @Override         public SimpleEnum deserialize(JsonParser jp, DeserializationContext ctxt)             throws IOException, JsonProcessingException         {             return SimpleEnum.valueOf(jp.getText().toUpperCase());         }     }      interface Base {         public String getText();     }          static class Impl1 implements Base {         @Override         public String getText() { return "1"; }     }      static class Impl2 extends Impl1 {         @Override         public String getText() { return "2"; }     }      static class BaseSerializer extends StdScalarSerializer<Base>     {         public BaseSerializer() { super(Base.class); }                  @Override         public void serialize(Base value, JsonGenerator jgen, SerializerProvider provider) throws IOException {             jgen.writeString("Base:"+value.getText());         }     }      static class MixableBean {         public int a = 1;         public int b = 2;         public int c = 3;     }      @JsonPropertyOrder({"c", "a", "b"})     static class MixInForOrder { }          protected static class MySimpleSerializers extends SimpleSerializers { }     protected static class MySimpleDeserializers extends SimpleDeserializers { }      /**      * Test module which uses custom 'serializers' and 'deserializers' container; used      * to trigger type problems.      */     protected static class MySimpleModule extends SimpleModule     {         public MySimpleModule(String name, Version version) {             super(name, version);             _deserializers = new MySimpleDeserializers();             _serializers = new MySimpleSerializers();         }     }      protected static class ContextVerifierModule extends Module     {         @Override         public String getModuleName() { return "x"; }          @Override         public Version version() { return Version.unknownVersion(); }          @Override         public void setupModule(SetupContext context)         {             ObjectCodec c = context.getOwner();             assertNotNull(c);             assertTrue(c instanceof ObjectMapper);             ObjectMapper m = context.getOwner();             assertNotNull(m);         }     }          /*     /**********************************************************     /* Unit tests; first, verifying need for custom handlers     /**********************************************************      */      /**      * Basic test to ensure we do not have functioning default      * serializers for custom types used in tests.      */     public void testWithoutModule()     {         ObjectMapper mapper = new ObjectMapper();         // first: serialization failure:         try {             mapper.writeValueAsString(new CustomBean("foo", 3));             fail("Should have caused an exception");         } catch (IOException e) {             verifyException(e, "No serializer found");         }          // then deserialization         try {             mapper.readValue("{\"str\":\"ab\",\"num\":2}", CustomBean.class);             fail("Should have caused an exception");         } catch (IOException e) {             verifyException(e, "No suitable constructor found");         }     }          /*     /**********************************************************     /* Unit tests; simple serializers     /**********************************************************      */          public void testSimpleBeanSerializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule mod = new SimpleModule("test", Version.unknownVersion());         mod.addSerializer(new CustomBeanSerializer());         mapper.registerModule(mod);         assertEquals(quote("abcde|5"), mapper.writeValueAsString(new CustomBean("abcde", 5)));     }      public void testSimpleEnumSerializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule mod = new SimpleModule("test", Version.unknownVersion());         mod.addSerializer(new SimpleEnumSerializer());         mapper.registerModule(mod);         assertEquals(quote("b"), mapper.writeValueAsString(SimpleEnum.B));     }      // for [JACKSON-550]     public void testSimpleInterfaceSerializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule mod = new SimpleModule("test", Version.unknownVersion());         mod.addSerializer(new BaseSerializer());         mapper.registerModule(mod);         assertEquals(quote("Base:1"), mapper.writeValueAsString(new Impl1()));         assertEquals(quote("Base:2"), mapper.writeValueAsString(new Impl2()));     }          /*     /**********************************************************     /* Unit tests; simple deserializers     /**********************************************************      */          public void testSimpleBeanDeserializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule mod = new SimpleModule("test", Version.unknownVersion());         mod.addDeserializer(CustomBean.class, new CustomBeanDeserializer());         mapper.registerModule(mod);         CustomBean bean = mapper.readValue(quote("xyz|3"), CustomBean.class);         assertEquals("xyz", bean.str);         assertEquals(3, bean.num);     }      public void testSimpleEnumDeserializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule mod = new SimpleModule("test", Version.unknownVersion());         mod.addDeserializer(SimpleEnum.class, new SimpleEnumDeserializer());         mapper.registerModule(mod);         SimpleEnum result = mapper.readValue(quote("a"), SimpleEnum.class);         assertSame(SimpleEnum.A, result);     }       // Simple verification of [JACKSON-455]     public void testMultipleModules() throws Exception     {         MySimpleModule mod1 = new MySimpleModule("test1", Version.unknownVersion());         SimpleModule mod2 = new SimpleModule("test2", Version.unknownVersion());         mod1.addSerializer(SimpleEnum.class, new SimpleEnumSerializer());         mod1.addDeserializer(CustomBean.class, new CustomBeanDeserializer());         mod2.addDeserializer(SimpleEnum.class, new SimpleEnumDeserializer());         mod2.addSerializer(CustomBean.class, new CustomBeanSerializer());          ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(mod1);         mapper.registerModule(mod2);         assertEquals(quote("b"), mapper.writeValueAsString(SimpleEnum.B));         SimpleEnum result = mapper.readValue(quote("a"), SimpleEnum.class);         assertSame(SimpleEnum.A, result);          // also let's try it with different order of registration, just in case         mapper = new ObjectMapper();         mapper.registerModule(mod2);         mapper.registerModule(mod1);         assertEquals(quote("b"), mapper.writeValueAsString(SimpleEnum.B));         result = mapper.readValue(quote("a"), SimpleEnum.class);         assertSame(SimpleEnum.A, result);     }      /*     /**********************************************************     /* Unit tests; other     /**********************************************************      */          // [JACKSON-644]: ability to register mix-ins     public void testMixIns() throws Exception     {         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.setMixInAnnotation(MixableBean.class, MixInForOrder.class);         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(module);         Map<String,Object> props = this.writeAndMap(mapper, new MixableBean());         assertEquals(3, props.size());         assertEquals(Integer.valueOf(3), props.get("c"));         assertEquals(Integer.valueOf(1), props.get("a"));         assertEquals(Integer.valueOf(2), props.get("b"));     }      // [JACKSON-686]     public void testAccessToMapper() throws Exception     {         ContextVerifierModule module = new ContextVerifierModule();                 ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(module);     } }  
package com.fasterxml.jackson.databind.module;  import java.io.IOException; import java.lang.reflect.Type;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.jsontype.TypeDeserializer; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.module.SimpleDeserializers; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.Serializers; import com.fasterxml.jackson.databind.type.*;  @SuppressWarnings("serial") public class TestTypeModifiers extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      static class ModifierModule extends SimpleModule     {         public ModifierModule() {             super("test", Version.unknownVersion());         }          @Override         public void setupModule(SetupContext context)         {             context.addSerializers(new Serializers.Base() {                 @Override                 public JsonSerializer<?> findMapLikeSerializer(SerializationConfig config,                         MapLikeType type, BeanDescription beanDesc,                         JsonSerializer<Object> keySerializer,                         TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)                 {                     if (MapMarker.class.isAssignableFrom(type.getRawClass())) {                         return new MyMapSerializer(keySerializer, elementValueSerializer);                     }                     return null;                 }                  @Override                 public JsonSerializer<?> findCollectionLikeSerializer(SerializationConfig config,                         CollectionLikeType type, BeanDescription beanDesc,                         TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)                 {                     if (CollectionMarker.class.isAssignableFrom(type.getRawClass())) {                         return new MyCollectionSerializer();                     }                     return null;                 }             });             context.addDeserializers(new SimpleDeserializers() {                 @Override                 public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config,                         BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)                     throws JsonMappingException                 {                     if (CollectionMarker.class.isAssignableFrom(type.getRawClass())) {                         return new MyCollectionDeserializer();                     }                     return null;                 }                 @Override                 public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type, DeserializationConfig config,                         BeanDescription beanDesc, KeyDeserializer keyDeserializer,                         TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)                     throws JsonMappingException                 {                     if (MapMarker.class.isAssignableFrom(type.getRawClass())) {                         return new MyMapDeserializer();                     }                     return null;                 }             });         }     }      static class XxxSerializer extends JsonSerializer<Object>     {         @Override         public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {             jgen.writeString("xxx:"+value);         }     }          interface MapMarker<K,V> {         public K getKey();         public V getValue();     }     interface CollectionMarker<V> {         public V getValue();     }      @JsonSerialize(contentUsing=XxxSerializer.class)     static class MyMapLikeType implements MapMarker<String,Integer> {         public String key;         public int value;          public MyMapLikeType() { }         public MyMapLikeType(String k, int v) {             key = k;             value = v;         }          @Override         public String getKey() { return key; }         @Override         public Integer getValue() { return value; }     }      static class MyCollectionLikeType implements CollectionMarker<Integer>     {         public int value;          public MyCollectionLikeType() { }         public MyCollectionLikeType(int v) {             value = v;         }          @Override         public Integer getValue() { return value; }     }      static class MyMapSerializer extends JsonSerializer<MapMarker<?,?>>     {         protected final JsonSerializer<Object> _keySerializer;         protected final JsonSerializer<Object> _valueSerializer;                  public MyMapSerializer(JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer) {             _keySerializer = keySer;             _valueSerializer = valueSer;         }                  @Override         public void serialize(MapMarker<?,?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException {             jgen.writeStartObject();             if (_keySerializer == null) {                 jgen.writeFieldName((String) value.getKey());             } else {                 _keySerializer.serialize(value.getKey(), jgen, provider);             }             if (_valueSerializer == null) {                 jgen.writeNumber(((Number) value.getValue()).intValue());             } else {                 _valueSerializer.serialize(value.getValue(), jgen, provider);             }             jgen.writeEndObject();         }     }     static class MyMapDeserializer extends JsonDeserializer<MapMarker<?,?>>     {         @Override         public MapMarker<?,?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {             if (jp.getCurrentToken() != JsonToken.START_OBJECT) throw new IOException("Wrong token: "+jp.getCurrentToken());             if (jp.nextToken() != JsonToken.FIELD_NAME) throw new IOException("Wrong token: "+jp.getCurrentToken());             String key = jp.getCurrentName();             if (jp.nextToken() != JsonToken.VALUE_NUMBER_INT) throw new IOException("Wrong token: "+jp.getCurrentToken());             int value = jp.getIntValue();             if (jp.nextToken() != JsonToken.END_OBJECT) throw new IOException("Wrong token: "+jp.getCurrentToken());             return new MyMapLikeType(key, value);         }             }      static class MyCollectionSerializer extends JsonSerializer<MyCollectionLikeType>     {         @Override         public void serialize(MyCollectionLikeType value, JsonGenerator jgen, SerializerProvider provider) throws IOException {             jgen.writeStartArray();             jgen.writeNumber(value.value);             jgen.writeEndArray();         }     }     static class MyCollectionDeserializer extends JsonDeserializer<MyCollectionLikeType>     {         @Override         public MyCollectionLikeType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {             if (jp.getCurrentToken() != JsonToken.START_ARRAY) throw new IOException("Wrong token: "+jp.getCurrentToken());             if (jp.nextToken() != JsonToken.VALUE_NUMBER_INT) throw new IOException("Wrong token: "+jp.getCurrentToken());             int value = jp.getIntValue();             if (jp.nextToken() != JsonToken.END_ARRAY) throw new IOException("Wrong token: "+jp.getCurrentToken());             return new MyCollectionLikeType(value);         }             }          static class MyTypeModifier extends TypeModifier     {         @Override         public JavaType modifyType(JavaType type, Type jdkType, TypeBindings context, TypeFactory typeFactory)         {             Class<?> raw = type.getRawClass();             if (MapMarker.class.isAssignableFrom(raw)) {                 JavaType[] params = typeFactory.findTypeParameters(type, MapMarker.class);                 return typeFactory.constructMapLikeType(raw, params[0], params[1]);             }             if (CollectionMarker.class.isAssignableFrom(raw)) {                 JavaType[] params = typeFactory.findTypeParameters(type, CollectionMarker.class);                 return typeFactory.constructCollectionLikeType(raw, params[0]);             }             return type;         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      /**      * Basic test for ensuring that we can get "xxx-like" types recognized.      */     public void testLikeTypeConstruction() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));         JavaType type = mapper.constructType(MyMapLikeType.class);         assertTrue(type.isMapLikeType());         // also, must have resolved type info         JavaType param = ((MapLikeType) type).getKeyType();         assertNotNull(param);         assertSame(String.class, param.getRawClass());         param = ((MapLikeType) type).getContentType();         assertNotNull(param);         assertSame(Integer.class, param.getRawClass());                  type = mapper.constructType(MyCollectionLikeType.class);         assertTrue(type.isCollectionLikeType());         param = ((CollectionLikeType) type).getContentType();         assertNotNull(param);         assertSame(Integer.class, param.getRawClass());     }      public void testCollectionLikeSerialization() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));         mapper.registerModule(new ModifierModule());         assertEquals("[19]", mapper.writeValueAsString(new MyCollectionLikeType(19)));     }      public void testMapLikeSerialization() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));         mapper.registerModule(new ModifierModule());         // Due to custom serializer, should get:         assertEquals("{\"x\":\"xxx:3\"}", mapper.writeValueAsString(new MyMapLikeType("x", 3)));     }       public void testCollectionLikeDeserialization() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));         mapper.registerModule(new ModifierModule());         // !!! TBI         MyMapLikeType result = mapper.readValue("{\"a\":13}", MyMapLikeType.class);         assertEquals("a", result.getKey());         assertEquals(Integer.valueOf(13), result.getValue());     }      public void testMapLikeDeserialization() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));         mapper.registerModule(new ModifierModule());         // !!! TBI         MyCollectionLikeType result = mapper.readValue("[-37]", MyCollectionLikeType.class);         assertEquals(Integer.valueOf(-37), result.getValue());     } } 
package com.fasterxml.jackson.databind.node;  import java.io.*; import java.util.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.node.ArrayNode; import com.fasterxml.jackson.databind.node.JsonNodeFactory; import com.fasterxml.jackson.databind.node.TextNode; import com.fasterxml.jackson.databind.node.TreeTraversingParser;  /**  * Additional tests for {@link ArrayNode} container class.  */ public class TestArrayNode     extends BaseMapTest {     public void testBasics() throws IOException     {         ArrayNode n = new ArrayNode(JsonNodeFactory.instance);         assertStandardEquals(n);         assertFalse(n.elements().hasNext());         assertFalse(n.fieldNames().hasNext());         TextNode text = TextNode.valueOf("x");         n.add(text);         assertEquals(1, n.size());         assertFalse(0 == n.hashCode());         assertTrue(n.elements().hasNext());         // no field names for arrays         assertFalse(n.fieldNames().hasNext());         assertNull(n.get("x")); // not used with arrays         assertTrue(n.path("x").isMissingNode());         assertSame(text, n.get(0));          // single element, so:         assertFalse(n.has("field"));         assertFalse(n.hasNonNull("field"));         assertTrue(n.has(0));         assertTrue(n.hasNonNull(0));         assertFalse(n.has(1));         assertFalse(n.hasNonNull(1));                  // add null node too         n.add((JsonNode) null);         assertEquals(2, n.size());         assertTrue(n.get(1).isNull());         assertTrue(n.has(1));         assertFalse(n.hasNonNull(1));         // change to text         n.set(1, text);         assertSame(text, n.get(1));         n.set(0, null);         assertTrue(n.get(0).isNull());          // and finally, clear it all         ArrayNode n2 = new ArrayNode(JsonNodeFactory.instance);         n2.add("foobar");         assertFalse(n.equals(n2));         n.addAll(n2);         assertEquals(3, n.size());          assertFalse(n.get(0).isTextual());         assertNotNull(n.remove(0));         assertEquals(2, n.size());         assertTrue(n.get(0).isTextual());          ArrayList<JsonNode> nodes = new ArrayList<JsonNode>();         nodes.add(text);         n.addAll(nodes);         assertEquals(3, n.size());         assertNull(n.get(10000));         assertNull(n.remove(-4));          TextNode text2 = TextNode.valueOf("b");         n.insert(0, text2);         assertEquals(4, n.size());         assertSame(text2, n.get(0));          assertNotNull(n.addArray());         assertEquals(5, n.size());         n.addPOJO("foo");         assertEquals(6, n.size());          // Try serializing it for fun, too...         JsonGenerator jg = new MappingJsonFactory().createGenerator(new StringWriter());         n.serialize(jg, null);          n.removeAll();         assertEquals(0, n.size());     }      public void testAdds()     {         ArrayNode n = new ArrayNode(JsonNodeFactory.instance);         assertNotNull(n.addArray());         assertNotNull(n.addObject());         n.addPOJO("foobar");         n.add(1);         n.add(1L);         n.add(0.5);         n.add(0.5f);         assertEquals(7, n.size());          assertNotNull(n.insertArray(0));         assertNotNull(n.insertObject(0));         n.insertPOJO(2, "xxx");         assertEquals(10, n.size());     }      /**      * Test to verify [JACKSON-227]      */     public void testNullChecking()     {         ArrayNode a1 = JsonNodeFactory.instance.arrayNode();         ArrayNode a2 = JsonNodeFactory.instance.arrayNode();         // used to throw NPE before fix:         a1.addAll(a2);         assertEquals(0, a1.size());         assertEquals(0, a2.size());          a2.addAll(a1);         assertEquals(0, a1.size());         assertEquals(0, a2.size());     }      /**      * Another test to verify [JACKSON-227]...      */     public void testNullChecking2()     {         ObjectMapper mapper = new ObjectMapper();         ArrayNode src = mapper.createArrayNode();         ArrayNode dest = mapper.createArrayNode();         src.add("element");         dest.addAll(src);     }          public void testParser() throws Exception     {         ArrayNode n = new ArrayNode(JsonNodeFactory.instance);         n.add(123);         TreeTraversingParser p = new TreeTraversingParser(n, null);         p.setCodec(null);         assertNull(p.getCodec());         assertNotNull(p.getParsingContext());         assertNotNull(p.getTokenLocation());         assertNotNull(p.getCurrentLocation());         assertNull(p.getEmbeddedObject());         assertNull(p.currentNode());          //assertNull(p.getNumberType());          assertToken(JsonToken.START_ARRAY, p.nextToken());         p.skipChildren();         assertToken(JsonToken.END_ARRAY, p.getCurrentToken());         p.close();          p = new TreeTraversingParser(n, null);         p.nextToken();         assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());         assertEquals(JsonParser.NumberType.INT, p.getNumberType());         p.close();     } } 
package com.fasterxml.jackson.databind.node;  import java.io.IOException;  import static org.junit.Assert.*;  import org.junit.Assert;  import com.fasterxml.jackson.core.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.util.TokenBuffer;  /**  * Unit tests for verifying functionality of {@link JsonNode} methods that  * convert values to other types  */ public class TestConversions extends BaseMapTest {     static class Root {         public Leaf leaf;     }      static class Leaf {         public int value;          public Leaf() { }         public Leaf(int v) { value = v; }     }          // MixIn for [JACKSON-554]     @JsonDeserialize(using = LeafDeserializer.class)     public static class LeafMixIn     {     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      private final static ObjectMapper MAPPER = new ObjectMapper();          public void testAsInt() throws Exception     {         assertEquals(9, IntNode.valueOf(9).asInt());         assertEquals(7, LongNode.valueOf(7L).asInt());         assertEquals(13, new TextNode("13").asInt());         assertEquals(0, new TextNode("foobar").asInt());         assertEquals(27, new TextNode("foobar").asInt(27));         assertEquals(1, BooleanNode.TRUE.asInt());     }      public void testAsBoolean() throws Exception     {         assertEquals(false, BooleanNode.FALSE.asBoolean());         assertEquals(true, BooleanNode.TRUE.asBoolean());         assertEquals(false, IntNode.valueOf(0).asBoolean());         assertEquals(true, IntNode.valueOf(1).asBoolean());         assertEquals(false, LongNode.valueOf(0).asBoolean());         assertEquals(true, LongNode.valueOf(-34L).asBoolean());         assertEquals(true, new TextNode("true").asBoolean());         assertEquals(false, new TextNode("false").asBoolean());         assertEquals(false, new TextNode("barf").asBoolean());         assertEquals(true, new TextNode("barf").asBoolean(true));          assertEquals(true, new POJONode(Boolean.TRUE).asBoolean());     }          // Deserializer to trigger the problem described in [JACKSON-554]     public static class LeafDeserializer extends JsonDeserializer<Leaf>     {         @Override         public Leaf deserialize(JsonParser jp, DeserializationContext ctxt)                 throws IOException, JsonProcessingException         {             JsonNode tree = (JsonNode) jp.readValueAsTree();             Leaf leaf = new Leaf();             leaf.value = tree.get("value").intValue();             return leaf;         }     }      // Test for [JACKSON-554]     public void testTreeToValue() throws Exception     {         String JSON = "{\"leaf\":{\"value\":13}}";         ObjectMapper mapper = new ObjectMapper();         mapper.addMixInAnnotations(Leaf.class, LeafMixIn.class);         JsonNode root = mapper.readTree(JSON);         // Ok, try converting to bean using two mechanisms         Root r1 = mapper.treeToValue(root, Root.class);         assertNotNull(r1);         assertEquals(13, r1.leaf.value);     }      // Test for [JACKSON-631]     public void testBase64Text() throws Exception     {         // let's actually iterate over sets of encoding modes, lengths                  final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };         final Base64Variant[] VARIANTS = {                 Base64Variants.MIME,                 Base64Variants.MIME_NO_LINEFEEDS,                 Base64Variants.MODIFIED_FOR_URL,                 Base64Variants.PEM         };          for (int len : LENS) {             byte[] input = new byte[len];             for (int i = 0; i < input.length; ++i) {                 input[i] = (byte) i;             }             for (Base64Variant variant : VARIANTS) {                 TextNode n = new TextNode(variant.encode(input));                 byte[] data = null;                 try {                     data = n.getBinaryValue(variant);                 } catch (Exception e) {                     throw new IOException("Failed (variant "+variant+", data length "+len+"): "+e.getMessage());                 }                 assertNotNull(data);                 assertArrayEquals(data, input);             }         }     }      static class Issue709Bean {         public byte[] data;     }          /**      * Simple test to verify that byte[] values can be handled properly when      * converting, as long as there is metadata (from POJO definitions).      */     public void testIssue709() throws Exception     {         byte[] inputData = new byte[] { 1, 2, 3 };         ObjectNode node = MAPPER.createObjectNode();         node.put("data", inputData);         Issue709Bean result = MAPPER.treeToValue(node, Issue709Bean.class);         String json = MAPPER.writeValueAsString(node);         Issue709Bean resultFromString = MAPPER.readValue(json, Issue709Bean.class);         Issue709Bean resultFromConvert = MAPPER.convertValue(node, Issue709Bean.class);                  // all methods should work equally well:         Assert.assertArrayEquals(inputData, resultFromString.data);         Assert.assertArrayEquals(inputData, resultFromConvert.data);         Assert.assertArrayEquals(inputData, result.data);     }      public void testEmbeddedObject() throws Exception     {         TokenBuffer buf = new TokenBuffer(MAPPER);         buf.writeObject(new byte[3]);         JsonNode node = MAPPER.readTree(buf.asParser());         buf.close();         assertTrue(node.isBinary());         byte[] data = node.binaryValue();         assertNotNull(data);         assertEquals(3, data.length);     }          private final Object MARKER = new Object();      public void testEmbeddedObjectInArray() throws Exception     {         TokenBuffer buf = new TokenBuffer(MAPPER);         buf.writeStartArray();         buf.writeObject(MARKER);         buf.writeEndArray();         JsonNode node = MAPPER.readTree(buf.asParser());         buf.close();         assertTrue(node.isArray());         assertEquals(1, node.size());         JsonNode n = node.get(0);         assertTrue(n.isPojo());         assertSame(MARKER, ((POJONode) n).getPojo());     }      public void testEmbeddedObjectInObject() throws Exception     {         TokenBuffer buf = new TokenBuffer(MAPPER);         buf.writeStartObject();         buf.writeFieldName("pojo");         buf.writeObject(MARKER);         buf.writeEndObject();         JsonNode node = MAPPER.readTree(buf.asParser());         buf.close();         assertTrue(node.isObject());         assertEquals(1, node.size());         JsonNode n = node.get("pojo");         assertTrue(n.isPojo());         assertSame(MARKER, ((POJONode) n).getPojo());     } }  
package com.fasterxml.jackson.databind.node;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  /**  * Simple tests to verify that [JACKSON-707] is implemented correctly.  */ public class TestDeepCopy extends BaseMapTest {     private final ObjectMapper mapper = new ObjectMapper();          public void testWithObjectSimple()     {         ObjectNode root = mapper.createObjectNode();         root.put("a", 3);         assertEquals(1, root.size());                  ObjectNode copy = root.deepCopy();         assertEquals(1, copy.size());          // adding to root won't change copy:         root.put("b", 7);         assertEquals(2, root.size());         assertEquals(1, copy.size());          // nor vice versa         copy.put("c", 3);         assertEquals(2, root.size());         assertEquals(2, copy.size());     }      public void testWithArraySimple()     {         ArrayNode root = mapper.createArrayNode();         root.add("a");         assertEquals(1, root.size());                  ArrayNode copy = root.deepCopy();         assertEquals(1, copy.size());          // adding to root won't change copy:         root.add( 7);         assertEquals(2, root.size());         assertEquals(1, copy.size());          // nor vice versa         copy.add(3);         assertEquals(2, root.size());         assertEquals(2, copy.size());     }      public void testWithNested()     {         ObjectNode root = mapper.createObjectNode();         ObjectNode leafObject = root.putObject("ob");         ArrayNode leafArray = root.putArray("arr");         assertEquals(2, root.size());          leafObject.put("a", 3);         assertEquals(1, leafObject.size());         leafArray.add(true);         assertEquals(1, leafArray.size());                  ObjectNode copy = root.deepCopy();         assertNotSame(copy, root);         assertEquals(2, copy.size());          // should be detached, once again          leafObject.put("x", 9);         assertEquals(2, leafObject.size());         assertEquals(1, copy.get("ob").size());          leafArray.add("foobar");         assertEquals(2, leafArray.size());         assertEquals(1, copy.get("arr").size());          // nor vice versa         ((ObjectNode) copy.get("ob")).put("c", 3);         assertEquals(2, leafObject.size());         assertEquals(2, copy.get("ob").size());          ((ArrayNode) copy.get("arr")).add(13);         assertEquals(2, leafArray.size());         assertEquals(2, copy.get("arr").size());     } } 
package com.fasterxml.jackson.databind.node;  import java.util.*;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.node.ObjectNode;  public class TestFindMethods     extends BaseMapTest {     public void testNonMatching() throws Exception     {         JsonNode root = _buildTree();          assertNull(root.findValue("boogaboo"));         assertNull(root.findParent("boogaboo"));         JsonNode n = root.findPath("boogaboo");         assertNotNull(n);         assertTrue(n.isMissingNode());          assertTrue(root.findValues("boogaboo").isEmpty());         assertTrue(root.findParents("boogaboo").isEmpty());     }      public void testMatchingSingle() throws Exception     {         JsonNode root = _buildTree();          JsonNode node = root.findValue("b");         assertNotNull(node);         assertEquals(3, node.intValue());         node = root.findParent("b");         assertNotNull(node);         assertTrue(node.isObject());         assertEquals(1, ((ObjectNode) node).size());         assertEquals(3, node.path("b").intValue());     }      public void testMatchingMultiple() throws Exception     {         JsonNode root = _buildTree();          List<JsonNode> nodes = root.findValues("value");         assertEquals(2, nodes.size());         // here we count on nodes being returned in order; true with Jackson:         assertEquals(3, nodes.get(0).intValue());         assertEquals(42, nodes.get(1).intValue());          nodes = root.findParents("value");         assertEquals(2, nodes.size());         // should only return JSON Object nodes:         assertTrue(nodes.get(0).isObject());         assertTrue(nodes.get(1).isObject());         assertEquals(3, nodes.get(0).path("value").intValue());         assertEquals(42, nodes.get(1).path("value").intValue());          // and finally, convenience conversion method         List<String> values = root.findValuesAsText("value");         assertEquals(2, values.size());         assertEquals("3", values.get(0));         assertEquals("42", values.get(1));     }          private JsonNode _buildTree() throws Exception     {         final String SAMPLE = "{ \"a\" : { \"value\" : 3 },"             +"\"array\" : [ { \"b\" : 3 }, {\"value\" : 42}, { \"other\" : true } ]"             +"}";         return new ObjectMapper().readTree(SAMPLE);     } } 
package com.fasterxml.jackson.databind.node;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*;  /**  * Basic tests for {@link JsonNode} base class and some features  * of implementation classes  */ public class TestJsonNode extends NodeTestBase {     public void testText()     {         assertNull(TextNode.valueOf(null));         TextNode empty = TextNode.valueOf("");         assertStandardEquals(empty);         assertSame(TextNode.EMPTY_STRING_NODE, empty);          // 1.6:         assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0);         assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75);              // [JACKSON-587]         long value = 127353264013893L;         TextNode n = TextNode.valueOf(String.valueOf(value));         assertEquals(value, n.asLong());                  // and then with non-numeric input         assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar"));      }      public void testBoolean()     {         BooleanNode f = BooleanNode.getFalse();         assertNotNull(f);         assertTrue(f.isBoolean());         assertSame(f, BooleanNode.valueOf(false));         assertStandardEquals(f);         assertFalse(f.booleanValue());         assertFalse(f.asBoolean());         assertEquals("false", f.asText());         assertEquals(JsonToken.VALUE_FALSE, f.asToken());          // and ditto for true         BooleanNode t = BooleanNode.getTrue();         assertNotNull(t);         assertTrue(t.isBoolean());         assertSame(t, BooleanNode.valueOf(true));         assertStandardEquals(t);         assertTrue(t.booleanValue());         assertTrue(t.asBoolean());         assertEquals("true", t.asText());         assertEquals(JsonToken.VALUE_TRUE, t.asToken());          // 1.6:         assertNodeNumbers(f, 0, 0.0);         assertNodeNumbers(t, 1, 1.0);     }       public void testBinary() throws Exception     {         assertNull(BinaryNode.valueOf(null));         assertNull(BinaryNode.valueOf(null, 0, 0));          BinaryNode empty = BinaryNode.valueOf(new byte[1], 0, 0);         assertSame(BinaryNode.EMPTY_BINARY_NODE, empty);         assertStandardEquals(empty);          byte[] data = new byte[3];         data[1] = (byte) 3;         BinaryNode n = BinaryNode.valueOf(data, 1, 1);         data[2] = (byte) 3;         BinaryNode n2 = BinaryNode.valueOf(data, 2, 1);         assertTrue(n.equals(n2));         assertEquals("\"Aw==\"", n.toString());          assertEquals("AAMD", new BinaryNode(data).asText());          // 1.6:         assertNodeNumbersForNonNumeric(n);     }      public void testPOJO()     {         POJONode n = new POJONode("x"); // not really a pojo but that's ok         assertStandardEquals(n);         assertEquals(n, new POJONode("x"));         assertEquals("x", n.asText());         // not sure if this is what it'll remain as but:         assertEquals("x", n.toString());          assertEquals(new POJONode(null), new POJONode(null));          // 1.6:         // default; non-numeric         assertNodeNumbersForNonNumeric(n);         // but if wrapping actual number, use it         assertNodeNumbers(new POJONode(Integer.valueOf(123)), 123, 123.0);     } } 
package com.fasterxml.jackson.databind.node;  import com.fasterxml.jackson.core.JsonToken;  public class TestMissingNode extends NodeTestBase {     public void testMissing()     {         MissingNode n = MissingNode.getInstance();         assertTrue(n.isMissingNode());         assertEquals(JsonToken.NOT_AVAILABLE, n.asToken());         // as per [JACKSON-775]         assertEquals("", n.asText());         assertStandardEquals(n);         assertEquals("", n.toString());          /* As of 2.0, MissingNode is considered non-numeric, meaning          * that default values are served.          */         assertNodeNumbersForNonNumeric(n);          // [JACKSON-823]         assertTrue(n.asBoolean(true));         assertEquals(4, n.asInt(4));         assertEquals(5L, n.asLong(5));         assertEquals(0.25, n.asDouble(0.25));     } } 
package com.fasterxml.jackson.databind.node;  import java.math.BigDecimal; import java.math.BigInteger;  public class TestNullNode extends NodeTestBase {     public void testBasicsWithNullNode() throws Exception     {         // Let's use something that doesn't add much beyond JsonNode base         NullNode n = NullNode.instance;          // basic properties         assertFalse(n.isContainerNode());         assertFalse(n.isBigDecimal());         assertFalse(n.isBigInteger());         assertFalse(n.isBinary());         assertFalse(n.isBoolean());         assertFalse(n.isPojo());         assertFalse(n.isMissingNode());          // fallback accessors         assertFalse(n.booleanValue());         assertNull(n.numberValue());         assertEquals(0, n.intValue());         assertEquals(0L, n.longValue());         assertEquals(BigDecimal.ZERO, n.decimalValue());         assertEquals(BigInteger.ZERO, n.bigIntegerValue());          assertEquals(0, n.size());         assertFalse(n.elements().hasNext());         assertFalse(n.fieldNames().hasNext());         // path is never null; but does point to missing node         assertNotNull(n.path("xyz"));         assertTrue(n.path("xyz").isMissingNode());          assertFalse(n.has("field"));         assertFalse(n.has(3));          // 1.6:         assertNodeNumbersForNonNumeric(n);     } } 
package com.fasterxml.jackson.databind.node;  import java.math.BigDecimal; import java.math.BigInteger;  import com.fasterxml.jackson.core.JsonParser; import com.fasterxml.jackson.core.JsonToken;  import com.fasterxml.jackson.databind.JsonNode; import com.fasterxml.jackson.databind.ObjectMapper;  /**  * Basic tests for {@link JsonNode} implementations that  * contain numeric values.  */ public class TestNumberNodes extends NodeTestBase {     public void testShort()     {         ShortNode n = ShortNode.valueOf((short) 1);         assertStandardEquals(n);         assertTrue(0 != n.hashCode());         assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());         assertEquals(JsonParser.NumberType.INT, n.numberType());	// should be SHORT         assertEquals(1, n.intValue());         assertEquals(1L, n.longValue());         assertEquals(BigDecimal.ONE, n.decimalValue());         assertEquals(BigInteger.ONE, n.bigIntegerValue());         assertEquals("1", n.asText());          assertNodeNumbers(n, 1, 1.0);          assertTrue(ShortNode.valueOf((short) 0).canConvertToInt());         assertTrue(ShortNode.valueOf(Short.MAX_VALUE).canConvertToInt());         assertTrue(ShortNode.valueOf(Short.MIN_VALUE).canConvertToInt());          assertTrue(ShortNode.valueOf((short) 0).canConvertToLong());         assertTrue(ShortNode.valueOf(Short.MAX_VALUE).canConvertToLong());         assertTrue(ShortNode.valueOf(Short.MIN_VALUE).canConvertToLong());     }      	public void testInt()     {         IntNode n = IntNode.valueOf(1);         assertStandardEquals(n);         assertTrue(0 != n.hashCode());         assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());         assertEquals(JsonParser.NumberType.INT, n.numberType());         assertEquals(1, n.intValue());         assertEquals(1L, n.longValue());         assertEquals(BigDecimal.ONE, n.decimalValue());         assertEquals(BigInteger.ONE, n.bigIntegerValue());         assertEquals("1", n.asText());          assertNodeNumbers(n, 1, 1.0);          assertTrue(IntNode.valueOf(0).canConvertToInt());         assertTrue(IntNode.valueOf(Integer.MAX_VALUE).canConvertToInt());         assertTrue(IntNode.valueOf(Integer.MIN_VALUE).canConvertToInt());          assertTrue(IntNode.valueOf(0).canConvertToLong());         assertTrue(IntNode.valueOf(Integer.MAX_VALUE).canConvertToLong());         assertTrue(IntNode.valueOf(Integer.MIN_VALUE).canConvertToLong());     }      public void testLong()     {         LongNode n = LongNode.valueOf(1L);         assertStandardEquals(n);         assertTrue(0 != n.hashCode());         assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());         assertEquals(JsonParser.NumberType.LONG, n.numberType());         assertEquals(1, n.intValue());         assertEquals(1L, n.longValue());         assertEquals(BigDecimal.ONE, n.decimalValue());         assertEquals(BigInteger.ONE, n.bigIntegerValue());         assertEquals("1", n.asText());          assertNodeNumbers(n, 1, 1.0);          // ok if contains small enough value         assertTrue(LongNode.valueOf(0).canConvertToInt());         assertTrue(LongNode.valueOf(Integer.MAX_VALUE).canConvertToInt());         assertTrue(LongNode.valueOf(Integer.MIN_VALUE).canConvertToInt());         // but not in other cases         assertFalse(LongNode.valueOf(1L + Integer.MAX_VALUE).canConvertToInt());         assertFalse(LongNode.valueOf(-1L + Integer.MIN_VALUE).canConvertToInt());          assertTrue(LongNode.valueOf(0L).canConvertToLong());         assertTrue(LongNode.valueOf(Long.MAX_VALUE).canConvertToLong());         assertTrue(LongNode.valueOf(Long.MIN_VALUE).canConvertToLong());     }      public void testDouble()     {         DoubleNode n = DoubleNode.valueOf(0.25);         assertStandardEquals(n);         assertTrue(0 != n.hashCode());         assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());         assertEquals(JsonParser.NumberType.DOUBLE, n.numberType());         assertEquals(0, n.intValue());         assertEquals(0.25, n.doubleValue());         assertNotNull(n.decimalValue());         assertEquals(BigInteger.ZERO, n.bigIntegerValue());         assertEquals("0.25", n.asText());          // 1.6:         assertNodeNumbers(DoubleNode.valueOf(4.5), 4, 4.5);          assertTrue(DoubleNode.valueOf(0).canConvertToInt());         assertTrue(DoubleNode.valueOf(Integer.MAX_VALUE).canConvertToInt());         assertTrue(DoubleNode.valueOf(Integer.MIN_VALUE).canConvertToInt());         assertFalse(DoubleNode.valueOf(1L + Integer.MAX_VALUE).canConvertToInt());         assertFalse(DoubleNode.valueOf(-1L + Integer.MIN_VALUE).canConvertToInt());          assertTrue(DoubleNode.valueOf(0L).canConvertToLong());         assertTrue(DoubleNode.valueOf(Long.MAX_VALUE).canConvertToLong());         assertTrue(DoubleNode.valueOf(Long.MIN_VALUE).canConvertToLong());     }      // @since 2.2     public void testFloat()     {         FloatNode n = FloatNode.valueOf(0.25f);         assertStandardEquals(n);         assertTrue(0 != n.hashCode());         assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());         assertEquals(JsonParser.NumberType.FLOAT, n.numberType());         assertEquals(0, n.intValue());         assertEquals(0.25, n.doubleValue());         assertEquals(0.25f, n.floatValue());         assertNotNull(n.decimalValue());         assertEquals(BigInteger.ZERO, n.bigIntegerValue());         assertEquals("0.25", n.asText());          // 1.6:         assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f);          assertTrue(FloatNode.valueOf(0).canConvertToInt());         assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt());         assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt());          // rounding errors if we just add/sub 1... so:         assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt());         assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt());          assertTrue(FloatNode.valueOf(0L).canConvertToLong());         assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong());         assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong());     }          public void testDecimalNode() throws Exception     {         DecimalNode n = DecimalNode.valueOf(BigDecimal.ONE);         assertStandardEquals(n);         assertTrue(n.equals(new DecimalNode(BigDecimal.ONE)));         assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());         assertEquals(JsonParser.NumberType.BIG_DECIMAL, n.numberType());         assertTrue(n.isNumber());         assertFalse(n.isIntegralNumber());         assertTrue(n.isBigDecimal());         assertEquals(BigDecimal.ONE, n.numberValue());         assertEquals(1, n.intValue());         assertEquals(1L, n.longValue());         assertEquals(BigDecimal.ONE, n.decimalValue());         assertEquals("1", n.asText());          // 1.6:         assertNodeNumbers(n, 1, 1.0);          assertTrue(DecimalNode.valueOf(BigDecimal.ZERO).canConvertToInt());         assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Integer.MAX_VALUE)).canConvertToInt());         assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Integer.MIN_VALUE)).canConvertToInt());         assertFalse(DecimalNode.valueOf(BigDecimal.valueOf(1L + Integer.MAX_VALUE)).canConvertToInt());         assertFalse(DecimalNode.valueOf(BigDecimal.valueOf(-1L + Integer.MIN_VALUE)).canConvertToInt());          assertTrue(DecimalNode.valueOf(BigDecimal.ZERO).canConvertToLong());         assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Long.MAX_VALUE)).canConvertToLong());         assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Long.MIN_VALUE)).canConvertToLong());     }      public void testBigIntegerNode() throws Exception     {         BigIntegerNode n = BigIntegerNode.valueOf(BigInteger.ONE);         assertStandardEquals(n);         assertTrue(n.equals(new BigIntegerNode(BigInteger.ONE)));         assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());         assertEquals(JsonParser.NumberType.BIG_INTEGER, n.numberType());         assertTrue(n.isNumber());         assertTrue(n.isIntegralNumber());         assertTrue(n.isBigInteger());         assertEquals(BigInteger.ONE, n.numberValue());         assertEquals(1, n.intValue());         assertEquals(1L, n.longValue());         assertEquals(BigInteger.ONE, n.bigIntegerValue());         assertEquals("1", n.asText());                  // 1.6:         assertNodeNumbers(n, 1, 1.0);          BigInteger maxLong = BigInteger.valueOf(Long.MAX_VALUE);                  n = BigIntegerNode.valueOf(maxLong);         assertEquals(Long.MAX_VALUE, n.longValue());          ObjectMapper mapper = new ObjectMapper();         JsonNode n2 = mapper.readTree(maxLong.toString());         assertEquals(Long.MAX_VALUE, n2.longValue());          // then over long limit:         BigInteger beyondLong = maxLong.shiftLeft(2); // 4x max long         n2 = mapper.readTree(beyondLong.toString());         assertEquals(beyondLong, n2.bigIntegerValue());          assertTrue(BigIntegerNode.valueOf(BigInteger.ZERO).canConvertToInt());         assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Integer.MAX_VALUE)).canConvertToInt());         assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Integer.MIN_VALUE)).canConvertToInt());         assertFalse(BigIntegerNode.valueOf(BigInteger.valueOf(1L + Integer.MAX_VALUE)).canConvertToInt());         assertFalse(BigIntegerNode.valueOf(BigInteger.valueOf(-1L + Integer.MIN_VALUE)).canConvertToInt());          assertTrue(BigIntegerNode.valueOf(BigInteger.ZERO).canConvertToLong());         assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Long.MAX_VALUE)).canConvertToLong());         assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Long.MIN_VALUE)).canConvertToLong());     }  } 
package com.fasterxml.jackson.databind.node;  import java.math.BigDecimal; import java.util.*;  import com.fasterxml.jackson.databind.*;  /**  * Additional tests for {@link ObjectNode} container class.  */ public class TestObjectNode     extends BaseMapTest {     private final ObjectMapper MAPPER = new ObjectMapper();      public void testBasics()     {         ObjectNode n = new ObjectNode(JsonNodeFactory.instance);         assertStandardEquals(n);          assertFalse(n.elements().hasNext());         assertFalse(n.fields().hasNext());         assertFalse(n.fieldNames().hasNext());         assertNull(n.get("a"));         assertTrue(n.path("a").isMissingNode());          TextNode text = TextNode.valueOf("x");         n.set("a", text);         assertEquals(1, n.size());         assertTrue(n.elements().hasNext());         assertTrue(n.fields().hasNext());         assertTrue(n.fieldNames().hasNext());         assertSame(text, n.get("a"));         assertSame(text, n.path("a"));         assertNull(n.get("b"));         assertNull(n.get(0)); // not used with objects          assertFalse(n.has(0));         assertFalse(n.hasNonNull(0));         assertTrue(n.has("a"));         assertTrue(n.hasNonNull("a"));         assertFalse(n.has("b"));         assertFalse(n.hasNonNull("b"));          ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance);         n2.put("b", 13);         assertFalse(n.equals(n2));         n.setAll(n2);                  assertEquals(2, n.size());         n.set("null", (JsonNode)null);         assertEquals(3, n.size());         // may be non-intuitive, but explicit nulls do exist in tree:         assertTrue(n.has("null"));         assertFalse(n.hasNonNull("null"));         // should replace, not add         n.put("null", "notReallNull");         assertEquals(3, n.size());         assertNotNull(n.remove("null"));         assertEquals(2, n.size());          Map<String,JsonNode> nodes = new HashMap<String,JsonNode>();         nodes.put("d", text);         n.setAll(nodes);         assertEquals(3, n.size());          n.removeAll();         assertEquals(0, n.size());     }      /**      * Verify null handling      */     public void testNullChecking()     {         ObjectNode o1 = JsonNodeFactory.instance.objectNode();         ObjectNode o2 = JsonNodeFactory.instance.objectNode();         // used to throw NPE before fix:         o1.setAll(o2);         assertEquals(0, o1.size());         assertEquals(0, o2.size());          // also: nulls should be converted to NullNodes...         o1.set("x", null);         JsonNode n = o1.get("x");         assertNotNull(n);         assertSame(n, NullNode.instance);          o1.put("str", (String) null);         n = o1.get("str");         assertNotNull(n);         assertSame(n, NullNode.instance);          o1.put("d", (BigDecimal) null);         n = o1.get("d");         assertNotNull(n);         assertSame(n, NullNode.instance);     }      /**      * Another test to verify [JACKSON-227]...      */     public void testNullChecking2()     {         ObjectNode src = MAPPER.createObjectNode();         ObjectNode dest = MAPPER.createObjectNode();         src.put("a", "b");         dest.setAll(src);     }      public void testRemove()     {         ObjectNode ob = MAPPER.createObjectNode();         ob.put("a", "a");         ob.put("b", "b");         ob.put("c", "c");         assertEquals(3, ob.size());         assertSame(ob, ob.without(Arrays.asList("a", "c")));         assertEquals(1, ob.size());         assertEquals("b", ob.get("b").textValue());     }      public void testRetain()     {         ObjectNode ob = MAPPER.createObjectNode();         ob.put("a", "a");         ob.put("b", "b");         ob.put("c", "c");         assertEquals(3, ob.size());         assertSame(ob, ob.retain("a", "c"));         assertEquals(2, ob.size());         assertEquals("a", ob.get("a").textValue());         assertNull(ob.get("b"));         assertEquals("c", ob.get("c").textValue());     }      public void testValidWith() throws Exception     {         ObjectNode root = MAPPER.createObjectNode();         assertEquals("{}", MAPPER.writeValueAsString(root));         JsonNode child = root.with("prop");         assertTrue(child instanceof ObjectNode);         assertEquals("{\"prop\":{}}", MAPPER.writeValueAsString(root));     }      public void testValidWithArray() throws Exception     {         ObjectNode root = MAPPER.createObjectNode();         assertEquals("{}", MAPPER.writeValueAsString(root));         JsonNode child = root.withArray("arr");         assertTrue(child instanceof ArrayNode);         assertEquals("{\"arr\":[]}", MAPPER.writeValueAsString(root));     }      public void testInvalidWith() throws Exception     {         JsonNode root = MAPPER.createArrayNode();         try { // should not work for non-ObjectNode nodes:             root.with("prop");             fail("Expected exception");         } catch (UnsupportedOperationException e) {             verifyException(e, "not of type ObjectNode");         }         // also: should fail of we already have non-object property         ObjectNode root2 = MAPPER.createObjectNode();         root2.put("prop", 13);         try { // should not work for non-ObjectNode nodes:             root2.with("prop");             fail("Expected exception");         } catch (UnsupportedOperationException e) {             verifyException(e, "has value that is not");         }     }      public void testInvalidWithArray() throws Exception     {         JsonNode root = MAPPER.createArrayNode();         try { // should not work for non-ObjectNode nodes:             root.withArray("prop");             fail("Expected exception");         } catch (UnsupportedOperationException e) {             verifyException(e, "not of type ObjectNode");         }         // also: should fail of we already have non-Array property         ObjectNode root2 = MAPPER.createObjectNode();         root2.put("prop", 13);         try { // should not work for non-ObjectNode nodes:             root2.withArray("prop");             fail("Expected exception");         } catch (UnsupportedOperationException e) {             verifyException(e, "has value that is not");         }     }      // [Issue#93]     public void testSetAll() throws Exception     {         ObjectNode root = MAPPER.createObjectNode();         assertEquals(0, root.size());         HashMap<String,JsonNode> map = new HashMap<String,JsonNode>();         map.put("a", root.numberNode(1));         root.setAll(map);         assertEquals(1, root.size());         assertTrue(root.has("a"));         assertFalse(root.has("b"));          map.put("b", root.numberNode(2));         root.setAll(map);         assertEquals(2, root.size());         assertTrue(root.has("a"));         assertTrue(root.has("b"));         assertEquals(2, root.path("b").intValue());          // Then with ObjectNodes...         ObjectNode root2 = MAPPER.createObjectNode();         root2.setAll(root);         assertEquals(2, root.size());         assertEquals(2, root2.size());          root2.setAll(root);         assertEquals(2, root.size());         assertEquals(2, root2.size());          ObjectNode root3 = MAPPER.createObjectNode();         root3.put("a", 2);         root3.put("c", 3);         assertEquals(2, root3.path("a").intValue());         root3.setAll(root2);         assertEquals(3, root3.size());         assertEquals(1, root3.path("a").intValue());     } } 
package com.fasterxml.jackson.databind.node;  import java.io.*;  import com.fasterxml.jackson.databind.*;  /**  * This unit test suite tries to verify that JsonNode-based trees  * can be deserialized as expected.  */ public class TestTreeDeserialization     extends BaseMapTest {     final static class Bean {         int _x;         JsonNode _node;          public void setX(int x) { _x = x; }         public void setNode(JsonNode n) { _node = n; }     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      /**      * This test checks that is possible to mix "regular" Java objects      * and JsonNode.      */     public void testMixed() throws IOException     {         ObjectMapper om = new ObjectMapper();         String JSON = "{\"node\" : { \"a\" : 3 }, \"x\" : 9 }";         Bean bean = om.readValue(JSON, Bean.class);          assertEquals(9, bean._x);         JsonNode n = bean._node;         assertNotNull(n);         assertEquals(1, n.size());         ObjectNode on = (ObjectNode) n;         assertEquals(3, on.get("a").intValue());     }      /// Verifying [JACKSON-143]     public void testArrayNodeEquality()     {         ArrayNode n1 = new ArrayNode(null);         ArrayNode n2 = new ArrayNode(null);          assertTrue(n1.equals(n2));         assertTrue(n2.equals(n1));          n1.add(TextNode.valueOf("Test"));          assertFalse(n1.equals(n2));         assertFalse(n2.equals(n1));          n2.add(TextNode.valueOf("Test"));          assertTrue(n1.equals(n2));         assertTrue(n2.equals(n1));     }      public void testObjectNodeEquality()     {         ObjectNode n1 = new ObjectNode(null);         ObjectNode n2 = new ObjectNode(null);          assertTrue(n1.equals(n2));         assertTrue(n2.equals(n1));          n1.set("x", TextNode.valueOf("Test"));          assertFalse(n1.equals(n2));         assertFalse(n2.equals(n1));          n2.set("x", TextNode.valueOf("Test"));          assertTrue(n1.equals(n2));         assertTrue(n2.equals(n1));     }      public void testReadFromString() throws Exception     {         String json = "{\"field\":\"{\\\"name\\\":\\\"John Smith\\\"}\"}";         ObjectMapper mapper = new ObjectMapper();         JsonNode jNode = mapper.readValue(json, JsonNode.class);          String generated = mapper.writeValueAsString( jNode);  //back slashes are gone         JsonNode out = mapper.readValue( generated, JsonNode.class );   //crashes here         assertTrue(out.isObject());         assertEquals(1, out.size());         String value = out.path("field").asText();         assertNotNull(value);     }      // Issue#186     public void testNullHandling() throws Exception     {         // First, a stand-alone null         JsonNode n = objectReader().readTree("null");         assertNotNull(n);         assertTrue(n.isNull());          n = objectMapper().readTree("null");         assertNotNull(n);         assertTrue(n.isNull());                  // Then object property         ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}");         assertEquals(1, root.size());         n = root.get("x");         assertNotNull(n);         assertTrue(n.isNull());     } } 
package com.fasterxml.jackson.databind.node;  import java.io.*; import java.math.BigDecimal; import java.util.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.test.BaseTest;  /**  * This unit test suite tries to verify that ObjectMapper  * can properly parse JSON and bind contents into appropriate  * JsonNode instances.  */ public class TestTreeMapperDeserializer     extends BaseTest { 	public void testSimple()         throws Exception     {         final String JSON = SAMPLE_DOC_JSON_SPEC;          ObjectMapper mapper = new ObjectMapper();          for (int type = 0; type < 2; ++type) {             JsonNode result;              if (type == 0) {                 result = mapper.readTree(new StringReader(JSON));             } else {                 result = mapper.readTree(JSON);             }              assertType(result, ObjectNode.class);             assertEquals(1, result.size());             assertTrue(result.isObject());                          ObjectNode main = (ObjectNode) result;             assertEquals("Image", main.fieldNames().next());             JsonNode ob = main.elements().next();             assertType(ob, ObjectNode.class);             ObjectNode imageMap = (ObjectNode) ob;                          assertEquals(5, imageMap.size());             ob = imageMap.get("Width");             assertTrue(ob.isIntegralNumber());             assertFalse(ob.isFloatingPointNumber());             assertEquals(SAMPLE_SPEC_VALUE_WIDTH, ob.intValue());             ob = imageMap.get("Height");             assertTrue(ob.isIntegralNumber());             assertEquals(SAMPLE_SPEC_VALUE_HEIGHT, ob.intValue());                          ob = imageMap.get("Title");             assertTrue(ob.isTextual());             assertEquals(SAMPLE_SPEC_VALUE_TITLE, ob.textValue());                          ob = imageMap.get("Thumbnail");             assertType(ob, ObjectNode.class);             ObjectNode tn = (ObjectNode) ob;             ob = tn.get("Url");             assertTrue(ob.isTextual());             assertEquals(SAMPLE_SPEC_VALUE_TN_URL, ob.textValue());             ob = tn.get("Height");             assertTrue(ob.isIntegralNumber());             assertEquals(SAMPLE_SPEC_VALUE_TN_HEIGHT, ob.intValue());             ob = tn.get("Width");             assertTrue(ob.isTextual());             assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, ob.textValue());                          ob = imageMap.get("IDs");             assertTrue(ob.isArray());             ArrayNode idList = (ArrayNode) ob;             assertEquals(4, idList.size());             assertEquals(4, calcLength(idList.elements()));             assertEquals(4, calcLength(idList.iterator()));             {                 int[] values = new int[] {                     SAMPLE_SPEC_VALUE_TN_ID1,                     SAMPLE_SPEC_VALUE_TN_ID2,                     SAMPLE_SPEC_VALUE_TN_ID3,                     SAMPLE_SPEC_VALUE_TN_ID4                 };                 for (int i = 0; i < values.length; ++i) {                     assertEquals(values[i], idList.get(i).intValue());                 }                 int i = 0;                 for (JsonNode n : idList) {                     assertEquals(values[i], n.intValue());                     ++i;                 }             }         }     }      public void testBoolean()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         JsonNode result = mapper.readTree("true\n");         assertFalse(result.isNull());         assertFalse(result.isNumber());         assertFalse(result.isTextual());         assertTrue(result.isBoolean());         assertType(result, BooleanNode.class);         assertTrue(result.booleanValue());         assertEquals("true", result.asText());         assertFalse(result.isMissingNode());          // also, equality should work ok         assertEquals(result, BooleanNode.valueOf(true));         assertEquals(result, BooleanNode.getTrue());     }      public void testDouble()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         double value = 3.04;         JsonNode result = mapper.readTree(String.valueOf(value));         assertTrue(result.isNumber());         assertFalse(result.isNull());         assertType(result, DoubleNode.class);         assertTrue(result.isFloatingPointNumber());         assertTrue(result.isDouble());         assertFalse(result.isInt());         assertFalse(result.isLong());         assertFalse(result.isIntegralNumber());         assertFalse(result.isTextual());         assertFalse(result.isMissingNode());          assertEquals(value, result.doubleValue());         assertEquals(value, result.numberValue().doubleValue());         assertEquals((int) value, result.intValue());         assertEquals((long) value, result.longValue());         assertEquals(String.valueOf(value), result.asText());          // also, equality should work ok         assertEquals(result, DoubleNode.valueOf(value));     }      public void testInt()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         int value = -90184;         JsonNode result = mapper.readTree(String.valueOf(value));         assertTrue(result.isNumber());         assertTrue(result.isIntegralNumber());         assertTrue(result.isInt());         assertType(result, IntNode.class);         assertFalse(result.isLong());         assertFalse(result.isFloatingPointNumber());         assertFalse(result.isDouble());         assertFalse(result.isNull());         assertFalse(result.isTextual());         assertFalse(result.isMissingNode());          assertEquals(value, result.numberValue().intValue());         assertEquals(value, result.intValue());         assertEquals(String.valueOf(value), result.asText());         assertEquals((double) value, result.doubleValue());         assertEquals((long) value, result.longValue());          // also, equality should work ok         assertEquals(result, IntNode.valueOf(value));     }      public void testLong()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         // need to use something being 32-bit value space         long value = 12345678L << 32;         JsonNode result = mapper.readTree(String.valueOf(value));         assertTrue(result.isNumber());         assertTrue(result.isIntegralNumber());         assertTrue(result.isLong());         assertType(result, LongNode.class);         assertFalse(result.isInt());         assertFalse(result.isFloatingPointNumber());         assertFalse(result.isDouble());         assertFalse(result.isNull());         assertFalse(result.isTextual());         assertFalse(result.isMissingNode());          assertEquals(value, result.numberValue().longValue());         assertEquals(value, result.longValue());         assertEquals(String.valueOf(value), result.asText());         assertEquals((double) value, result.doubleValue());          // also, equality should work ok         assertEquals(result, LongNode.valueOf(value));     }      public void testNull()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         JsonNode result = mapper.readTree("   null ");         // should not get java null, but NullNode...         assertNotNull(result);         assertTrue(result.isNull());         assertFalse(result.isNumber());         assertFalse(result.isTextual());         assertEquals("null", result.asText());          // also, equality should work ok         assertEquals(result, NullNode.instance);     }      public void testDecimalNode()         throws Exception     {         // no "natural" way to get it, must construct         BigDecimal value = new BigDecimal("0.1");         JsonNode result = DecimalNode.valueOf(value);          assertFalse(result.isArray());         assertFalse(result.isObject());         assertTrue(result.isNumber());         assertFalse(result.isIntegralNumber());         assertFalse(result.isLong());         assertType(result, DecimalNode.class);         assertFalse(result.isInt());         assertTrue(result.isFloatingPointNumber());         assertTrue(result.isBigDecimal());         assertFalse(result.isDouble());         assertFalse(result.isNull());         assertFalse(result.isTextual());         assertFalse(result.isMissingNode());          assertEquals(value, result.numberValue());         assertEquals(value.toString(), result.asText());          // also, equality should work ok         assertEquals(result, DecimalNode.valueOf(value));     }      public void testSimpleArray() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         ArrayNode result = mapper.createArrayNode();          assertTrue(result.isArray());         assertType(result, ArrayNode.class);          assertFalse(result.isObject());         assertFalse(result.isNumber());         assertFalse(result.isNull());         assertFalse(result.isTextual());          // and let's add stuff...         result.add(false);         result.insertNull(0);          // should be equal to itself no matter what         assertEquals(result, result);         assertFalse(result.equals(null)); // but not to null          // plus see that we can access stuff         assertEquals(NullNode.instance, result.path(0));         assertEquals(NullNode.instance, result.get(0));         assertEquals(BooleanNode.FALSE, result.path(1));         assertEquals(BooleanNode.FALSE, result.get(1));         assertEquals(2, result.size());          assertNull(result.get(-1));         assertNull(result.get(2));         JsonNode missing = result.path(2);         assertTrue(missing.isMissingNode());         assertTrue(result.path(-100).isMissingNode());          // then construct and compare         ArrayNode array2 = mapper.createArrayNode();         array2.addNull();         array2.add(false);         assertEquals(result, array2);          // plus remove entries         JsonNode rm1 = array2.remove(0);         assertEquals(NullNode.instance, rm1);         assertEquals(1, array2.size());         assertEquals(BooleanNode.FALSE, array2.get(0));         assertFalse(result.equals(array2));          JsonNode rm2 = array2.remove(0);         assertEquals(BooleanNode.FALSE, rm2);         assertEquals(0, array2.size());     }      /**      * Type mappers should be able to gracefully deal with end of      * input.      */     public void testEOF() throws Exception     {         String JSON =             "{ \"key\": [ { \"a\" : { \"name\": \"foo\",  \"type\": 1\n"             +"},  \"type\": 3, \"url\": \"http://www.google.com\" } ],\n"             +"\"name\": \"xyz\", \"type\": 1, \"url\" : null }\n  "             ;         JsonFactory jf = new JsonFactory();         ObjectMapper mapper = new ObjectMapper();         JsonParser jp = jf.createParser(new StringReader(JSON));         JsonNode result = mapper.readTree(jp);          assertTrue(result.isObject());         assertEquals(4, result.size());          assertNull(mapper.readTree(jp));     }      public void testMultiple() throws Exception     {         String JSON = "12  \"string\" [ 1, 2, 3 ]";         JsonFactory jf = new JsonFactory();         ObjectMapper mapper = new ObjectMapper();         JsonParser jp = jf.createParser(new StringReader(JSON));         JsonNode result = mapper.readTree(jp);          assertTrue(result.isIntegralNumber());         assertTrue(result.isInt());         assertFalse(result.isTextual());         assertEquals(12, result.intValue());          result = mapper.readTree(jp);         assertTrue(result.isTextual());         assertFalse(result.isIntegralNumber());         assertFalse(result.isInt());         assertEquals("string", result.textValue());          result = mapper.readTree(jp);         assertTrue(result.isArray());         assertEquals(3, result.size());          assertNull(mapper.readTree(jp));     }      /**      * Let's also verify behavior of "MissingNode" -- one needs to be able      * to traverse such bogus nodes with appropriate methods.      */     @SuppressWarnings("unused")     public void testMissingNode()         throws Exception     {         String JSON = "[ { }, [ ] ]";         ObjectMapper mapper = new ObjectMapper();         JsonNode result = mapper.readTree(new StringReader(JSON));          assertTrue(result.isContainerNode());         assertTrue(result.isArray());         assertEquals(2, result.size());          int count = 0;         for (JsonNode node : result) {             ++count;         }         assertEquals(2, count);          Iterator<JsonNode> it = result.iterator();          JsonNode onode = it.next();         assertTrue(onode.isContainerNode());         assertTrue(onode.isObject());         assertEquals(0, onode.size());         assertFalse(onode.isMissingNode()); // real node         assertNull(onode.textValue());          // how about dereferencing?         assertNull(onode.get(0));         JsonNode dummyNode = onode.path(0);         assertNotNull(dummyNode);         assertTrue(dummyNode.isMissingNode());         assertNull(dummyNode.get(3));         assertNull(dummyNode.get("whatever"));         JsonNode dummyNode2 = dummyNode.path(98);         assertNotNull(dummyNode2);         assertTrue(dummyNode2.isMissingNode());         JsonNode dummyNode3 = dummyNode.path("field");         assertNotNull(dummyNode3);         assertTrue(dummyNode3.isMissingNode());          // and same for the array node          JsonNode anode = it.next();         assertTrue(anode.isContainerNode());         assertTrue(anode.isArray());         assertFalse(anode.isMissingNode()); // real node         assertEquals(0, anode.size());          assertNull(anode.get(0));         dummyNode = anode.path(0);         assertNotNull(dummyNode);         assertTrue(dummyNode.isMissingNode());         assertNull(dummyNode.get(0));         assertNull(dummyNode.get("myfield"));         dummyNode2 = dummyNode.path(98);         assertNotNull(dummyNode2);         assertTrue(dummyNode2.isMissingNode());         dummyNode3 = dummyNode.path("f");         assertNotNull(dummyNode3);         assertTrue(dummyNode3.isMissingNode());     }      public void testArray() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         final String JSON = "[[[-0.027512,51.503221],[-0.008497,51.503221],[-0.008497,51.509744],[-0.027512,51.509744]]]";          JsonNode n = mapper.readTree(JSON);         assertNotNull(n);         assertTrue(n.isArray());         ArrayNode an = (ArrayNode) n;         assertEquals(1, an.size());         ArrayNode an2 = (ArrayNode) n.get(0);         assertTrue(an2.isArray());         assertEquals(4, an2.size());     }          /*     /**********************************************     /* Helper methods     /**********************************************      */      private int calcLength(Iterator<JsonNode> it)     {         int count = 0;         while (it.hasNext()) {             it.next();             ++count;         }         return count;     } }  
package com.fasterxml.jackson.databind.node;  import java.util.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.test.BaseTest;  /**  * Unit tests to verify that Json Objects map property to Map-like  * ObjectNodes.  */ public class TestTreeMapperMaps     extends BaseTest {     public void testSimpleObject() throws Exception     {         String JSON = "{ \"key\" : 1, \"b\" : \"x\" }";         ObjectMapper mapper = new ObjectMapper();         JsonNode root = mapper.readTree(JSON);          // basic properties first:         assertFalse(root.isValueNode());         assertTrue(root.isContainerNode());         assertFalse(root.isArray());         assertTrue(root.isObject());         assertEquals(2, root.size());          // Related to [JACKSON-50]:         Iterator<JsonNode> it = root.iterator();         assertNotNull(it);         assertTrue(it.hasNext());         JsonNode n = it.next();         assertNotNull(n);         assertEquals(IntNode.valueOf(1), n);          assertTrue(it.hasNext());         n = it.next();         assertNotNull(n);         assertEquals(TextNode.valueOf("x"), n);          assertFalse(it.hasNext());          // Ok, then, let's traverse via extended interface         ObjectNode obNode = (ObjectNode) root;         Iterator<Map.Entry<String,JsonNode>> fit = obNode.fields();         // we also know that LinkedHashMap is used, i.e. order preserved         assertTrue(fit.hasNext());         Map.Entry<String,JsonNode> en = fit.next();         assertEquals("key", en.getKey());         assertEquals(IntNode.valueOf(1), en.getValue());          assertTrue(fit.hasNext());         en = fit.next();         assertEquals("b", en.getKey());         assertEquals(TextNode.valueOf("x"), en.getValue());          // Plus: we should be able to modify the node via iterator too:         fit.remove();         assertEquals(1, obNode.size());         assertEquals(IntNode.valueOf(1), root.get("key"));         assertNull(root.get("b"));     }      public void testSimplePath() throws Exception     {         JsonNode root = new ObjectMapper().readTree("{ \"results\" : { \"a\" : 3 } }");         assertTrue(root.isObject());         JsonNode rnode = root.path("results");         assertNotNull(rnode);         assertTrue(rnode.isObject());         assertEquals(3, rnode.path("a").intValue());     }  } 
package com.fasterxml.jackson.databind.node;  import static org.junit.Assert.*;  import java.io.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.test.BaseTest;  /**  * This unit test suite tries to verify that the trees ObjectMapper  * constructs can be serialized properly.  */ public class TestTreeMapperSerializer     extends BaseTest {     final static String FIELD1 = "first";     final static String FIELD2 = "Second?";     final static String FIELD3 = "foo'n \"bar\"";     final static String FIELD4 = "4";      final static String TEXT1 = "Some text & \"stuff\"";     final static String TEXT2 = "Some more text:\twith\nlinefeeds and all!";      final static double DOUBLE_VALUE = 9.25;      public void testFromArray()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         ArrayNode root = mapper.createArrayNode();         root.add(TEXT1);         root.add(3);         ObjectNode obj = root.addObject();         obj.put(FIELD1, true);         obj.putArray(FIELD2);         root.add(false);          /* Ok, ready... let's serialize using one of two alternate          * methods: first preferred (using generator)          * (there are 2 variants here too)          */         for (int i = 0; i < 2; ++i) {             StringWriter sw = new StringWriter();             if (i == 0) {                 JsonGenerator gen = new JsonFactory().createGenerator(sw);                 root.serialize(gen, null);                 gen.close();             } else {                 mapper.writeValue(sw, root);             }             verifyFromArray(sw.toString());         }                      // And then convenient but less efficient alternative:         verifyFromArray(root.toString());     }      public void testFromMap()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         ObjectNode root = mapper.createObjectNode();         root.put(FIELD4, TEXT2);         root.put(FIELD3, -1);         root.putArray(FIELD2);         root.put(FIELD1, DOUBLE_VALUE);          /* Let's serialize using one of two alternate methods:          * first preferred (using generator)          * (there are 2 variants here too)          */         for (int i = 0; i < 2; ++i) {             StringWriter sw = new StringWriter();             if (i == 0) {                 JsonGenerator gen = new JsonFactory().createGenerator(sw);                 root.serialize(gen, null);                 gen.close();             } else {                 mapper.writeValue(sw, root);             }             verifyFromMap(sw.toString());         }          // And then convenient but less efficient alternative:         verifyFromMap(root.toString());     }      /**      * Unit test to check for regression of [JACKSON-18].      */     public void testSmallNumbers()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         ArrayNode root = mapper.createArrayNode();         for (int i = -20; i <= 20; ++i) {             JsonNode n = root.numberNode(i);             root.add(n);             // Hmmh. Not sure why toString() won't be triggered otherwise...             assertEquals(String.valueOf(i), n.toString());         }          // Loop over 2 different serialization methods         for (int type = 0; type < 2; ++type) {             StringWriter sw = new StringWriter();             if (type == 0) {                 JsonGenerator gen = new JsonFactory().createGenerator(sw);                 root.serialize(gen, null);                 gen.close();             } else {                 mapper.writeValue(sw, root);             }                          String doc = sw.toString();             JsonParser jp = new JsonFactory().createParser(new StringReader(doc));                          assertEquals(JsonToken.START_ARRAY, jp.nextToken());             for (int i = -20; i <= 20; ++i) {                 assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                 assertEquals(i, jp.getIntValue());                 assertEquals(""+i, jp.getText());             }             assertEquals(JsonToken.END_ARRAY, jp.nextToken());             jp.close();         }     }      public void testNull() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         StringWriter sw = new StringWriter();         mapper.writeValue(sw, NullNode.instance);         assertEquals("null", sw.toString());     }      public void testBinary()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         final int LENGTH = 13045;         byte[] data = new byte[LENGTH];         for (int i = 0; i < LENGTH; ++i) {             data[i] = (byte) i;         }         StringWriter sw = new StringWriter();         mapper.writeValue(sw, BinaryNode.valueOf(data));          JsonParser jp = new JsonFactory().createParser(sw.toString());         // note: can't determine it's binary from json alone:         assertToken(JsonToken.VALUE_STRING, jp.nextToken());         assertArrayEquals(data, jp.getBinaryValue());         jp.close();     }      /*     ///////////////////////////////////////////////////////////////     // Internal methods     ///////////////////////////////////////////////////////////////      */      private void verifyFromArray(String input)         throws Exception     {         JsonParser jp = new JsonFactory().createParser(new StringReader(input));                  assertEquals(JsonToken.START_ARRAY, jp.nextToken());                  assertEquals(JsonToken.VALUE_STRING, jp.nextToken());         assertEquals(TEXT1, getAndVerifyText(jp));                  assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertEquals(3, jp.getIntValue());                  assertEquals(JsonToken.START_OBJECT, jp.nextToken());         assertEquals(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals(FIELD1, getAndVerifyText(jp));                  assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());         assertEquals(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals(FIELD2, getAndVerifyText(jp));                  assertEquals(JsonToken.START_ARRAY, jp.nextToken());         assertEquals(JsonToken.END_ARRAY, jp.nextToken());         assertEquals(JsonToken.END_OBJECT, jp.nextToken());                  assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());                  assertEquals(JsonToken.END_ARRAY, jp.nextToken());         assertNull(jp.nextToken());     }      private void verifyFromMap(String input)         throws Exception     {         JsonParser jp = new JsonFactory().createParser(new StringReader(input));         assertEquals(JsonToken.START_OBJECT, jp.nextToken());         assertEquals(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals(FIELD4, getAndVerifyText(jp));         assertEquals(JsonToken.VALUE_STRING, jp.nextToken());         assertEquals(TEXT2, getAndVerifyText(jp));                  assertEquals(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals(FIELD3, getAndVerifyText(jp));         assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertEquals(-1, jp.getIntValue());                  assertEquals(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals(FIELD2, getAndVerifyText(jp));         assertEquals(JsonToken.START_ARRAY, jp.nextToken());         assertEquals(JsonToken.END_ARRAY, jp.nextToken());                  assertEquals(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals(FIELD1, getAndVerifyText(jp));         assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());         assertEquals(DOUBLE_VALUE, jp.getDoubleValue(), 0);                  assertEquals(JsonToken.END_OBJECT, jp.nextToken());                  assertNull(jp.nextToken());     } } 
package com.fasterxml.jackson.databind.node;  import java.util.*;  import static org.junit.Assert.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.node.BinaryNode; import com.fasterxml.jackson.databind.node.ObjectNode; import com.fasterxml.jackson.databind.node.POJONode; import com.fasterxml.jackson.databind.node.TextNode;  public class TestTreeTraversingParser     extends BaseMapTest {     static class Person {         public String name;         public int magicNumber;         public List<String> kids;     }      // Helper class for [JACKSON-370]     @JsonIgnoreProperties(ignoreUnknown=true)     public static class Jackson370Bean {         public Inner inner;     }      public static class Inner {         public String value;     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */          public void testSimple() throws Exception     {         // For convenience, parse tree from JSON first         final String JSON =             "{ \"a\" : 123, \"list\" : [ 12.25, null, true, { }, [ ] ] }";         ObjectMapper m = new ObjectMapper();         JsonNode tree = m.readTree(JSON);         JsonParser jp = tree.traverse();          assertNull(jp.getCurrentToken());         assertNull(jp.getCurrentName());          assertToken(JsonToken.START_OBJECT, jp.nextToken());         assertNull(jp.getCurrentName());         assertEquals("Expected START_OBJECT", JsonToken.START_OBJECT.asString(), jp.getText());          assertToken(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals("a", jp.getCurrentName());         assertEquals("a", jp.getText());          assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertEquals("a", jp.getCurrentName());         assertEquals(123, jp.getIntValue());         assertEquals("123", jp.getText());          assertToken(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals("list", jp.getCurrentName());         assertEquals("list", jp.getText());          assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertEquals("list", jp.getCurrentName());         assertEquals(JsonToken.START_ARRAY.asString(), jp.getText());          assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());         assertNull(jp.getCurrentName());         assertEquals(12.25, jp.getDoubleValue(), 0);         assertEquals("12.25", jp.getText());          assertToken(JsonToken.VALUE_NULL, jp.nextToken());         assertNull(jp.getCurrentName());         assertEquals(JsonToken.VALUE_NULL.asString(), jp.getText());          assertToken(JsonToken.VALUE_TRUE, jp.nextToken());         assertNull(jp.getCurrentName());         assertTrue(jp.getBooleanValue());         assertEquals(JsonToken.VALUE_TRUE.asString(), jp.getText());          assertToken(JsonToken.START_OBJECT, jp.nextToken());         assertNull(jp.getCurrentName());         assertToken(JsonToken.END_OBJECT, jp.nextToken());         assertNull(jp.getCurrentName());          assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertNull(jp.getCurrentName());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertNull(jp.getCurrentName());          assertToken(JsonToken.END_ARRAY, jp.nextToken());          assertToken(JsonToken.END_OBJECT, jp.nextToken());         assertNull(jp.getCurrentName());          assertNull(jp.nextToken());          jp.close();         assertTrue(jp.isClosed());     }      public void testArray() throws Exception     {         // For convenience, parse tree from JSON first         ObjectMapper m = new ObjectMapper();          JsonParser jp = m.readTree("[]").traverse();         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         jp.close();          jp = m.readTree("[[]]").traverse();         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         jp.close();          jp = m.readTree("[[ 12.1 ]]").traverse();         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         jp.close();     }          public void testNested() throws Exception     {         // For convenience, parse tree from JSON first         final String JSON =             "{\"coordinates\":[[[-3,\n1],[179.859681,51.175092]]]}"             ;         ObjectMapper m = new ObjectMapper();         JsonNode tree = m.readTree(JSON);         JsonParser jp = tree.traverse();         assertToken(JsonToken.START_OBJECT, jp.nextToken());         assertToken(JsonToken.FIELD_NAME, jp.nextToken());          assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.START_ARRAY, jp.nextToken());          assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());          assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());         assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());                  assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());          assertToken(JsonToken.END_OBJECT, jp.nextToken());     }          /**      * Unit test that verifies that we can (re)parse sample document      * from JSON specification.      */     public void testSpecDoc() throws Exception     {         ObjectMapper m = new ObjectMapper();         JsonNode tree = m.readTree(SAMPLE_DOC_JSON_SPEC);         JsonParser jp = tree.traverse();          verifyJsonSpecSampleDoc(jp, true);     }      public void testBinaryPojo() throws Exception     {         byte[] inputBinary = new byte[] { 1, 2, 100 };         POJONode n = new POJONode(inputBinary);         JsonParser jp = n.traverse();          assertNull(jp.getCurrentToken());         assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken());         byte[] data = jp.getBinaryValue();         assertNotNull(data);         assertArrayEquals(inputBinary, data);         Object pojo = jp.getEmbeddedObject();         assertSame(data, pojo);     }      public void testBinaryNode() throws Exception     {         byte[] inputBinary = new byte[] { 0, -5 };         BinaryNode n = new BinaryNode(inputBinary);         JsonParser jp = n.traverse();          assertNull(jp.getCurrentToken());         // exposed as POJO... not as VALUE_STRING         assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken());         byte[] data = jp.getBinaryValue();         assertNotNull(data);         assertArrayEquals(inputBinary, data);          // but as importantly, can be viewed as base64 encoded thing:         assertEquals("APs=", jp.getText());          assertNull(jp.nextToken());     }      public void testTextAsBinary() throws Exception     {         TextNode n = new TextNode("   APs=\n");         JsonParser jp = n.traverse();         assertNull(jp.getCurrentToken());         assertToken(JsonToken.VALUE_STRING, jp.nextToken());         byte[] data = jp.getBinaryValue();         assertNotNull(data);         assertArrayEquals(new byte[] { 0, -5 }, data);          assertNull(jp.nextToken());         jp.close();         assertTrue(jp.isClosed());          // Also: let's verify we get an exception for garbage...         n = new TextNode("?!??");         jp = n.traverse();         assertToken(JsonToken.VALUE_STRING, jp.nextToken());         try {             jp.getBinaryValue();         } catch (JsonParseException e) {             verifyException(e, "Illegal character");         }     }      /**      * Very simple test case to verify that tree-to-POJO      * conversion works ok      */     public void testDataBind() throws Exception     {         ObjectMapper m = new ObjectMapper();         JsonNode tree = m.readTree             ("{ \"name\" : \"Tatu\", \n"              +"\"magicNumber\" : 42,"              +"\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n"              +"}");         Person tatu = m.treeToValue(tree, Person.class);         assertNotNull(tatu);         assertEquals(42, tatu.magicNumber);         assertEquals("Tatu", tatu.name);         assertNotNull(tatu.kids);         assertEquals(3, tatu.kids.size());         assertEquals("Leo", tatu.kids.get(0));         assertEquals("Lila", tatu.kids.get(1));         assertEquals("Leia", tatu.kids.get(2));     }      // [JACKSON-370]     public void testSkipChildrenWrt370() throws Exception     {         ObjectMapper o = new ObjectMapper();         ObjectNode n = o.createObjectNode();         n.putObject("inner").put("value", "test");         n.putObject("unknown").putNull("inner");         Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class);         assertNotNull(obj.inner);         assertEquals("test", obj.inner.value);             } }  
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * This unit test suite tests use of Annotations for  * bean serialization.  */ public class TestAnnotationInheritance     extends com.fasterxml.jackson.test.BaseTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      /// Base class for testing {@link JsonProperty} annotations     static class BasePojo     {         @JsonProperty public int width() { return 3; }         @JsonProperty public int length() { return 7; }     }      /**      * It should also be possible to specify annotations on interfaces,      * to be implemented by classes. This should not only work when interface      * is used (which may be the case for de-serialization) but also      * when implementing class is used and overrides methods. In latter      * case overriding methods should still "inherit" annotations -- this      * is not something JVM runtime provides, but Jackson class      * instrospector does.      */     interface PojoInterface     {         @JsonProperty int width();         @JsonProperty int length();     }      /**      * Sub-class for testing that inheritance is handled properly      * wrt annotations.      */     static class PojoSubclass extends BasePojo     {         /**          * Should still be recognized as a Getter here.          */         @Override         public int width() { return 9; }     }      static class PojoImpl implements PojoInterface     {         // Both should be recognized as getters here          @Override         public int width() { return 1; }         @Override         public int length() { return 2; }          public int getFoobar() { return 5; }     }      /*     /**********************************************************     /* Main tests     /**********************************************************      */      public void testSimpleGetterInheritance() throws Exception     {         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new PojoSubclass());         assertEquals(2, result.size());         assertEquals(Integer.valueOf(7), result.get("length"));         assertEquals(Integer.valueOf(9), result.get("width"));     }      public void testSimpleGetterInterfaceImpl() throws Exception     {         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new PojoImpl());         // should get 2 from interface, and one more from impl itself         assertEquals(3, result.size());         assertEquals(Integer.valueOf(5), result.get("foobar"));         assertEquals(Integer.valueOf(1), result.get("width"));         assertEquals(Integer.valueOf(2), result.get("length"));     }      /*     //////////////////////////////////////////////     // Helper methods     //////////////////////////////////////////////      */      @SuppressWarnings("unchecked") 	private Map<String,Object> writeAndMap(ObjectMapper m, Object value)         throws IOException     {         StringWriter sw = new StringWriter();         m.writeValue(sw, value);         return (Map<String,Object>) m.readValue(sw.toString(), Object.class);     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.util.*;   import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.core.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  /**  * This unit test suite tests use of Annotations for  * bean serialization.  */ public class TestAnnotations     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      /// Class for testing {@link JsonProperty} annotations with getters     final static class SizeClassGetter     {         @JsonProperty public int size() { return 3; }         @JsonProperty("length") public int foobar() { return -17; }         // note: need not be public since there's annotation         @JsonProperty protected int value() { return 0; }          // dummy method; not a getter signature         protected int getNotReally(int arg) { return 0; }     }      // And additional testing to cover [JACKSON-64]     final static class SizeClassGetter2     {         // Should still be considered property "x"         @JsonProperty protected int getX() { return 3; }     }      // and some support for testing [JACKSON-120]     final static class SizeClassGetter3     {         // Should be considered property "y" even tho non-public         @JsonSerialize protected int getY() { return 8; }     }       /**      * Class for testing {@link JsonSerializer} annotation      * for class itself.      */     @JsonSerialize(using=BogusSerializer.class)     final static class ClassSerializer {     }      /**      * Class for testing an active {@link JsonSerialize#using} annotation      * for a method      */     final static class ClassMethodSerializer {         private int _x;          public ClassMethodSerializer(int x) { _x = x; }          @JsonSerialize(using=StringSerializer.class)         public int getX() { return _x; }     }      /**      * Class for testing an inactive (one that will not have any effect)      * {@link JsonSerialize} annotation for a method      */     final static class InactiveClassMethodSerializer {         private int _x;          public InactiveClassMethodSerializer(int x) { _x = x; }          // Basically, has no effect, hence gets serialized as number         @JsonSerialize(using=JsonSerializer.None.class)         public int getX() { return _x; }     }      /**      * Class for verifying that getter information is inherited      * as expected via normal class inheritance      */     static class BaseBean {         public int getX() { return 1; }         @JsonProperty("y")         private int getY() { return 2; }     }      static class SubClassBean extends BaseBean {         public int getZ() { return 3; }     }      // For [JACKSON-666] ("SerializationFeature of the Beast!")     @JsonPropertyOrder(alphabetic=true)     static class GettersWithoutSetters     {         public int d = 0;                  @JsonCreator         public GettersWithoutSetters(@JsonProperty("a") int a) { }                  // included, since there is a constructor property         public int getA() { return 3; }          // not included, as there's nothing matching         public int getB() { return 4; }          // include as there is setter         public int getC() { return 5; }         public void setC(int v) { }          // and included, as there is a field         public int getD() { return 6; }     }      // [JACKSON-806]: override 'need-setter' with explicit annotation     static class GettersWithoutSetters2     {         @JsonProperty         public int getA() { return 123; }     }          /*     /**********************************************************     /* Other helper classes     /**********************************************************      */      public final static class BogusSerializer extends JsonSerializer<Object>     {         @Override         public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonGenerationException         {             jgen.writeBoolean(true);         }     }      private final static class StringSerializer extends JsonSerializer<Object>     {         @Override         public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonGenerationException         {             jgen.writeString("X"+value+"X");         }      }      /*     /**********************************************************     /* Main tests     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testSimpleGetter() throws Exception     {         Map<String,Object> result = writeAndMap(MAPPER, new SizeClassGetter());         assertEquals(3, result.size());         assertEquals(Integer.valueOf(3), result.get("size"));         assertEquals(Integer.valueOf(-17), result.get("length"));         assertEquals(Integer.valueOf(0), result.get("value"));     }      public void testSimpleGetter2() throws Exception     {         Map<String,Object> result = writeAndMap(MAPPER, new SizeClassGetter2());         assertEquals(1, result.size());         assertEquals(Integer.valueOf(3), result.get("x"));     }      // testing [JACKSON-120], implied getter     public void testSimpleGetter3() throws Exception     {         Map<String,Object> result = writeAndMap(MAPPER, new SizeClassGetter3());         assertEquals(1, result.size());         assertEquals(Integer.valueOf(8), result.get("y"));     }      /**      * Let's also verify that inherited super-class getters are used      * as expected      */     public void testGetterInheritance() throws Exception     {         Map<String,Object> result = writeAndMap(MAPPER, new SubClassBean());         assertEquals(3, result.size());         assertEquals(Integer.valueOf(1), result.get("x"));         assertEquals(Integer.valueOf(2), result.get("y"));         assertEquals(Integer.valueOf(3), result.get("z"));     }      /**      * Unit test to verify that {@link JsonSerialize#using} annotation works      * when applied to a class      */     public void testClassSerializer() throws Exception     {         StringWriter sw = new StringWriter();         MAPPER.writeValue(sw, new ClassSerializer());         assertEquals("true", sw.toString());     }      /**      * Unit test to verify that @JsonSerializer annotation works      * when applied to a Method      */     public void testActiveMethodSerializer() throws Exception     {         StringWriter sw = new StringWriter();         MAPPER.writeValue(sw, new ClassMethodSerializer(13));         /* Here we will get wrapped as an object, since we have          * full object, just override a single property          */         assertEquals("{\"x\":\"X13X\"}", sw.toString());     }      public void testInactiveMethodSerializer() throws Exception     {         String json = MAPPER.writeValueAsString(new InactiveClassMethodSerializer(8));         /* Here we will get wrapped as an object, since we have          * full object, just override a single property          */         assertEquals("{\"x\":8}", json);     }      public void testGettersWithoutSetters() throws Exception     {         ObjectMapper m = new ObjectMapper();         GettersWithoutSetters bean = new GettersWithoutSetters(123);         assertFalse(m.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS));              // by default, all 4 found:         assertEquals("{\"a\":3,\"b\":4,\"c\":5,\"d\":6}", m.writeValueAsString(bean));          // but 3 if we require mutator:         m = new ObjectMapper();         m.enable(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS);         assertEquals("{\"a\":3,\"c\":5,\"d\":6}", m.writeValueAsString(bean));     }      public void testGettersWithoutSettersOverride() throws Exception     {         GettersWithoutSetters2 bean = new GettersWithoutSetters2();         ObjectMapper m = new ObjectMapper();         m.enable(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS);         assertEquals("{\"a\":123}", m.writeValueAsString(bean));     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature;  public class TestAnyGetter     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      static class Bean     {         final static Map<String,Boolean> extra = new HashMap<String,Boolean>();         static {             extra.put("a", Boolean.TRUE);         }                  public int getX() { return 3; }          @JsonAnyGetter         public Map<String,Boolean> getExtra() { return extra; }     }      static class AnyOnlyBean     {         @JsonAnyGetter         public Map<String,Integer> any() {             HashMap<String,Integer> map = new HashMap<String,Integer>();             map.put("a", 3);             return map;         }     }      /*     /**********************************************************     /* Test cases     /**********************************************************      */      public void testSimpleJsonValue() throws Exception     {         ObjectMapper m = new ObjectMapper();         String json = serializeAsString(m, new Bean());         Map<?,?> map = m.readValue(json, Map.class);         assertEquals(2, map.size());         assertEquals(Integer.valueOf(3), map.get("x"));         assertEquals(Boolean.TRUE, map.get("a"));     }      // [JACKSON-392]     public void testAnyOnly() throws Exception     {         ObjectMapper m;          // First, with normal fail settings:         m = new ObjectMapper();         m.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, true);         String json = serializeAsString(m, new AnyOnlyBean());         assertEquals("{\"a\":3}", json);          // then without fail         m = new ObjectMapper();         m.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);         json = serializeAsString(m, new AnyOnlyBean());         assertEquals("{\"a\":3}", json);     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.test.BaseTest;  public class TestArraySerialization     extends BaseTest {     private final ObjectMapper MAPPER = new ObjectMapper();          public void testLongStringArray() throws Exception     {         final int SIZE = 40000;          StringBuilder sb = new StringBuilder(SIZE*2);         for (int i = 0; i < SIZE; ++i) {             sb.append((char) i);         }         String str = sb.toString();         byte[] data = MAPPER.writeValueAsBytes(new String[] { "abc", str, null, str });         JsonParser jp = MAPPER.getFactory().createParser(data);         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.VALUE_STRING, jp.nextToken());         assertEquals("abc", jp.getText());         assertToken(JsonToken.VALUE_STRING, jp.nextToken());         String actual = jp.getText();         assertEquals(str.length(), actual.length());         assertEquals(str, actual);         assertToken(JsonToken.VALUE_NULL, jp.nextToken());         assertToken(JsonToken.VALUE_STRING, jp.nextToken());         assertEquals(str, jp.getText());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertNull(jp.nextToken());     }          public void testIntArray() throws Exception     {         StringWriter sw = new StringWriter();         MAPPER.writeValue(sw, new int[] { 1, 2, 3, -7 });         assertEquals("[1,2,3,-7]", sw.toString().trim());     }      public void testBigIntArray() throws Exception     {         final int SIZE = 99999;         int[] ints = new int[SIZE];         for (int i = 0; i < ints.length; ++i) {             ints[i] = i;         }          // Let's try couple of times, to ensure that state is handled         // correctly by ObjectMapper (wrt buffer recycling used         // with 'writeAsBytes()')         JsonFactory f = MAPPER.getFactory();         for (int round = 0; round < 3; ++round) {             byte[] data = MAPPER.writeValueAsBytes(ints);             JsonParser jp = f.createParser(data);             assertToken(JsonToken.START_ARRAY, jp.nextToken());             for (int i = 0; i < SIZE; ++i) {                 assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                 assertEquals(i, jp.getIntValue());             }             assertToken(JsonToken.END_ARRAY, jp.nextToken());         }     }          public void testLongArray() throws Exception     {         StringWriter sw = new StringWriter();         MAPPER.writeValue(sw, new long[] { Long.MIN_VALUE, 0, Long.MAX_VALUE });         assertEquals("["+Long.MIN_VALUE+",0,"+Long.MAX_VALUE+"]", sw.toString().trim());     }      public void testStringArray() throws Exception     {         StringWriter sw = new StringWriter();         MAPPER.writeValue(sw, new String[] { "a", "\"foo\"", null });         assertEquals("[\"a\",\"\\\"foo\\\"\",null]", sw.toString().trim());     }      public void testDoubleArray() throws Exception     {         StringWriter sw = new StringWriter();         MAPPER.writeValue(sw, new double[] { 1.01, 2.0, -7, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY });         assertEquals("[1.01,2.0,-7.0,\"NaN\",\"-Infinity\",\"Infinity\"]", sw.toString().trim());     }      public void testFloatArray() throws Exception     {         StringWriter sw = new StringWriter();         MAPPER.writeValue(sw, new float[] { 1.01f, 2.0f, -7f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY });         assertEquals("[1.01,2.0,-7.0,\"NaN\",\"-Infinity\",\"Infinity\"]", sw.toString().trim());     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.introspect.VisibilityChecker;  /**  * Unit tests for checking extended auto-detect configuration,  * in context of serialization  */ public class TestAutoDetect     extends BaseMapTest {     static class FieldBean     {         public String p1 = "public";         protected String p2 = "protected";         @SuppressWarnings("unused")         private String p3 = "private";     }      @JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC)     static class ProtFieldBean extends FieldBean { }      static class MethodBean     {         public String getA() { return "a"; }         protected String getB() { return "b"; }         @SuppressWarnings("unused")         private String getC() { return "c"; }     }      @JsonAutoDetect(getterVisibility=JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC)     static class ProtMethodBean extends MethodBean { }      /*     /*********************************************************     /* Test methods     /*********************************************************      */      public void testDefaults() throws Exception     {         ObjectMapper m = new ObjectMapper();         // by default, only public fields and getters are detected         assertEquals("{\"p1\":\"public\"}",                      m.writeValueAsString(new FieldBean()));         assertEquals("{\"a\":\"a\"}",                      m.writeValueAsString(new MethodBean()));     }      public void testProtectedViaAnnotations() throws Exception     {         ObjectMapper m = new ObjectMapper();          Map<String,Object> result = writeAndMap(m, new ProtFieldBean());         assertEquals(2, result.size());         assertEquals("public", result.get("p1"));         assertEquals("protected", result.get("p2"));         assertNull(result.get("p3"));          result = writeAndMap(m, new ProtMethodBean());         assertEquals(2, result.size());         assertEquals("a", result.get("a"));         assertEquals("b", result.get("b"));         assertNull(result.get("c"));     }      public void testPrivateUsingGlobals() throws Exception     {         ObjectMapper m = new ObjectMapper();         VisibilityChecker<?> vc = m.getVisibilityChecker();         vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY);         m.setVisibilityChecker(vc);                  Map<String,Object> result = writeAndMap(m, new FieldBean());         assertEquals(3, result.size());         assertEquals("public", result.get("p1"));         assertEquals("protected", result.get("p2"));         assertEquals("private", result.get("p3"));          m = new ObjectMapper();         vc = m.getVisibilityChecker();         vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY);         m.setVisibilityChecker(vc);         result = writeAndMap(m, new MethodBean());         assertEquals(3, result.size());         assertEquals("a", result.get("a"));         assertEquals("b", result.get("b"));         assertEquals("c", result.get("c"));     }      // [JACKSON-621]     public void testBasicSetup() throws Exception     {         ObjectMapper m = new ObjectMapper();         VisibilityChecker<?> vc = m.getVisibilityChecker();         vc = vc.with(JsonAutoDetect.Visibility.ANY);         m.setVisibilityChecker(vc);          Map<String,Object> result = writeAndMap(m, new FieldBean());         assertEquals(3, result.size());         assertEquals("public", result.get("p1"));         assertEquals("protected", result.get("p2"));         assertEquals("private", result.get("p3"));     }      // [JACKSON-595]     public void testMapperShortcutMethods() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);          Map<String,Object> result = writeAndMap(m, new FieldBean());         assertEquals(3, result.size());         assertEquals("public", result.get("p1"));         assertEquals("protected", result.get("p2"));         assertEquals("private", result.get("p3"));     }  } 
package com.fasterxml.jackson.databind.ser;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.core.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.introspect.AnnotatedField; import com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.BeanPropertyWriter; import com.fasterxml.jackson.databind.ser.BeanSerializer; import com.fasterxml.jackson.databind.ser.BeanSerializerBuilder; import com.fasterxml.jackson.databind.ser.BeanSerializerModifier; import com.fasterxml.jackson.databind.ser.std.StdSerializer; import com.fasterxml.jackson.databind.type.ArrayType; import com.fasterxml.jackson.databind.type.CollectionType; import com.fasterxml.jackson.databind.type.MapType;  /**  * Unit tests for verifying that it is possible to configure  * construction of {@link BeanSerializer} instances.  */ @SuppressWarnings("serial") public class TestBeanSerializer extends BaseMapTest {     /*     /********************************************************     /* Helper types     /********************************************************      */      static class ModuleImpl extends SimpleModule     {         protected BeanSerializerModifier modifier;                  public ModuleImpl(BeanSerializerModifier modifier)         {             super("test", Version.unknownVersion());             this.modifier = modifier;         }                  @Override         public void setupModule(SetupContext context)         {             super.setupModule(context);             if (modifier != null) {                 context.addBeanSerializerModifier(modifier);             }         }     }      @JsonPropertyOrder({"b", "a"})     static class Bean {         public String b = "b";         public String a = "a";     }      static class RemovingModifier extends BeanSerializerModifier     {         private final String _removedProperty;                  public RemovingModifier(String remove) { _removedProperty = remove; }                  @Override         public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc,                 List<BeanPropertyWriter> beanProperties)         {             Iterator<BeanPropertyWriter> it = beanProperties.iterator();             while (it.hasNext()) {                 BeanPropertyWriter bpw = it.next();                 if (bpw.getName().equals(_removedProperty)) {                     it.remove();                 }             }             return beanProperties;         }     }          static class ReorderingModifier extends BeanSerializerModifier     {         @Override         public List<BeanPropertyWriter> orderProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)         {             TreeMap<String,BeanPropertyWriter> props = new TreeMap<String,BeanPropertyWriter>();             for (BeanPropertyWriter bpw : beanProperties) {                 props.put(bpw.getName(), bpw);             }             return new ArrayList<BeanPropertyWriter>(props.values());         }     }      static class ReplacingModifier extends BeanSerializerModifier     {         private final JsonSerializer<?> _serializer;                  public ReplacingModifier(JsonSerializer<?> s) { _serializer = s; }                  @Override         public JsonSerializer<?> modifySerializer(SerializationConfig config, BeanDescription beanDesc,                 JsonSerializer<?> serializer) {             return _serializer;         }     }      static class BuilderModifier extends BeanSerializerModifier     {         private final JsonSerializer<?> _serializer;                  public BuilderModifier(JsonSerializer<?> ser) {             _serializer = ser;         }                  @Override         public BeanSerializerBuilder updateBuilder(SerializationConfig config,                 BeanDescription beanDesc, BeanSerializerBuilder builder) {             return new BogusSerializerBuilder(builder, _serializer);         }     }      static class BogusSerializerBuilder extends BeanSerializerBuilder     {         private final JsonSerializer<?> _serializer;                  public BogusSerializerBuilder(BeanSerializerBuilder src,                 JsonSerializer<?> ser) {             super(src);             _serializer = ser;         }          @Override         public JsonSerializer<?> build() {             return _serializer;         }     }          static class BogusBeanSerializer extends JsonSerializer<Object>     {         private final int _value;                  public BogusBeanSerializer(int v) { _value = v; }                  @Override         public void serialize(Object value, JsonGenerator jgen,                 SerializerProvider provider) throws IOException {             jgen.writeNumber(_value);         }     }      // for [JACKSON-670]          static class EmptyBean {         @JsonIgnore         public String name = "foo";     }      static class EmptyBeanModifier extends BeanSerializerModifier     {         @Override         public List<BeanPropertyWriter> changeProperties(SerializationConfig config,                 BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)         {             JavaType strType = config.constructType(String.class);             // we need a valid BeanPropertyDefinition; this will do (just need name to match)             POJOPropertyBuilder prop = new POJOPropertyBuilder("bogus", null, true);             try {                 AnnotatedField f = new AnnotatedField(EmptyBean.class.getDeclaredField("name"), null);                 beanProperties.add(new BeanPropertyWriter(prop, f, null,                         strType,                         null, null, strType,                         false, null));             } catch (NoSuchFieldException e) {                 throw new IllegalStateException(e.getMessage());             }             return beanProperties;         }     }      // For [JACKSON-694]: error message for conflicting getters sub-optimal     static class BeanWithConflict     {         public int getX() { return 3; }         public boolean isX() { return false; }     }      // [Issue#120], arrays, collections, maps          static class ArraySerializerModifier extends BeanSerializerModifier {         @Override         public JsonSerializer<?> modifyArraySerializer(SerializationConfig config,                 ArrayType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {             return new StdSerializer<Object>(Object.class) {                 @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {                     jgen.writeNumber(123);                 }             };         }     }      static class CollectionSerializerModifier extends BeanSerializerModifier {         @Override         public JsonSerializer<?> modifyCollectionSerializer(SerializationConfig config,                 CollectionType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {             return new StdSerializer<Object>(Object.class) {                 @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {                     jgen.writeNumber(123);                 }             };         }     }      static class MapSerializerModifier extends BeanSerializerModifier {         @Override         public JsonSerializer<?> modifyMapSerializer(SerializationConfig config,                 MapType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {             return new StdSerializer<Object>(Object.class) {                 @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {                     jgen.writeNumber(123);                 }             };         }     }      static class EnumSerializerModifier extends BeanSerializerModifier {         @Override         public JsonSerializer<?> modifyEnumSerializer(SerializationConfig config,                 JavaType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {             return new StdSerializer<Object>(Object.class) {                 @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {                     jgen.writeNumber(123);                 }             };         }     }      static class KeySerializerModifier extends BeanSerializerModifier {         @Override         public JsonSerializer<?> modifyKeySerializer(SerializationConfig config,                 JavaType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {             return new StdSerializer<Object>(Object.class) {                 @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {                     jgen.writeFieldName("foo");                 }             };         }     }          enum EnumABC { A, B, C };          /*     /********************************************************     /* Unit tests: success     /********************************************************      */      public void testPropertyRemoval() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new ModuleImpl(new RemovingModifier("a")));         Bean bean = new Bean();         assertEquals("{\"b\":\"b\"}", mapper.writeValueAsString(bean));     }      public void testPropertyReorder() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new ModuleImpl(new ReorderingModifier()));         Bean bean = new Bean();         assertEquals("{\"a\":\"a\",\"b\":\"b\"}", mapper.writeValueAsString(bean));     }      public void testBuilderReplacement() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new ModuleImpl(new BuilderModifier(new BogusBeanSerializer(17))));         Bean bean = new Bean();         assertEquals("17", mapper.writeValueAsString(bean));     }         public void testSerializerReplacement() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new ModuleImpl(new ReplacingModifier(new BogusBeanSerializer(123))));         Bean bean = new Bean();         assertEquals("123", mapper.writeValueAsString(bean));     }      // for [JACKSON-670]     public void testEmptyBean() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test", Version.unknownVersion()) {             @Override             public void setupModule(SetupContext context)             {                 super.setupModule(context);                 context.addBeanSerializerModifier(new EmptyBeanModifier());             }         });         String json = mapper.writeValueAsString(new EmptyBean());         assertEquals("{\"bogus\":\"foo\"}", json);     }      // [Issue#121]      public void testModifyArraySerializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setSerializerModifier(new ArraySerializerModifier()));         assertEquals("123", mapper.writeValueAsString(new Integer[] { 1, 2 }));     }      public void testModifyCollectionSerializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setSerializerModifier(new CollectionSerializerModifier()));         assertEquals("123", mapper.writeValueAsString(new ArrayList<Integer>()));     }      public void testModifyMapSerializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setSerializerModifier(new MapSerializerModifier()));         assertEquals("123", mapper.writeValueAsString(new HashMap<String,String>()));     }      public void testModifyEnumSerializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setSerializerModifier(new EnumSerializerModifier()));         assertEquals("123", mapper.writeValueAsString(EnumABC.C));     }      public void testModifyKeySerializer() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.registerModule(new SimpleModule("test")             .setSerializerModifier(new KeySerializerModifier()));         Map<String,Integer> map = new HashMap<String,Integer>();         map.put("x", 3);         assertEquals("{\"foo\":3}", mapper.writeValueAsString(map));     }          /*     /********************************************************     /* Unit tests: failure handling     /********************************************************      */          // for [JACKSON-694]     public void testFailWithDupProps() throws Exception     {         BeanWithConflict bean = new BeanWithConflict();         ObjectMapper mapper = new ObjectMapper();         try {             String json = mapper.writeValueAsString(bean);             fail("Should have failed due to conflicting accessor definitions; got JSON = "+json);         } catch (JsonProcessingException e) {             verifyException(e, "Conflicting getter definitions");         }     }         } 
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  public class TestCollectionSerialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      enum Key { A, B, C };      // Field-based simple bean with a single property, "values"     final static class CollectionBean     {         @JsonProperty // not required             public Collection<Object> values;          public CollectionBean(Collection<Object> c) { values = c; }     }      static class EnumMapBean     {         EnumMap<Key,String> _map;          public EnumMapBean(EnumMap<Key,String> m)         {             _map = m;         }          public EnumMap<Key,String> getMap() { return _map; }     }      final static class IterableWrapper         implements Iterable<Integer>     {         List<Integer> _ints = new ArrayList<Integer>();          public IterableWrapper(int[] values) {             for (int i : values) {                 _ints.add(Integer.valueOf(i));             }         }          @Override         public Iterator<Integer> iterator() {             return _ints.iterator();         }     }      /**      * Class needed for testing [JACKSON-220]      */     @SuppressWarnings("serial")     @JsonSerialize(using=ListSerializer.class)         static class PseudoList extends ArrayList<String>     {         public PseudoList(String... values) {             super(Arrays.asList(values));         }     }      static class ListSerializer extends JsonSerializer<List<String>>     {         @Override         public void serialize(List<String> value,                               JsonGenerator jgen,                               SerializerProvider provider)             throws IOException         {             // just use standard List.toString(), output as JSON String             jgen.writeString(value.toString());         }     }      // for [JACKSON-254], suppression of empty collections     static class EmptyListBean {         public List<String> empty = new ArrayList<String>();     }      static class EmptyArrayBean {         public String[] empty = new String[0];     }      // [JACKSON-689]     static class BeanWithIterable {         private final ArrayList<String> values = new ArrayList<String>();         {             values.add("value");         }          public Iterable<String> getValues() { return values; }     }      static class IntIterable implements Iterable<Integer>     {         @Override         public Iterator<Integer> iterator() {             return new IntIterator(1, 3);         }     }      static class IntIterator implements Iterator<Integer> {         int i;         final int last;          public IntIterator(int first, int last) {             i = first;             this.last = last;         }          @Override         public boolean hasNext() {             return i <= last;         }          @Override         public Integer next() {             return i++;         }          @Override         public void remove() { }          public int getX() { return 13; }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final static ObjectMapper MAPPER = new ObjectMapper();      public void testCollections()         throws IOException     {         // Let's try different collections, arrays etc         final int entryLen = 98;          for (int type = 0; type < 4; ++type) {             Object value;              if (type == 0) { // first, array                 int[] ints = new int[entryLen];                 for (int i = 0; i < entryLen; ++i) {                     ints[i] = Integer.valueOf(i);                 }                 value = ints;             } else {                 Collection<Integer> c;                  switch (type) {                 case 1:                     c = new LinkedList<Integer>();                     break;                 case 2:                     c = new TreeSet<Integer>(); // has to be ordered                     break;                 default:                     c = new ArrayList<Integer>();                     break;                 }                 for (int i = 0; i < entryLen; ++i) {                     c.add(Integer.valueOf(i));                 }                 value = c;             }             String json = MAPPER.writeValueAsString(value);                          // and then need to verify:             JsonParser jp = new JsonFactory().createParser(json);             assertToken(JsonToken.START_ARRAY, jp.nextToken());             for (int i = 0; i < entryLen; ++i) {                 assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                 assertEquals(i, jp.getIntValue());             }             assertToken(JsonToken.END_ARRAY, jp.nextToken());         }     }      public void testBigCollection()         throws IOException     {         final int COUNT = 9999;         ArrayList<Integer> value = new ArrayList<Integer>();         for (int i = 0; i <= COUNT; ++i) {             value.add(i);         }         // Let's test using 3 main variants...         for (int mode = 0; mode < 3; ++mode) {             JsonParser jp = null;             switch (mode) {             case 0:                 {                     byte[] data = MAPPER.writeValueAsBytes(value);                     jp = new JsonFactory().createParser(data);                 }                 break;             case 1:                 {                     StringWriter sw = new StringWriter(value.size());                     MAPPER.writeValue(sw, value);                     jp = createParserUsingReader(sw.toString());                 }                 break;             case 2:                 {                     String str = MAPPER.writeValueAsString(value);                     jp = createParserUsingReader(str);                 }                 break;             }              // and verify             assertToken(JsonToken.START_ARRAY, jp.nextToken());             for (int i = 0; i <= COUNT; ++i) {                 assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());                 assertEquals(i, jp.getIntValue());             }             assertToken(JsonToken.END_ARRAY, jp.nextToken());             jp.close();         }     }      public void testEnumMap()         throws IOException     {         EnumMap<Key,String> map = new EnumMap<Key,String>(Key.class);         map.put(Key.B, "xyz");         map.put(Key.C, "abc");         // assuming EnumMap uses enum entry order, which I think is true...         String json = MAPPER.writeValueAsString(map);         assertEquals("{\"B\":\"xyz\",\"C\":\"abc\"}",json.trim());     }      public void testIterator()         throws IOException     {         StringWriter sw = new StringWriter();         ArrayList<Integer> l = new ArrayList<Integer>();         l.add(1);         l.add(-9);         l.add(0);         MAPPER.writeValue(sw, l.iterator());         assertEquals("[1,-9,0]", sw.toString().trim());     }      public void testIterable()         throws IOException     {         StringWriter sw = new StringWriter();         MAPPER.writeValue(sw, new IterableWrapper(new int[] { 1, 2, 3 }));         assertEquals("[1,2,3]", sw.toString().trim());     }      // Test that checks that empty collections are properly serialized     // when they are Bean properties     @SuppressWarnings("unchecked")     public void testEmptyBeanCollection()         throws IOException     {         Collection<Object> x = new ArrayList<Object>();         x.add("foobar");         CollectionBean cb = new CollectionBean(x);         Map<String,Object> result = writeAndMap(MAPPER, cb);         assertEquals(1, result.size());         assertTrue(result.containsKey("values"));         Collection<Object> x2 = (Collection<Object>) result.get("values");         assertNotNull(x2);         assertEquals(x, x2);     }      public void testNullBeanCollection()         throws IOException     {         CollectionBean cb = new CollectionBean(null);         Map<String,Object> result = writeAndMap(MAPPER, cb);         assertEquals(1, result.size());         assertTrue(result.containsKey("values"));         assertNull(result.get("values"));     }      @SuppressWarnings("unchecked")     public void testEmptyBeanEnumMap()         throws IOException     {         EnumMap<Key,String> map = new EnumMap<Key,String>(Key.class);         EnumMapBean b = new EnumMapBean(map);         Map<String,Object> result = writeAndMap(MAPPER, b);          assertEquals(1, result.size());         assertTrue(result.containsKey("map"));         // we deserialized to untyped, not back to bean, so:         Map<Object,Object> map2 = (Map<Object,Object>) result.get("map");         assertNotNull(map2);         assertEquals(0, map2.size());     }      // Should also be able to serialize null EnumMaps as expected     public void testNullBeanEnumMap()         throws IOException     {         EnumMapBean b = new EnumMapBean(null);         Map<String,Object> result = writeAndMap(MAPPER, b);          assertEquals(1, result.size());         assertTrue(result.containsKey("map"));         assertNull(result.get("map"));     }      // Test [JACKSON-220]     public void testListSerializer() throws IOException     {         assertEquals("\"[ab, cd, ef]\"",                 MAPPER.writeValueAsString(new PseudoList("ab", "cd", "ef")));     }      // [JACKSON-254]     public void testEmptyListOrArray() throws IOException     {         // by default, empty lists serialized normally         EmptyListBean list = new EmptyListBean();         EmptyArrayBean array = new EmptyArrayBean();         assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS));         assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(list));         assertEquals("{\"empty\":[]}", MAPPER.writeValueAsString(array));          // note: value of setting may be cached when constructing serializer, need a new instance         ObjectMapper m = new ObjectMapper();         m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false);         assertEquals("{}", m.writeValueAsString(list));         assertEquals("{}", m.writeValueAsString(array));     }          // [JACKSON-689], [JACKSON-876]     public void testWithIterable() throws IOException     {         // 689:         assertEquals("{\"values\":[\"value\"]}",                 MAPPER.writeValueAsString(new BeanWithIterable()));         // 876:         assertEquals("[1,2,3]",                 MAPPER.writeValueAsString(new IntIterable()));     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.StringWriter; import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.introspect.ClassIntrospector;  /**  * Unit tests for checking handling of SerializationConfig.  */ public class TestConfig     extends BaseMapTest {     /*     /**********************************************************     /* Helper beans     /**********************************************************      */      @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT,                    typing=JsonSerialize.Typing.STATIC)     final static class Config { }      final static class ConfigNone { }      static class AnnoBean {         public int getX() { return 1; }         @JsonProperty("y")         private int getY() { return 2; }     }      static class Indentable {         public int a = 3;     }      public static class SimpleBean {         public int x = 1;     }          /*     /**********************************************************     /* Main tests     /**********************************************************      */      final static ObjectMapper MAPPER = new ObjectMapper();      /* Test to verify that we don't overflow number of features; if we      * hit the limit, need to change implementation -- this test just      * gives low-water mark      */     public void testEnumIndexes()     {         int max = 0;                  for (SerializationFeature f : SerializationFeature.values()) {             max = Math.max(max, f.ordinal());         }         if (max >= 31) { // 31 is actually ok; 32 not             fail("Max number of SerializationFeature enums reached: "+max);         }     }          public void testDefaults()     {         SerializationConfig cfg = MAPPER.getSerializationConfig();          // First, defaults:         assertTrue(cfg.isEnabled(MapperFeature.USE_ANNOTATIONS));         assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));         assertTrue(cfg.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS));          assertTrue(cfg.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));          assertFalse(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT));         assertFalse(cfg.isEnabled(MapperFeature.USE_STATIC_TYPING));          // since 1.3:         assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS));         // since 1.4                  assertTrue(cfg.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS));         // since 1.5         assertTrue(cfg.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION));      }      public void testOverrideIntrospectors()     {         SerializationConfig cfg = MAPPER.getSerializationConfig();         // and finally, ensure we could override introspectors         cfg = cfg.with((ClassIntrospector) null); // no way to verify tho         cfg = cfg.with((AnnotationIntrospector) null);         assertNull(cfg.getAnnotationIntrospector());     }      public void testMisc()     {         ObjectMapper m = new ObjectMapper();         m.setDateFormat(null); // just to execute the code path         assertNotNull(m.getSerializationConfig().toString()); // ditto     }      public void testIndentation() throws Exception     {         Map<String,Integer> map = new HashMap<String,Integer>();         map.put("a", Integer.valueOf(2));         String result = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT)                 .writeValueAsString(map);         // 02-Jun-2009, tatu: not really a clean way but...         String lf = getLF();         assertEquals("{"+lf+"  \"a\" : 2"+lf+"}", result);     }      public void testAnnotationsDisabled() throws Exception     {         // first: verify that annotation introspection is enabled by default         assertTrue(MAPPER.isEnabled(MapperFeature.USE_ANNOTATIONS));         Map<String,Object> result = writeAndMap(MAPPER, new AnnoBean());         assertEquals(2, result.size());          ObjectMapper m2 = new ObjectMapper();         m2.configure(MapperFeature.USE_ANNOTATIONS, false);         result = writeAndMap(m2, new AnnoBean());         assertEquals(1, result.size());     }      /**      * Test for verifying working of [JACKSON-191]      */     public void testProviderConfig() throws Exception        {         ObjectMapper mapper = new ObjectMapper();         DefaultSerializerProvider prov = (DefaultSerializerProvider) mapper.getSerializerProvider();         assertEquals(0, prov.cachedSerializersCount());         // and then should get one constructed for:         Map<String,Object> result = this.writeAndMap(mapper, new AnnoBean());         assertEquals(2, result.size());         assertEquals(Integer.valueOf(1), result.get("x"));         assertEquals(Integer.valueOf(2), result.get("y"));          /* Note: it is 2 because we'll also get serializer for basic 'int', not          * just AnnoBean          */         /* 12-Jan-2010, tatus: Actually, probably more, if and when we typing          *   aspects are considered (depending on what is cached)          */         int count = prov.cachedSerializersCount();         if (count < 2) {             fail("Should have at least 2 cached serializers, got "+count);         }         prov.flushCachedSerializers();         assertEquals(0, prov.cachedSerializersCount());     }      // Test for [Issue#12]     public void testIndentWithPassedGenerator() throws Exception     {         Indentable input = new Indentable();         assertEquals("{\"a\":3}", MAPPER.writeValueAsString(input));         String LF = getLF();         String INDENTED = "{"+LF+"  \"a\" : 3"+LF+"}";         final ObjectWriter indentWriter = MAPPER.writer().with(SerializationFeature.INDENT_OUTPUT);         assertEquals(INDENTED, indentWriter.writeValueAsString(input));          // [Issue#12]         StringWriter sw = new StringWriter();         JsonGenerator jgen = MAPPER.getFactory().createGenerator(sw);         indentWriter.writeValue(jgen, input);         jgen.close();         assertEquals(INDENTED, sw.toString());          // and also with ObjectMapper itself         sw = new StringWriter();         ObjectMapper m2 = new ObjectMapper();         m2.enable(SerializationFeature.INDENT_OUTPUT);         jgen = m2.getFactory().createGenerator(sw);         m2.writeValue(jgen, input);         jgen.close();         assertEquals(INDENTED, sw.toString());     }      public void testNoAccessOverrides() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.disable(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS);         assertEquals("{\"x\":1}", m.writeValueAsString(new SimpleBean()));     }          private final static String getLF() {         return System.getProperty("line.separator");     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.IOException; import java.io.StringWriter; import java.util.*;  import javax.xml.parsers.DocumentBuilderFactory;  import org.w3c.dom.Element;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.module.SimpleModule; import com.fasterxml.jackson.databind.ser.std.CollectionSerializer; import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer; import com.fasterxml.jackson.databind.util.StdConverter;  /**  * Test for verifying [JACKSON-238]  *  * @author Pablo Lalloni <plalloni@gmail.com>  * @author tatu  */ public class TestCustomSerializers     extends com.fasterxml.jackson.databind.BaseMapTest {     /*     /**********************************************************     /* Helper beans     /**********************************************************      */      static class ElementSerializer extends JsonSerializer<Element>     {         @Override         public void serialize(Element value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {             jgen.writeString("element");         }     }          @JsonSerialize(using = ElementSerializer.class)     public static class ElementMixin {}      public static class Immutable {         protected int x() { return 3; }         protected int y() { return 7; }     }      /*     /**********************************************************     /* Unit tests     /**********************************************************     */          public void testCustomization() throws Exception     {         ObjectMapper objectMapper = new ObjectMapper();         objectMapper.addMixInAnnotations(Element.class, ElementMixin.class);         Element element = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement("el");         StringWriter sw = new StringWriter();         objectMapper.writeValue(sw, element);         assertEquals(sw.toString(), "\"element\"");     }      @SuppressWarnings({ "unchecked", "rawtypes" })     public void testCustomLists() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         JsonSerializer<?> ser = new CollectionSerializer(null, false, null, null, null);         final JsonSerializer<Object> collectionSerializer = (JsonSerializer<Object>) ser;          module.addSerializer(Collection.class, new JsonSerializer<Collection>() {             @Override             public void serialize(Collection value, JsonGenerator jgen, SerializerProvider provider)                     throws IOException, JsonProcessingException {                 if (value.size() != 0) {                     collectionSerializer.serialize(value, jgen, provider);                 } else {                     jgen.writeNull();                 }             }         });         mapper.registerModule(module);         assertEquals("null", mapper.writeValueAsString(new ArrayList<Object>()));     }      // [Issue#87]: delegating serializer     public void testDelegating() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test", Version.unknownVersion());         module.addSerializer(new StdDelegatingSerializer(Immutable.class,                 new StdConverter<Immutable, Map<String,Integer>>() {                     @Override                     public Map<String, Integer> convert(Immutable value)                     {                         HashMap<String,Integer> map = new LinkedHashMap<String,Integer>();                         map.put("x", value.x());                         map.put("y", value.y());                         return map;                     }         }));         mapper.registerModule(module);         assertEquals("{\"x\":3,\"y\":7}", mapper.writeValueAsString(new Immutable()));     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;   import com.fasterxml.jackson.databind.*;  /**  * Simple unit tests to verify that it is possible to handle  * potentially cyclic structures, as long as object graph itself  * is not cyclic. This is the case for directed hierarchies like  * trees and DAGs.  */ public class TestCyclicTypes     extends BaseMapTest {     /*     /**********************************************************     /* Helper bean classes     /**********************************************************      */      static class Bean     {         Bean _next;         final String _name;          public Bean(Bean next, String name) {             _next = next;             _name = name;         }          public Bean getNext() { return _next; }         public String getName() { return _name; }          public void assignNext(Bean n) { _next = n; }     }      /*     /**********************************************************     /* Types     /**********************************************************      */      public void testLinked() throws Exception     {         Bean last = new Bean(null, "last");         Bean first = new Bean(last, "first");         Map<String,Object> map = writeAndMap(new ObjectMapper(), first);          assertEquals(2, map.size());         assertEquals("first", map.get("name"));          @SuppressWarnings("unchecked")         Map<String,Object> map2 = (Map<String,Object>) map.get("next");         assertNotNull(map2);         assertEquals(2, map2.size());         assertEquals("last", map2.get("name"));         assertNull(map2.get("next"));     }      /**      * Test for verifying that [JACKSON-158] works as expected      */     public void testSelfReference() throws Exception     {         Bean selfRef = new Bean(null, "self-refs");         Bean first = new Bean(selfRef, "first");         selfRef.assignNext(selfRef);         ObjectMapper m = new ObjectMapper();         Bean[] wrapper = new Bean[] { first };         try {             writeAndMap(m, wrapper);         } catch (JsonMappingException e) {             verifyException(e, "Direct self-reference leading to cycle");         }     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.text.*; import java.util.*;   import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.databind.*;  public class TestDateSerialization     extends BaseMapTest {     static class TimeZoneBean {         private TimeZone tz;                  public TimeZoneBean(String name) {             tz = TimeZone.getTimeZone(name);         }          public TimeZone getTz() { return tz; }     }      static class DateAsNumberBean {         @JsonFormat(shape=JsonFormat.Shape.NUMBER)         public Date date;         public DateAsNumberBean(long l) { date = new java.util.Date(l); }     }      static class DateAsStringBean {         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd")         public Date date;         public DateAsStringBean(long l) { date = new java.util.Date(l); }     }      static class DateInCETBean {         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern="yyyy-MM-dd,HH:00", timezone="CET")         public Date date;         public DateInCETBean(long l) { date = new java.util.Date(l); }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testDateNumeric() throws IOException     {         // default is to output time stamps...         assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));         // shouldn't matter which offset we give...         String json = MAPPER.writeValueAsString(new Date(199L));         assertEquals("199", json);     }      public void testDateISO8601() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);         // let's hit epoch start         String json = mapper.writeValueAsString(new Date(0L));         assertEquals("\"1970-01-01T00:00:00.000+0000\"", json);     }      public void testDateOther() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");         df.setTimeZone(TimeZone.getTimeZone("PST"));         mapper.setDateFormat(df);         // let's hit epoch start, offset by a bit         assertEquals(quote("1969-12-31X16:00:00"), mapper.writeValueAsString(new Date(0L)));     }      @SuppressWarnings("deprecation")     public void testSqlDate() throws IOException     {         // use date 1999-04-01 (note: months are 0-based, use constant)         java.sql.Date date = new java.sql.Date(99, Calendar.APRIL, 1);         assertEquals(quote("1999-04-01"), MAPPER.writeValueAsString(date));     }      public void testTimeZone() throws IOException     {         TimeZone input = TimeZone.getTimeZone("PST");         String json = MAPPER.writeValueAsString(input);         assertEquals(quote("PST"), json);     }      // [JACKSON-663]     public void testTimeZoneInBean() throws IOException     {         String json = MAPPER.writeValueAsString(new TimeZoneBean("PST"));         assertEquals("{\"tz\":\"PST\"}", json);     }          // [JACKSON-648]: (re)configuring via ObjectWriter     public void testDateUsingObjectWriter() throws IOException     {         DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss");         df.setTimeZone(TimeZone.getTimeZone("PST"));         assertEquals(quote("1969-12-31X16:00:00"),                 MAPPER.writer(df).writeValueAsString(new Date(0L)));         ObjectWriter w = MAPPER.writer((DateFormat)null);         assertEquals("0", w.writeValueAsString(new Date(0L)));          w = w.with(df);         assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L)));         w = w.with((DateFormat) null);         assertEquals("0", w.writeValueAsString(new Date(0L)));     }      // [JACKSON-606]     public void testDatesAsMapKeys() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         Map<Date,Integer> map = new HashMap<Date,Integer>();         assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS));         map.put(new Date(0L), Integer.valueOf(1));         // by default will serialize as ISO-8601 values...         assertEquals("{\"1970-01-01T00:00:00.000+0000\":1}", mapper.writeValueAsString(map));                  // but can change to use timestamps too         mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true);         assertEquals("{\"0\":1}", mapper.writeValueAsString(map));     }      // [JACKSON-435]     public void testDateWithJsonFormat() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String json;          // first: test overriding writing as timestamp         mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);         json = mapper.writeValueAsString(new DateAsNumberBean(0L));         assertEquals("{\"date\":0}", json);          // then reverse         mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);         json = mapper.writer().with(getUTCTimeZone()).writeValueAsString(new DateAsStringBean(0L));         assertEquals("{\"date\":\"1970-01-01\"}", json);          // and with different DateFormat; CET is one hour ahead of GMT         json = mapper.writeValueAsString(new DateInCETBean(0L));         assertEquals("{\"date\":\"1970-01-01,01:00\"}", json);     }      /**      * Test to ensure that setting a TimeZone _after_ dateformat should enforce      * that timezone on format, regardless of TimeZone format had.      */     public void testWithTimeZoneOverride() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd/HH:mm z"));         mapper.setTimeZone(TimeZone.getTimeZone("PST"));         mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);         String json = mapper.writeValueAsString(new Date(0));         // pacific time is GMT-8; so midnight becomes 16:00 previous day:         assertEquals(quote("1969-12-31/16:00 PST"), json);     } }  
package com.fasterxml.jackson.databind.ser;  import java.io.IOException;  import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  public class TestEmptyClass     extends BaseMapTest {     static class Empty { }      @JsonSerialize     static class EmptyWithAnno { }      // for [JACKSON-695]:      @JsonSerialize(using=NonZeroSerializer.class)     static class NonZero {         public int nr;                  public NonZero(int i) { nr = i; }     }      @JsonSerialize(include=JsonSerialize.Inclusion.NON_EMPTY)     static class NonZeroWrapper {         public NonZero value;                  public NonZeroWrapper(int i) {             value = new NonZero(i);         }     }          static class NonZeroSerializer extends JsonSerializer<NonZero>     {         @Override         public void serialize(NonZero value, JsonGenerator jgen, SerializerProvider provider) throws IOException         {             jgen.writeNumber(value.nr);         }          @Override         public boolean isEmpty(NonZero value) {             if (value == null) return true;             return (value.nr == 0);         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      protected final ObjectMapper mapper = new ObjectMapper();          /**      * Test to check that [JACKSON-201] works if there is a recognized      * annotation (which indicates type is serializable)      */     public void testEmptyWithAnnotations() throws Exception     {         // First: without annotations, should complain         try {             serializeAsString(mapper, new Empty());         } catch (JsonMappingException e) {             verifyException(e, "No serializer found for class");         }          // But not if there is a recognized annotation         assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno()));          // Including class annotation through mix-ins         ObjectMapper m2 = new ObjectMapper();         m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class);         assertEquals("{}", m2.writeValueAsString(new Empty()));     }      /**      * Alternative it is possible to use a feature to allow      * serializing empty classes, too      */     public void testEmptyWithFeature() throws Exception     {         // should be enabled by default         assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS));         mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);         assertEquals("{}", serializeAsString(mapper, new Empty()));     }      // [JACKSON-695], JsonSerializer.isEmpty()     public void testCustomNoEmpty() throws Exception     {         // first non-empty:         assertEquals("{\"value\":123}", mapper.writeValueAsString(new NonZeroWrapper(123)));         // then empty:         assertEquals("{}", mapper.writeValueAsString(new NonZeroWrapper(0)));     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonFormat.Shape; import com.fasterxml.jackson.annotation.JsonProperty; import com.fasterxml.jackson.annotation.JsonValue;  import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonProcessingException;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.jsontype.TypeSerializer; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;  /**  * Unit tests for verifying serialization of simple basic non-structured  * types; primitives (and/or their wrappers), Strings.  */ public class TestEnumSerialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper enums     /**********************************************************      */      /**      * Test enumeration for verifying Enum serialization functionality.      */     protected enum TestEnum {         A, B, C;         private TestEnum() { }          @Override public String toString() { return name().toLowerCase(); }     }      /**      * Alternative version that forces use of "toString-serializer".      */     @JsonSerialize(using=ToStringSerializer.class)     protected enum AnnotatedTestEnum {         A2, B2, C2;         private AnnotatedTestEnum() { }          @Override public String toString() { return name().toLowerCase(); }     }      protected enum EnumWithJsonValue {         A("foo"), B("bar");         private final String name;         private EnumWithJsonValue(String n) {             name = n;         }         @JsonValue         @Override         public String toString() { return name; }     }          protected static interface ToStringMixin {         @Override         @JsonValue public String toString();     }      protected enum SerializableEnum implements JsonSerializable     {         A, B, C;          private SerializableEnum() { }          @Override         public void serializeWithType(JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer)                 throws IOException, JsonProcessingException         {             serialize(jgen, provider);         }          @Override         public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException         {             jgen.writeString("foo");         }     }      protected enum LowerCaseEnum {         A, B, C;         private LowerCaseEnum() { }         @Override         public String toString() { return name().toLowerCase(); }     }      static class MapBean {         public Map<TestEnum,Integer> map = new HashMap<TestEnum,Integer>();                  public void add(TestEnum key, int value) {             map.put(key, Integer.valueOf(value));         }     }      // [JACKSON-757]     static enum NOT_OK {         V1("v1");          protected String key;         // any runtime-persistent annotation is fine         NOT_OK(@JsonProperty String key) { this.key = key; }     }      static enum OK {         V1("v1");         protected String key;         OK(String key) { this.key = key; }     }          // Types for [https://github.com/FasterXML/jackson-databind/issues/24]     // (Enums as JSON Objects)      @JsonFormat(shape=JsonFormat.Shape.OBJECT)     static enum PoNUM {         A("a1"), B("b2");          @JsonProperty         protected final String value;                  private PoNUM(String v) { value = v; }          public String getValue() { return value; }     }      static class PoNUMContainer {         @JsonFormat(shape=Shape.NUMBER)         public OK text = OK.V1;     }          @JsonFormat(shape=JsonFormat.Shape.ARRAY) // not supported as of now     static enum BrokenPoNum     {         A, B;     }          /*     /**********************************************************     /* Tests     /**********************************************************      */      private final ObjectMapper mapper = new ObjectMapper();          public void testSimple() throws Exception     {         assertEquals("\"B\"", mapper.writeValueAsString(TestEnum.B));     }      public void testEnumSet() throws Exception     {         StringWriter sw = new StringWriter();         EnumSet<TestEnum> value = EnumSet.of(TestEnum.B);         mapper.writeValue(sw, value);         assertEquals("[\"B\"]", sw.toString());     }      /**      * Whereas regular Enum serializer uses enum names, some users      * prefer calling toString() instead. So let's verify that      * this can be done using annotation for enum class.      */     public void testEnumUsingToString() throws Exception     {         StringWriter sw = new StringWriter();         mapper.writeValue(sw, AnnotatedTestEnum.C2);         assertEquals("\"c2\"", sw.toString());     }      // Test [JACKSON-214]     public void testSubclassedEnums() throws Exception     {         assertEquals("\"B\"", mapper.writeValueAsString(EnumWithSubClass.B));     }      // [JACKSON-193]     public void testEnumsWithJsonValue() throws Exception     {         assertEquals("\"bar\"", mapper.writeValueAsString(EnumWithJsonValue.B));     }      // also, for [JACKSON-193], needs to work via mix-ins     public void testEnumsWithJsonValueUsingMixin() throws Exception     {         // can't share, as new mix-ins are added         ObjectMapper mapper = new ObjectMapper();         mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class);         assertEquals("\"b\"", mapper.writeValueAsString(TestEnum.B));     }      /**      * Test for ensuring that @JsonSerializable is used with Enum types as well      * as with any other types.      */     public void testSerializableEnum() throws Exception     {         assertEquals("\"foo\"", mapper.writeValueAsString(SerializableEnum.A));     }      // [JACKSON-212]     public void testToStringEnum() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true);         assertEquals("\"b\"", mapper.writeValueAsString(LowerCaseEnum.B));     }      // [JACKSON-212]     public void testToStringEnumWithEnumMap() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true);         EnumMap<LowerCaseEnum,String> m = new EnumMap<LowerCaseEnum,String>(LowerCaseEnum.class);         m.put(LowerCaseEnum.C, "value");         assertEquals("{\"c\":\"value\"}", mapper.writeValueAsString(m));     }      // [JACKSON-576]     public void testMapWithEnumKeys() throws Exception     {         MapBean bean = new MapBean();         bean.add(TestEnum.B, 3);         String json = mapper.writeValueAsString(bean);         assertEquals("{\"map\":{\"b\":3}}", json);     }          // [JACKSON-684]     public void testAsIndex() throws Exception     {         // By default, serialize using name         ObjectMapper mapper = new ObjectMapper();         assertFalse(mapper.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX));         assertEquals(quote("B"), mapper.writeValueAsString(TestEnum.B));          // but we can change (dynamically, too!) it to be number-based         mapper.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX);         assertEquals("1", mapper.writeValueAsString(TestEnum.B));     }      // [JACKSON-757]     public void testAnnotationsOnEnumCtor() throws Exception     {         assertEquals(quote("V1"), mapper.writeValueAsString(OK.V1));         assertEquals(quote("V1"), mapper.writeValueAsString(NOT_OK.V1));         assertEquals(quote("V2"), mapper.writeValueAsString(NOT_OK2.V2));     }      // Tests for [issue#24]      public void testEnumAsObjectValid() throws Exception {         assertEquals("{\"value\":\"a1\"}", mapper.writeValueAsString(PoNUM.A));     }      public void testEnumAsIndexViaAnnotations() throws Exception {         assertEquals("{\"text\":0}", mapper.writeValueAsString(new PoNUMContainer()));     }          public void testEnumAsObjectBroken() throws Exception     {         try {             String json = mapper.writeValueAsString(BrokenPoNum.A);             fail("Should not have succeeded, produced: "+json);         } catch (JsonMappingException e) {             verifyException(e, "Unsupported serialization shape");         }     } }  // [JACKSON-757], non-inner enum enum NOT_OK2 {     V2("v2");      protected String key;     // any runtime-persistent annotation is fine     NOT_OK2(@JsonProperty String key) { this.key = key; } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.module.SimpleModule;  import com.fasterxml.jackson.test.BaseTest; import com.fasterxml.jackson.test.BrokenStringWriter;  /**  * Unit test for verifying that exceptions are properly handled (caught,  * re-thrown or wrapped, depending)  * with Object serialization.  */ public class TestExceptionHandling     extends BaseTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      static class Bean {         // no methods, we'll use our custom serializer     }      static class SerializerWithErrors         extends JsonSerializer<Bean>     {         @Override         public void serialize(Bean value, JsonGenerator jgen, SerializerProvider provider)         {             throw new IllegalArgumentException("test string");         }     }      /*     /**********************************************************     /* Tests     /**********************************************************      */      /**      * Unit test that verifies that by default all exceptions except for      * JsonMappingException are caught and wrapped.      */     public void testCatchAndRethrow()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SimpleModule module = new SimpleModule("test-exceptions", Version.unknownVersion());         module.addSerializer(Bean.class, new SerializerWithErrors());         mapper.registerModule(module);         try {             StringWriter sw = new StringWriter();             /* And just to make things more interesting, let's create              * a nested data struct...              */             Bean[] b = { new Bean() };             List<Bean[]> l = new ArrayList<Bean[]>();             l.add(b);             mapper.writeValue(sw, l);             fail("Should have gotten an exception");         } catch (IOException e) {             // should contain original message somewhere             verifyException(e, "test string");             Throwable root = e.getCause();             assertNotNull(root);              if (!(root instanceof IllegalArgumentException)) {                 fail("Wrapped exception not IAE, but "+root.getClass());             }         }     }      /**      * Unit test for verifying that regular IOExceptions are not wrapped      * but are passed through as is.      */     public void testExceptionWithSimpleMapper()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         try {             BrokenStringWriter sw = new BrokenStringWriter("TEST");             mapper.writeValue(sw, createLongObject());             fail("Should have gotten an exception");         } catch (IOException e) {             verifyException(e, IOException.class, "TEST");         }     }      public void testExceptionWithMapperAndGenerator()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         JsonFactory f = new MappingJsonFactory();         BrokenStringWriter sw = new BrokenStringWriter("TEST");         JsonGenerator jg = f.createGenerator(sw);          try {             mapper.writeValue(jg, createLongObject());             fail("Should have gotten an exception");         } catch (IOException e) {             verifyException(e, IOException.class, "TEST");         }     }      public void testExceptionWithGeneratorMapping()         throws Exception     {         JsonFactory f = new MappingJsonFactory();         JsonGenerator jg = f.createGenerator(new BrokenStringWriter("TEST"));         try {             jg.writeObject(createLongObject());             fail("Should have gotten an exception");         } catch (Exception e) {             verifyException(e, IOException.class, "TEST");         }     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */      void verifyException(Exception e, Class<?> expType, String expMsg)         throws Exception     {         if (e.getClass() != expType) {             fail("Expected exception of type "+expType.getName()+", got "+e.getClass().getName());         }         if (expMsg != null) {             verifyException(e, expMsg);         }     }      Object createLongObject()     {         List<Object> leaf = new ArrayList<Object>();         for (int i = 0; i < 256; ++i) {             leaf.add(Integer.valueOf(i));         }         List<Object> root = new ArrayList<Object>(256);         for (int i = 0; i < 256; ++i) {             root.add(leaf);         }         return root;     } }  
package com.fasterxml.jackson.databind.ser;  import java.util.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying that simple exceptions can be serialized.  */ public class TestExceptionSerialization     extends BaseMapTest {     /*     /**********************************************************     /* Tests     /**********************************************************      */      public void testSimple() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String TEST = "test exception";         Map<String,Object> result = writeAndMap(mapper, new Exception(TEST));         // JDK 7 has introduced a new property 'suppressed' to Throwable         Object ob = result.get("suppressed");         if (ob != null) {             assertEquals(5, result.size());         } else {             assertEquals(4, result.size());         }          assertEquals(TEST, result.get("message"));         assertNull(result.get("cause"));         assertEquals(TEST, result.get("localizedMessage"));          // hmmh. what should we get for stack traces?         Object traces = result.get("stackTrace");         if (!(traces instanceof List<?>)) {             fail("Expected a List for exception member 'stackTrace', got: "+traces);         }     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.core.JsonGenerator;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;  /**  * Unit tests for checking whether JsonSerializerFactory.Feature  * configuration works  */ public class TestFeatures     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      /**      * Class with one explicitly defined getter, one name-based      * auto-detectable getter.      */     static class GetterClass     {         @JsonProperty("x") public int getX() { return -2; }         public int getY() { return 1; }     }      /**      * Another test-class that explicitly disables auto-detection      */     @JsonAutoDetect(getterVisibility=Visibility.NONE)     static class DisabledGetterClass     {         @JsonProperty("x") public int getX() { return -2; }         public int getY() { return 1; }     }      /**      * Another test-class that explicitly enables auto-detection      */     @JsonAutoDetect(isGetterVisibility=Visibility.NONE)     static class EnabledGetterClass     {         @JsonProperty("x") public int getX() { return -2; }         public int getY() { return 1; }          // not auto-detected, since "is getter" auto-detect disabled         public boolean isOk() { return true; }     }      /**      * One more: only detect "isXxx", not "getXXX"      */     @JsonAutoDetect(getterVisibility=Visibility.NONE)     static class EnabledIsGetterClass     {         // Won't be auto-detected any more         public int getY() { return 1; }          // but this will be         public boolean isOk() { return true; }     }      static class CloseableBean implements Closeable     {         public int a = 3;          protected boolean wasClosed = false;          @Override         public void close() throws IOException {             wasClosed = true;         }     }      private static class StringListBean {         @SuppressWarnings("unused")         public Collection<String> values;                  public StringListBean(Collection<String> v) { values = v; }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      public void testGlobalAutoDetection() throws IOException     {         // First: auto-detection enabled (default):         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new GetterClass());         assertEquals(2, result.size());         assertEquals(Integer.valueOf(-2), result.get("x"));         assertEquals(Integer.valueOf(1), result.get("y"));          // Then auto-detection disabled. But note: we MUST create a new         // mapper, since old version of serializer may be cached by now         m = new ObjectMapper();         m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);         result = writeAndMap(m, new GetterClass());         assertEquals(1, result.size());         assertTrue(result.containsKey("x"));     }      public void testPerClassAutoDetection() throws IOException     {         // First: class-level auto-detection disabling         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new DisabledGetterClass());         assertEquals(1, result.size());         assertTrue(result.containsKey("x"));          // And then class-level auto-detection enabling, should override defaults         m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);         result = writeAndMap(m, new EnabledGetterClass());         assertEquals(2, result.size());         assertTrue(result.containsKey("x"));         assertTrue(result.containsKey("y"));     }      public void testPerClassAutoDetectionForIsGetter() throws IOException     {         ObjectMapper m = new ObjectMapper();         // class level should override         m.configure(MapperFeature.AUTO_DETECT_GETTERS, true);         m.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);          Map<String,Object> result = writeAndMap(m, new EnabledIsGetterClass());         assertEquals(1, result.size());         assertTrue(result.containsKey("ok"));         assertEquals(Boolean.TRUE, result.get("ok"));     }      // Simple test verifying that chainable methods work ok...     public void testConfigChainability()     {         ObjectMapper m = new ObjectMapper();         assertTrue(m.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));         assertTrue(m.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));         m.configure(MapperFeature.AUTO_DETECT_SETTERS, false)             .configure(MapperFeature.AUTO_DETECT_GETTERS, false);         assertFalse(m.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));         assertFalse(m.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));     }      // Test for [JACKSON-282]     public void testCloseCloseable() throws IOException     {         ObjectMapper m = new ObjectMapper();         // default should be disabled:         CloseableBean bean = new CloseableBean();         m.writeValueAsString(bean);         assertFalse(bean.wasClosed);          // but can enable it:         m.configure(SerializationFeature.CLOSE_CLOSEABLE, true);         bean = new CloseableBean();         m.writeValueAsString(bean);         assertTrue(bean.wasClosed);          // also: let's ensure that ObjectWriter won't interfere with it         bean = new CloseableBean();         m.writerWithType(CloseableBean.class).writeValueAsString(bean);         assertTrue(bean.wasClosed);     }      // Test for [JACKSON-289]     public void testCharArrays() throws IOException     {         char[] chars = new char[] { 'a','b','c' };         ObjectMapper m = new ObjectMapper();         // default: serialize as Strings         assertEquals(quote("abc"), m.writeValueAsString(chars));                  // new feature: serialize as JSON array:         m.configure(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS, true);         assertEquals("[\"a\",\"b\",\"c\"]", m.writeValueAsString(chars));     }      // Test for [JACKSON-401]     public void testFlushingAutomatic() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE));         // default is to flush after writeValue()         StringWriter sw = new StringWriter();         JsonGenerator jgen = mapper.getFactory().createGenerator(sw);         mapper.writeValue(jgen, Integer.valueOf(13));         assertEquals("13", sw.toString());         jgen.close();          // ditto with ObjectWriter         sw = new StringWriter();         jgen = mapper.getFactory().createGenerator(sw);         ObjectWriter ow = mapper.writer();         ow.writeValue(jgen, Integer.valueOf(99));         assertEquals("99", sw.toString());         jgen.close();     }      // Test for [JACKSON-401]     public void testFlushingNotAutomatic() throws IOException     {         // but should not occur if configured otherwise         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.FLUSH_AFTER_WRITE_VALUE, false);         StringWriter sw = new StringWriter();         JsonGenerator jgen = mapper.getFactory().createGenerator(sw);          mapper.writeValue(jgen, Integer.valueOf(13));         // no flushing now:         assertEquals("", sw.toString());         // except when actually flushing         jgen.flush();         assertEquals("13", sw.toString());         jgen.close();         // Also, same should happen with ObjectWriter         sw = new StringWriter();         jgen = mapper.getFactory().createGenerator(sw);         ObjectWriter ow = mapper.writer();         ow.writeValue(jgen, Integer.valueOf(99));         assertEquals("", sw.toString());         // except when actually flushing         jgen.flush();         assertEquals("99", sw.toString());         jgen.close();     }      // Test for [JACKSON-805]     public void testSingleElementCollections() throws IOException     {         final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED);          // Lists:         ArrayList<String> strs = new ArrayList<String>();         strs.add("xyz");         assertEquals(quote("xyz"), writer.writeValueAsString(strs));         ArrayList<Integer> ints = new ArrayList<Integer>();         ints.add(13);         assertEquals("13", writer.writeValueAsString(ints));          // other Collections, like Sets:         HashSet<Long> longs = new HashSet<Long>();         longs.add(42L);         assertEquals("42", writer.writeValueAsString(longs));         // [Issue#180]         final String EXP_STRINGS = "{\"values\":\"foo\"}";         assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo"))));          final Set<String> SET = new HashSet<String>();         SET.add("foo");         assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET)));                  // arrays:         assertEquals("true", writer.writeValueAsString(new boolean[] { true }));         assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE }));         assertEquals("3", writer.writeValueAsString(new int[] { 3 }));         assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" }));              } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonDeserialize; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  /**  * Unit tests for verifying that field-backed properties can also be serialized  * (since version 1.1) as well as getter-accessible properties.  */ public class TestFieldSerialization     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      static class SimpleFieldBean     {         public int x, y;          // not auto-detectable, not public         int z;          // ignored, not detectable either         @JsonIgnore public int a;     }          static class SimpleFieldBean2     {         @JsonSerialize String[] values;          // note: this annotation should not matter for serialization:         @JsonDeserialize int dummy;     }      static class TransientBean     {         public int a;         // transients should not be included         public transient int b;         // or statics         public static int c;     }      @JsonAutoDetect(setterVisibility=Visibility.PUBLIC_ONLY, fieldVisibility=Visibility.NONE)     public class NoAutoDetectBean     {         // not auto-detectable any more         public int x;          @JsonProperty("z")         public int _z;     }      /**      * Let's test invalid bean too: can't have 2 logical properties      * with same name.      *<p>      * 21-Feb-2010, tatus: That is, not within same class.      *    As per [JACKSON-226] it is acceptable to "override"      *    field definitions in sub-classes.      */     public static class DupFieldBean     {         @JsonProperty("foo")         public int _z;          @JsonSerialize         private int foo;     }      public static class DupFieldBean2     {         public int z;          @JsonProperty("z")         public int _z;     }      public static class OkDupFieldBean         extends SimpleFieldBean     {         @JsonProperty("x")         protected int myX;          public int y;          public OkDupFieldBean(int x, int y) {             this.myX = x;             this.y = y;         }     }      /**      * It is ok to have a method-based and field-based property      * introspectable: only one should be serialized, and since      * methods have precedence, it should be the method one.      */     public static class FieldAndMethodBean     {         @JsonProperty public int z;          @JsonProperty("z") public int getZ() { return z+1; }     }      /*     /**********************************************************     /* Main tests, success     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testSimpleAutoDetect() throws Exception     {         SimpleFieldBean bean = new SimpleFieldBean();         // let's set x, leave y as is         bean.x = 13;         Map<String,Object> result = writeAndMap(MAPPER, bean);         assertEquals(2, result.size());         assertEquals(Integer.valueOf(13), result.get("x"));         assertEquals(Integer.valueOf(0), result.get("y"));     }      @SuppressWarnings("unchecked") 	public void testSimpleAnnotation() throws Exception     {         SimpleFieldBean2 bean = new SimpleFieldBean2();         bean.values = new String[] { "a", "b" };         Map<String,Object> result = writeAndMap(MAPPER, bean);         assertEquals(1, result.size());         List<String> values = (List<String>) result.get("values");         assertEquals(2, values.size());         assertEquals("a", values.get(0));         assertEquals("b", values.get(1));     }      public void testTransientAndStatic() throws Exception     {         TransientBean bean = new TransientBean();         Map<String,Object> result = writeAndMap(MAPPER, bean);         assertEquals(1, result.size());         assertEquals(Integer.valueOf(0), result.get("a"));     }      public void testNoAutoDetect() throws Exception     {         NoAutoDetectBean bean = new NoAutoDetectBean();         bean._z = -4;         Map<String,Object> result = writeAndMap(MAPPER, bean);         assertEquals(1, result.size());         assertEquals(Integer.valueOf(-4), result.get("z"));     }      /**      * Unit test that verifies that if both a field and a getter      * method exist for a logical property (which is allowed),      * getter has precendence over field.      */     public void testMethodPrecedence() throws Exception     {         FieldAndMethodBean bean = new FieldAndMethodBean();         bean.z = 9;         assertEquals(10, bean.getZ());         assertEquals("{\"z\":10}", MAPPER.writeValueAsString(bean));     }      /**      * Testing [JACKSON-226]: it is ok to have "field override",      * as long as there are no intra-class conflicts.      */     public void testOkDupFields() throws Exception     {         OkDupFieldBean bean = new OkDupFieldBean(1, 2);         Map<String,Object> json = writeAndMap(MAPPER, bean);         assertEquals(2, json.size());         assertEquals(Integer.valueOf(1), json.get("x"));         assertEquals(Integer.valueOf(2), json.get("y"));     }      /*     /**********************************************************     /* Main tests, failure cases     /**********************************************************      */      public void testFailureDueToDups() throws Exception     {         try {             writeAndMap(MAPPER, new DupFieldBean());         } catch (JsonMappingException e) {             verifyException(e, "Multiple fields representing");         }     }      public void testFailureDueToDupField() throws Exception     {         try {             writeAndMap(MAPPER, new DupFieldBean2());         } catch (JsonMappingException e) {             verifyException(e, "Multiple fields representing");         }     } }  
package com.fasterxml.jackson.databind.ser;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ser.FilterProvider; import com.fasterxml.jackson.databind.ser.impl.*;  /**  * Tests for verifying that bean property filtering using JsonFilter  * works as expected.  */ public class TestFiltering extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      @JsonFilter("RootFilter")     static class Bean {         public String a = "a";         public String b = "b";     }           // [Issue#89]     static class Pod     {         protected String username;  //        @JsonProperty(value = "user_password")         protected String userPassword;          public String getUsername() {             return username;         }          public void setUsername(String value) {             this.username = value;         }          @JsonIgnore         @JsonProperty(value = "user_password")         public java.lang.String getUserPassword() {             return userPassword;         }          @JsonProperty(value = "user_password")         public void setUserPassword(String value) {             this.userPassword = value;         }      }         /*     /**********************************************************     /* Unit tests     /**********************************************************      */          public void testSimpleInclusionFilter() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         FilterProvider prov = new SimpleFilterProvider().addFilter("RootFilter",                 SimpleBeanPropertyFilter.filterOutAllExcept("a"));         assertEquals("{\"a\":\"a\"}", mapper.writer(prov).writeValueAsString(new Bean()));          // [JACKSON-504]: also verify it works via mapper         mapper = new ObjectMapper();         mapper.setFilters(prov);         assertEquals("{\"a\":\"a\"}", mapper.writeValueAsString(new Bean()));     }      public void testSimpleExclusionFilter() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         FilterProvider prov = new SimpleFilterProvider().addFilter("RootFilter",                 SimpleBeanPropertyFilter.serializeAllExcept("a"));         assertEquals("{\"b\":\"b\"}", mapper.writer(prov).writeValueAsString(new Bean()));     }      // should handle missing case gracefully     public void testMissingFilter() throws Exception     {         // First: default behavior should be to throw an exception         ObjectMapper mapper = new ObjectMapper();         try {             mapper.writeValueAsString(new Bean());             fail("Should have failed without configured filter");         } catch (JsonMappingException e) { // should be resolved to a MappingException (internally may be something else)             verifyException(e, "Can not resolve BeanPropertyFilter with id 'RootFilter'");         }                  // but when changing behavior, should work difference         SimpleFilterProvider fp = new SimpleFilterProvider().setFailOnUnknownId(false);         mapper.setFilters(fp);         String json = mapper.writeValueAsString(new Bean());         assertEquals("{\"a\":\"a\",\"b\":\"b\"}", json);     }          // defaulting, as per [JACKSON-449]     public void testDefaultFilter() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         FilterProvider prov = new SimpleFilterProvider().setDefaultFilter(SimpleBeanPropertyFilter.filterOutAllExcept("b"));         assertEquals("{\"b\":\"b\"}", mapper.writer(prov).writeValueAsString(new Bean()));     }      // [Issue#89] combining @JsonIgnore, @JsonProperty     public void testIssue89() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         Pod pod = new Pod();         pod.username = "Bob";         pod.userPassword = "s3cr3t!";          String json = mapper.writeValueAsString(pod);          assertEquals("{\"username\":\"Bob\"}", json);          Pod pod2 = mapper.readValue("{\"username\":\"Bill\",\"user_password\":\"foo!\"}", Pod.class);         assertEquals("Bill", pod2.username);         assertEquals("foo!", pod2.userPassword);     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;   import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestGenericTypes extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */          static class Account {         private Long id;                 private String name;                  public Account(String name, Long id) {             this.id = id;             this.name = name;         }          public String getName() { return name; }         public Long getId() { return id; }     }      static class Key<T> {         private final T id;                  public Key(T id) { this.id = id; }                  public T getId() { return id; }          public <V> Key<V> getParent() { return null; }     }       static class Person1 {         private Long id;         private String name;         private Key<Account> account;                  public Person1(String name) { this.name = name; }          public String getName() {                 return name;         }          public Key<Account> getAccount() {                 return account;         }          public Long getId() {                 return id;         }          public void setAccount(Key<Account> account) {             this.account = account;         }         }      static class Person2 {         private Long id;         private String name;         private List<Key<Account>> accounts;                  public Person2(String name) {                 this.name = name;         }          public String getName() { return name; }         public List<Key<Account>> getAccounts() { return accounts; }         public Long getId() { return id; }          public void setAccounts(List<Key<Account>> accounts) {             this.accounts = accounts;         }     }      static class GenericBogusWrapper<T> {         public Element wrapped;          public GenericBogusWrapper(T v) { wrapped = new Element(v); }          class Element {             public T value;                  public Element(T v) { value = v; }         }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */      @SuppressWarnings("unchecked")     public void testIssue468a() throws Exception     {         Person1 p1 = new Person1("John");         p1.setAccount(new Key<Account>(new Account("something", 42L)));                  // First: ensure we can serialize (pre 1.7 this failed)         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(p1);          // and then verify that results make sense         Map<String,Object> map = mapper.readValue(json, Map.class);         assertEquals("John", map.get("name"));         Object ob = map.get("account");         assertNotNull(ob);         Map<String,Object> acct = (Map<String,Object>) ob;         Object idOb = acct.get("id");         assertNotNull(idOb);         Map<String,Object> key = (Map<String,Object>) idOb;         assertEquals("something", key.get("name"));         assertEquals(Integer.valueOf(42), key.get("id"));     }      @SuppressWarnings("unchecked")     public void testIssue468b() throws Exception     {         Person2 p2 = new Person2("John");         List<Key<Account>> accounts = new ArrayList<Key<Account>>();         accounts.add(new Key<Account>(new Account("a", 42L)));         accounts.add(new Key<Account>(new Account("b", 43L)));         accounts.add(new Key<Account>(new Account("c", 44L)));         p2.setAccounts(accounts);          // serialize without error:         ObjectMapper mapper = new ObjectMapper();                        String json = mapper.writeValueAsString(p2);          // then verify output         Map<String,Object> map = mapper.readValue(json, Map.class);         assertEquals("John", map.get("name"));         Object ob = map.get("accounts");         assertNotNull(ob);         List<?> acctList = (List<?>) ob;         assertEquals(3, acctList.size());         // ... might want to verify more, but for now that should suffice     }      /**      * Issue [JACKSON-572] is about unbound type variables, usually resulting      * from inner classes of generic classes (like Sets).      */     public void testUnboundIssue572() throws Exception     {         GenericBogusWrapper<Integer> list = new GenericBogusWrapper<Integer>(Integer.valueOf(7));         String json = new ObjectMapper().writeValueAsString(list);         assertEquals("{\"wrapped\":{\"value\":7}}", json);     } }  
package com.fasterxml.jackson.databind.ser;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.type.TypeFactory; import com.fasterxml.jackson.databind.util.JSONPObject;  public class TestJSONP     extends BaseMapTest {     static class Base {         public String a;     }     static class Impl extends Base {         public String b;          public Impl(String a, String b) {             this.a = a;             this.b = b;         }     }          public void testSimpleScalars() throws Exception     {         ObjectMapper m = new ObjectMapper();         assertEquals("callback(\"abc\")",                 serializeAsString(m, new JSONPObject("callback", "abc")));         assertEquals("calc(123)",                 serializeAsString(m, new JSONPObject("calc", Integer.valueOf(123))));         assertEquals("dummy(null)",                 serializeAsString(m, new JSONPObject("dummy", null)));     }      public void testSimpleBean() throws Exception     {         ObjectMapper m = new ObjectMapper();         assertEquals("xxx({\"a\":\"123\",\"b\":\"456\"})",                 serializeAsString(m, new JSONPObject("xxx",                         new Impl("123", "456"))));     }          /**      * Test to ensure that it is possible to force a static type for wrapped      * value.      */     public void testWithType() throws Exception     {         ObjectMapper m = new ObjectMapper();         Object ob = new Impl("abc", "def");         JavaType type = TypeFactory.defaultInstance().uncheckedSimpleType(Base.class);         assertEquals("do({\"a\":\"abc\"})",                 serializeAsString(m, new JSONPObject("do", ob, type)));     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.util.TokenBuffer;  /**  * Unit tests for those Jackson types we want to ensure can be serialized.  */ public class TestJacksonTypes     extends BaseMapTest {     public void testLocation() throws IOException     {         File f = new File("/tmp/test.json");         JsonLocation loc = new JsonLocation(f, -1, 100, 13);         ObjectMapper mapper = new ObjectMapper();         Map<String,Object> result = writeAndMap(mapper, loc);         assertEquals(5, result.size());         assertEquals(f.getAbsolutePath(), result.get("sourceRef"));         assertEquals(Integer.valueOf(-1), result.get("charOffset"));         assertEquals(Integer.valueOf(-1), result.get("byteOffset"));         assertEquals(Integer.valueOf(100), result.get("lineNr"));         assertEquals(Integer.valueOf(13), result.get("columnNr"));      }      /**      * Verify that {@link TokenBuffer} can be properly serialized      * automatically, using the "standard" JSON sample document      */     public void testTokenBuffer() throws Exception     {         // First, copy events from known good source (StringReader)         JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC);         TokenBuffer tb = new TokenBuffer(null);         while (jp.nextToken() != null) {             tb.copyCurrentEvent(jp);         }         // Then serialize as String         String str = serializeAsString(tb);         // and verify it looks ok         verifyJsonSpecSampleDoc(createParserUsingReader(str), true);     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.math.BigDecimal; import java.net.InetAddress; import java.nio.charset.Charset; import java.util.*; import java.util.regex.Pattern;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for JDK types not covered by other tests (i.e. things  * that are not Enums, Collections, Maps, or standard Date/Time types)  */ public class TestJdkTypes     extends com.fasterxml.jackson.databind.BaseMapTest {     private final ObjectMapper MAPPER = new ObjectMapper();          /**      * Unit test to catch bug [JACKSON-8].      */     public void testBigDecimal()         throws Exception     {         Map<String, Object> map = new HashMap<String, Object>();         String PI_STR = "3.14159265";         map.put("pi", new BigDecimal(PI_STR));         String str = MAPPER.writeValueAsString(map);         assertEquals("{\"pi\":3.14159265}", str);     }          public void testBigDecimalAsPlainString()         throws Exception     {         MAPPER.enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);         Map<String, Object> map = new HashMap<String, Object>();         String PI_STR = "3.00000000";         map.put("pi", new BigDecimal(PI_STR));         String str = MAPPER.writeValueAsString(map);         assertEquals("{\"pi\":3.00000000}", str);     }          /**      * Unit test related to [JACKSON-155]      */     public void testFile() throws IOException     {         // this may get translated to different representation on Windows, maybe Mac:         File f = new File(new File("/tmp"), "foo.text");         String str = MAPPER.writeValueAsString(f);         // escape backslashes (for portability with windows)         String escapedAbsPath = f.getAbsolutePath().replaceAll("\\\\", "\\\\\\\\");          assertEquals(quote(escapedAbsPath), str);     }      public void testRegexps() throws IOException     {         final String PATTERN_STR = "\\s+([a-b]+)\\w?";         Pattern p = Pattern.compile(PATTERN_STR);         Map<String,Object> input = new HashMap<String,Object>();         input.put("p", p);         Map<String,Object> result = writeAndMap(MAPPER, input);         assertEquals(p.pattern(), result.get("p"));     }      public void testCurrency() throws IOException     {         Currency usd = Currency.getInstance("USD");         assertEquals(quote("USD"), MAPPER.writeValueAsString(usd));     }      public void testLocale() throws IOException     {         assertEquals(quote("en"), MAPPER.writeValueAsString(new Locale("en")));         assertEquals(quote("es_ES"), MAPPER.writeValueAsString(new Locale("es", "ES")));         assertEquals(quote("fi_FI_savo"), MAPPER.writeValueAsString(new Locale("FI", "fi", "savo")));     }      // [JACKSON-484]     public void testInetAddress() throws IOException     {         assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1")));         assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com")));     }      // [JACKSON-597]     public void testClass() throws IOException     {         assertEquals(quote("java.lang.String"), MAPPER.writeValueAsString(String.class));         assertEquals(quote("int"), MAPPER.writeValueAsString(Integer.TYPE));         assertEquals(quote("boolean"), MAPPER.writeValueAsString(Boolean.TYPE));         assertEquals(quote("void"), MAPPER.writeValueAsString(Void.TYPE));     }      // [JACKSON-789]     public void testCharset() throws IOException     {         assertEquals(quote("UTF-8"), MAPPER.writeValueAsString(Charset.forName("UTF-8")));     } } 
package com.fasterxml.jackson.databind.ser;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.ObjectMapper;  /**  * This unit test suite tests functioning of {@link JsonRawValue}  * annotation with bean serialization.  */ public class TestJsonRawValue     extends com.fasterxml.jackson.databind.BaseMapTest {     /*     /*********************************************************     /* Helper bean classes     /*********************************************************      */      /// Class for testing {@link JsonRawValue} annotations with getters returning String     @JsonPropertyOrder(alphabetic=true)     final static class ClassGetter<T>     {     	private final T _value;     	         private ClassGetter(T value) { _value = value;}           public T getNonRaw() { return _value; }          @JsonProperty("raw") @JsonRawValue public T foobar() { return _value; }                  @JsonProperty @JsonRawValue protected T value() { return _value; }     }          /*     /*********************************************************     /* Test cases     /*********************************************************      */      public void testSimpleStringGetter() throws Exception     {         ObjectMapper m = new ObjectMapper();         String value = "abc";         String result = m.writeValueAsString(new ClassGetter<String>(value));         String expected = String.format("{\"nonRaw\":\"%s\",\"raw\":%s,\"value\":%s}", value, value, value);         assertEquals(expected, result);     }      public void testSimpleNonStringGetter() throws Exception     {         ObjectMapper m = new ObjectMapper();         int value = 123;         String result = m.writeValueAsString(new ClassGetter<Integer>(value));         String expected = String.format("{\"nonRaw\":%d,\"raw\":%d,\"value\":%d}", value, value, value);         assertEquals(expected, result);     }      public void testNullStringGetter() throws Exception     {         ObjectMapper m = new ObjectMapper();         String result = m.writeValueAsString(new ClassGetter<String>(null));         String expected = "{\"nonRaw\":null,\"raw\":null,\"value\":null}";         assertEquals(expected, result);     }  } 
package com.fasterxml.jackson.databind.ser;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.core.JsonGenerator;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  /**  * This unit test suite tests use of @JsonClass Annotation  * with bean serialization.  */ public class TestJsonSerialize     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      interface ValueInterface {         public int getX();     }      static class ValueClass         implements ValueInterface     {         @Override         public int getX() { return 3; }         public int getY() { return 5; }     }      /**      * Test class to verify that <code>JsonSerialize.as</code>      * works as expected      */     static class WrapperClassForAs     {         @JsonSerialize(as=ValueInterface.class)         public ValueClass getValue() {             return new ValueClass();         }     }      // This should indicate that static type be used for all fields     @JsonSerialize(typing=JsonSerialize.Typing.STATIC)     static class WrapperClassForStaticTyping     {         public ValueInterface getValue() {             return new ValueClass();         }     }      static class WrapperClassForStaticTyping2     {         @JsonSerialize(typing=JsonSerialize.Typing.STATIC)         public ValueInterface getStaticValue() {             return new ValueClass();         }          @JsonSerialize(typing=JsonSerialize.Typing.DYNAMIC)         public ValueInterface getDynamicValue() {             return new ValueClass();         }     }      /**      * Test bean that has an invalid {@link JsonSerialize} annotation.      */     static class BrokenClass     {         // invalid annotation: String not a supertype of Long         @JsonSerialize(as=String.class)         public Long getValue() {             return Long.valueOf(4L);         }     }      @SuppressWarnings("serial")     static class ValueMap extends HashMap<String,ValueInterface> { }     @SuppressWarnings("serial")     static class ValueList extends ArrayList<ValueInterface> { }     @SuppressWarnings("serial")     static class ValueLinkedList extends LinkedList<ValueInterface> { }          // Classes for [JACKSON-294]     static class Foo294     {         @JsonProperty private String id;         @JsonSerialize(using = Bar294Serializer.class)         private Bar294 bar;          public Foo294() { }         public Foo294(String id, String id2) {             this.id = id;             bar = new Bar294(id2);         }     }      static class Bar294{         @JsonProperty private String id;         @JsonProperty private String name;          public Bar294() { }         public Bar294(String id) {             this.id = id;         }          public String getId() { return id; }         public String getName() { return name; }     }      static class Bar294Serializer extends JsonSerializer<Bar294>     {         @Override         public void serialize(Bar294 bar, JsonGenerator jgen,             SerializerProvider provider) throws IOException         {             jgen.writeString(bar.id);         }     }      /*     /**********************************************************     /* Main tests     /**********************************************************      */      @SuppressWarnings("unchecked")     public void testSimpleValueDefinition() throws Exception     {         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new WrapperClassForAs());         assertEquals(1, result.size());         Object ob = result.get("value");         // Should see only "x", not "y"         result = (Map<String,Object>) ob;         assertEquals(1, result.size());         assertEquals(Integer.valueOf(3), result.get("x"));     }      public void testBrokenAnnotation() throws Exception     {         ObjectMapper m = new ObjectMapper();         try {             serializeAsString(m, new BrokenClass());         } catch (Exception e) {             verifyException(e, "not a super-type of");         }     }      @SuppressWarnings("unchecked")     public void testStaticTypingForClass() throws Exception     {         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new WrapperClassForStaticTyping());         assertEquals(1, result.size());         Object ob = result.get("value");         // Should see only "x", not "y"         result = (Map<String,Object>) ob;         assertEquals(1, result.size());         assertEquals(Integer.valueOf(3), result.get("x"));     }      @SuppressWarnings("unchecked")     public void testMixedTypingForClass() throws Exception     {         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new WrapperClassForStaticTyping2());         assertEquals(2, result.size());          Object obStatic = result.get("staticValue");         // Should see only "x", not "y"         Map<String,Object> stat = (Map<String,Object>) obStatic;         assertEquals(1, stat.size());         assertEquals(Integer.valueOf(3), stat.get("x"));          Object obDynamic = result.get("dynamicValue");         // Should see both         Map<String,Object> dyn = (Map<String,Object>) obDynamic;         assertEquals(2, dyn.size());         assertEquals(Integer.valueOf(3), dyn.get("x"));         assertEquals(Integer.valueOf(5), dyn.get("y"));     }      public void testStaticTypingWithMap() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(MapperFeature.USE_STATIC_TYPING, true);         ValueMap map = new ValueMap();         map.put("a", new ValueClass());         assertEquals("{\"a\":{\"x\":3}}", serializeAsString(m, map));     }      public void testStaticTypingWithArrayList() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(MapperFeature.USE_STATIC_TYPING, true);         ValueList list = new ValueList();         list.add(new ValueClass());         assertEquals("[{\"x\":3}]", m.writeValueAsString(list));     }      public void testStaticTypingWithLinkedList() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(MapperFeature.USE_STATIC_TYPING, true);         ValueLinkedList list = new ValueLinkedList();         list.add(new ValueClass());         assertEquals("[{\"x\":3}]", serializeAsString(m, list));     }          public void testStaticTypingWithArray() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(MapperFeature.USE_STATIC_TYPING, true);         ValueInterface[] array = new ValueInterface[] { new ValueClass() };         assertEquals("[{\"x\":3}]", serializeAsString(m, array));     }      public void testProblem294() throws Exception     {         assertEquals("{\"id\":\"fooId\",\"bar\":\"barId\"}",                 new ObjectMapper().writeValueAsString(new Foo294("fooId", "barId")));     }      } 
package com.fasterxml.jackson.databind.ser;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.core.JsonProcessingException;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.ser.std.NullSerializer;  @SuppressWarnings("serial") public class TestJsonSerialize2     extends BaseMapTest {     // [JACKSON-480]      static class SimpleKey {         protected final String key;                  public SimpleKey(String str) { key = str; }                  @Override public String toString() { return "toString:"+key; }     }      static class SimpleValue {         public final String value;                  public SimpleValue(String str) { value = str; }     }      @JsonPropertyOrder({"value", "value2"})     static class ActualValue extends SimpleValue     {         public final String other = "123";                  public ActualValue(String str) { super(str); }     }      static class SimpleKeySerializer extends JsonSerializer<SimpleKey> {         @Override         public void serialize(SimpleKey key, JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonProcessingException {             jgen.writeFieldName("key "+key.key);         }     }      static class SimpleValueSerializer extends JsonSerializer<SimpleValue> {         @Override         public void serialize(SimpleValue value, JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonProcessingException {             jgen.writeString("value "+value.value);         }     }      @JsonSerialize(contentAs=SimpleValue.class)     static class SimpleValueList extends ArrayList<ActualValue> { }      @JsonSerialize(contentAs=SimpleValue.class)     static class SimpleValueMap extends HashMap<SimpleKey, ActualValue> { }      @JsonSerialize(contentUsing=SimpleValueSerializer.class)     static class SimpleValueListWithSerializer extends ArrayList<ActualValue> { }      @JsonSerialize(keyUsing=SimpleKeySerializer.class, contentUsing=SimpleValueSerializer.class)     static class SimpleValueMapWithSerializer extends HashMap<SimpleKey, ActualValue> { }          static class ListWrapperSimple     {         @JsonSerialize(contentAs=SimpleValue.class)         public final ArrayList<ActualValue> values = new ArrayList<ActualValue>();                  public ListWrapperSimple(String value) {             values.add(new ActualValue(value));         }     }      static class ListWrapperWithSerializer     {         @JsonSerialize(contentUsing=SimpleValueSerializer.class)         public final ArrayList<ActualValue> values = new ArrayList<ActualValue>();                  public ListWrapperWithSerializer(String value) {             values.add(new ActualValue(value));         }     }          static class MapWrapperSimple     {         @JsonSerialize(contentAs=SimpleValue.class)         public final HashMap<SimpleKey, ActualValue> values = new HashMap<SimpleKey, ActualValue>();                  public MapWrapperSimple(String key, String value) {             values.put(new SimpleKey(key), new ActualValue(value));         }     }      static class MapWrapperWithSerializer     {         @JsonSerialize(keyUsing=SimpleKeySerializer.class, contentUsing=SimpleValueSerializer.class)         public final HashMap<SimpleKey, ActualValue> values = new HashMap<SimpleKey, ActualValue>();                  public MapWrapperWithSerializer(String key, String value) {             values.put(new SimpleKey(key), new ActualValue(value));         }     }      static class NullBean     {         @JsonSerialize(using=NullSerializer.class)         public String value = "abc";     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          // [JACKSON-480], test value annotation applied to List value class     public void testSerializedAsListWithClassAnnotations() throws IOException     {         SimpleValueList list = new SimpleValueList();         list.add(new ActualValue("foo"));         assertEquals("[{\"value\":\"foo\"}]", MAPPER.writeValueAsString(list));     }      // [JACKSON-480], test value annotation applied to Map value class     public void testSerializedAsMapWithClassAnnotations() throws IOException     {         SimpleValueMap map = new SimpleValueMap();         map.put(new SimpleKey("x"), new ActualValue("y"));         assertEquals("{\"toString:x\":{\"value\":\"y\"}}", MAPPER.writeValueAsString(map));     }      // [JACKSON-480], test Serialization annotation with List     public void testSerializedAsListWithClassSerializer() throws IOException     {         ObjectMapper m = new ObjectMapper();         SimpleValueListWithSerializer list = new SimpleValueListWithSerializer();         list.add(new ActualValue("foo"));         assertEquals("[\"value foo\"]", m.writeValueAsString(list));     }      // [JACKSON-480], test annotations when applied to List property (getter, setter)     public void testSerializedAsListWithPropertyAnnotations() throws IOException     {         ListWrapperSimple input = new ListWrapperSimple("bar");         assertEquals("{\"values\":[{\"value\":\"bar\"}]}", MAPPER.writeValueAsString(input));     }          // [JACKSON-480], test Serialization annotation with Map     public void testSerializedAsMapWithClassSerializer() throws IOException     {         SimpleValueMapWithSerializer map = new SimpleValueMapWithSerializer();         map.put(new SimpleKey("abc"), new ActualValue("123"));         assertEquals("{\"key abc\":\"value 123\"}", MAPPER.writeValueAsString(map));     }      // [JACKSON-480], test annotations when applied to Map property (getter, setter)     public void testSerializedAsMapWithPropertyAnnotations() throws IOException     {         MapWrapperSimple input = new MapWrapperSimple("a", "b");         assertEquals("{\"values\":{\"toString:a\":{\"value\":\"b\"}}}",                 MAPPER.writeValueAsString(input));     }          public void testSerializedAsListWithPropertyAnnotations2() throws IOException     {         ListWrapperWithSerializer input = new ListWrapperWithSerializer("abc");         assertEquals("{\"values\":[\"value abc\"]}", MAPPER.writeValueAsString(input));     }      public void testSerializedAsMapWithPropertyAnnotations2() throws IOException     {         MapWrapperWithSerializer input = new MapWrapperWithSerializer("foo", "b");         assertEquals("{\"values\":{\"key foo\":\"value b\"}}", MAPPER.writeValueAsString(input));     }      // [JACKSON-602]: Include.NON_EMPTY     public void testEmptyInclusion() throws IOException     {         ObjectMapper defMapper = MAPPER;         ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_EMPTY);          StringWrapper str = new StringWrapper("");         assertEquals("{\"str\":\"\"}", defMapper.writeValueAsString(str));         assertEquals("{}", inclMapper.writeValueAsString(str));         assertEquals("{}", inclMapper.writeValueAsString(new StringWrapper()));          ListWrapper<String> list = new ListWrapper<String>();         assertEquals("{\"list\":[]}", defMapper.writeValueAsString(list));         assertEquals("{}", inclMapper.writeValueAsString(list));         assertEquals("{}", inclMapper.writeValueAsString(new ListWrapper<String>()));          MapWrapper<String,Integer> map = new MapWrapper<String,Integer>(new HashMap<String,Integer>());         assertEquals("{\"map\":{}}", defMapper.writeValueAsString(map));         assertEquals("{}", inclMapper.writeValueAsString(map));         assertEquals("{}", inclMapper.writeValueAsString(new MapWrapper<String,Integer>(null)));          ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]);         assertEquals("{\"array\":[]}", defMapper.writeValueAsString(array));         assertEquals("{}", inclMapper.writeValueAsString(array));         assertEquals("{}", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null)));     }      // [JACKSON-699]     public void testNullSerializer() throws Exception     {         String json = MAPPER.writeValueAsString(new NullBean());         assertEquals("{\"value\":null}", json);     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.core.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  public class TestJsonSerialize3 extends BaseMapTest {     // [JACKSON-829]     static class FooToBarSerializer extends JsonSerializer<String> {         @Override         public void serialize(String value, JsonGenerator jgen, SerializerProvider provider)                throws IOException {             if ("foo".equals(value)) {                 jgen.writeString("bar");             } else {                 jgen.writeString(value);             }         }     }      static class MyObject {         @JsonSerialize(contentUsing = FooToBarSerializer.class)         List<String> list;     }         /*     /**********************************************************     /* Test methods     /**********************************************************      */          public void testCustomContentSerializer() throws Exception     {         ObjectMapper m = new ObjectMapper();         MyObject object = new MyObject();         object.list = Arrays.asList("foo");         String json = m.writeValueAsString(object);         assertEquals("{\"list\":[\"bar\"]}", json);     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.IOException;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  public class TestJsonSerializeAs extends BaseMapTest {     // [JACKSON-799] stuff:          public interface Fooable {         public int getFoo();     }      // force use of interface     @JsonSerialize(as=Fooable.class)     public static class FooImpl implements Fooable {         @Override         public int getFoo() { return 42; }         public int getBar() { return 15; }     }      public class Fooables {         public FooImpl[] getFoos() {             return new FooImpl[] { new FooImpl() };         }     }      public class FooableWrapper {         public FooImpl getFoo() {             return new FooImpl();         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final ObjectWriter WRITER = objectWriter();          // [JACKSON-799]     public void testSerializeAsInClass() throws IOException     {         assertEquals("{\"foo\":42}", WRITER.writeValueAsString(new FooImpl()));     }      public void testSerializeAsForArrayProp() throws IOException     {         assertEquals("{\"foos\":[{\"foo\":42}]}", WRITER.writeValueAsString(new Fooables()));     }      public void testSerializeAsForSimpleProp() throws IOException     {         assertEquals("{\"foo\":{\"foo\":42}}", WRITER.writeValueAsString(new FooableWrapper()));     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize; import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;  /**  * This unit test suite tests functioning of {@link JsonValue}  * annotation with bean serialization.  */ public class TestJsonValue     extends BaseMapTest {     /*     /*********************************************************     /* Helper bean classes     /*********************************************************      */      static class ValueClass<T>     {         final T _value;          public ValueClass(T v) { _value = v; }          @JsonValue T value() { return _value; }          // shouldn't need this, but may be useful for troubleshooting:         @Override         public String toString() { return "???"; }     }      /**      * Another test class to check that it is also possible to      * force specific serializer to use with @JsonValue annotated      * method. Difference is between Integer serialization, and      * conversion to a Json String.      */     final static class ToStringValueClass<T>         extends ValueClass<T>     {         public ToStringValueClass(T value) { super(value); }          // Also, need to use this annotation to help         @JsonSerialize(using=ToStringSerializer.class)         @Override         @JsonValue T value() { return super.value(); }     }      final static class ToStringValueClass2         extends ValueClass<String>     {         public ToStringValueClass2(String value) { super(value); }          /* Simple as well, but let's ensure that other getters won't matter...          */          @JsonProperty int getFoobar() { return 4; }          public String[] getSomethingElse() { return new String[] { "1", "a" }; }     }      static class ValueBase {         public String a = "a";     }      static class ValueType extends ValueBase {         public String b = "b";     }          // Finally, let's also test static vs dynamic type     static class ValueWrapper {         @JsonValue         public ValueBase getX() { return new ValueType(); }     }      static class MapBean     {         @JsonValue         public Map<String,String> toMap()         {             HashMap<String,String> map = new HashMap<String,String>();             map.put("a", "1");             return map;         }     }      @SuppressWarnings("serial")     static class MapAsNumber extends HashMap<String,String>     {         @JsonValue         public int value() { return 42; }     }      @SuppressWarnings("serial")     static class ListAsNumber extends ArrayList<Integer>     {         @JsonValue         public int value() { return 13; }     }      static class IntExtBean {         public List<Internal> values = new ArrayList<Internal>();                  public void add(int v) { values.add(new Internal(v)); }     }          static class Internal {         public int value;                  public Internal(int v) { value = v; }                  @JsonValue         public External asExternal() { return new External(this); }     }          static class External {         public int i;                  External(Internal e) { i = e.value; }     }      // [Issue#167]          @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "boingo")     @JsonSubTypes(value = {@JsonSubTypes.Type(name = "boopsy", value = AdditionInterfaceImpl.class) })     static interface AdditionInterface     {     	public int add(int in);     } 	     public static class AdditionInterfaceImpl implements AdditionInterface     { 	    private final int toAdd; 	 	    @JsonCreator 	    public AdditionInterfaceImpl(@JsonProperty("toAdd") int toAdd) { 	      this.toAdd = toAdd; 	    } 	 	    @JsonProperty 	    public int getToAdd() { 	      return toAdd; 	    } 	 	    @Override 	    public int add(int in) { 	      return in + toAdd; 	    }     } 	     public static class NegatingAdditionInterface implements AdditionInterface     { 	    final AdditionInterface delegate; 	 	    public NegatingAdditionInterface(AdditionInterface delegate) { 	    	this.delegate = delegate; 	    } 	 	    @Override 	    public int add(int in) { 	      return delegate.add(-in); 	    } 	 	    @JsonValue 	    public AdditionInterface getDelegate() { 	      return delegate; 	    }     }          /*     /*********************************************************     /* Test cases     /*********************************************************      */      private final ObjectMapper MAPPER = new ObjectMapper();          public void testSimpleJsonValue() throws Exception     {         String result = MAPPER.writeValueAsString(new ValueClass<String>("abc"));         assertEquals("\"abc\"", result);     }      public void testJsonValueWithUseSerializer() throws Exception     {         String result = serializeAsString(MAPPER, new ToStringValueClass<Integer>(Integer.valueOf(123)));         assertEquals("\"123\"", result);     }      /**      * Test for verifying that additional getters won't confuse serializer.      */     public void testMixedJsonValue() throws Exception     {         String result = serializeAsString(MAPPER, new ToStringValueClass2("xyz"));         assertEquals("\"xyz\"", result);     }      public void testValueWithStaticType() throws Exception     {         // Ok; first, with dynamic type:         assertEquals("{\"a\":\"a\",\"b\":\"b\"}", MAPPER.writeValueAsString(new ValueWrapper()));          // then static         ObjectMapper staticMapper = new ObjectMapper();         staticMapper.configure(MapperFeature.USE_STATIC_TYPING, true);         assertEquals("{\"a\":\"a\"}", staticMapper.writeValueAsString(new ValueWrapper()));     }      public void testMapWithJsonValue() throws Exception {         assertEquals("{\"a\":\"1\"}", MAPPER.writeValueAsString(new MapBean()));     }      public void testWithMap() throws Exception {         assertEquals("42", MAPPER.writeValueAsString(new MapAsNumber()));      }      public void testWithList() throws Exception {         assertEquals("13", MAPPER.writeValueAsString(new ListAsNumber()));     }      public void testInList() throws Exception {         IntExtBean bean = new IntExtBean();         bean.add(1);         bean.add(2);         String json = MAPPER.writeValueAsString(bean);         assertEquals(json, "{\"values\":[{\"i\":1},{\"i\":2}]}");     }      // [Issue#167]     public void testPolymorphicSerdeWithDelegate() throws Exception     { 	    AdditionInterface adder = new AdditionInterfaceImpl(1); 	 	    assertEquals(2, adder.add(1)); 	    String json = MAPPER.writeValueAsString(adder); 	    assertEquals("{\"boingo\":\"boopsy\",\"toAdd\":1}", json); 	    assertEquals(2, MAPPER.readValue(json, AdditionInterface.class).add(1)); 	 	    adder = new NegatingAdditionInterface(adder); 	    assertEquals(0, adder.add(1)); 	    json = MAPPER.writeValueAsString(adder); 	     	    assertEquals("{\"boingo\":\"boopsy\",\"toAdd\":1}", json); 	    assertEquals(2, MAPPER.readValue(json, AdditionInterface.class).add(1));     }  } 
package com.fasterxml.jackson.databind.ser;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.core.JsonGenerator; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  public class TestKeySerializers extends BaseMapTest {     public static class KarlSerializer extends JsonSerializer<String>     {         @Override         public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException {             jgen.writeFieldName("Karl");         }     }      public static class NotKarlBean     {         public Map<String,Integer> map = new HashMap<String,Integer>();         {             map.put("Not Karl", 1);         }     }      public static class KarlBean     {         @JsonSerialize(keyUsing = KarlSerializer.class)         public Map<String,Integer> map = new HashMap<String,Integer>();         {             map.put("Not Karl", 1);         }     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */          public void testNotKarl() throws IOException {         final ObjectMapper mapper = new ObjectMapper();         final String serialized = mapper.writeValueAsString(new NotKarlBean());         assertEquals("{\"map\":{\"Not Karl\":1}}", serialized);     }      public void testKarl() throws IOException {         final ObjectMapper mapper = new ObjectMapper();         final String serialized = mapper.writeValueAsString(new KarlBean());         assertEquals("{\"map\":{\"Karl\":1}}", serialized);     }      // [Issue#75]: caching of KeySerializers     public void testBoth() throws IOException     {         final ObjectMapper mapper = new ObjectMapper();         final String value1 = mapper.writeValueAsString(new NotKarlBean());         assertEquals("{\"map\":{\"Not Karl\":1}}", value1);         final String value2 = mapper.writeValueAsString(new KarlBean());         assertEquals("{\"map\":{\"Karl\":1}}", value2);     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*; import java.util.*; import java.util.concurrent.ConcurrentHashMap;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  @SuppressWarnings("serial") public class TestMapSerialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper classes     /**********************************************************      */      /**      * Class needed for testing [JACKSON-220]      */     @JsonSerialize(using=MapSerializer.class)         static class PseudoMap extends LinkedHashMap<String,String>     {         public PseudoMap(String... values) {             for (int i = 0, len = values.length; i < len; i += 2) {                 put(values[i], values[i+1]);             }         }     }      static class MapSerializer extends JsonSerializer<Map<String,String>>     {         @Override         public void serialize(Map<String,String> value,                               JsonGenerator jgen,                               SerializerProvider provider)             throws IOException         {             // just use standard Map.toString(), output as JSON String             jgen.writeString(value.toString());         }     }      // For [JACKSON-574]     static class DefaultKeySerializer extends JsonSerializer<Object>     {         @Override         public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException         {             jgen.writeFieldName("DEFAULT:"+value);         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */      final ObjectMapper MAPPER = new ObjectMapper();          // Test [JACKSON-220]     public void testMapSerializer() throws IOException     {         assertEquals("\"{a=b, c=d}\"", MAPPER.writeValueAsString(new PseudoMap("a", "b", "c", "d")));     }      // Test [JACKSON-314]     public void testMapNullSerialization() throws IOException     {         ObjectMapper m = new ObjectMapper();         Map<String,String> map = new HashMap<String,String>();         map.put("a", null);         // by default, should output null-valued entries:         assertEquals("{\"a\":null}", m.writeValueAsString(map));         // but not if explicitly asked not to (note: config value is dynamic here)         m.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);         assertEquals("{}", m.writeValueAsString(map));     }      // [JACKSON-499], problems with map entries, values     public void testMapKeyValueSerialization() throws IOException     {         Map<String,String> map = new HashMap<String,String>();         map.put("a", "b");         assertEquals("[\"a\"]", MAPPER.writeValueAsString(map.keySet()));         assertEquals("[\"b\"]", MAPPER.writeValueAsString(map.values()));          // TreeMap has similar inner class(es):         map = new TreeMap<String,String>();         map.put("c", "d");         assertEquals("[\"c\"]", MAPPER.writeValueAsString(map.keySet()));         assertEquals("[\"d\"]", MAPPER.writeValueAsString(map.values()));          // and for [JACKSON-533], same for concurrent maps         map = new ConcurrentHashMap<String,String>();         map.put("e", "f");         assertEquals("[\"e\"]", MAPPER.writeValueAsString(map.keySet()));         assertEquals("[\"f\"]", MAPPER.writeValueAsString(map.values()));     }      // For [JACKSON-574]     public void testDefaultKeySerializer() throws IOException     {         ObjectMapper m = new ObjectMapper();         m.getSerializerProvider().setDefaultKeySerializer(new DefaultKeySerializer());         Map<String,String> map = new HashMap<String,String>();         map.put("a", "b");         assertEquals("{\"DEFAULT:a\":\"b\"}", m.writeValueAsString(map));     }      // [JACKSON-636]: sort Map entries by key     public void testOrderByKey() throws IOException     {         ObjectMapper m = new ObjectMapper();         assertFalse(m.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS));         LinkedHashMap<String,Integer> map = new LinkedHashMap<String,Integer>();         map.put("b", 3);         map.put("a", 6);         // by default, no (re)ordering:         assertEquals("{\"b\":3,\"a\":6}", m.writeValueAsString(map));         // but can be changed         assertEquals("{\"a\":6,\"b\":3}", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map));     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.IOException; import java.util.*;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.annotation.JsonSerialize;  /**  * Unit tests for checking that alternative settings for  * {@link JsonSerialize#include} annotation property work  * as expected.  */ public class TestNullProperties     extends BaseMapTest {     /*     /**********************************************************     /* Helper beans     /**********************************************************      */      static class SimpleBean     {         public String getA() { return "a"; }         public String getB() { return null; }     }          @JsonSerialize(include=JsonSerialize.Inclusion.ALWAYS) // just to ensure default     static class NoNullsBean     {         @JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)         public String getA() { return null; }          public String getB() { return null; }     }      @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)     static class NonDefaultBean     {         String _a = "a", _b = "b";          NonDefaultBean() { }          public String getA() { return _a; }         public String getB() { return _b; }     }      static class MixedBean     {         String _a = "a", _b = "b";          MixedBean() { }          @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)         public String getA() { return _a; }          @JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)         public String getB() { return _b; }     }      // to ensure that default values work for collections as well     static class ListBean {         @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)         public List<String> strings = new ArrayList<String>();     }          @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)     static class ArrayBean {         public int[] ints = new int[] { 1, 2 };     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */          public void testGlobal() throws IOException     {         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new SimpleBean());         assertEquals(2, result.size());         assertEquals("a", result.get("a"));         assertNull(result.get("b"));         assertTrue(result.containsKey("b"));     }      public void testNonNullByClass() throws IOException     {         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new NoNullsBean());         assertEquals(1, result.size());         assertFalse(result.containsKey("a"));         assertNull(result.get("a"));         assertTrue(result.containsKey("b"));         assertNull(result.get("b"));     }      public void testNonDefaultByClass() throws IOException     {         ObjectMapper m = new ObjectMapper();         NonDefaultBean bean = new NonDefaultBean();         // need to change one of defaults         bean._a = "notA";         Map<String,Object> result = writeAndMap(m, bean);         assertEquals(1, result.size());         assertTrue(result.containsKey("a"));         assertEquals("notA", result.get("a"));         assertFalse(result.containsKey("b"));         assertNull(result.get("b"));     }      public void testMixedMethod() throws IOException     {         ObjectMapper m = new ObjectMapper();          MixedBean bean = new MixedBean();         bean._a = "xyz";         bean._b = null;         Map<String,Object> result = writeAndMap(m, bean);         assertEquals(1, result.size());         assertEquals("xyz", result.get("a"));         assertFalse(result.containsKey("b"));          bean._a = "a";         bean._b = "b";         result = writeAndMap(m, bean);         assertEquals(1, result.size());         assertEquals("b", result.get("b"));         assertFalse(result.containsKey("a"));     }      public void testDefaultForEmptyList() throws IOException     {         ObjectMapper m = new ObjectMapper();         assertEquals("{}", m.writeValueAsString(new ListBean()));     }      // [JACKSON-531]: make NON_DEFAULT work for arrays too     public void testNonEmptyDefaultArray() throws IOException     {         ObjectMapper m = new ObjectMapper();         assertEquals("{}", m.writeValueAsString(new ArrayBean()));     } } 
package com.fasterxml.jackson.databind.ser;  import java.io.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*;  public class TestNullSerialization     extends BaseMapTest {     static class NullSerializer extends JsonSerializer<Object>     {         @Override         public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)             throws IOException, JsonProcessingException         {             jgen.writeString("foobar");         }     }      static class Bean1 {         public String name = null;     }      static class Bean2 {         public String type = null;     }          @SuppressWarnings("serial")     static class MyNullProvider extends DefaultSerializerProvider     {         public MyNullProvider() { super(); }         public MyNullProvider(MyNullProvider base, SerializationConfig config, SerializerFactory jsf) {             super(base, config, jsf);         }                  @Override         public DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) {             return new MyNullProvider(this, config, jsf);         }                  @Override         public JsonSerializer<Object> findNullValueSerializer(BeanProperty property)             throws JsonMappingException         {             if ("name".equals(property.getName())) {                 return new NullSerializer();             }             return super.findNullValueSerializer(property);         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */          public void testSimple() throws Exception     {         assertEquals("null", new ObjectMapper().writeValueAsString(null));     }      public void testOverriddenDefaultNulls() throws Exception     {         DefaultSerializerProvider sp = new DefaultSerializerProvider.Impl();         sp.setNullValueSerializer(new NullSerializer());         ObjectMapper m = new ObjectMapper();         m.setSerializerProvider(sp);         assertEquals("\"foobar\"", m.writeValueAsString(null));     }      public void testCustomNulls() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.setSerializerProvider(new MyNullProvider());         assertEquals("{\"name\":\"foobar\"}", m.writeValueAsString(new Bean1()));         assertEquals("{\"type\":null}", m.writeValueAsString(new Bean2()));     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;   import com.fasterxml.jackson.core.PrettyPrinter; import com.fasterxml.jackson.databind.*;  /**  * Unit tests for checking features added to {@link ObjectWriter}, such  * as adding of explicit pretty printer.  */ public class TestObjectWriter     extends BaseMapTest {     public void testPrettyPrinter() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         ObjectWriter writer = mapper.writer();         HashMap<String, Integer> data = new HashMap<String,Integer>();         data.put("a", 1);                  // default: no indentation         assertEquals("{\"a\":1}", writer.writeValueAsString(data));          // and then with standard         writer = writer.withDefaultPrettyPrinter();          // pretty printer uses system-specific line feeds, so we do that as well.         String lf = System.getProperty("line.separator");         assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data));          // and finally, again without indentation         writer = writer.with((PrettyPrinter) null);         assertEquals("{\"a\":1}", writer.writeValueAsString(data));     }      public void testPrefetch() throws Exception     {         ObjectWriter writer = objectWriter();         assertFalse(writer.hasPrefetchedSerializer());         writer = objectWriter().withType(String.class);         assertTrue(writer.hasPrefetchedSerializer());     } }  
package com.fasterxml.jackson.databind.ser;  import java.io.StringWriter; import java.util.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonTypeInfo.As; import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.type.TypeFactory;  /**  * Unit tests for verifying functioning of [JACKSON-195], ability to  * force specific root type for serialization (super type of value)  */ public class TestRootType     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      interface BaseInterface {         int getB();     }          static class BaseType         implements BaseInterface     {         public String a = "a";          @Override         public int getB() { return 3; }     }      static class SubType extends BaseType {         public String a2 = "x";                  public boolean getB2() { return true; }     }      @JsonTypeInfo(use=Id.NAME, include=As.PROPERTY, property="beanClass")     public abstract static class BaseClass398 { }      public static class TestClass398 extends BaseClass398 {        public String property = "aa";     }          @JsonRootName("root")     static class WithRootName {         public int a = 3;     }      /*     /**********************************************************     /* Main tests     /**********************************************************      */          @SuppressWarnings("unchecked")     public void testSuperClass() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SubType bean = new SubType();          // first, test with dynamically detected type         Map<String,Object> result = writeAndMap(mapper, bean);         assertEquals(4, result.size());         assertEquals("a", result.get("a"));         assertEquals(Integer.valueOf(3), result.get("b"));         assertEquals("x", result.get("a2"));         assertEquals(Boolean.TRUE, result.get("b2"));          // and then using specified typed writer         ObjectWriter w = mapper.writerWithType(BaseType.class);         String json = w.writeValueAsString(bean);         result = (Map<String,Object>)mapper.readValue(json, Map.class);         assertEquals(2, result.size());         assertEquals("a", result.get("a"));         assertEquals(Integer.valueOf(3), result.get("b"));     }      public void testSuperInterface() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SubType bean = new SubType();          // let's constrain by interface:         ObjectWriter w = mapper.writerWithType(BaseInterface.class);         String json = w.writeValueAsString(bean);         @SuppressWarnings("unchecked")         Map<String,Object> result = mapper.readValue(json, Map.class);         assertEquals(1, result.size());         assertEquals(Integer.valueOf(3), result.get("b"));     }      public void testInArray() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         // must force static typing, otherwise won't matter a lot         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);         SubType[] ob = new SubType[] { new SubType() };         String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob);         // should propagate interface type through due to root declaration; static typing         assertEquals("[{\"b\":3}]", json);     }          /**      * Unit test to ensure that proper exception is thrown if declared      * root type is not compatible with given value instance.      */     public void testIncompatibleRootType() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         SubType bean = new SubType();          // and then let's try using incompatible type         ObjectWriter w = mapper.writerWithType(HashMap.class);         try {             w.writeValueAsString(bean);             fail("Should have failed due to incompatible type");         } catch (JsonProcessingException e) {             verifyException(e, "Incompatible types");         }     }          /**      * Unit test to verify [JACKSON-398]      */     public void testJackson398() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class);         List<TestClass398> typedList = new ArrayList<TestClass398>();         typedList.add(new TestClass398());          final String EXP = "[{\"beanClass\":\"TestRootType$TestClass398\",\"property\":\"aa\"}]";                  // First simplest way:         String json = mapper.writerWithType(collectionType).writeValueAsString(typedList);         assertEquals(EXP, json);          StringWriter out = new StringWriter();         JsonFactory f = new JsonFactory();         mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList);          assertEquals(EXP, out.toString());     }      // Test to verify [JACKSON-163]     public void testRootWrapping() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);         String json = mapper.writeValueAsString(new StringWrapper("abc"));         assertEquals("{\"StringWrapper\":{\"str\":\"abc\"}}", json);     }      /**      * Test to verify that there is support for specifying root type as primitive,      * even if wrapper value is passed (there is no way to pass primitive values as      * Objects); this to support frameworks that may pass unprocessed      * {@link java.lang.reflect.Type} from field or method.      */     public void testIssue456WrapperPart() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         assertEquals("123", mapper.writerWithType(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));         assertEquals("456", mapper.writerWithType(Long.TYPE).writeValueAsString(Long.valueOf(456L)));     }      // [JACKSON-630] also, allow annotation to define root name     public void testRootNameAnnotation() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);         String json = mapper.writeValueAsString(new WithRootName());         assertEquals("{\"root\":{\"a\":3}}", json);     } } 
package com.fasterxml.jackson.databind.ser;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying that constraints on ordering of serialized  * properties are held.  */ public class TestSerializationOrder     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      static class BeanWithCreator     {         public int a;         public int b;         public int c;          @JsonCreator public BeanWithCreator(@JsonProperty("c") int c, @JsonProperty("a") int a) {             this.a = a;             this.c = c;         }     }      @JsonPropertyOrder({"c", "a", "b"})     static class BeanWithOrder     {         public int d, b, a, c;                  public BeanWithOrder(int a, int b, int c, int d) {             this.a = a;             this.b = b;             this.c = c;             this.d = d;         }     }      @JsonPropertyOrder(value={"d"}, alphabetic=true)     static class SubBeanWithOrder extends BeanWithOrder     {         public SubBeanWithOrder(int a, int b, int c, int d) {             super(a, b, c, d);         }     }      @JsonPropertyOrder({"b", "a",         // note: including non-existant properties is fine (has no effect, but not an error)         "foobar",         "c"     })     static class OrderMixIn { }      @JsonPropertyOrder(value={"a","b","x","z"})     static class BeanFor268 { // testing [JACKSON-268]     	@JsonProperty("a") public String xA = "a";     	@JsonProperty("z") public String aZ = "z";     	@JsonProperty("b") public String xB() { return "b"; }     	@JsonProperty("x") public String aX() { return "x"; }     }      static class BeanFor459 {         public int d = 4;         public int c = 3;         public int b = 2;         public int a = 1;     }          /*     /*********************************************     /* Unit tests     /*********************************************      */      // Test for [JACKSON-170]     public void testImplicitOrderByCreator() throws Exception     {         assertEquals("{\"c\":1,\"a\":2,\"b\":0}", serializeAsString(new BeanWithCreator(1, 2)));     }      public void testExplicitOrder() throws Exception     {         assertEquals("{\"c\":3,\"a\":1,\"b\":2,\"d\":4}", serializeAsString(new BeanWithOrder(1, 2, 3, 4)));     }      public void testAlphabeticOrder() throws Exception     {         assertEquals("{\"d\":4,\"a\":1,\"b\":2,\"c\":3}", serializeAsString(new SubBeanWithOrder(1, 2, 3, 4)));     }       public void testOrderWithMixins() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.addMixInAnnotations(BeanWithOrder.class, OrderMixIn.class);         assertEquals("{\"b\":2,\"a\":1,\"c\":3,\"d\":4}", serializeAsString(m, new BeanWithOrder(1, 2, 3, 4)));     }      // Test for [JACKSON-268]     public void testOrderWrt268() throws Exception     {         assertEquals("{\"a\":\"a\",\"b\":\"b\",\"x\":\"x\",\"z\":\"z\"}",         		serializeAsString(new BeanFor268()));     }      // Test for [JACKSON-459]     public void testOrderWithFeature() throws Exception     {         ObjectMapper m = new ObjectMapper();         m.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true);         assertEquals("{\"a\":1,\"b\":2,\"c\":3,\"d\":4}", serializeAsString(m, new BeanFor459()));     } } 
package com.fasterxml.jackson.databind.ser;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ser.BeanSerializerFactory;  public class TestSerializerProvider     extends com.fasterxml.jackson.databind.BaseMapTest {     static class MyBean {         public int getX() { return 3; }     }      public void testFindExplicit() throws JsonMappingException     {         ObjectMapper mapper = new ObjectMapper();         SerializationConfig config = mapper.getSerializationConfig();         SerializerFactory f = new BeanSerializerFactory(null);         DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f);          // Should have working default key and null key serializers         assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null));         assertNotNull(prov.getDefaultNullKeySerializer());         assertNotNull(prov.getDefaultNullValueSerializer());         // as well as 'unknown type' one (throws exception)         assertNotNull(prov.getUnknownTypeSerializer(getClass()));                  assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class));         // call twice to verify it'll be cached (second code path)         assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class));          assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class));         assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class));     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.concurrent.atomic.*;   import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  /**  * Unit tests for verifying serialization of simple basic non-structured  * types; primitives (and/or their wrappers), Strings.  */ public class TestSimpleAtomicTypes     extends BaseMapTest {     public void testAtomicBoolean() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         assertEquals("true", serializeAsString(mapper, new AtomicBoolean(true)));         assertEquals("false", serializeAsString(mapper, new AtomicBoolean(false)));     }      public void testAtomicInteger() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         assertEquals("1", serializeAsString(mapper, new AtomicInteger(1)));         assertEquals("-9", serializeAsString(mapper, new AtomicInteger(-9)));     }      public void testAtomicLong() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         assertEquals("0", serializeAsString(mapper, new AtomicLong(0)));     }      public void testAtomicReference() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String[] strs = new String[] { "abc" };         assertEquals("[\"abc\"]", serializeAsString(mapper, new AtomicReference<String[]>(strs)));     } } 
package com.fasterxml.jackson.databind.ser;  import java.math.BigInteger;   import com.fasterxml.jackson.core.Base64Variants; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  import static org.junit.Assert.*;  /**  * Unit tests for verifying serialization of simple basic non-structured  * types; primitives (and/or their wrappers), Strings.  */ public class TestSimpleTypes     extends BaseMapTest {     private final ObjectMapper MAPPER = new ObjectMapper();          public void testBoolean() throws Exception     {         assertEquals("true", serializeAsString(MAPPER, Boolean.TRUE));         assertEquals("false", serializeAsString(MAPPER, Boolean.FALSE));     }      public void testBooleanArray() throws Exception     {         assertEquals("[true,false]", serializeAsString(MAPPER, new boolean[] { true, false} ));         assertEquals("[true,false]", serializeAsString(MAPPER, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));     }      public void testByteArray() throws Exception     {         byte[] data = { 1, 17, -3, 127, -128 };         Byte[] data2 = new Byte[data.length];         for (int i = 0; i < data.length; ++i) {             data2[i] = data[i]; // auto-boxing         }         // For this we need to deserialize, to get base64 codec         String str1 = serializeAsString(MAPPER, data);         String str2 = serializeAsString(MAPPER, data2);         assertArrayEquals(data, MAPPER.readValue(str1, byte[].class));         assertArrayEquals(data2, MAPPER.readValue(str2, Byte[].class));     }      // as per [Issue#42], allow Base64 variant use as well     public void testBase64Variants() throws Exception     {         final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8");                  // default encoding is "MIME, no linefeeds", so:         assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), MAPPER.writeValueAsString(INPUT));         assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="),                 MAPPER.writer(Base64Variants.MIME_NO_LINEFEEDS).writeValueAsString(INPUT));          // but others should be slightly different         assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="),                 MAPPER.writer(Base64Variants.MIME).writeValueAsString(INPUT));         assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"), // no padding or LF                 MAPPER.writer(Base64Variants.MODIFIED_FOR_URL).writeValueAsString(INPUT));         // PEM mandates 64 char lines:         assertEquals(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="),                 MAPPER.writer(Base64Variants.PEM).writeValueAsString(INPUT));     }          public void testShortArray() throws Exception     {         assertEquals("[0,1]", serializeAsString(MAPPER, new short[] { 0, 1 }));         assertEquals("[2,3]", serializeAsString(MAPPER, new Short[] { 2, 3 }));     }      public void testIntArray() throws Exception     {         assertEquals("[0,-3]", serializeAsString(MAPPER, new int[] { 0, -3 }));         assertEquals("[13,9]", serializeAsString(MAPPER, new Integer[] { 13, 9 }));     }      /* Note: dealing with floating-point values is tricky; not sure if      * we can really use equality tests here... JDK does have decent      * conversions though, to retain accuracy and round-trippability.      * But still...      */     public void testFloat() throws Exception     {         double[] values = new double[] {             0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY         };         for (double d : values) {            float f = (float) d;     	   String expected = String.valueOf(f);            if (Float.isNaN(f) || Float.isInfinite(f)) {                expected = "\""+expected+"\"";        	   }            assertEquals(expected,serializeAsString(MAPPER, Float.valueOf(f)));         }     }      public void testDouble() throws Exception     {         double[] values = new double[] {             0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY         };         for (double d : values) {             String expected = String.valueOf(d);             if (Double.isNaN(d) || Double.isInfinite(d)) {                 expected = "\""+d+"\"";             }             assertEquals(expected, MAPPER.writeValueAsString(Double.valueOf(d)));         }     }      public void testBigInteger() throws Exception     {         BigInteger[] values = new BigInteger[] {                 BigInteger.ONE, BigInteger.TEN, BigInteger.ZERO,                 BigInteger.valueOf(1234567890L),                 new BigInteger("123456789012345678901234568"),                 new BigInteger("-1250000124326904597090347547457")                 };          for (BigInteger value : values) {             String expected = value.toString();             assertEquals(expected, MAPPER.writeValueAsString(value));         }     }          public void testClass() throws Exception     {         String result = MAPPER.writeValueAsString(java.util.List.class);         assertEquals("\"java.util.List\"", result);     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.databind.*;  /**  * This unit test suite verifies that static fields and methods are  * ignored wrt serialization  */ public class TestStatics     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      final static class FieldBean     {         public int x = 1;          public static int y = 2;          // not even @JsonProperty should make statics usable...         @JsonProperty public static int z = 3;     }      final static class GetterBean     {         public int getX() { return 3; }          public static int getA() { return -3; }          // not even @JsonProperty should make statics usable...         @JsonProperty public static int getFoo() { return 123; }     }      /*     /**********************************************************     /* Unit tests     /**********************************************************      */      public void testStaticFields() throws Exception     {         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new FieldBean());         assertEquals(1, result.size());         assertEquals(Integer.valueOf(1), result.get("x"));     }      public void testStaticMethods() throws Exception     {         ObjectMapper m = new ObjectMapper();         Map<String,Object> result = writeAndMap(m, new GetterBean());         assertEquals(1, result.size());         assertEquals(Integer.valueOf(3), result.get("x"));     } } 
package com.fasterxml.jackson.databind.ser;   import java.io.*; import java.util.*;   import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.node.*;  /**  * This unit test suite tries to verify that JsonNode-based trees  * can be serialized as expected  */ public class TestTreeSerialization     extends BaseMapTest {     final static class Bean {         public String getX() { return "y"; }         public int getY() { return 13; }     }      @SuppressWarnings("unchecked") 	public void testSimpleViaObjectMapper()         throws IOException     {         ObjectMapper mapper = new ObjectMapper();         // also need tree mapper to construct tree to serialize         ObjectNode n = mapper.getNodeFactory().objectNode();         n.put("number", 15);         n.put("string", "abc");         ObjectNode n2 = n.putObject("ob");         n2.putArray("arr");         StringWriter sw = new StringWriter();         JsonGenerator jg = mapper.getFactory().createGenerator(sw);         mapper.writeTree(jg, n);          Map<String,Object> result = (Map<String,Object>) mapper.readValue(sw.toString(), Map.class);          assertEquals(3, result.size());         assertEquals("abc", result.get("string"));         assertEquals(Integer.valueOf(15), result.get("number"));         Map<String,Object> ob = (Map<String,Object>) result.get("ob");         assertEquals(1, ob.size());         List<Object> list = (List<Object>) ob.get("arr");         assertEquals(0, list.size());     }      /**      * Simple test to verify that POJONodes (JsonNode wrapper around      * any old Java object) work with serialization      */     @SuppressWarnings("unchecked") 	public void testPOJOString()         throws Exception     {         ObjectMapper mapper = new ObjectMapper();         // also need tree mapper to construct tree to serialize         ObjectNode n = mapper.getNodeFactory().objectNode();         n.set("pojo", mapper.getNodeFactory().POJONode("abc"));         StringWriter sw = new StringWriter();         JsonGenerator jg = mapper.getFactory().createGenerator(sw);         mapper.writeTree(jg, n);         Map<String,Object> result = (Map<String,Object>) mapper.readValue(sw.toString(), Map.class);         assertEquals(1, result.size());         assertEquals("abc", result.get("pojo"));     }      @SuppressWarnings("unchecked")     public void testPOJOIntArray()         throws IOException     {         ObjectMapper mapper = new ObjectMapper();         ObjectNode n = mapper.getNodeFactory().objectNode();         n.set("pojo", mapper.getNodeFactory().POJONode(new int[] { 1, 2, 3 }));         StringWriter sw = new StringWriter();         JsonGenerator jg = mapper.getFactory().createGenerator(sw);         mapper.writeTree(jg, n);          Map<String,Object> result = (Map<String,Object>) mapper.readValue(sw.toString(), Map.class);          assertEquals(1, result.size());         // int array becomes a list when mapped to general Object:         List<Object> list = (List<Object>) result.get("pojo");         assertEquals(3, list.size());         for (int i = 0; i < 3; ++i) {             assertEquals(Integer.valueOf(i+1), list.get(i));         }     }      @SuppressWarnings("unchecked")     public void testPOJOBean()         throws IOException     {         ObjectMapper mapper = new ObjectMapper();         // also need tree mapper to construct tree to serialize         ObjectNode n = mapper.getNodeFactory().objectNode();         n.set("pojo", mapper.getNodeFactory().POJONode(new Bean()));         StringWriter sw = new StringWriter();         JsonGenerator jg = mapper.getFactory().createGenerator(sw);         mapper.writeTree(jg, n);          Map<String,Object> result = (Map<String,Object>) mapper.readValue(sw.toString(), Map.class);          assertEquals(1, result.size());         Map<String,Object> bean = (Map<String,Object>) result.get("pojo");         assertEquals(2, bean.size());         assertEquals("y", bean.get("x"));         assertEquals(Integer.valueOf(13), bean.get("y"));     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;  import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestTypedRootValueSerialization extends BaseMapTest {     // [JACKSON-822]     static interface Issue822Interface {         public int getA();     }      // If this annotation is added, things will work:     //@com.fasterxml.jackson.databind.annotation.JsonSerialize(as=Issue822Interface.class)     // but it should not be necessary when root type is passed     static class Issue822Impl implements Issue822Interface {         @Override         public int getA() { return 3; }         public int getB() { return 9; }     }      // First ensure that basic interface-override works:     public void testTypedSerialization() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());         // start with specific value case:         assertEquals("{\"a\":3}", singleJson);     }          // [JACKSON-822]: ensure that type can be coerced     public void testTypedArrays() throws Exception     {         ObjectMapper mapper = new ObjectMapper(); // Work-around when real solution not yet implemented:         //        mapper.enable(MapperFeature.USE_STATIC_TYPING);         assertEquals("[{\"a\":3}]", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(                 new Issue822Interface[] { new Issue822Impl() }));     }          // [JACKSON-822]: ensure that type can be coerced     public void testTypedLists() throws Exception     {         ObjectMapper mapper = new ObjectMapper();      // Work-around when real solution not yet implemented:         //        mapper.enable(MapperFeature.USE_STATIC_TYPING);          List<Issue822Interface> list = new ArrayList<Issue822Interface>();         list.add(new Issue822Impl());         String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})                 .writeValueAsString(list);         assertEquals("[{\"a\":3}]", listJson);     }      public void testTypedMaps() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         Map<String,Issue822Interface> map = new HashMap<String,Issue822Interface>();         map.put("a", new Issue822Impl());         String listJson = mapper.writerWithType(new TypeReference<Map<String,Issue822Interface>>(){})                 .writeValueAsString(map);         assertEquals("{\"a\":{\"a\":3}}", listJson);     } } 
package com.fasterxml.jackson.databind.ser;  import java.util.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  /**  * This unit test suite tries verify simplest aspects of  * "Native" java type mapper; basically that is can properly serialize  * core JDK objects to JSON.  */ public class TestUntypedSerialization     extends BaseMapTest {     public void testFromArray()         throws Exception     {         ArrayList<Object> doc = new ArrayList<Object>();         doc.add("Elem1");         doc.add(Integer.valueOf(3));         Map<String,Object> struct = new LinkedHashMap<String, Object>();         struct.put("first", Boolean.TRUE);         struct.put("Second", new ArrayList<Object>());         doc.add(struct);         doc.add(Boolean.FALSE);          ObjectMapper mapper = new ObjectMapper();         JsonFactory f =  new JsonFactory();          // loop more than once, just to ensure caching works ok (during second round)         for (int i = 0; i < 3; ++i) {             String str = mapper.writeValueAsString(doc);                          JsonParser jp = f.createParser(str);             assertEquals(JsonToken.START_ARRAY, jp.nextToken());                          assertEquals(JsonToken.VALUE_STRING, jp.nextToken());             assertEquals("Elem1", getAndVerifyText(jp));                          assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());             assertEquals(3, jp.getIntValue());                          assertEquals(JsonToken.START_OBJECT, jp.nextToken());             assertEquals(JsonToken.FIELD_NAME, jp.nextToken());             assertEquals("first", getAndVerifyText(jp));                          assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());             assertEquals(JsonToken.FIELD_NAME, jp.nextToken());             assertEquals("Second", getAndVerifyText(jp));                          if (jp.nextToken() != JsonToken.START_ARRAY) {                 fail("Expected START_ARRAY: JSON == '"+str+"'");             }             assertEquals(JsonToken.END_ARRAY, jp.nextToken());             assertEquals(JsonToken.END_OBJECT, jp.nextToken());                          assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());                          assertEquals(JsonToken.END_ARRAY, jp.nextToken());             assertNull(jp.nextToken());         }     }      public void testFromMap()         throws Exception     {         LinkedHashMap<String,Object> doc = new LinkedHashMap<String,Object>();         JsonFactory f =  new JsonFactory();          doc.put("a1", "\"text\"");         doc.put("int", Integer.valueOf(137));         doc.put("foo bar", Long.valueOf(1234567890L));          ObjectMapper mapper = new ObjectMapper();         for (int i = 0; i < 3; ++i) {             String str = mapper.writeValueAsString(doc);             JsonParser jp = f.createParser(str);                          assertEquals(JsonToken.START_OBJECT, jp.nextToken());                          assertEquals(JsonToken.FIELD_NAME, jp.nextToken());             assertEquals("a1", getAndVerifyText(jp));             assertEquals(JsonToken.VALUE_STRING, jp.nextToken());             assertEquals("\"text\"", getAndVerifyText(jp));                          assertEquals(JsonToken.FIELD_NAME, jp.nextToken());             assertEquals("int", getAndVerifyText(jp));             assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());             assertEquals(137, jp.getIntValue());                          assertEquals(JsonToken.FIELD_NAME, jp.nextToken());             assertEquals("foo bar", getAndVerifyText(jp));             assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());             assertEquals(1234567890L, jp.getLongValue());                          assertEquals(JsonToken.END_OBJECT, jp.nextToken());              assertNull(jp.nextToken());         }     } } 
package com.fasterxml.jackson.databind.struct;  import java.util.ArrayList; import java.util.List;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.annotation.JsonFormat.Shape;  import com.fasterxml.jackson.databind.*;  public class TestFormatForCollections extends BaseMapTest {     // [issue#40]: Allow serialization 'as POJO' (resulting in JSON Object)      @JsonPropertyOrder({ "size", "value" })     @JsonFormat(shape=Shape.OBJECT)     @JsonIgnoreProperties({ "empty" }) // from 'isEmpty()'     static class CollectionAsPOJO         extends ArrayList<String>     {         private static final long serialVersionUID = 1L;          @JsonProperty("size")         public int foo() { return size(); }                  public List<String> getValues() {             return new ArrayList<String>(this);         }          public void setValues(List<String> v) {             addAll(v);         }                  // bogus setter to handle "size" property         public void setSize(int i) { }     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */      private final static ObjectMapper MAPPER = new ObjectMapper();           // [Issue#40]     public void testListAsObject() throws Exception     {         // First, serialize a "POJO-List"         CollectionAsPOJO list = new CollectionAsPOJO();         list.add("a");         list.add("b");         String json = MAPPER.writeValueAsString(list);         assertEquals("{\"size\":2,\"values\":[\"a\",\"b\"]}", json);          // and then bring it back!         CollectionAsPOJO result = MAPPER.readValue(json, CollectionAsPOJO.class);         assertEquals(2, result.size());     }  } 
package com.fasterxml.jackson.databind.struct;  import java.util.ArrayList; import java.util.List;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  // related to [JACKSON-847] public class TestObjectId extends BaseMapTest {     @JsonPropertyOrder({"a", "b"})     static class Wrapper {         public ColumnMetadata a, b;     }          @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@id")     static class ColumnMetadata {       private final String name;       private final String type;       private final String comment;        @JsonCreator       public ColumnMetadata(         @JsonProperty("name") String name,         @JsonProperty("type") String type,         @JsonProperty("comment") String comment       ) {         this.name = name;         this.type = type;         this.comment = comment;       }        @JsonProperty("name")       public String getName() {         return name;       }        @JsonProperty("type")       public String getType() {         return type;       }        @JsonProperty("comment")       public String getComment() {         return comment;       }         }      /* Problem in which always-as-id reference may prevent initial      * serialization of a POJO.      */          static class Company {         public List<Employee> employees;          public void add(Employee e) {             if (employees == null) {                 employees = new ArrayList<Employee>();             }             employees.add(e);         }     }      @JsonIdentityInfo(property="id",             generator=ObjectIdGenerators.PropertyGenerator.class)     static class Employee {         public int id;               public String name;               @JsonIdentityReference(alwaysAsId=true)         public Employee manager;          @JsonIdentityReference(alwaysAsId=true)         public List<Employee> reports;              public Employee() { }         public Employee(int id, String name, Employee manager) {             this.id = id;             this.name = name;             this.manager = manager;             reports = new ArrayList<Employee>();         }          public Employee addReport(Employee e) {             reports.add(e);             return this;         }     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */          private final ObjectMapper MAPPER = new ObjectMapper();          public void testColumnMetadata() throws Exception     {         ColumnMetadata col = new ColumnMetadata("Billy", "employee", "comment");         Wrapper w = new Wrapper();         w.a = col;         w.b = col;         String json = MAPPER.writeValueAsString(w);                  Wrapper deserialized = MAPPER.readValue(json, Wrapper.class);         assertNotNull(deserialized);         assertNotNull(deserialized.a);         assertNotNull(deserialized.b);                  assertEquals("Billy", deserialized.a.getName());         assertEquals("employee", deserialized.a.getType());         assertEquals("comment", deserialized.a.getComment());          assertSame(deserialized.a, deserialized.b);     }      // For Issue#188     public void testMixedRefsIssue188() throws Exception     {         Company comp = new Company();         Employee e1 = new Employee(1, "First", null);         Employee e2 = new Employee(2, "Second", e1);         e1.addReport(e2);         comp.add(e1);         comp.add(e2);          String json = MAPPER.writeValueAsString(comp);                  assertEquals("{\"employees\":["                 +"{\"id\":1,\"name\":\"First\",\"manager\":null,\"reports\":[2]},"                 +"{\"id\":2,\"name\":\"Second\",\"manager\":1,\"reports\":[]}"                 +"]}",                 json);     } } 
package com.fasterxml.jackson.databind.struct;  import com.fasterxml.jackson.annotation.JsonIdentityInfo; import com.fasterxml.jackson.annotation.ObjectIdGenerators;  import com.fasterxml.jackson.databind.*;  /**  * Unit test to verify handling of Object Id deserialization  */ public class TestObjectIdDeserialization extends BaseMapTest {     // // Classes for external id use          @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="id")     static class Identifiable     {         public int value;          public Identifiable next;                  public Identifiable() { this(0); }         public Identifiable(int v) {             value = v;         }     }      @JsonIdentityInfo(generator=ObjectIdGenerators.UUIDGenerator.class, property="#")     static class UUIDNode     {         public int value;         public UUIDNode parent;         public UUIDNode first;         public UUIDNode second;          public UUIDNode() { this(0); }         public UUIDNode(int v) { value = v; }     }          // // Classes for external id from property annotations:          static class IdWrapper     {         @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@id")         public ValueNode node;          public IdWrapper() { }         public IdWrapper(int v) {             node = new ValueNode(v);         }     }      static class ValueNode {         public int value;         public IdWrapper next;                  public ValueNode() { this(0); }         public ValueNode(int v) { value = v; }     }      // // Classes for external id use      @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="customId")     static class IdentifiableCustom     {         public int value;          public int customId;                  public IdentifiableCustom next;                  public IdentifiableCustom() { this(-1, 0); }         public IdentifiableCustom(int i, int v) {             customId = i;             value = v;         }     }      static class IdWrapperExt     {         @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class,         		property="customId")         public ValueNodeExt node;          public IdWrapperExt() { }         public IdWrapperExt(int v) {             node = new ValueNodeExt(v);         }     }      static class ValueNodeExt     {         public int value;         private int customId;         public IdWrapperExt next;                  public ValueNodeExt() { this(0); }         public ValueNodeExt(int v) { value = v; }          public void setCustomId(int i) {         	customId = i;         }     }          private final ObjectMapper mapper = new ObjectMapper();          /*     /*****************************************************     /* Unit tests, external id deserialization     /*****************************************************      */      private final static String EXP_SIMPLE_INT_CLASS = "{\"id\":1,\"value\":13,\"next\":1}";      public void testSimpleDeserializationClass() throws Exception     {         // then bring back...         Identifiable result = mapper.readValue(EXP_SIMPLE_INT_CLASS, Identifiable.class);         assertEquals(13, result.value);         assertSame(result, result.next);     }      public void testSimpleUUIDForClassRoundTrip() throws Exception     {         UUIDNode root = new UUIDNode(1);         UUIDNode child1 = new UUIDNode(2);         UUIDNode child2 = new UUIDNode(3);         root.first = child1;         root.second = child2;         child1.parent = root;         child2.parent = root;         child1.first = child2;          String json = mapper.writeValueAsString(root);          // and should come back the same too...         UUIDNode result = mapper.readValue(json, UUIDNode.class);         assertEquals(1, result.value);         UUIDNode result2 = result.first;         UUIDNode result3 = result.second;         assertNotNull(result2);         assertNotNull(result3);         assertEquals(2, result2.value);         assertEquals(3, result3.value);          assertSame(result, result2.parent);         assertSame(result, result3.parent);         assertSame(result3, result2.first);     }      // Bit more complex, due to extra wrapping etc:     private final static String EXP_SIMPLE_INT_PROP = "{\"node\":{\"@id\":1,\"value\":7,\"next\":{\"node\":1}}}";              public void testSimpleDeserializationProperty() throws Exception     {         IdWrapper result = mapper.readValue(EXP_SIMPLE_INT_PROP, IdWrapper.class);         assertEquals(7, result.node.value);         assertSame(result.node, result.node.next.node);     }      // Another test to ensure ordering is not required (i.e. can do front references)     public void testSimpleDeserWithForwardRefs() throws Exception     {         IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}"                 ,IdWrapper.class);         assertEquals(7, result.node.value);         assertSame(result.node, result.node.next.node);     }          /*     /*****************************************************     /* Unit tests, custom (property-based) id deserialization     /*****************************************************      */      private final static String EXP_CUSTOM_VIA_CLASS = "{\"customId\":123,\"value\":-900,\"next\":123}";      public void testCustomDeserializationClass() throws Exception     {         // then bring back...         IdentifiableCustom result = mapper.readValue(EXP_CUSTOM_VIA_CLASS, IdentifiableCustom.class);         assertEquals(-900, result.value);         assertSame(result, result.next);     }      private final static String EXP_CUSTOM_VIA_PROP = "{\"node\":{\"customId\":3,\"value\":99,\"next\":{\"node\":3}}}";          public void testCustomDeserializationProperty() throws Exception     {         // then bring back...     	IdWrapperExt result = mapper.readValue(EXP_CUSTOM_VIA_PROP, IdWrapperExt.class);         assertEquals(99, result.node.value);         assertSame(result.node, result.node.next.node);         assertEquals(3, result.node.customId);     } } 
package com.fasterxml.jackson.databind.struct;  import com.fasterxml.jackson.annotation.JsonIdentityInfo; import com.fasterxml.jackson.annotation.JsonIdentityReference; import com.fasterxml.jackson.annotation.JsonPropertyOrder; import com.fasterxml.jackson.annotation.ObjectIdGenerators;  import com.fasterxml.jackson.databind.*;  /**  * Unit test to verify handling of Object Id deserialization  */ public class TestObjectIdSerialization extends BaseMapTest {     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="id")     static class Identifiable     {         public int value;          public Identifiable next;                  public Identifiable() { this(0); }         public Identifiable(int v) {             value = v;         }     }      @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="customId")     static class IdentifiableWithProp     {         public int value;          // Property that contains Object Id to use         public int customId;          public IdentifiableWithProp next;                  public IdentifiableWithProp() { this(0, 0); }         public IdentifiableWithProp(int id, int value) {             this.customId = id;             this.value = value;         }     }      // For property reference, need another class:          static class IdWrapper     {         @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="@id")         public ValueNode node;          public IdWrapper() { }         public IdWrapper(int v) {             node = new ValueNode(v);         }     }      static class ValueNode {         public int value;         public IdWrapper next;                  public ValueNode() { this(0); }         public ValueNode(int v) { value = v; }     }      // Similarly for property-ref via property:          protected static class IdWrapperCustom     {         @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="id")         public ValueNodeCustom node;          public IdWrapperCustom() { }         public IdWrapperCustom(int id, int value) {             node = new ValueNodeCustom(id, value);         }     }      protected static class ValueNodeCustom {         public int value;         private int id;         public IdWrapperCustom next;          public int getId() { return id; }                  public ValueNodeCustom() { this(0, 0); }         public ValueNodeCustom(int id, int value) {             this.id = id;             this.value = value;         }     }      @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="id")     static class AlwaysAsId     {         public int value;                  public AlwaysAsId() { this(0); }         public AlwaysAsId(int v) {             value = v;         }     }      // For [https://github.com/FasterXML/jackson-annotations/issues/4]     @JsonPropertyOrder(alphabetic=true)     static class AlwaysContainer     {         @JsonIdentityReference(alwaysAsId=true)         public AlwaysAsId a = new AlwaysAsId(13);                  @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="id")         @JsonIdentityReference(alwaysAsId=true)         public Value b = new Value();     }      static class Value {         public int x = 3;     }      @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="id")     static class TreeNode     {         public int id;         public String name;          @JsonIdentityReference(alwaysAsId=true)         public TreeNode parent;          // children serialized with ids if need be         public TreeNode child;          public TreeNode() { }         public TreeNode(TreeNode p, int id, String name) {             parent = p;             this.id = id;             this.name = name;         }     }      // // Let's also have one 'broken' test      // no "id" property     @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="id")     static class Broken     {         public int value;         public int customId;     }          /*     /*****************************************************     /* Unit tests, external id serialization     /*****************************************************      */      private final static String EXP_SIMPLE_INT_CLASS = "{\"id\":1,\"value\":13,\"next\":1}";          private final ObjectMapper MAPPER = new ObjectMapper();      public void testSimpleSerializationClass() throws Exception     {         Identifiable src = new Identifiable(13);         src.next = src;                  // First, serialize:         String json = MAPPER.writeValueAsString(src);         assertEquals(EXP_SIMPLE_INT_CLASS, json);          // and ensure that state is cleared in-between as well:         json = MAPPER.writeValueAsString(src);         assertEquals(EXP_SIMPLE_INT_CLASS, json);     }          // Bit more complex, due to extra wrapping etc:     private final static String EXP_SIMPLE_INT_PROP = "{\"node\":{\"@id\":1,\"value\":7,\"next\":{\"node\":1}}}";      public void testSimpleSerializationProperty() throws Exception     {         IdWrapper src = new IdWrapper(7);         src.node.next = src;                  // First, serialize:         String json = MAPPER.writeValueAsString(src);         assertEquals(EXP_SIMPLE_INT_PROP, json);         // and second time too, for a good measure         json = MAPPER.writeValueAsString(src);         assertEquals(EXP_SIMPLE_INT_PROP, json);     }      /*     /*****************************************************     /* Unit tests, custom (property) id serialization     /*****************************************************      */      private final static String EXP_CUSTOM_PROP = "{\"customId\":123,\"value\":-19,\"next\":123}";     // Test for verifying that custom     public void testCustomPropertyForClass() throws Exception     {         IdentifiableWithProp src = new IdentifiableWithProp(123, -19);         src.next = src;                  // First, serialize:         String json = MAPPER.writeValueAsString(src);         assertEquals(EXP_CUSTOM_PROP, json);          // and ensure that state is cleared in-between as well:         json = MAPPER.writeValueAsString(src);         assertEquals(EXP_CUSTOM_PROP, json);     }      private final static String EXP_CUSTOM_PROP_VIA_REF = "{\"node\":{\"id\":123,\"value\":7,\"next\":{\"node\":123}}}";     // Test for verifying that custom     public void testCustomPropertyViaProperty() throws Exception     {         IdWrapperCustom src = new IdWrapperCustom(123, 7);         src.node.next = src;                  // First, serialize:         String json = MAPPER.writeValueAsString(src);         assertEquals(EXP_CUSTOM_PROP_VIA_REF, json);         // and second time too, for a good measure         json = MAPPER.writeValueAsString(src);         assertEquals(EXP_CUSTOM_PROP_VIA_REF, json);     }      public void testAlwaysAsId() throws Exception     {         String json = MAPPER.writeValueAsString(new AlwaysContainer());         assertEquals("{\"a\":1,\"b\":2}", json);     }      public void testAlwaysIdForTree() throws Exception     {         TreeNode root = new TreeNode(null, 1, "root");              TreeNode leaf = new TreeNode(root, 2, "leaf");         root.child = leaf;         String json = MAPPER.writeValueAsString(root); //        System.out.println(json);         assertEquals("{\"id\":1,\"name\":\"root\",\"parent\":null,\"child\":"                 +"{\"id\":2,\"name\":\"leaf\",\"parent\":1,\"child\":null}}",                 json);         		     }          /*     /*****************************************************     /* Unit tests, error handling     /*****************************************************      */      public void testInvalidProp() throws Exception     {         try {             MAPPER.writeValueAsString(new Broken());             fail("Should have thrown an exception");         } catch (JsonMappingException e) {             verifyException(e, "can not find property with name 'id'");         }     } } 
package com.fasterxml.jackson.databind.struct;  import java.util.*;  import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility; import com.fasterxml.jackson.annotation.JsonIdentityInfo; import com.fasterxml.jackson.annotation.JsonTypeInfo; import com.fasterxml.jackson.annotation.ObjectIdGenerators; import com.fasterxml.jackson.annotation.PropertyAccessor;  import com.fasterxml.jackson.databind.*; import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;  public class TestObjectIdWithPolymorphic extends BaseMapTest {     @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property="id")     static abstract class Base     {         public int value;          public Base next;                  public Base() { this(0); }         public Base(int v) {             value = v;         }     }      static class Impl extends Base     {         public int extra;          public Impl() { this(0, 0); }         public Impl(int v, int e) {             super(v);             extra = e;         }     }      // [JACKSON-811] types      @JsonIdentityInfo(generator=ObjectIdGenerators.PropertyGenerator.class, property="id")     public static class Base811 {         public int id;         public Base811 owner;                      private Base811() {}         public Base811(Process owner) {             this.owner = owner;             if (owner == null) {                 id = 0;             } else {                 id = ++owner.childIdCounter;                 owner.children.add(this);             }         }     }      public static class Process extends Base811 {         protected int childIdCounter = 0;         protected List<Base811> children = new ArrayList<Base811>();                  public Process() { super(null); }     }          public static abstract class Activity extends Base811 {         protected Activity parent;         public Activity(Process owner, Activity parent) {                 super(owner);                 this.parent = parent;         }         private Activity() {                 super();         }     }          public static class Scope extends Activity {         public final List<FaultHandler> faultHandlers = new ArrayList<FaultHandler>();         public Scope(Process owner, Activity parent) {             super(owner, parent);         }         private Scope() {             super();         }     }          public static class FaultHandler extends Base811 {         public final List<Catch> catchBlocks = new ArrayList<Catch>();                  public FaultHandler(Process owner) {             super(owner);         }          protected FaultHandler() {}     }          public static class Catch extends Scope {         public Catch(Process owner, Activity parent) {             super(owner, parent);         }         protected Catch() {};     }      /*     /*****************************************************     /* Unit tests for polymorphic type handling     /*****************************************************      */      private final ObjectMapper mapper = new ObjectMapper();      public void testPolymorphicRoundtrip() throws Exception     {         // create simple 2 node loop:         Impl in1 = new Impl(123, 456);         in1.next = new Impl(111, 222);         in1.next.next = in1;                  String json = mapper.writeValueAsString(in1);                  // then bring back...         Base result0 = mapper.readValue(json, Base.class);         assertNotNull(result0);         assertSame(Impl.class, result0.getClass());         Impl result = (Impl) result0;         assertEquals(123, result.value);         assertEquals(456, result.extra);         Impl result2 = (Impl) result.next;         assertEquals(111, result2.value);         assertEquals(222, result2.extra);         assertSame(result, result2.next);     }      public void testIssue811() throws Exception     {         ObjectMapper om = new ObjectMapper();         om.disable(MapperFeature.AUTO_DETECT_CREATORS);         om.disable(MapperFeature.AUTO_DETECT_GETTERS);         om.disable(MapperFeature.AUTO_DETECT_IS_GETTERS);         om.setVisibility(PropertyAccessor.FIELD, Visibility.ANY);                  om.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX);         om.enable(SerializationFeature.INDENT_OUTPUT);         om.enableDefaultTypingAsProperty(DefaultTyping.NON_FINAL, "@class");              Process p = new Process();         Scope s = new Scope(p, null);         FaultHandler fh = new FaultHandler(p);         Catch c = new Catch(p, s);         fh.catchBlocks.add(c);         s.faultHandlers.add(fh);                  String json = om.writeValueAsString(p);         Process restored = om.readValue(json, Process.class);         assertNotNull(restored);          assertEquals(0, p.id);         assertEquals(3, p.children.size());         assertSame(p, p.children.get(0).owner);         assertSame(p, p.children.get(1).owner);         assertSame(p, p.children.get(2).owner);     } } 
package com.fasterxml.jackson.databind.struct;  import com.fasterxml.jackson.annotation.JsonFormat; import com.fasterxml.jackson.annotation.JsonPropertyOrder; import com.fasterxml.jackson.annotation.JsonFormat.Shape;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.SerializationFeature; import com.fasterxml.jackson.databind.introspect.Annotated; import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;  public class TestPOJOAsArray extends BaseMapTest {     static class Pojo     {         @JsonFormat(shape=JsonFormat.Shape.ARRAY)         public PojoValue value;          public Pojo() { }         public Pojo(String name, int x, int y, boolean c) {             value = new PojoValue(name, x, y, c);         }     }      // note: must be serialized/deserialized alphabetically; fields NOT declared in that order     @JsonPropertyOrder(alphabetic=true)     static class PojoValue     {         public int x, y;         public String name;         public boolean complete;          public PojoValue() { }         public PojoValue(String name, int x, int y, boolean c) {             this.name = name;             this.x = x;             this.y = y;             this.complete = c;         }     }      @JsonPropertyOrder(alphabetic=true)     @JsonFormat(shape=JsonFormat.Shape.ARRAY)     static class FlatPojo     {         public int x, y;         public String name;         public boolean complete;          public FlatPojo() { }         public FlatPojo(String name, int x, int y, boolean c) {             this.name = name;             this.x = x;             this.y = y;             this.complete = c;         }     }      static class ForceArraysIntrospector extends JacksonAnnotationIntrospector     {         private static final long serialVersionUID = 1L;          @Override         public JsonFormat.Value findFormat(Annotated a) {             return new JsonFormat.Value().withShape(JsonFormat.Shape.ARRAY);         }     }      static class A {         public B value = new B();     }      @JsonPropertyOrder(alphabetic=true)     static class B {         public int x = 1;         public int y = 2;     }      // for [JACKSON-805]     @JsonFormat(shape=Shape.ARRAY)     static class SingleBean {         public String name = "foo";     }      @JsonPropertyOrder(alphabetic=true)     @JsonFormat(shape=Shape.ARRAY)     static class TwoStringsBean {         public String bar = null;         public String foo = "bar";     }          /*     /*****************************************************     /* Basic tests     /*****************************************************      */      private final static ObjectMapper MAPPER = new ObjectMapper();          /**      * Test that verifies that property annotation works      */     public void testReadSimplePropertyValue() throws Exception     {         String json = "{\"value\":[true,\"Foobar\",42,13]}";         Pojo p = MAPPER.readValue(json, Pojo.class);         assertNotNull(p.value);         assertTrue(p.value.complete);         assertEquals("Foobar", p.value.name);         assertEquals(42, p.value.x);         assertEquals(13, p.value.y);     }      /**      * Test that verifies that Class annotation works      */     public void testReadSimpleRootValue() throws Exception     {         String json = "[false,\"Bubba\",1,2]";         FlatPojo p = MAPPER.readValue(json, FlatPojo.class);         assertFalse(p.complete);         assertEquals("Bubba", p.name);         assertEquals(1, p.x);         assertEquals(2, p.y);     }          /**      * Test that verifies that property annotation works      */     public void testWriteSimplePropertyValue() throws Exception     {         String json = MAPPER.writeValueAsString(new Pojo("Foobar", 42, 13, true));         // will have wrapper POJO, then POJO-as-array..         assertEquals("{\"value\":[true,\"Foobar\",42,13]}", json);     }      /**      * Test that verifies that Class annotation works      */     public void testWriteSimpleRootValue() throws Exception     {         String json = MAPPER.writeValueAsString(new FlatPojo("Bubba", 1, 2, false));         // will have wrapper POJO, then POJO-as-array..         assertEquals("[false,\"Bubba\",1,2]", json);     }      // [Issue#223]     public void testNullColumn() throws Exception     {         assertEquals("[null,\"bar\"]", MAPPER.writeValueAsString(new TwoStringsBean()));     }      /*     /*****************************************************     /* Compatibility with "single-elem as array" feature     /*****************************************************      */          // for [JACKSON-805]     public void testSerializeAsArrayWithSingleProperty() throws Exception {         ObjectMapper mapper = new ObjectMapper();         mapper.enable(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED);         String json = mapper.writeValueAsString(new SingleBean());         assertEquals("\"foo\"", json);     }          /*     /*****************************************************     /* Round-trip tests     /*****************************************************      */      public void testAnnotationOverride() throws Exception     {         // by default, POJOs become JSON Objects;         assertEquals("{\"value\":{\"x\":1,\"y\":2}}", MAPPER.writeValueAsString(new A()));          // but override should change it:         ObjectMapper mapper2 = new ObjectMapper();         mapper2.setAnnotationIntrospector(new ForceArraysIntrospector());         assertEquals("[[1,2]]", mapper2.writeValueAsString(new A()));     } } 
package com.fasterxml.jackson.databind.struct;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestPOJOAsArrayAdvanced extends BaseMapTest {     @JsonFormat(shape=JsonFormat.Shape.ARRAY)     @JsonPropertyOrder(alphabetic=true)     static class CreatorAsArray     {         protected int x, y;         public int a, b;          @JsonCreator         public CreatorAsArray(@JsonProperty("x") int x, @JsonProperty("y") int y)         {             this.x = x;             this.y = y;         }          public int getX() { return x; }         public int getY() { return y; }     }      @JsonFormat(shape=JsonFormat.Shape.ARRAY)     @JsonPropertyOrder({"a","b","x","y"})     static class CreatorAsArrayShuffled     {         protected int x, y;         public int a, b;          @JsonCreator         public CreatorAsArrayShuffled(@JsonProperty("x") int x, @JsonProperty("y") int y)         {             this.x = x;             this.y = y;         }          public int getX() { return x; }         public int getY() { return y; }     }      static class ViewA { }     static class ViewB { }          @JsonFormat(shape=JsonFormat.Shape.ARRAY)     @JsonPropertyOrder(alphabetic=true)     static class AsArrayWithView     {         @JsonView(ViewA.class)         public int a;         @JsonView(ViewB.class)         public int b;         public int c;     }          /*     /*****************************************************     /* Basic tests     /*****************************************************      */      private final static ObjectMapper MAPPER = new ObjectMapper();      public void testWithView() throws Exception     {         // Ok, first, ensure that serializer will "black out" filtered properties         AsArrayWithView input = new AsArrayWithView();         input.a = 1;         input.b = 2;         input.c = 3;         String json = MAPPER.writerWithView(ViewA.class).writeValueAsString(input);         assertEquals("[1,null,3]", json);          // and then that conversely deserializer does something similar         AsArrayWithView output = MAPPER.reader(AsArrayWithView.class).withView(ViewB.class)                 .readValue("[1,2,3]");         // should include 'c' (not view-able) and 'b' (include in ViewB) but not 'a'         assertEquals(3, output.c);         assertEquals(2, output.b);         assertEquals(0, output.a);     }      public void testWithCreatorsOrdered() throws Exception     {         CreatorAsArray input = new CreatorAsArray(3, 4);         input.a = 1;         input.b = 2;          // note: Creator properties get sorted ahead of others, hence not [1,2,3,4] but:         String json = MAPPER.writeValueAsString(input);         assertEquals("[3,4,1,2]", json);          // and should get back in proper order, too         CreatorAsArray output = MAPPER.readValue(json, CreatorAsArray.class);         assertEquals(1, output.a);         assertEquals(2, output.b);         assertEquals(3, output.x);         assertEquals(4, output.y);     }      // Same as above, but ordering of properties different...     public void testWithCreatorsShuffled() throws Exception     {         CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4);         input.a = 1;         input.b = 2;          // note: explicit ordering overrides implicit creators-first ordering:         String json = MAPPER.writeValueAsString(input);         assertEquals("[1,2,3,4]", json);          // and should get back in proper order, too         CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class);         assertEquals(1, output.a);         assertEquals(2, output.b);         assertEquals(3, output.x);         assertEquals(4, output.y);     } } 
package com.fasterxml.jackson.databind.struct;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.annotation.JsonDeserialize;  /**  * Unit tests for "POJO as array" feature using Builder-style  * POJO construction.  */ public class TestPOJOAsArrayWithBuilder extends BaseMapTest {     @JsonDeserialize(builder=SimpleBuilderXY.class)     @JsonFormat(shape=JsonFormat.Shape.ARRAY)     @JsonPropertyOrder(alphabetic=true)     static class ValueClassXY     {         final int _x, _y;          protected ValueClassXY(int x, int y) {             _x = x+1;             _y = y+1;         }     }      @JsonFormat(shape=JsonFormat.Shape.ARRAY)     static class SimpleBuilderXY     {         public int x, y;                  public SimpleBuilderXY withX(int x) {             this.x = x;             return this;         }          public SimpleBuilderXY withY(int y) {             this.y = y;             return this;         }          public ValueClassXY build() {             return new ValueClassXY(x, y);         }     }          /*     /*****************************************************     /* Basic tests     /*****************************************************      */      private final static ObjectMapper MAPPER = new ObjectMapper();      public void testSimpleBuilder() throws Exception     {         // Ok, first, ensure that serializer will "black out" filtered properties         ValueClassXY value = MAPPER.readValue("[1,2]", ValueClassXY.class);         assertEquals(2, value._x);         assertEquals(3, value._y);     } } 
package com.fasterxml.jackson.databind.struct;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying [JACKSON-132] implementation.  */ public class TestUnwrapped extends BaseMapTest {     static class Unwrapping {         public String name;         @JsonUnwrapped         public Location location;          public Unwrapping() { }         public Unwrapping(String str, int x, int y) {             name = str;             location = new Location(x, y);         }     }      static class DeepUnwrapping     {         @JsonUnwrapped         public Unwrapping unwrapped;          public DeepUnwrapping() { }         public DeepUnwrapping(String str, int x, int y) {             unwrapped = new Unwrapping(str, x, y);         }     }          static class UnwrappingWithCreator {         public String name;          @JsonUnwrapped         public Location location;          @JsonCreator         public UnwrappingWithCreator(@JsonProperty("name") String n) {             name = n;         }     }          final static class Location {         public int x;         public int y;          public Location() { }         public Location(int x, int y) {             this.x = x;             this.y = y;         }     }      // Class with two unwrapped properties     static class TwoUnwrappedProperties {         @JsonUnwrapped         public Location location;         @JsonUnwrapped         public Name name;          public TwoUnwrappedProperties() { }     }      static class Name {         public String first, last;     }      /*     /**********************************************************     /* Tests, serialization     /**********************************************************      */      private final ObjectMapper mapper = new ObjectMapper();          public void testSimpleUnwrappingSerialize() throws Exception     {         assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}",                 mapper.writeValueAsString(new Unwrapping("Tatu", 1, 2)));     }     public void testDeepUnwrappingSerialize() throws Exception     {         assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}",                 mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2)));     }      /*     /**********************************************************     /* Tests, deserialization     /**********************************************************      */          public void testSimpleUnwrappedDeserialize() throws Exception     {         Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}",                 Unwrapping.class);         assertEquals("Tatu", bean.name);         Location loc = bean.location;         assertNotNull(loc);         assertEquals(-13, loc.x);         assertEquals(7, loc.y);     }          public void testDoubleUnwrapping() throws Exception     {         TwoUnwrappedProperties bean = mapper.readValue("{\"first\":\"Joe\",\"y\":7,\"last\":\"Smith\",\"x\":-13}",                 TwoUnwrappedProperties.class);         Location loc = bean.location;         assertNotNull(loc);         assertEquals(-13, loc.x);         assertEquals(7, loc.y);         Name name = bean.name;         assertNotNull(name);         assertEquals("Joe", name.first);         assertEquals("Smith", name.last);     }          public void testDeepUnwrapping() throws Exception     {         DeepUnwrapping bean = mapper.readValue("{\"x\":3,\"name\":\"Bob\",\"y\":27}",                 DeepUnwrapping.class);         Unwrapping uw = bean.unwrapped;         assertNotNull(uw);         assertEquals("Bob", uw.name);         Location loc = uw.location;         assertNotNull(loc);         assertEquals(3, loc.x);         assertEquals(27, loc.y);     }          public void testUnwrappedDeserializeWithCreator() throws Exception     {         UnwrappingWithCreator bean = mapper.readValue("{\"x\":1,\"y\":2,\"name\":\"Tatu\"}",                 UnwrappingWithCreator.class);         assertEquals("Tatu", bean.name);         Location loc = bean.location;         assertNotNull(loc);         assertEquals(1, loc.x);         assertEquals(2, loc.y);     }      // 22-Apr-2013, tatu: Commented out as it can't be simply fixed; requires implementing     //    deep-update/merge. But leaving here to help with that effort, if/when it proceeds.          /*          // [Issue#211]: Actually just variant of #160          static class Issue211Bean {         public String test1;          public String test2;         @JsonUnwrapped         public Issue211Unwrapped unwrapped;     }      static class Issue211Unwrapped {         public String test3;         public String test4;     }          public void testIssue211() throws Exception     {          Issue211Bean bean = new Issue211Bean();          bean.test1 = "Field 1";          bean.test2 = "Field 2";          Issue211Unwrapped tJackson2 = new Issue211Unwrapped();          tJackson2.test3 = "Field 3";          tJackson2.test4 = "Field 4";          bean.unwrapped = tJackson2;            final String JSON = "{\"test1\": \"Field 1 merged\", \"test3\": \"Field 3 merged\"}";          ObjectMapper o = new ObjectMapper();          Issue211Bean result = o.readerForUpdating(bean).withType(Issue211Bean.class).readValue(JSON);          assertSame(bean, result);          assertEquals("Field 1 merged", result.test1);          assertEquals("Field 2", result.test2);          assertNotNull(result.unwrapped);          assertEquals("Field 3 merged", result.unwrapped.test3);          assertEquals("Field 4", result.unwrapped.test4);     }       */ } 
package com.fasterxml.jackson.databind.struct;  import com.fasterxml.jackson.annotation.JsonUnwrapped; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.ObjectMapper;  public class TestUnwrappedWithPrefix extends BaseMapTest {     static class Unwrapping {         public String name;         @JsonUnwrapped         public Location location;          public Unwrapping() { }         public Unwrapping(String str, int x, int y) {             name = str;             location = new Location(x, y);         }     }      static class DeepUnwrapping     {         @JsonUnwrapped         public Unwrapping unwrapped;          public DeepUnwrapping() { }         public DeepUnwrapping(String str, int x, int y) {             unwrapped = new Unwrapping(str, x, y);         }     }      static class Location {         public int x;         public int y;          public Location() { }         public Location(int x, int y) {             this.x = x;             this.y = y;         }     }      // Class with unwrapping using prefixes     static class PrefixUnwrap     {         public String name;         @JsonUnwrapped(prefix="_")         public Location location;          public PrefixUnwrap() { }         public PrefixUnwrap(String str, int x, int y) {             name = str;             location = new Location(x, y);         }     }          static class DeepPrefixUnwrap     {         @JsonUnwrapped(prefix="u.")         public PrefixUnwrap unwrapped;          public DeepPrefixUnwrap() { }         public DeepPrefixUnwrap(String str, int x, int y) {             unwrapped = new PrefixUnwrap(str, x, y);         }     }      // Let's actually test hierarchic names with unwrapping bit more:          static class ConfigRoot     {         @JsonUnwrapped(prefix="general.")         public ConfigGeneral general = new ConfigGeneral();                  @JsonUnwrapped(prefix="misc.")         public ConfigMisc misc = new ConfigMisc();          public ConfigRoot() { }         public ConfigRoot(String name, int value)         {             general = new ConfigGeneral(name);             misc.value = value;         }     }      static class ConfigAlternate     {         @JsonUnwrapped         public ConfigGeneral general = new ConfigGeneral();                  @JsonUnwrapped(prefix="misc.")         public ConfigMisc misc = new ConfigMisc();          public int id;                  public ConfigAlternate() { }         public ConfigAlternate(int id, String name, int value)         {             this.id = id;             general = new ConfigGeneral(name);             misc.value = value;         }     }      static class ConfigGeneral     {         @JsonUnwrapped(prefix="names.")         public ConfigNames names = new ConfigNames();                  public ConfigGeneral() { }         public ConfigGeneral(String name) {             names.name = name;         }     }      static class ConfigNames {         public String name = "x";     }      static class ConfigMisc {         public int value;     }      // // // Reuse mapper to keep tests bit faster      private final ObjectMapper mapper = new ObjectMapper();      /*     /**********************************************************     /* Tests, serialization     /**********************************************************      */      public void testPrefixedUnwrappingSerialize() throws Exception     {         assertEquals("{\"name\":\"Tatu\",\"_x\":1,\"_y\":2}",                 mapper.writeValueAsString(new PrefixUnwrap("Tatu", 1, 2)));     }      public void testDeepPrefixedUnwrappingSerialize() throws Exception     {         String json = mapper.writeValueAsString(new DeepPrefixUnwrap("Bubba", 1, 1));         assertEquals("{\"u.name\":\"Bubba\",\"u._x\":1,\"u._y\":1}", json);     }      public void testHierarchicConfigSerialize() throws Exception     {         String json = mapper.writeValueAsString(new ConfigRoot("Fred", 25));         assertEquals("{\"general.names.name\":\"Fred\",\"misc.value\":25}", json);     }      /*     /**********************************************************     /* Tests, deserialization     /**********************************************************      */      public void testPrefixedUnwrapping() throws Exception     {         PrefixUnwrap bean = mapper.readValue("{\"name\":\"Axel\",\"_x\":4,\"_y\":7}", PrefixUnwrap.class);         assertNotNull(bean);         assertEquals("Axel", bean.name);         assertNotNull(bean.location);         assertEquals(4, bean.location.x);         assertEquals(7, bean.location.y);     }          public void testDeepPrefixedUnwrappingDeserialize() throws Exception     {         DeepPrefixUnwrap bean = mapper.readValue("{\"u.name\":\"Bubba\",\"u._x\":2,\"u._y\":3}",                 DeepPrefixUnwrap.class);         assertNotNull(bean.unwrapped);         assertNotNull(bean.unwrapped.location);         assertEquals(2, bean.unwrapped.location.x);         assertEquals(3, bean.unwrapped.location.y);         assertEquals("Bubba", bean.unwrapped.name);     }          public void testHierarchicConfigDeserialize() throws Exception     {         ConfigRoot root = mapper.readValue("{\"general.names.name\":\"Bob\",\"misc.value\":3}",                 ConfigRoot.class);         assertNotNull(root.general);         assertNotNull(root.general.names);         assertNotNull(root.misc);         assertEquals(3, root.misc.value);         assertEquals("Bob", root.general.names.name);     }      /*     /**********************************************************     /* Tests, deserialization     /**********************************************************      */          public void testHierarchicConfigRoundTrip() throws Exception     {         ConfigAlternate input = new ConfigAlternate(123, "Joe", 42);         String json = mapper.writeValueAsString(input);          ConfigAlternate root = mapper.readValue(json, ConfigAlternate.class);         assertEquals(123, root.id);         assertNotNull(root.general);         assertNotNull(root.general.names);         assertNotNull(root.misc);         assertEquals("Joe", root.general.names.name);         assertEquals(42, root.misc.value);     } } 
package com.fasterxml.jackson.databind.type;  import com.fasterxml.jackson.annotation.*; import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.introspect.AnnotatedClass; import com.fasterxml.jackson.databind.introspect.AnnotatedField; import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;  /**  * Unit test for verifying that {@link AnnotatedClass}  * works as expected.  */ public class TestAnnotatedClass     extends BaseMapTest {     /*     /**********************************************************     /* Annotated helper classes     /**********************************************************      */      static class BaseClass     {         public int foo;          public BaseClass(int x, int y) { }          @JsonProperty public int x() { return 3; }     }      static class SubClass extends BaseClass     {         public SubClass() { this(1); }         public SubClass(int x) { super(x, 2); }          public int y() { return 3; }     }      static abstract class GenericBase<T extends Number>     {         public abstract void setX(T value);     }      static class NumberBean         extends GenericBase<Integer>     {         @Override         public void setX(Integer value) { }     }      /**      * Test class for checking that field introspection      * works as expected      */     @SuppressWarnings("unused")     static class FieldBean     {         // static, not to be included:         public static boolean DUMMY;          // not public, no annotations, shouldn't be included         private long bar;          @JsonProperty         private String props;     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */      public void testFieldIntrospection()     {         // null -> no mix-in annotations         AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null);         // AnnotatedClass does not ignore non-visible fields, yet         assertEquals(2, ac.getFieldCount());         for (AnnotatedField f : ac.fields()) {             String fname = f.getName();             if (!"bar".equals(fname) && !"props".equals(fname)) {                 fail("Unexpected field name '"+fname+"'");             }         }     } } 
package com.fasterxml.jackson.databind.type;  import com.fasterxml.jackson.databind.*;  public class TestGenericFieldInSubtype extends BaseMapTest {     // [JACKSON-677]     public void test677() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         // and bit more checking as per later comments         JavaType t677 = mapper.constructType(Result677.Success677.class);         assertNotNull(t677);         Result677.Success677<Integer> s = new Result677.Success677<Integer>(Integer.valueOf(4));         String json = mapper.writeValueAsString(s);         assertEquals("{\"value\":4}", json);     }   // [JACKSON-887]     public void testInnerType() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         BaseType.SubType<?> r = mapper.readValue("{}", BaseType.SubType.class);         assertNotNull(r);     }  }  class Result677<T> {     public static class Success677<K> extends Result677<K> {      public K value;            public Success677() { }      public Success677(K k) { value = k; }     } }  abstract class BaseType<T> {     public T value;      public final static class SubType<T extends Number> extends BaseType<T>     {     } } 
package com.fasterxml.jackson.databind.type;  import java.util.*;  import com.fasterxml.jackson.databind.JavaType;  /**  * Simple tests to verify that {@link JavaType} types work to  * some degree  */ public class TestJavaType     extends com.fasterxml.jackson.test.BaseTest {     static class BaseType { }      static class SubType extends BaseType { }          static enum MyEnum { A, B; }     static enum MyEnum2 {         A(1), B(2);                  private MyEnum2(int value) { }     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */          public void testSimpleClass()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType baseType = tf.constructType(BaseType.class);         assertSame(BaseType.class, baseType.getRawClass());         assertTrue(baseType.hasRawClass(BaseType.class));          assertFalse(baseType.isArrayType());         assertFalse(baseType.isContainerType());         assertFalse(baseType.isEnumType());         assertFalse(baseType.isInterface());         assertFalse(baseType.isPrimitive());          assertNull(baseType.getContentType());         assertNull(baseType.getValueHandler());          /* both narrow and widen just return type itself (exact, not just          * equal)          * (also note that widen/narrow wouldn't work on basic simple          * class type otherwise)          */         assertSame(baseType, baseType.narrowBy(BaseType.class));         assertSame(baseType, baseType.widenBy(BaseType.class));          // Also: no narrowing for simple types (but should there be?)         try {             baseType.narrowBy(SubType.class);         } catch (IllegalArgumentException e) {             verifyException(e, "should never be called");         }          // Also, let's try assigning bogus handler         /*         baseType.setValueHandler("xyz"); // untyped         assertEquals("xyz", baseType.getValueHandler());         // illegal to re-set         try {             baseType.setValueHandler("foobar");             fail("Shouldn't allow re-setting value handler");         } catch (IllegalStateException iae) {             verifyException(iae, "Trying to reset");         }         */     }      public void testMapType()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType keyT = tf.constructType(String.class);         JavaType baseT = tf.constructType(BaseType.class);          MapType mapT = MapType.construct(Map.class, keyT, baseT);         assertNotNull(mapT);         assertTrue(mapT.isContainerType());          // NOPs:         assertSame(mapT, mapT.narrowContentsBy(BaseType.class));         assertSame(mapT, mapT.narrowKey(String.class));          assertTrue(mapT.equals(mapT));         assertFalse(mapT.equals(null));         assertFalse(mapT.equals("xyz"));          MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT);         assertFalse(mapT.equals(mapT2));          // Also, must use map type constructor, not simple...         try {             SimpleType.construct(HashMap.class);         } catch (IllegalArgumentException e) {             verifyException(e, "for a Map");         }     }      public void testArrayType()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType arrayT = ArrayType.construct(tf.constructType(String.class), null, null);         assertNotNull(arrayT);         assertTrue(arrayT.isContainerType());          // NOPs:         assertSame(arrayT, arrayT.narrowContentsBy(String.class));          assertNotNull(arrayT.toString());          assertTrue(arrayT.equals(arrayT));         assertFalse(arrayT.equals(null));         assertFalse(arrayT.equals("xyz"));          assertTrue(arrayT.equals(ArrayType.construct(tf.constructType(String.class), null, null)));         assertFalse(arrayT.equals(ArrayType.construct(tf.constructType(Integer.class), null, null)));          // Also, must NOT try to create using simple type         try {             SimpleType.construct(String[].class);         } catch (IllegalArgumentException e) {             verifyException(e, "for an array");         }     }      public void testCollectionType()     {         TypeFactory tf = TypeFactory.defaultInstance();         // List<String>         JavaType collectionT = CollectionType.construct(List.class, tf.constructType(String.class));         assertNotNull(collectionT);         assertTrue(collectionT.isContainerType());          // NOPs:         assertSame(collectionT, collectionT.narrowContentsBy(String.class));          assertNotNull(collectionT.toString());          assertTrue(collectionT.equals(collectionT));         assertFalse(collectionT.equals(null));         assertFalse(collectionT.equals("xyz"));          assertTrue(collectionT.equals(CollectionType.construct(List.class, tf.constructType(String.class))));         assertFalse(collectionT.equals(CollectionType.construct(Set.class, tf.constructType(String.class))));          // Also, must NOT try to create using simple type         try {             SimpleType.construct(ArrayList.class);         } catch (IllegalArgumentException e) {             verifyException(e, "for a Collection");         }     }      public void testEnumType()     {         TypeFactory tf = TypeFactory.defaultInstance();         assertTrue(tf.constructType(MyEnum.class).isEnumType());         assertTrue(tf.constructType(MyEnum2.class).isEnumType());         assertTrue(tf.constructType(MyEnum.A.getClass()).isEnumType());         assertTrue(tf.constructType(MyEnum2.A.getClass()).isEnumType());     }      public void testClassKey()     {         ClassKey key = new ClassKey(String.class);         assertEquals(0, key.compareTo(key));         assertTrue(key.equals(key));         assertFalse(key.equals(null));         assertFalse(key.equals("foo"));         assertFalse(key.equals(new ClassKey(Integer.class)));         assertEquals(String.class.getName(), key.toString());     }      // [Issue#116]     public void testJavaTypeAsJLRType()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType t1 = tf.constructType(getClass());         // should just get it back as-is:         JavaType t2 = tf.constructType(t1);         assertSame(t1, t2);     } }  
package com.fasterxml.jackson.databind.type;  import java.util.*;  import com.fasterxml.jackson.databind.JavaType;  /**  * Simple tests to verify for generic type binding functionality  * implemented by {@link TypeBindings} class.  */ public class TestTypeBindings     extends com.fasterxml.jackson.test.BaseTest {         static class AbstractType<A,B> { }          static class LongStringType extends AbstractType<Long,String> { }      static class InnerGenericTyping<K, V> extends AbstractMap<K, Collection<V>>     {         @Override         public Set<java.util.Map.Entry<K, Collection<V>>> entrySet() {             return null;         }         public class InnerClass extends AbstractMap<K, Collection<V>> {             @Override             public Set<java.util.Map.Entry<K, Collection<V>>> entrySet() {                 return null;             }         }     }          /*     /**********************************************************     /* Test methods     /**********************************************************      */          public void testAbstract() throws Exception     {         /* Abstract type does declare type parameters, but they are only          * known as 'Object.class' (via lower bound)          */         TypeFactory tf = TypeFactory.defaultInstance();         TypeBindings b = new TypeBindings(tf, AbstractType.class);         assertEquals(2, b.getBindingCount());         JavaType obType = tf.constructType(Object.class);         assertEquals(obType, b.findType("A"));         assertEquals(obType, b.findType("B"));     }      public void testSimple() throws Exception     {         TypeFactory tf = TypeFactory.defaultInstance();         // concrete class does have bindings however         TypeBindings b = new TypeBindings(tf, LongStringType.class);         assertEquals(2, b.getBindingCount());         assertEquals(tf.constructType(Long.class), b.findType("A"));         assertEquals(tf.constructType(String.class), b.findType("B"));     }       // [JACKSON-677]     public void testInnerType() throws Exception     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType type = tf.constructType(InnerGenericTyping.InnerClass.class);         assertEquals(MapType.class, type.getClass());         JavaType keyType = type.getKeyType();         assertEquals(Object.class, keyType.getRawClass());         JavaType valueType = type.getContentType();         assertEquals(Collection.class, valueType.getRawClass());         JavaType vt2 = valueType.getContentType();         assertEquals(Object.class, vt2.getRawClass());     } } 
package com.fasterxml.jackson.databind.type;  import java.lang.reflect.Field; import java.util.*; import java.util.concurrent.atomic.AtomicReference;  import com.fasterxml.jackson.core.type.TypeReference; import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.ObjectMapper; import com.fasterxml.jackson.databind.type.CollectionType; import com.fasterxml.jackson.databind.type.HierarchicType; import com.fasterxml.jackson.databind.type.MapType; import com.fasterxml.jackson.databind.type.SimpleType; import com.fasterxml.jackson.databind.type.TypeFactory; import com.fasterxml.jackson.test.BaseTest;  /**  * Simple tests to verify that the {@link TypeFactory} constructs  * type information as expected.  */ public class TestTypeFactory     extends BaseTest {         /*     /**********************************************************     /* Helper types     /**********************************************************      */      enum EnumForCanonical { YES, NO; }      static class SingleArgGeneric<X> { }      abstract static class MyMap extends IntermediateMap<String,Long> { }     abstract static class IntermediateMap<K,V> implements Map<K,V> { }      abstract static class MyList extends IntermediateList<Long> { }     abstract static class IntermediateList<E> implements List<E> { }      @SuppressWarnings("serial")     static class GenericList<T> extends ArrayList<T> { }          interface MapInterface extends Cloneable, IntermediateInterfaceMap<String> { }     interface IntermediateInterfaceMap<FOO> extends Map<FOO, Integer> { }      @SuppressWarnings("serial")     static class MyStringIntMap extends MyStringXMap<Integer> { }     @SuppressWarnings("serial")     static class MyStringXMap<V> extends HashMap<String,V> { }      // And one more, now with obfuscated type names; essentially it's just Map<Int,Long>     static abstract class IntLongMap extends XLongMap<Integer> { }     // trick here is that V now refers to key type, not value type     static abstract class XLongMap<V> extends XXMap<V,Long> { }     static abstract class XXMap<K,V> implements Map<K,V> { }      static class SneakyBean {         public IntLongMap intMap;         public MyList longList;     }      static class SneakyBean2 {         // self-reference; should be resolved as "Comparable<Object>"         public <T extends Comparable<T>> T getFoobar() { return null; }     }          @SuppressWarnings("serial")     public static class LongValuedMap<K> extends HashMap<K, Long> { }      static class StringLongMapBean {         public LongValuedMap<String> value;     }      static class StringListBean {         public GenericList<String> value;     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */          public void testSimpleTypes()     {         Class<?>[] classes = new Class<?>[] {             boolean.class, byte.class, char.class,                 short.class, int.class, long.class,                 float.class, double.class,              Boolean.class, Byte.class, Character.class,                 Short.class, Integer.class, Long.class,                 Float.class, Double.class,                  String.class,                 Object.class,                  Calendar.class,                 Date.class,         };          TypeFactory tf = TypeFactory.defaultInstance();         for (Class<?> clz : classes) {             assertSame(clz, tf.constructType(clz).getRawClass());             assertSame(clz, tf.constructType(clz).getRawClass());         }     }      public void testArrays()     {         Class<?>[] classes = new Class<?>[] {             boolean[].class, byte[].class, char[].class,                 short[].class, int[].class, long[].class,                 float[].class, double[].class,                  String[].class, Object[].class,                 Calendar[].class,         };          TypeFactory tf = TypeFactory.defaultInstance();         for (Class<?> clz : classes) {             assertSame(clz, tf.constructType(clz).getRawClass());             Class<?> elemType = clz.getComponentType();             assertSame(clz, tf.constructArrayType(elemType).getRawClass());         }     }      public void testCollections()     {         // Ok, first: let's test what happens when we pass 'raw' Collection:         TypeFactory tf = TypeFactory.defaultInstance();         JavaType t = tf.constructType(ArrayList.class);         assertEquals(CollectionType.class, t.getClass());         assertSame(ArrayList.class, t.getRawClass());          // And then the proper way         t = tf.constructType(new TypeReference<ArrayList<String>>() { });         assertEquals(CollectionType.class, t.getClass());         assertSame(ArrayList.class, t.getRawClass());          JavaType elemType = ((CollectionType) t).getContentType();         assertNotNull(elemType);         assertSame(SimpleType.class, elemType.getClass());         assertSame(String.class, elemType.getRawClass());          // And alternate method too         t = tf.constructCollectionType(ArrayList.class, String.class);         assertEquals(CollectionType.class, t.getClass());         assertSame(String.class, ((CollectionType) t).getContentType().getRawClass());     }          public void testMaps()     {         TypeFactory tf = TypeFactory.defaultInstance();         // Ok, first: let's test what happens when we pass 'raw' Map:         JavaType t = tf.constructType(HashMap.class);         assertEquals(MapType.class, t.getClass());         assertSame(HashMap.class, t.getRawClass());          // Then explicit construction         t = tf.constructMapType(TreeMap.class, String.class, Integer.class);         assertEquals(MapType.class, t.getClass());         assertSame(String.class, ((MapType) t).getKeyType().getRawClass());         assertSame(Integer.class, ((MapType) t).getContentType().getRawClass());          // And then with TypeReference         t = tf.constructType(new TypeReference<HashMap<String,Integer>>() { });         assertEquals(MapType.class, t.getClass());         assertSame(HashMap.class, t.getRawClass());         MapType mt = (MapType) t;         assertEquals(tf.constructType(String.class), mt.getKeyType());         assertEquals(tf.constructType(Integer.class), mt.getContentType());          t = tf.constructType(new TypeReference<LongValuedMap<Boolean>>() { });         assertEquals(MapType.class, t.getClass());         assertSame(LongValuedMap.class, t.getRawClass());         mt = (MapType) t;         assertEquals(tf.constructType(Boolean.class), mt.getKeyType());         assertEquals(tf.constructType(Long.class), mt.getContentType());     }      public void testIterator()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType t = tf.constructType(new TypeReference<Iterator<String>>() { });         assertEquals(SimpleType.class, t.getClass());         assertSame(Iterator.class, t.getRawClass());         assertEquals(1, t.containedTypeCount());         assertEquals(tf.constructType(String.class), t.containedType(0));         assertNull(t.containedType(1));     }      /**      * Test for verifying that parametric types can be constructed      * programmatically      *       * @since 1.5      */     public void testParametricTypes()     {         TypeFactory tf = TypeFactory.defaultInstance();         // first, simple class based         JavaType t = tf.constructParametricType(ArrayList.class, String.class); // ArrayList<String>         assertEquals(CollectionType.class, t.getClass());         JavaType strC = tf.constructType(String.class);         assertEquals(1, t.containedTypeCount());         assertEquals(strC, t.containedType(0));         assertNull(t.containedType(1));          // Then using JavaType         JavaType t2 = tf.constructParametricType(Map.class, strC, t); // Map<String,ArrayList<String>>         // should actually produce a MapType         assertEquals(MapType.class, t2.getClass());         assertEquals(2, t2.containedTypeCount());         assertEquals(strC, t2.containedType(0));         assertEquals(t, t2.containedType(1));         assertNull(t2.containedType(2));          // and then custom generic type as well         JavaType custom = tf.constructParametricType(SingleArgGeneric.class, String.class);         assertEquals(SimpleType.class, custom.getClass());         assertEquals(1, custom.containedTypeCount());         assertEquals(strC, custom.containedType(0));         assertNull(custom.containedType(1));         // should also be able to access variable name:         assertEquals("X", custom.containedTypeName(0));          // And finally, ensure that we can't create invalid combinations         try {             // Maps must take 2 type parameters, not just one             tf.constructParametricType(Map.class, strC);         } catch (IllegalArgumentException e) {             verifyException(e, "Need exactly 2 parameter types for Map types");         }          try {             // Type only accepts one type param             tf.constructParametricType(SingleArgGeneric.class, strC, strC);         } catch (IllegalArgumentException e) {             verifyException(e, "expected 1 parameters, was given 2");         }     }      /**      * Test for checking that canonical name handling works ok      */     public void testCanonicalNames()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType t = tf.constructType(java.util.Calendar.class);         String can = t.toCanonical();         assertEquals("java.util.Calendar", can);         assertEquals(t, tf.constructFromCanonical(can));          // Generic maps and collections will default to Object.class if type-erased         t = tf.constructType(java.util.ArrayList.class);         can = t.toCanonical();         assertEquals("java.util.ArrayList<java.lang.Object>", can);         assertEquals(t, tf.constructFromCanonical(can));          t = tf.constructType(java.util.TreeMap.class);         can = t.toCanonical();         assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can);         assertEquals(t, tf.constructFromCanonical(can));          // And then EnumMap (actual use case for us)         t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);         can = t.toCanonical();         assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>",                 can);         assertEquals(t, tf.constructFromCanonical(can));              }      /*     /**********************************************************     /* Unit tests: low-level inheritance resolution     /**********************************************************      */          /**      * @since 1.6      */     public void testSuperTypeDetectionClass()     {         TypeFactory tf = TypeFactory.defaultInstance();         HierarchicType sub = tf._findSuperTypeChain(MyStringIntMap.class, HashMap.class);         assertNotNull(sub);         assertEquals(2, _countSupers(sub));         assertSame(MyStringIntMap.class, sub.getRawClass());         HierarchicType sup = sub.getSuperType();         assertSame(MyStringXMap.class, sup.getRawClass());         HierarchicType sup2 = sup.getSuperType();         assertSame(HashMap.class, sup2.getRawClass());         assertNull(sup2.getSuperType());     }          /**      * @since 1.6      */     public void testSuperTypeDetectionInterface()     {         // List first         TypeFactory tf = TypeFactory.defaultInstance();         HierarchicType sub = tf._findSuperTypeChain(MyList.class, List.class);         assertNotNull(sub);         assertEquals(2, _countSupers(sub));         assertSame(MyList.class, sub.getRawClass());         HierarchicType sup = sub.getSuperType();         assertSame(IntermediateList.class, sup.getRawClass());         HierarchicType sup2 = sup.getSuperType();         assertSame(List.class, sup2.getRawClass());         assertNull(sup2.getSuperType());                  // Then Map         sub = tf._findSuperTypeChain(MyMap.class, Map.class);         assertNotNull(sub);         assertEquals(2, _countSupers(sub));         assertSame(MyMap.class, sub.getRawClass());         sup = sub.getSuperType();         assertSame(IntermediateMap.class, sup.getRawClass());         sup2 = sup.getSuperType();         assertSame(Map.class, sup2.getRawClass());         assertNull(sup2.getSuperType());     }      /**      * @since 1.6      */     public void testAtomicArrayRefParameterDetection()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType type = tf.constructType(new TypeReference<AtomicReference<long[]>>() { });         HierarchicType sub = tf._findSuperTypeChain(type.getRawClass(), AtomicReference.class);         assertNotNull(sub);         assertEquals(0, _countSupers(sub));         assertTrue(AtomicReference.class.isAssignableFrom(type.getRawClass()));         assertNull(sub.getSuperType());     }      private int _countSupers(HierarchicType t)     {         int depth = 0;         for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {             ++depth;         }         return depth;     }          /*     /**********************************************************     /* Unit tests: map/collection type parameter resolution     /**********************************************************      */          /**      * @since 1.6      */     public void testMapTypesSimple()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType type = tf.constructType(new TypeReference<Map<String,Boolean>>() { });         MapType mapType = (MapType) type;         assertEquals(tf.constructType(String.class), mapType.getKeyType());         assertEquals(tf.constructType(Boolean.class), mapType.getContentType());     }      /**      * @since 1.6      */     public void testMapTypesRaw()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType type = tf.constructType(HashMap.class);         MapType mapType = (MapType) type;         assertEquals(tf.constructType(Object.class), mapType.getKeyType());         assertEquals(tf.constructType(Object.class), mapType.getContentType());             }      /**      * @since 1.6      */     public void testMapTypesAdvanced()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType type = tf.constructType(MyMap.class);         MapType mapType = (MapType) type;         assertEquals(tf.constructType(String.class), mapType.getKeyType());         assertEquals(tf.constructType(Long.class), mapType.getContentType());          type = tf.constructType(MapInterface.class);         mapType = (MapType) type;         assertEquals(tf.constructType(String.class), mapType.getKeyType());         assertEquals(tf.constructType(Integer.class), mapType.getContentType());          type = tf.constructType(MyStringIntMap.class);         mapType = (MapType) type;         assertEquals(tf.constructType(String.class), mapType.getKeyType());         assertEquals(tf.constructType(Integer.class), mapType.getContentType());     }      /**      * Specific test to verify that complicate name mangling schemes      * do not fool type resolver      *       * @since 1.6      */     public void testMapTypesSneaky()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType type = tf.constructType(IntLongMap.class);         MapType mapType = (MapType) type;         assertEquals(tf.constructType(Integer.class), mapType.getKeyType());         assertEquals(tf.constructType(Long.class), mapType.getContentType());     }              /**      * Plus sneaky types may be found via introspection as well.      *       * @since 1.7      */     public void testSneakyFieldTypes() throws Exception     {         TypeFactory tf = TypeFactory.defaultInstance();         Field field = SneakyBean.class.getDeclaredField("intMap");         JavaType type = tf.constructType(field.getGenericType());         assertTrue(type instanceof MapType);         MapType mapType = (MapType) type;         assertEquals(tf.constructType(Integer.class), mapType.getKeyType());         assertEquals(tf.constructType(Long.class), mapType.getContentType());          field = SneakyBean.class.getDeclaredField("longList");         type = tf.constructType(field.getGenericType());         assertTrue(type instanceof CollectionType);         CollectionType collectionType = (CollectionType) type;         assertEquals(tf.constructType(Long.class), collectionType.getContentType());     }              /**      * Looks like type handling actually differs for properties, too.      *       * @since 1.7      */     public void testSneakyBeanProperties() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         StringLongMapBean bean = mapper.readValue("{\"value\":{\"a\":123}}", StringLongMapBean.class);         assertNotNull(bean);         Map<String,Long> map = bean.value;         assertEquals(1, map.size());         assertEquals(Long.valueOf(123), map.get("a"));          StringListBean bean2 = mapper.readValue("{\"value\":[\"...\"]}", StringListBean.class);         assertNotNull(bean2);         List<String> list = bean2.value;         assertSame(GenericList.class, list.getClass());         assertEquals(1, list.size());         assertEquals("...", list.get(0));     }          public void testAtomicArrayRefParameters()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType type = tf.constructType(new TypeReference<AtomicReference<long[]>>() { });         JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);         assertNotNull(params);         assertEquals(1, params.length);         assertEquals(tf.constructType(long[].class), params[0]);     }      public void testSneakySelfRefs() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         String json = mapper.writeValueAsString(new SneakyBean2());         assertEquals("{\"foobar\":null}", json);     }      /*     /**********************************************************     /* Unit tests: construction of "raw" types     /**********************************************************      */      public void testRawCollections()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType type = tf.constructRawCollectionType(ArrayList.class);         assertTrue(type.isContainerType());         assertEquals(TypeFactory.unknownType(), type.getContentType());          type = tf.constructRawCollectionLikeType(String.class); // class doesn't really matter         assertTrue(type.isCollectionLikeType());         assertEquals(TypeFactory.unknownType(), type.getContentType());     }      public void testRawMaps()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType type = tf.constructRawMapType(HashMap.class);         assertTrue(type.isContainerType());         assertEquals(TypeFactory.unknownType(), type.getKeyType());         assertEquals(TypeFactory.unknownType(), type.getContentType());          type = tf.constructRawMapLikeType(String.class); // class doesn't really matter         assertTrue(type.isMapLikeType());         assertEquals(TypeFactory.unknownType(), type.getKeyType());         assertEquals(TypeFactory.unknownType(), type.getContentType());     }      /*     /**********************************************************     /* Unit tests: other     /**********************************************************      */          public void testMoreSpecificType()     {         TypeFactory tf = TypeFactory.defaultInstance();          JavaType t1 = tf.constructCollectionType(Collection.class, Object.class);         JavaType t2 = tf.constructCollectionType(List.class, Object.class);         assertSame(t2, tf.moreSpecificType(t1, t2));         assertSame(t2, tf.moreSpecificType(t2, t1));          t1 = tf.constructType(Double.class);         t2 = tf.constructType(Number.class);         assertSame(t1, tf.moreSpecificType(t1, t2));         assertSame(t1, tf.moreSpecificType(t2, t1));          // and then unrelated, return first         t1 = tf.constructType(Double.class);         t2 = tf.constructType(String.class);         assertSame(t1, tf.moreSpecificType(t1, t2));         assertSame(t2, tf.moreSpecificType(t2, t1));     } }         
package com.fasterxml.jackson.databind.type;  import java.util.*;  import com.fasterxml.jackson.core.type.TypeReference;  import com.fasterxml.jackson.databind.JavaType; import com.fasterxml.jackson.databind.type.CollectionType; import com.fasterxml.jackson.databind.type.MapType; import com.fasterxml.jackson.databind.type.TypeFactory;  @SuppressWarnings("serial") public class TestTypeResolution extends com.fasterxml.jackson.test.BaseTest {     public static class LongValuedMap<K> extends HashMap<K, Long> { }      static class GenericList<X> extends ArrayList<X> { }     static class GenericList2<Y> extends GenericList<Y> { }      static class LongList extends GenericList2<Long> { }     static class MyLongList<T> extends LongList { }      /*     /**********************************************************     /* Test methods     /**********************************************************      */          public void testMaps()     {         TypeFactory tf = TypeFactory.defaultInstance();         JavaType t = tf.constructType(new TypeReference<LongValuedMap<String>>() { });         MapType type = (MapType) t;         assertSame(LongValuedMap.class, type.getRawClass());         assertEquals(tf.constructType(String.class), type.getKeyType());         assertEquals(tf.constructType(Long.class), type.getContentType());             }      public void testList()     {         JavaType t;          TypeFactory tf = TypeFactory.defaultInstance();         t = tf.constructType(new TypeReference<MyLongList<Integer>>() {});         CollectionType type = (CollectionType) t;         assertSame(MyLongList.class, type.getRawClass());         assertEquals(tf.constructType(Long.class), type.getContentType());                  t = tf.constructType(LongList.class);         type = (CollectionType) t;         assertSame(LongList.class, type.getRawClass());         assertEquals(tf.constructType(Long.class), type.getContentType());             } } 
package com.fasterxml.jackson.databind.util;  import org.junit.Assert;  import com.fasterxml.jackson.databind.BaseMapTest;  public class ArrayBuildersTest extends BaseMapTest { 	// Test for [Issue#157] 	public void testInsertInListNoDup() 	{         String [] arr = new String[]{"me", "you", "him"};         String [] newarr;                  newarr = ArrayBuilders.insertInListNoDup(arr, "you");         Assert.assertArrayEquals(new String[]{"you", "me", "him"}, newarr);          newarr = ArrayBuilders.insertInListNoDup(arr, "me");         Assert.assertArrayEquals(new String[]{"me", "you","him"}, newarr);          newarr = ArrayBuilders.insertInListNoDup(arr, "him");         Assert.assertArrayEquals(new String[]{"him", "me", "you"}, newarr);          newarr = ArrayBuilders.insertInListNoDup(arr, "foobar");         Assert.assertArrayEquals(new String[]{"foobar", "me", "you", "him"}, newarr); 	} } 
package com.fasterxml.jackson.databind.util;  import java.text.DateFormat; import java.util.*;   import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.util.ISO8601DateFormat;  /**  * @see ISO8601DateFormat  */ public class ISO8601DateFormatTest extends BaseMapTest {     private ISO8601DateFormat df;     private Date date;      @Override     public void setUp()     {         Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);         cal.setTimeZone(TimeZone.getTimeZone("GMT"));         cal.set(Calendar.MILLISECOND, 0);         date = cal.getTime();         df = new ISO8601DateFormat();     }      public void testFormat() {         String result = df.format(date);         assertEquals("2007-08-13T19:51:23Z", result);     }      public void testParse() throws Exception {         Date result = df.parse("2007-08-13T19:51:23Z");         assertEquals(date, result);     }      public void testCloneObject() throws Exception {         DateFormat clone = (DateFormat)df.clone();         assertSame(df, clone);     }  } 
package com.fasterxml.jackson.databind.util;  import java.util.*;   import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.util.ISO8601Utils;  /**  * @see ISO8601Utils  */ public class ISO8601UtilsTest extends BaseMapTest {     private Date date;     private Date dateZeroMillis;      @Override     public void setUp()     {         Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);         cal.setTimeZone(TimeZone.getTimeZone("GMT"));         cal.set(Calendar.MILLISECOND, 789);         date = cal.getTime();         cal.set(Calendar.MILLISECOND, 0);         dateZeroMillis = cal.getTime();     }      public void testFormat() {         String result = ISO8601Utils.format(date);         assertEquals("2007-08-13T19:51:23Z", result);     }      public void testFormatMillis() {         String result = ISO8601Utils.format(date, true);         assertEquals("2007-08-13T19:51:23.789Z", result);          result = ISO8601Utils.format(date, false);         assertEquals("2007-08-13T19:51:23Z", result);     }      public void testFormatTimeZone() {         String result = ISO8601Utils.format(date, false, TimeZone.getTimeZone("GMT+02:00"));         assertEquals("2007-08-13T21:51:23+02:00", result);         result = ISO8601Utils.format(date, true, TimeZone.getTimeZone("GMT+02:00"));         assertEquals("2007-08-13T21:51:23.789+02:00", result);         result = ISO8601Utils.format(date, true, TimeZone.getTimeZone("GMT"));         assertEquals("2007-08-13T19:51:23.789Z", result);     }      public void testParse() {         Date d = ISO8601Utils.parse("2007-08-13T19:51:23.789Z");         assertEquals(date, d);          d = ISO8601Utils.parse("2007-08-13T19:51:23Z");         assertEquals(dateZeroMillis, d);          d = ISO8601Utils.parse("2007-08-13T21:51:23.789+02:00");         assertEquals(date, d);     }  } 
package com.fasterxml.jackson.databind.util;  import java.util.*;  import static org.junit.Assert.*;   import com.fasterxml.jackson.databind.BaseMapTest; import com.fasterxml.jackson.databind.util.ClassUtil;  public class TestClassUtil     extends BaseMapTest {     /*     /**********************************************************     /* Test classes, enums     /**********************************************************      */      /* Test classes and interfaces needed for testing class util      * methods      */     static abstract class BaseClass implements Comparable<BaseClass>,         BaseInt     {         BaseClass(String str) { }     }      interface BaseInt { }      interface SubInt extends BaseInt { }      enum TestEnum { A; }      abstract class InnerNonStatic { }      static class Inner {         protected Inner() {             throw new IllegalStateException("test");         }     }      static abstract class SubClass         extends BaseClass         implements SubInt {         SubClass() { super("x"); }     }      /*     /**********************************************************     /* Test methods     /**********************************************************      */          public void testSuperTypes()     {         Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null);         Class<?>[] classes = result.toArray(new Class<?>[result.size()]);         Class<?>[] exp = new Class[] {             SubInt.class, BaseInt.class,             BaseClass.class,             Comparable.class         };         assertArrayEquals(exp, classes);     }      public void testSuperInterfaces()     {         Collection<Class<?>> result = ClassUtil.findSuperTypes(SubInt.class, null);         Class<?>[] classes = result.toArray(new Class<?>[result.size()]);         Class<?>[] exp = new Class[] {             BaseInt.class         };         assertArrayEquals(exp, classes);     }          public void testIsConcrete()     {         assertTrue(ClassUtil.isConcrete(getClass()));         assertFalse(ClassUtil.isConcrete(BaseClass.class));         assertFalse(ClassUtil.isConcrete(BaseInt.class));     }      public void testCanBeABeanType()     {         assertEquals("annotation", ClassUtil.canBeABeanType(java.lang.annotation.Retention.class));         assertEquals("array", ClassUtil.canBeABeanType(String[].class));         assertEquals("enum", ClassUtil.canBeABeanType(TestEnum.class));         assertEquals("primitive", ClassUtil.canBeABeanType(Integer.TYPE));         assertNull(ClassUtil.canBeABeanType(Integer.class));          assertEquals("non-static member class", ClassUtil.isLocalType(InnerNonStatic.class, false));         assertNull(ClassUtil.isLocalType(Integer.class, false));     }      public void testExceptionHelpers()     {         RuntimeException e = new RuntimeException("test");         RuntimeException wrapper = new RuntimeException(e);          assertSame(e, ClassUtil.getRootCause(wrapper));          try {             ClassUtil.throwAsIAE(e);             fail("Shouldn't get this far");         } catch (RuntimeException e2) {             assertSame(e, e2);         }          try {             ClassUtil.unwrapAndThrowAsIAE(wrapper);             fail("Shouldn't get this far");         } catch (RuntimeException e2) {             assertSame(e, e2);         }     }      public void testFailedCreateInstance()     {         try {             ClassUtil.createInstance(BaseClass.class, true);         } catch (IllegalArgumentException e) {             verifyException(e, "has no default");         }          try {             // false means ctor would need to be public             ClassUtil.createInstance(Inner.class, false);         } catch (IllegalArgumentException e) {             verifyException(e, "is not accessible");         }          // and finally, check that we'll get expected exception...         try {             ClassUtil.createInstance(Inner.class, true);         } catch (IllegalStateException e) {             verifyException(e, "test");         }     } } 
package com.fasterxml.jackson.databind.util;  import java.util.*;  import com.fasterxml.jackson.test.BaseTest;  public class TestObjectBuffer     extends BaseTest {     /**      * First a test that treats results as plain old Object[]      */     public void testUntyped()     {         _testObjectBuffer(null);     }      public void testTyped()     {         _testObjectBuffer(Integer.class);     }      /*     /**********************************************************     /* Helper methods     /**********************************************************      */      private void _testObjectBuffer(Class<?> clz)     {         int[] SIZES = new int[] {             3, 19, 99, 1007, 79000, 256001         };          // Let's loop separately for reused instance, new instance         for (int reuse = 0; reuse < 2; ++reuse) {             ObjectBuffer buf = (reuse == 0) ? null : new ObjectBuffer();              // then distinct sizes             for (int sizeIndex = 0; sizeIndex < SIZES.length; ++sizeIndex) {                 int size = SIZES[sizeIndex];                 Random r = new Random(size);                 ObjectBuffer thisBuf = (buf == null) ? new ObjectBuffer() : buf;                 Object[] chunk = thisBuf.resetAndStart();                 int ix = 0;                  for (int i = 0; i < size; ++i) {                     if (ix >= chunk.length) {                         chunk = thisBuf.appendCompletedChunk(chunk);                         ix = 0;                     }                     chunk[ix++] = Integer.valueOf(r.nextInt());                 }                  Object[] result;                                  if (clz == null) {                     result = thisBuf.completeAndClearBuffer(chunk, ix);                 } else {                     result = thisBuf.completeAndClearBuffer(chunk, ix, clz);                 }                 assertEquals(size, result.length);                  r = new Random(size);                 for (int i = 0; i < size; ++i) {                     assertEquals(r.nextInt(), ((Integer) result[i]).intValue());                 }             }         }     } } 
package com.fasterxml.jackson.databind.util;  import java.io.*;  import com.fasterxml.jackson.core.*; import com.fasterxml.jackson.core.util.JsonParserSequence;  public class TestTokenBuffer extends com.fasterxml.jackson.test.BaseTest {     /*     /**********************************************************     /* Basic TokenBuffer tests     /**********************************************************      */          /**      * Test writing of individual simple values      */     public void testSimpleWrites() throws IOException     {         TokenBuffer buf = new TokenBuffer(null); // no ObjectCodec          // First, with empty buffer         JsonParser jp = buf.asParser();         assertNull(jp.getCurrentToken());         assertNull(jp.nextToken());         jp.close();          // Then with simple text         buf.writeString("abc");          // First, simple text         jp = buf.asParser();         assertNull(jp.getCurrentToken());         assertToken(JsonToken.VALUE_STRING, jp.nextToken());         assertEquals("abc", jp.getText());         assertNull(jp.nextToken());         jp.close();          // Then, let's append at root level         buf.writeNumber(13);         jp = buf.asParser();         assertNull(jp.getCurrentToken());         assertToken(JsonToken.VALUE_STRING, jp.nextToken());         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertEquals(13, jp.getIntValue());         assertNull(jp.nextToken());         jp.close();         buf.close();     }      public void testSimpleArray() throws IOException     {         TokenBuffer buf = new TokenBuffer(null); // no ObjectCodec          // First, empty array         assertTrue(buf.getOutputContext().inRoot());         buf.writeStartArray();         assertTrue(buf.getOutputContext().inArray());         buf.writeEndArray();         assertTrue(buf.getOutputContext().inRoot());          JsonParser jp = buf.asParser();         assertNull(jp.getCurrentToken());         assertTrue(jp.getParsingContext().inRoot());         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertTrue(jp.getParsingContext().inArray());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertTrue(jp.getParsingContext().inRoot());         assertNull(jp.nextToken());         jp.close();         buf.close();          // Then one with simple contents         buf = new TokenBuffer(null);         buf.writeStartArray();         buf.writeBoolean(true);         buf.writeNull();         buf.writeEndArray();         jp = buf.asParser();         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.VALUE_TRUE, jp.nextToken());         assertTrue(jp.getBooleanValue());         assertToken(JsonToken.VALUE_NULL, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertNull(jp.nextToken());         jp.close();         buf.close();          // And finally, with array-in-array         buf = new TokenBuffer(null);         buf.writeStartArray();         buf.writeStartArray();         buf.writeBinary(new byte[3]);         buf.writeEndArray();         buf.writeEndArray();         jp = buf.asParser();         assertToken(JsonToken.START_ARRAY, jp.nextToken());         assertToken(JsonToken.START_ARRAY, jp.nextToken());         // TokenBuffer exposes it as embedded object...         assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken());         Object ob = jp.getEmbeddedObject();         assertNotNull(ob);         assertTrue(ob instanceof byte[]);         assertEquals(3, ((byte[]) ob).length);         assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertToken(JsonToken.END_ARRAY, jp.nextToken());         assertNull(jp.nextToken());         jp.close();         buf.close();     }      public void testSimpleObject() throws IOException     {         TokenBuffer buf = new TokenBuffer(null);          // First, empty JSON Object         assertTrue(buf.getOutputContext().inRoot());         buf.writeStartObject();         assertTrue(buf.getOutputContext().inObject());         buf.writeEndObject();         assertTrue(buf.getOutputContext().inRoot());          JsonParser jp = buf.asParser();         assertNull(jp.getCurrentToken());         assertTrue(jp.getParsingContext().inRoot());         assertToken(JsonToken.START_OBJECT, jp.nextToken());         assertTrue(jp.getParsingContext().inObject());         assertToken(JsonToken.END_OBJECT, jp.nextToken());         assertTrue(jp.getParsingContext().inRoot());         assertNull(jp.nextToken());         jp.close();         buf.close();          // Then one with simple contents         buf = new TokenBuffer(null);         buf.writeStartObject();         buf.writeNumberField("num", 1.25);         buf.writeEndObject();          jp = buf.asParser();         assertNull(jp.getCurrentToken());         assertToken(JsonToken.START_OBJECT, jp.nextToken());         assertNull(jp.getCurrentName());         assertToken(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals("num", jp.getCurrentName());         // and override should also work:         jp.overrideCurrentName("bah");         assertEquals("bah", jp.getCurrentName());                  assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());         assertEquals(1.25, jp.getDoubleValue());         // should still have access to (overridden) name         assertEquals("bah", jp.getCurrentName());         assertToken(JsonToken.END_OBJECT, jp.nextToken());         // but not any more         assertNull(jp.getCurrentName());         assertNull(jp.nextToken());         jp.close();         buf.close();     }      /**      * Verify handling of that "standard" test document (from JSON      * specification)      */     public void testWithJSONSampleDoc() throws Exception     {         // First, copy events from known good source (StringReader)         JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC);         TokenBuffer tb = new TokenBuffer(null);         while (jp.nextToken() != null) {             tb.copyCurrentEvent(jp);         }          // And then request verification; first structure only:         verifyJsonSpecSampleDoc(tb.asParser(), false);          // then content check too:         verifyJsonSpecSampleDoc(tb.asParser(), true);         tb.close();     }      public void testAppend() throws IOException     {         TokenBuffer buf1 = new TokenBuffer(null);         buf1.writeStartObject();         buf1.writeFieldName("a");         buf1.writeBoolean(true);                  TokenBuffer buf2 = new TokenBuffer(null);         buf2.writeFieldName("b");         buf2.writeNumber(13);         buf2.writeEndObject();                  buf1.append(buf2);                  // and verify that we got it all...         JsonParser jp = buf1.asParser();         assertToken(JsonToken.START_OBJECT, jp.nextToken());         assertToken(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals("a", jp.getCurrentName());         assertToken(JsonToken.VALUE_TRUE, jp.nextToken());         assertToken(JsonToken.FIELD_NAME, jp.nextToken());         assertEquals("b", jp.getCurrentName());         assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());         assertEquals(13, jp.getIntValue());         assertToken(JsonToken.END_OBJECT, jp.nextToken());         jp.close();         buf1.close();     }          /*     /**********************************************************     /* Tests to verify interaction of TokenBuffer and JsonParserSequence     /**********************************************************      */          public void testWithJsonParserSequenceSimple() throws IOException     {         // Let's join a TokenBuffer with JsonParser first         TokenBuffer buf = new TokenBuffer(null);         buf.writeStartArray();         buf.writeString("test");         JsonParser jp = createParserUsingReader("[ true, null ]");                  JsonParserSequence seq = JsonParserSequence.createFlattened(buf.asParser(), jp);         assertEquals(2, seq.containedParsersCount());          assertFalse(jp.isClosed());                  assertFalse(seq.hasCurrentToken());         assertNull(seq.getCurrentToken());         assertNull(seq.getCurrentName());          assertToken(JsonToken.START_ARRAY, seq.nextToken());         assertToken(JsonToken.VALUE_STRING, seq.nextToken());         assertEquals("test", seq.getText());         // end of first parser input, should switch over:                  assertToken(JsonToken.START_ARRAY, seq.nextToken());         assertToken(JsonToken.VALUE_TRUE, seq.nextToken());         assertToken(JsonToken.VALUE_NULL, seq.nextToken());         assertToken(JsonToken.END_ARRAY, seq.nextToken());          /* 17-Jan-2009, tatus: At this point, we may or may not get an          *   exception, depending on how underlying parsers work.          *   Ideally this should be fixed, probably by asking underlying          *   parsers to disable checking for balanced start/end markers.          */          // for this particular case, we won't get an exception tho...         assertNull(seq.nextToken());         // not an error to call again...         assertNull(seq.nextToken());          // also: original parsers should be closed         assertTrue(jp.isClosed());         jp.close();         buf.close();     }          /**      * Test to verify that TokenBuffer and JsonParserSequence work together      * as expected.      */     public void testWithMultipleJsonParserSequences() throws IOException     {         TokenBuffer buf1 = new TokenBuffer(null);         buf1.writeStartArray();         TokenBuffer buf2 = new TokenBuffer(null);         buf2.writeString("a");         TokenBuffer buf3 = new TokenBuffer(null);         buf3.writeNumber(13);         TokenBuffer buf4 = new TokenBuffer(null);         buf4.writeEndArray();          JsonParserSequence seq1 = JsonParserSequence.createFlattened(buf1.asParser(), buf2.asParser());         assertEquals(2, seq1.containedParsersCount());         JsonParserSequence seq2 = JsonParserSequence.createFlattened(buf3.asParser(), buf4.asParser());         assertEquals(2, seq2.containedParsersCount());         JsonParserSequence combo = JsonParserSequence.createFlattened(seq1, seq2);         // should flatten it to have 4 underlying parsers         assertEquals(4, combo.containedParsersCount());          assertToken(JsonToken.START_ARRAY, combo.nextToken());         assertToken(JsonToken.VALUE_STRING, combo.nextToken());         assertEquals("a", combo.getText());         assertToken(JsonToken.VALUE_NUMBER_INT, combo.nextToken());         assertEquals(13, combo.getIntValue());         assertToken(JsonToken.END_ARRAY, combo.nextToken());         assertNull(combo.nextToken());                 buf1.close();         buf2.close();         buf3.close();         buf4.close();     }     } 
package com.fasterxml.jackson.databind.views;  import com.fasterxml.jackson.annotation.JsonView;  import com.fasterxml.jackson.databind.*;  public class TestViewDeserialization extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      // Classes that represent views     static class ViewA { }     static class ViewAA extends ViewA { }     static class ViewB { }     static class ViewBB extends ViewB { }          static class Bean     {         @JsonView(ViewA.class)         public int a;          @JsonView({ViewAA.class, ViewB.class})         public String aa;          protected int b;                  @JsonView(ViewB.class)         public void setB(int value) { b = value; }     }      static class DefaultsBean     {         public int a;          @JsonView(ViewA.class)         public int b;     }      /*     /************************************************************************      /* Tests     /************************************************************************       */      private final ObjectMapper mapper = new ObjectMapper();          public void testSimple() throws Exception     {         // by default, should have it all...         Bean bean = mapper                 .readValue("{\"a\":3, \"aa\":\"foo\", \"b\": 9 }", Bean.class);         assertEquals(3, bean.a);         assertEquals("foo", bean.aa);         assertEquals(9, bean.b);                  // but with different views, different contents         bean = mapper.readerWithView(ViewAA.class)                 .withType(Bean.class)                 .readValue("{\"a\":3, \"aa\":\"foo\", \"b\": 9 }");         // should include 'a' and 'aa' (as per view)         assertEquals(3, bean.a);         assertEquals("foo", bean.aa);         // but not 'b'         assertEquals(0, bean.b);          bean = mapper.readerWithView(ViewA.class)                 .withType(Bean.class)                 .readValue("{\"a\":1, \"aa\":\"x\", \"b\": 3 }");         assertEquals(1, bean.a);         assertNull(bean.aa);         assertEquals(0, bean.b);                  bean = mapper.reader(Bean.class)                 .withView(ViewB.class)                 .readValue("{\"a\":-3, \"aa\":\"y\", \"b\": 2 }");         assertEquals(0, bean.a);         assertEquals("y", bean.aa);         assertEquals(2, bean.b);     }      public void testWithoutDefaultInclusion() throws Exception     {         // without active view, all included still:         DefaultsBean bean = mapper                 .readValue("{\"a\":3, \"b\": 9 }", DefaultsBean.class);         assertEquals(3, bean.a);         assertEquals(9, bean.b);          ObjectMapper myMapper = new ObjectMapper();         myMapper.disable(MapperFeature.DEFAULT_VIEW_INCLUSION);          // but with, say, AA, will not get 'b'         bean = myMapper.readerWithView(ViewAA.class)                 .withType(DefaultsBean.class)                 .readValue("{\"a\":1, \"b\": 2 }");         // 'a' not there any more         assertEquals(0, bean.a);         assertEquals(2, bean.b);     } } 
package com.fasterxml.jackson.databind.views;  import java.io.*; import java.util.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  /**  * Unit tests for verifying JSON view functionality: ability to declaratively  * suppress subset of properties from being serialized.  */ public class TestViewSerialization     extends BaseMapTest {     /*     /**********************************************************     /* Helper types     /**********************************************************      */      // Classes that represent views     static class ViewA { }     static class ViewAA extends ViewA { }     static class ViewB { }     static class ViewBB extends ViewB { }          static class Bean     {         @JsonView(ViewA.class)         public String a = "1";          @JsonView({ViewAA.class, ViewB.class})         public String aa = "2";          @JsonView(ViewB.class)         public String getB() { return "3"; }     }      /**      * Bean with mix of explicitly annotated      * properties, and implicit ones that may or may      * not be included in views.      */     static class MixedBean     {         @JsonView(ViewA.class)         public String a = "1";          public String getB() { return "2"; }     }      /**      * As indicated by [JACKSON-261], @JsonView should imply      * that associated element (method, field) is to be considered      * a property      */     static class ImplicitBean {         @JsonView(ViewA.class)         private int a = 1;     }      static class VisibilityBean {         @JsonProperty protected String id = "id";              @JsonView(ViewA.class)         public String value = "x";     }         // [JACKSON-868]     public static class WebView { }     public static class OtherView { }     public static class Foo {         @JsonView(WebView.class)         public int getFoo() { return 3; }     }          /*     /**********************************************************     /* Unit tests     /**********************************************************      */              @SuppressWarnings("unchecked")     public void testSimple() throws IOException     {         StringWriter sw = new StringWriter();         ObjectMapper mapper = new ObjectMapper();         // Ok, first, using no view whatsoever; all 3         Bean bean = new Bean();         Map<String,Object> map = writeAndMap(mapper, bean);         assertEquals(3, map.size());          // Then with "ViewA", just one property         sw = new StringWriter();         mapper.writerWithView(ViewA.class).writeValue(sw, bean);         map = mapper.readValue(sw.toString(), Map.class);         assertEquals(1, map.size());         assertEquals("1", map.get("a"));          // "ViewAA", 2 properties         sw = new StringWriter();         mapper.writerWithView(ViewAA.class).writeValue(sw, bean);         map = mapper.readValue(sw.toString(), Map.class);         assertEquals(2, map.size());         assertEquals("1", map.get("a"));         assertEquals("2", map.get("aa"));          // "ViewB", 2 prop2         String json = mapper.writerWithView(ViewB.class).writeValueAsString(bean);         map = mapper.readValue(json, Map.class);         assertEquals(2, map.size());         assertEquals("2", map.get("aa"));         assertEquals("3", map.get("b"));          // and "ViewBB", 2 as well         json = mapper.writerWithView(ViewBB.class).writeValueAsString(bean);         map = mapper.readValue(json, Map.class);         assertEquals(2, map.size());         assertEquals("2", map.get("aa"));         assertEquals("3", map.get("b"));     }      /**      * Unit test to verify implementation of [JACKSON-232], to      * allow "opt-in" handling for JSON Views: that is, that      * default for properties is to exclude unless included in      * a view.      */     @SuppressWarnings("unchecked")     public void testDefaultExclusion() throws IOException     {         MixedBean bean = new MixedBean();         StringWriter sw = new StringWriter();          ObjectMapper mapper = new ObjectMapper();         // default setting: both fields will get included         mapper.writerWithView(ViewA.class).writeValue(sw, bean);         Map<String,Object> map = mapper.readValue(sw.toString(), Map.class);         assertEquals(2, map.size());         assertEquals("1", map.get("a"));         assertEquals("2", map.get("b"));          // but can also change (but not necessarily on the fly...)         mapper = new ObjectMapper();         mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false);         // with this setting, only explicit inclusions count:         String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean);         map = mapper.readValue(json, Map.class);         assertEquals(1, map.size());         assertEquals("1", map.get("a"));         assertNull(map.get("b"));     }      /**      * As per [JACKSON-261], @JsonView annotation should imply that associated      * method/field does indicate a property.      */     public void testImplicitAutoDetection() throws Exception     {     	assertEquals("{\"a\":1}", serializeAsString(new ImplicitBean()));     }      public void testVisibility() throws Exception     {         ObjectMapper mapper = new ObjectMapper();         VisibilityBean bean = new VisibilityBean();         // Without view setting, should only see "id"         String json = mapper.writerWithView(Object.class).writeValueAsString(bean);         //json = mapper.writeValueAsString(bean);         assertEquals("{\"id\":\"id\"}", json);     }      // [JACKSON-868]     public void test() throws IOException     {         ObjectMapper mapper = new ObjectMapper();         mapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);         String json = mapper.writerWithView(OtherView.class).writeValueAsString(new Foo());         assertEquals(json, "{}");     }     } 
package com.fasterxml.jackson.databind.views;  import java.io.*;  import com.fasterxml.jackson.annotation.*;  import com.fasterxml.jackson.databind.*;  public class TestViewsSerialization2 extends BaseMapTest {     /*     /************************************************************************      /* Tests     /************************************************************************       */        public void testDataBindingUsage( ) throws Exception   {     ObjectMapper objectMapper = createObjectMapper( null );     String result = serializeWithObjectMapper(new ComplexTestData( ), Views.View.class, objectMapper );     assertEquals(-1, result.indexOf( "nameHidden" ));   }    public void testDataBindingUsageWithoutView( ) throws Exception   {     ObjectMapper objectMapper = createObjectMapper( null );     String json = serializeWithObjectMapper(new ComplexTestData( ), null, objectMapper);     assertTrue(json.indexOf( "nameHidden" ) > 0);   }    /*   /************************************************************************   /* Helper  methods   /************************************************************************    */    private ObjectMapper createObjectMapper(Class<?> viewClass)   {     ObjectMapper objectMapper = new ObjectMapper( );     objectMapper.configure( SerializationFeature.FAIL_ON_EMPTY_BEANS, false );     objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL );     objectMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false ); //    objectMapper.getSerializationConfig( ).disable( SerializationConfig.SerializationFeature.DEFAULT_VIEW_INCLUSION ); //    objectMapper.getSerializationConfig( ).setSerializationView( viewClass );     return objectMapper;   }      private String serializeWithObjectMapper(Object object, Class<? extends Views.View> view, ObjectMapper objectMapper )       throws IOException   {     return objectMapper.writerWithView(view).writeValueAsString(object);   }    /*   /************************************************************************   /* Helper classes   /************************************************************************    */    static class Views   {     public interface View { }     public interface ExtendedView  extends View { }   }      static class ComplexTestData   {     String nameNull = null;      String nameComplex = "complexValue";      String nameComplexHidden = "nameComplexHiddenValue";      SimpleTestData testData = new SimpleTestData( );      SimpleTestData[] testDataArray = new SimpleTestData[] { new SimpleTestData( ), null };      @JsonView( Views.View.class )     public String getNameNull()     {       return nameNull;     }      public void setNameNull( String nameNull )     {       this.nameNull = nameNull;     }      @JsonView( Views.View.class )     public String getNameComplex()     {       return nameComplex;     }      public void setNameComplex( String nameComplex )     {       this.nameComplex = nameComplex;     }      public String getNameComplexHidden()     {       return nameComplexHidden;     }      public void setNameComplexHidden( String nameComplexHidden )     {       this.nameComplexHidden = nameComplexHidden;     }      @JsonView( Views.View.class )     public SimpleTestData getTestData()     {       return testData;     }      public void setTestData( SimpleTestData testData )     {       this.testData = testData;     }      @JsonView( Views.View.class )     public SimpleTestData[] getTestDataArray()     {       return testDataArray;     }      public void setTestDataArray( SimpleTestData[] testDataArray )     {       this.testDataArray = testDataArray;     }   }    static class SimpleTestData   {     String name = "shown";      String nameHidden = "hidden";      @JsonView( Views.View.class )     public String getName()     {       return name;     }      public void setName( String name )     {       this.name = name;     }      public String getNameHidden( )     {       return nameHidden;     }      public void setNameHidden( String nameHidden )     {       this.nameHidden = nameHidden;     }   }  }
