/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri;  import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathTestCase; import org.apache.commons.jxpath.ri.compiler.Constant; import org.apache.commons.jxpath.ri.compiler.CoreFunction; import org.apache.commons.jxpath.ri.compiler.CoreOperationAdd; import org.apache.commons.jxpath.ri.compiler.CoreOperationAnd; import org.apache.commons.jxpath.ri.compiler.CoreOperationDivide; import org.apache.commons.jxpath.ri.compiler.CoreOperationEqual; import org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThan; import org.apache.commons.jxpath.ri.compiler.CoreOperationGreaterThanOrEqual; import org.apache.commons.jxpath.ri.compiler.CoreOperationLessThan; import org.apache.commons.jxpath.ri.compiler.CoreOperationLessThanOrEqual; import org.apache.commons.jxpath.ri.compiler.CoreOperationMod; import org.apache.commons.jxpath.ri.compiler.CoreOperationMultiply; import org.apache.commons.jxpath.ri.compiler.CoreOperationNegate; import org.apache.commons.jxpath.ri.compiler.CoreOperationNotEqual; import org.apache.commons.jxpath.ri.compiler.CoreOperationOr; import org.apache.commons.jxpath.ri.compiler.CoreOperationSubtract; import org.apache.commons.jxpath.ri.compiler.CoreOperationUnion; import org.apache.commons.jxpath.ri.compiler.ExpressionPath; import org.apache.commons.jxpath.ri.compiler.ExtensionFunction; import org.apache.commons.jxpath.ri.compiler.LocationPath; import org.apache.commons.jxpath.ri.compiler.NameAttributeTest; import org.apache.commons.jxpath.ri.compiler.VariableReference;  /**  * Test compiler.  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class JXPathCompiledExpressionTest extends JXPathTestCase {          /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public JXPathCompiledExpressionTest(String name) {         super(name);     }      public void testConstant() {         assertXPathExpression("1", Constant.class);         assertXPathExpression("1.5", Constant.class);         assertXPathExpression("'foo'", Constant.class);     }          public void testCoreFunction() {         assertXPathExpression("last()", CoreFunction.class);         assertXPathExpression("position()", CoreFunction.class);         assertXPathExpression("count(book)", CoreFunction.class);         assertXPathExpression("id(13)", CoreFunction.class);         assertXPathExpression("local-name()", CoreFunction.class);         assertXPathExpression("local-name(book)", CoreFunction.class);         assertXPathExpression("namespace-uri()", CoreFunction.class);         assertXPathExpression("namespace-uri(book)", CoreFunction.class);         assertXPathExpression("name()", CoreFunction.class);         assertXPathExpression("name(book)", CoreFunction.class);         assertXPathExpression("string(3)", CoreFunction.class);         assertXPathExpression("concat('a', 'b')", CoreFunction.class);         assertXPathExpression("starts-with('a', 'b')", CoreFunction.class);         assertXPathExpression("contains('a', 'b')", CoreFunction.class);         assertXPathExpression("substring-before('a', 1)", CoreFunction.class);         assertXPathExpression("substring-after('a', 2)", CoreFunction.class);         assertXPathExpression("substring('a', 2)", CoreFunction.class);         assertXPathExpression("substring('a', 2, 3)", CoreFunction.class);         assertXPathExpression("string-length('a')", CoreFunction.class);         assertXPathExpression("normalize-space('a')", CoreFunction.class);         assertXPathExpression("translate('a', 'b', 'c')", CoreFunction.class);         assertXPathExpression("boolean('true')", CoreFunction.class);         assertXPathExpression("not(1)", CoreFunction.class);         assertXPathExpression("true()", CoreFunction.class);         assertXPathExpression("false()", CoreFunction.class);         assertXPathExpression("lang('fr')", CoreFunction.class);         assertXPathExpression("number('12')", CoreFunction.class);         assertXPathExpression("sum(book/price)", CoreFunction.class);         assertXPathExpression("floor(11.4)", CoreFunction.class);         assertXPathExpression("ceiling(11.4)", CoreFunction.class);         assertXPathExpression("round(11.4)", CoreFunction.class);         assertXPathExpression("key('title', 'Hobbit')", CoreFunction.class);         assertXPathExpression("format-number(12, '##')", CoreFunction.class);     }          public void testCoreOperationAnd() {         assertXPathExpression(             "2 and 4",             CoreOperationAnd.class);          assertXPathExpression(             "2 > 1 and 4 < 5",             CoreOperationAnd.class);                 }              public void testCoreOperationOr() {         assertXPathExpression(             "2 or 4",             CoreOperationOr.class);          assertXPathExpression(             "2 > 1 or 4 < 5",             CoreOperationOr.class);          assertXPathExpression(             "1 > 1 and 2 <= 2 or 3 = 4",             CoreOperationOr.class);     }      public void testCoreOperationEqual() {         assertXPathExpression(             "2 = 4",             CoreOperationEqual.class);          assertXPathExpression(             "2 + 1 = 3",             CoreOperationEqual.class);     }          public void testCoreOperationNameAttributeTest() {         assertXPathExpression(             "@name = 'bar'",             NameAttributeTest.class);     }      public void testCoreOperationNotEqual() {         assertXPathExpression(             "2 != 4",             CoreOperationNotEqual.class);          assertXPathExpression(             "2 + 1 != 3",             CoreOperationNotEqual.class);     }      public void testCoreOperationLessThan() {         assertXPathExpression(             "3<4",             CoreOperationLessThan.class,             "3 < 4");          assertXPathExpression(             "3<(2>=1)",             CoreOperationLessThan.class,             "3 < (2 >= 1)");     }          public void testCoreOperationLessThanOrEqual() {         assertXPathExpression(             "3<=4",             CoreOperationLessThanOrEqual.class,             "3 <= 4");          assertXPathExpression(             "3<=(2>=1)",             CoreOperationLessThanOrEqual.class,             "3 <= (2 >= 1)");     }      public void testCoreOperationGreaterThan() {         assertXPathExpression(             "3>4",             CoreOperationGreaterThan.class,             "3 > 4");          assertXPathExpression(             "3>(2>=1)",             CoreOperationGreaterThan.class,             "3 > (2 >= 1)");          assertXPathExpression(             "1 > (1 and 2 <= (2 or 3) = 4)",             CoreOperationGreaterThan.class);     }          public void testCoreOperationGreaterThanOrEqual() {         assertXPathExpression(             "3>=4",             CoreOperationGreaterThanOrEqual.class,             "3 >= 4");          assertXPathExpression(             "3>=(2>=1)",             CoreOperationGreaterThanOrEqual.class,             "3 >= (2 >= 1)");     }      public void testCoreOperationDivide() {         assertXPathExpression(             "2 div 4",             CoreOperationDivide.class);          assertXPathExpression(             "2|3 div -3",             CoreOperationDivide.class,             "2 | 3 div -3");     }      public void testCoreOperationMod() {         assertXPathExpression(             "2 mod 4",             CoreOperationMod.class);          assertXPathExpression(             "2|3 mod -3",             CoreOperationMod.class,             "2 | 3 mod -3");     }      public void testCoreOperationMultiply() {         assertXPathExpression(             "2*4",             CoreOperationMultiply.class,             "2 * 4");                      assertXPathExpression(             "2*(3 + 1)",             CoreOperationMultiply.class,             "2 * (3 + 1)");     }          public void testCoreOperationMinus() {         assertXPathExpression(             "1 - 1",             CoreOperationSubtract.class);                      assertXPathExpression(             "1 - 1 - 2",             CoreOperationSubtract.class);                      assertXPathExpression(             "1 - (1 - 2)",             CoreOperationSubtract.class);     }          public void testCoreOperationSum() {         assertXPathExpression(             "3 + 1 + 4",              CoreOperationAdd.class);                      assertXPathExpression(             "(3 + 1) + 4",             CoreOperationAdd.class,             "3 + 1 + 4");                      assertXPathExpression(             "3 + (1 + 4)",             CoreOperationAdd.class,             "3 + 1 + 4");                      assertXPathExpression(             "3 + -1",              CoreOperationAdd.class,              "3 + -1");                      assertXPathExpression(             "2*-3 + -1",             CoreOperationAdd.class,             "2 * -3 + -1");     }          public void testCoreOperationUnaryMinus() {         assertXPathExpression("-3", CoreOperationNegate.class);         assertXPathExpression("-(3 + 1)", CoreOperationNegate.class);     }      public void testCoreOperationUnion() {         assertXPathExpression(             "3 | 1 | 4",             CoreOperationUnion.class);     }          public void testExpressionPath() {         assertXPathExpression(             "$x/foo/bar",             ExpressionPath.class);                 assertXPathExpression(             "(2 + 2)/foo/bar",             ExpressionPath.class);                 assertXPathExpression(             "$x[3][2 + 2]/foo/bar",             ExpressionPath.class);             }          public void testExtensionFunction() {         assertXPathExpression(             "my:function(3, other.function())",             ExtensionFunction.class);             }       public void testLocationPathAxisSelf() {         assertXPathExpression(             "self::foo:bar",             LocationPath.class);                           assertXPathExpression(             ".",             LocationPath.class);          }          public void testLocationPathAxisChild() {         assertXPathExpression(             "child::foo:bar",             LocationPath.class,             "foo:bar");                           assertXPathExpression(             "foo:bar",             LocationPath.class);                           assertXPathExpression(             "/foo:bar",             LocationPath.class);                           assertXPathExpression(             "/foo/bar",             LocationPath.class);               assertXPathExpression(             "*",             LocationPath.class);                           assertXPathExpression(             "foo:*",             LocationPath.class);                       }          public void testLocationPathAxisParent() {         assertXPathExpression(             "parent::foo:bar",             LocationPath.class);                           assertXPathExpression(             "..",             LocationPath.class);          }          public void testLocationPathAxisAttribute() {         assertXPathExpression(             "attribute::foo:bar",             LocationPath.class,             "@foo:bar");          assertXPathExpression(             "@foo:bar",             LocationPath.class);          assertXPathExpression(             "../@foo:bar",             LocationPath.class);          assertXPathExpression(             "@*",             LocationPath.class);          assertXPathExpression(             "@*[last()]",             LocationPath.class);     }          public void testLocationPathAxisDescendant() {         assertXPathExpression(             "descendant::foo:bar",             LocationPath.class);     }          public void testLocationPathAxisDescendantOrSelf() {         assertXPathExpression(             "descendant-or-self::foo:bar",             LocationPath.class);          assertXPathExpression(             "//foo",              LocationPath.class);          assertXPathExpression(             "foo//bar",              LocationPath.class);     }          public void testLocationPathAxisOther() {         assertXPathExpression(             "ancestor::foo:bar",             LocationPath.class);                      assertXPathExpression(             "ancestor-or-self::foo:bar",             LocationPath.class);                      assertXPathExpression(             "namespace::foo:bar",             LocationPath.class);          assertXPathExpression(             "preceding::foo:bar",             LocationPath.class);          assertXPathExpression(             "preceding-sibling::foo:bar",             LocationPath.class);          assertXPathExpression(             "following::foo:bar",             LocationPath.class);          assertXPathExpression(             "following-sibling::foo:bar",             LocationPath.class);     }          public void testLocationPathNodeTest() {         assertXPathExpression(             "node()",             LocationPath.class);          assertXPathExpression(             "text()",             LocationPath.class);          assertXPathExpression(             "comment()",             LocationPath.class);          assertXPathExpression(             "processing-instruction()",             LocationPath.class);          assertXPathExpression(             "processing-instruction('test')",             LocationPath.class);     }          public void testVariableReference() {         assertXPathExpression(             "$x",             VariableReference.class);                          assertXPathExpression(             "$x:y",             VariableReference.class);     }          /**      * Compiles the xpath into an Expression, checks the expression      * class, converts the expression to string and checks that the string      * matches the expected one.      */     private void assertXPathExpression(         String xpath,         Class expectedClass,         String expected)      {         JXPathCompiledExpression expression =             (JXPathCompiledExpression) JXPathContext.compile(xpath);                  assertEquals(             "Expression class for " + xpath,             expectedClass,             expression.getExpression().getClass());                      assertEquals(             "Expression toString() for " + xpath,             expected,             expression.getExpression().toString());     }          private void assertXPathExpression(         String xpath,         Class expectedClass)      {         assertXPathExpression(xpath, expectedClass, xpath);     }      }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri;  import junit.framework.TestCase;  import org.apache.commons.jxpath.JXPathContext;  /**  * Test thread safety.  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class StressTest extends TestCase {          private static final int THREAD_COUNT = 50;     private static final int THREAD_DURATION = 1000;     private static JXPathContext context;     private static int count;     private static Throwable exception;              /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public StressTest(String name) {         super(name);     }      public void testThreads() throws Throwable {         context = JXPathContext.newContext(null, new Double(100));         Thread[] threadArray = new Thread[THREAD_COUNT];         for (int i = 0; i < THREAD_COUNT; i++) {             threadArray[i] = new Thread(new StressRunnable());         }                  for (int i = 0; i < threadArray.length; i++) {             threadArray[i].start();         }          for (int i = 0; i < threadArray.length; i++) {             try {                 threadArray[i].join();             }             catch (InterruptedException e) {                 assertTrue("Interrupted", false);             }         }          if (exception != null) {             throw exception;         }         assertEquals("Test count", THREAD_COUNT * THREAD_DURATION, count);     }          private final class StressRunnable implements Runnable {         public void run() {             for (int j = 0; j < THREAD_DURATION && exception == null; j++) {                 try {                      double random = 1 + Math.random();                     double sum =                         ((Double) context.getValue("/ + " + random))                             .doubleValue();                     assertEquals(100 + random, sum, 0.0001);                     synchronized (context) {                         count++;                     }                 }                                     catch (Throwable t) {                     exception = t;                 }             }         }     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.axes;  import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathTestCase;  /**  * Test for the protection mechanism that stops infinite recursion  * in descent down a recursive graph.   */ public class RecursiveAxesTest extends JXPathTestCase {      private RecursiveBean bean;     private JXPathContext context;      public RecursiveAxesTest(String name) {         super(name);     }      public static void main(String[] args) {         junit.textui.TestRunner.run(RecursiveAxesTest.class);     }      /**      * @see TestCase#setUp()      */     protected void setUp() throws Exception {         bean = new RecursiveBean("zero");         RecursiveBean bean1 = new RecursiveBean("one");         RecursiveBean bean2 = new RecursiveBean("two");         RecursiveBean bean3 = new RecursiveBean("three");         bean.setFirst(bean1);         bean1.setFirst(bean2);         bean2.setFirst(bean1);         bean2.setSecond(bean3);          context = JXPathContext.newContext(null, bean);     }      public void testInfiniteDescent() {         // Existing scalar property         assertXPathPointer(             context,             "//.[name = 'three']",             "/first/first/second");     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.axes;  import java.util.HashMap;  import junit.framework.TestCase;  import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.NestedTestBean; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.TestNull; import org.apache.commons.jxpath.ri.model.NodePointer; import org.apache.commons.jxpath.ri.model.VariablePointer; import org.apache.commons.jxpath.ri.model.beans.BeanPointer; import org.apache.commons.jxpath.ri.model.beans.BeanPropertyPointer; import org.apache.commons.jxpath.ri.model.beans.CollectionPointer; import org.apache.commons.jxpath.ri.model.beans.NullElementPointer; import org.apache.commons.jxpath.ri.model.beans.NullPointer; import org.apache.commons.jxpath.ri.model.beans.NullPropertyPointer; import org.apache.commons.jxpath.ri.model.beans.TestBeanFactory; import org.apache.commons.jxpath.ri.model.dom.DOMNodePointer; import org.apache.commons.jxpath.ri.model.dynamic.DynamicPointer; import org.apache.commons.jxpath.ri.model.dynamic.DynamicPropertyPointer;  public class SimplePathInterpreterTest extends TestCase {      private TestBeanWithNode bean;     private JXPathContext context;      /**      * Constructor for SimplePathInterpreterTest.      */     public SimplePathInterpreterTest(String name) {         super(name);     }      public static void main(String[] args) {         junit.textui.TestRunner.run(SimplePathInterpreterTest.class);     }      /**      * @see TestCase#setUp()      */     protected void setUp() throws Exception {         bean = TestBeanWithNode.createTestBeanWithDOM();         HashMap submap = new HashMap();         submap.put("key", new NestedTestBean("Name 9"));         submap.put("strings", bean.getNestedBean().getStrings());         bean.getList().add(new int[]{1, 2});         bean.getList().add(bean.getVendor());         bean.getMap().put("Key3",             new Object[]{                 new NestedTestBean("some"),                 new Integer(2),                 bean.getVendor(),                 submap             }         );         bean.getMap().put("Key4", bean.getVendor());         bean.getMap().put("Key5", submap);         bean.getMap().put("Key6", new Object[0]);         context = JXPathContext.newContext(null, bean);         context.setLenient(true);         context.setFactory(new TestBeanFactory());     }      public void testDoStepNoPredicatesPropertyOwner() {         // Existing scalar property         assertValueAndPointer("/int",                 new Integer(1),                 "/int",                 "Bb",                 "BbB");          // self::         assertValueAndPointer("/./int",                 new Integer(1),                 "/int",                 "Bb",                 "BbB");          // Missing property         assertNullPointer("/foo",                 "/foo",                 "Bn");          // existingProperty/existingScalarProperty         assertValueAndPointer("/nestedBean/int",                 new Integer(1),                 "/nestedBean/int",                 "BbBb",                 "BbBbB");          // existingProperty/collectionProperty         assertValueAndPointer("/nestedBean/strings",                 bean.getNestedBean().getStrings(),                 "/nestedBean/strings",                 "BbBb",                 "BbBbC");          // existingProperty/missingProperty         assertNullPointer("/nestedBean/foo",                 "/nestedBean/foo",                 "BbBn");          // map/missingProperty         assertNullPointer("/map/foo",                 "/map[@name='foo']",                 "BbDd");          // Existing property by search in collection         assertValueAndPointer("/list/int",                 new Integer(1),                 "/list[3]/int",                 "BbBb",                 "BbBbB");          // Missing property by search in collection         assertNullPointer("/list/foo",                 "/list[1]/foo",                 "BbBn");          // existingProperty/missingProperty/missingProperty         assertNullPointer("/nestedBean/foo/bar",                 "/nestedBean/foo/bar",                 "BbBnNn");          // collection/existingProperty/missingProperty         assertNullPointer("/list/int/bar",                 "/list[3]/int/bar",                 "BbBbBn");          // collectionProperty/missingProperty/missingProperty         assertNullPointer("/list/foo/bar",                 "/list[1]/foo/bar",                 "BbBnNn");          // map/missingProperty/anotherStep         assertNullPointer("/map/foo/bar",                 "/map[@name='foo']/bar",                 "BbDdNn");          // Existing dynamic property         assertValueAndPointer("/map/Key1",                 "Value 1",                 "/map[@name='Key1']",                 "BbDd",                 "BbDdB");          // collectionProperty         assertValueAndPointer("/integers",                 bean.getIntegers(),                 "/integers",                 "Bb",                 "BbC");     }      public void testDoStepNoPredicatesStandard() {         // Existing DOM node         assertValueAndPointer("/vendor/location/address/city",                 "Fruit Market",                 "/vendor/location[2]/address[1]/city[1]",                 "BbMMMM");          // Missing DOM node         assertNullPointer("/vendor/location/address/pity",                 "/vendor/location[1]/address[1]/pity",                 "BbMMMn");          // Missing DOM node inside a missing element         assertNullPointer("/vendor/location/address/itty/bitty",                 "/vendor/location[1]/address[1]/itty/bitty",                 "BbMMMnNn");          // Missing DOM node by search for the best match         assertNullPointer("/vendor/location/address/city/pretty",                 "/vendor/location[2]/address[1]/city[1]/pretty",                 "BbMMMMn");     }      public void testDoStepPredicatesPropertyOwner() {         // missingProperty[@name=foo]         assertNullPointer("/foo[@name='foo']",                 "/foo[@name='foo']",                 "BnNn");          // missingProperty[index]         assertNullPointer("/foo[3]",                 "/foo[3]",                 "Bn");     }      public void testDoStepPredicatesStandard() {         // Looking for an actual XML attribute called "name"         // nodeProperty/name[@name=value]         assertValueAndPointer("/vendor/contact[@name='jack']",                 "Jack",                 "/vendor/contact[2]",                 "BbMM");          // Indexing in XML         assertValueAndPointer("/vendor/contact[2]",                 "Jack",                 "/vendor/contact[2]",                 "BbMM");          // Indexing in XML, no result         assertNullPointer("/vendor/contact[5]",                 "/vendor/contact[5]",                 "BbMn");          // Combination of search by name and indexing in XML         assertValueAndPointer("/vendor/contact[@name='jack'][2]",                 "Jack Black",                 "/vendor/contact[4]",                 "BbMM");          // Combination of search by name and indexing in XML         assertValueAndPointer("/vendor/contact[@name='jack'][2]",                 "Jack Black",                 "/vendor/contact[4]",                 "BbMM");     }      public void testDoPredicateName() {         // existingProperty[@name=existingProperty]         assertValueAndPointer("/nestedBean[@name='int']",                 new Integer(1),                 "/nestedBean/int",                 "BbBb",                 "BbBbB");          // /self::node()[@name=existingProperty]         assertValueAndPointer("/.[@name='int']",                 new Integer(1),                 "/int",                 "Bb",                 "BbB");          // dynamicProperty[@name=existingProperty]         assertValueAndPointer("/map[@name='Key1']",                 "Value 1",                 "/map[@name='Key1']",                 "BbDd",                 "BbDdB");          // existingProperty[@name=collectionProperty]         assertValueAndPointer("/nestedBean[@name='strings']",                 bean.getNestedBean().getStrings(),                 "/nestedBean/strings",                 "BbBb",                 "BbBbC");          // existingProperty[@name=missingProperty]         assertNullPointer("/nestedBean[@name='foo']",                 "/nestedBean[@name='foo']",                 "BbBn");          // map[@name=collectionProperty]         assertValueAndPointer("/map[@name='Key3']",                 bean.getMap().get("Key3"),                 "/map[@name='Key3']",                 "BbDd",                 "BbDdC");                          // map[@name=missingProperty]         assertNullPointer("/map[@name='foo']",                 "/map[@name='foo']",                 "BbDd");          // collectionProperty[@name=...] (find node)         assertValueAndPointer("/list[@name='fruitco']",                 context.getValue("/vendor"),                 "/list[5]",                 "BbCM");          // collectionProperty[@name=...] (find map entry)         assertValueAndPointer("/map/Key3[@name='key']/name",                 "Name 9",                 "/map[@name='Key3'][4][@name='key']/name",                 "BbDdCDdBb",                 "BbDdCDdBbB");          // map/collectionProperty[@name...]         assertValueAndPointer("map/Key3[@name='fruitco']",                 context.getValue("/vendor"),                 "/map[@name='Key3'][3]",                 "BbDdCM");          // Bean property -> DOM Node, name match         assertValueAndPointer("/vendor[@name='fruitco']",                 context.getValue("/vendor"),                 "/vendor",                 "BbM");          // Bean property -> DOM Node, name mismatch         assertNullPointer("/vendor[@name='foo']",                 "/vendor[@name='foo']",                 "BbMn");          assertNullPointer("/vendor[@name='foo'][3]",                 "/vendor[@name='foo'][3]",                 "BbMn");          // existingProperty(bean)[@name=missingProperty]/anotherStep         assertNullPointer("/nestedBean[@name='foo']/bar",                 "/nestedBean[@name='foo']/bar",                 "BbBnNn");          // map[@name=missingProperty]/anotherStep         assertNullPointer("/map[@name='foo']/bar",                 "/map[@name='foo']/bar",                 "BbDdNn");          // existingProperty(node)[@name=missingProperty]/anotherStep         assertNullPointer("/vendor[@name='foo']/bar",                 "/vendor[@name='foo']/bar",                 "BbMnNn");          // existingProperty(node)[@name=missingProperty][index]/anotherStep         assertNullPointer("/vendor[@name='foo'][3]/bar",                 "/vendor[@name='foo'][3]/bar",                 "BbMnNn");          // Existing dynamic property + existing property         assertValueAndPointer("/map[@name='Key2'][@name='name']",                 "Name 6",                 "/map[@name='Key2']/name",                 "BbDdBb",                 "BbDdBbB");          // Existing dynamic property + existing property + index         assertValueAndPointer("/map[@name='Key2'][@name='strings'][2]",                 "String 2",                 "/map[@name='Key2']/strings[2]",                 "BbDdBb",                 "BbDdBbB");          // bean/map/map/property         assertValueAndPointer("map[@name='Key5'][@name='key']/name",                 "Name 9",                 "/map[@name='Key5'][@name='key']/name",                 "BbDdDdBb",                 "BbDdDdBbB");          assertNullPointer("map[@name='Key2'][@name='foo']",                 "/map[@name='Key2'][@name='foo']",                 "BbDdBn");          assertNullPointer("map[@name='Key2'][@name='foo'][@name='bar']",                 "/map[@name='Key2'][@name='foo'][@name='bar']",                 "BbDdBnNn");          // bean/map/node         assertValueAndPointer("map[@name='Key4'][@name='fruitco']",                 context.getValue("/vendor"),                 "/map[@name='Key4']",                 "BbDdM");     }      public void testDoPredicatesStandard() {         // bean/map/collection/node         assertValueAndPointer("map[@name='Key3'][@name='fruitco']",                 context.getValue("/vendor"),                 "/map[@name='Key3'][3]",                 "BbDdCM");          // bean/map/collection/missingNode         assertNullPointer("map[@name='Key3'][@name='foo']",                 "/map[@name='Key3'][4][@name='foo']",                 "BbDdCDd");          // bean/map/node         assertValueAndPointer("map[@name='Key4'][@name='fruitco']",                 context.getValue("/vendor"),                 "/map[@name='Key4']",                 "BbDdM");          // bean/map/emptyCollection[@name=foo]         assertNullPointer("map[@name='Key6'][@name='fruitco']",                 "/map[@name='Key6'][@name='fruitco']",                 "BbDdCn");          // bean/node[@name=foo][index]         assertValueAndPointer("/vendor/contact[@name='jack'][2]",                 "Jack Black",                 "/vendor/contact[4]",                 "BbMM");          // bean/node[@name=foo][missingIndex]         assertNullPointer("/vendor/contact[@name='jack'][5]",                 "/vendor/contact[@name='jack'][5]",                 "BbMnNn");          // bean/node/.[@name=foo][index]         assertValueAndPointer("/vendor/contact/.[@name='jack']",                 "Jack",                 "/vendor/contact[2]",                 "BbMM");     }      public void testDoPredicateIndex() {         // Existing dynamic property + existing property + index         assertValueAndPointer("/map[@name='Key2'][@name='strings'][2]",                 "String 2",                 "/map[@name='Key2']/strings[2]",                 "BbDdBb",                 "BbDdBbB");          // existingProperty[@name=collectionProperty][index]         assertValueAndPointer("/nestedBean[@name='strings'][2]",                 bean.getNestedBean().getStrings()[1],                 "/nestedBean/strings[2]",                 "BbBb",                 "BbBbB");          // existingProperty[@name=missingProperty][index]         assertNullPointer("/nestedBean[@name='foo'][3]",                 "/nestedBean[@name='foo'][3]",                 "BbBn");          // existingProperty[@name=collectionProperty][missingIndex]         assertNullPointer("/nestedBean[@name='strings'][5]",                 "/nestedBean/strings[5]",                 "BbBbE");          // map[@name=collectionProperty][index]         assertValueAndPointer("/map[@name='Key3'][2]",                 new Integer(2),                 "/map[@name='Key3'][2]",                 "BbDd",                 "BbDdB");          // map[@name=collectionProperty][missingIndex]         assertNullPointer("/map[@name='Key3'][5]",                 "/map[@name='Key3'][5]",                 "BbDdE");          // map[@name=collectionProperty][missingIndex]/property         assertNullPointer("/map[@name='Key3'][5]/foo",                 "/map[@name='Key3'][5]/foo",                 "BbDdENn");          // map[@name=map][@name=collection][index]         assertValueAndPointer("/map[@name='Key5'][@name='strings'][2]",                 "String 2",                 "/map[@name='Key5'][@name='strings'][2]",                 "BbDdDd",                 "BbDdDdB");          // map[@name=map][@name=collection][missingIndex]         assertNullPointer("/map[@name='Key5'][@name='strings'][5]",                 "/map[@name='Key5'][@name='strings'][5]",                 "BbDdDdE");          // Existing dynamic property + indexing         assertValueAndPointer("/map[@name='Key3'][2]",                 new Integer(2),                 "/map[@name='Key3'][2]",                 "BbDd",                 "BbDdB");          // Existing dynamic property + indexing         assertValueAndPointer("/map[@name='Key3'][1]/name",                 "some",                 "/map[@name='Key3'][1]/name",                 "BbDdBb",                 "BbDdBbB");          // map[@name=missingProperty][index]         assertNullPointer("/map[@name='foo'][3]",                 "/map[@name='foo'][3]",                 "BbDdE");          // collectionProperty[index]         assertValueAndPointer("/integers[2]",                 new Integer(2),                 "/integers[2]",                 "Bb",                 "BbB");          // existingProperty/collectionProperty[index]         assertValueAndPointer("/nestedBean/strings[2]",                 bean.getNestedBean().getStrings()[1],                 "/nestedBean/strings[2]",                 "BbBb",                 "BbBbB");          // existingProperty[index]/existingProperty         assertValueAndPointer("/list[3]/int",                 new Integer(1),                 "/list[3]/int",                 "BbBb",                 "BbBbB");          // existingProperty[missingIndex]         assertNullPointer("/list[6]",                 "/list[6]",                 "BbE");          // existingProperty/missingProperty[index]         assertNullPointer("/nestedBean/foo[3]",                 "/nestedBean/foo[3]",                 "BbBn");          // map[@name=missingProperty][index]         assertNullPointer("/map/foo[3]",                 "/map[@name='foo'][3]",                 "BbDdE");          // existingProperty/collectionProperty[missingIndex]         assertNullPointer("/nestedBean/strings[5]",                 "/nestedBean/strings[5]",                 "BbBbE");          // map/collectionProperty[missingIndex]/property         assertNullPointer("/map/Key3[5]/foo",                 "/map[@name='Key3'][5]/foo",                 "BbDdENn");          // map[@name=map]/collection[index]         assertValueAndPointer("/map[@name='Key5']/strings[2]",                 "String 2",                 "/map[@name='Key5'][@name='strings'][2]",                 "BbDdDd",                 "BbDdDdB");          // map[@name=map]/collection[missingIndex]         assertNullPointer("/map[@name='Key5']/strings[5]",                 "/map[@name='Key5'][@name='strings'][5]",                 "BbDdDdE");          // scalarPropertyAsCollection[index]         assertValueAndPointer("/int[1]",                 new Integer(1),                 "/int",                 "Bb",                 "BbB");          // scalarPropertyAsCollection[index]         assertValueAndPointer(".[1]/int",                 new Integer(1),                 "/int",                 "Bb",                 "BbB");     }      public void testInterpretExpressionPath() {         context.getVariables().declareVariable("array", new String[]{"Value1"});         context.getVariables().declareVariable("testnull", new TestNull());          assertNullPointer("$testnull/nothing[2]",                 "$testnull/nothing[2]",                 "VBbE");     }      private void assertValueAndPointer(             String path, Object expectedValue, String expectedPath,             String expectedSignature)     {         assertValueAndPointer(             path,             expectedValue,             expectedPath,             expectedSignature,             expectedSignature);     }          private void assertValueAndPointer(             String path, Object expectedValue, String expectedPath,             String expectedSignature, String expectedValueSignature)     {         Object value = context.getValue(path);         assertEquals("Checking value: " + path, expectedValue, value);          Pointer pointer = context.getPointer(path);         assertEquals("Checking pointer: " + path,                 expectedPath, pointer.toString());          assertEquals("Checking signature: " + path,                 expectedSignature, pointerSignature(pointer));                  Pointer vPointer = ((NodePointer) pointer).getValuePointer();         assertEquals("Checking value pointer signature: " + path,                 expectedValueSignature, pointerSignature(vPointer));     }      private void assertNullPointer(String path, String expectedPath,             String expectedSignature)     {         Pointer pointer = context.getPointer(path);         assertNotNull("Null path exists: " + path,                     pointer);         assertEquals("Null path as path: " + path,                     expectedPath, pointer.asPath());         assertEquals("Checking Signature: " + path,                     expectedSignature, pointerSignature(pointer));                          Pointer vPointer = ((NodePointer) pointer).getValuePointer();         assertTrue("Null path is null: " + path,                     !((NodePointer) vPointer).isActual());         assertEquals("Checking value pointer signature: " + path,                     expectedSignature + "N", pointerSignature(vPointer));     }      /**      * Since we need to test the internal Signature of a pointer,      * we will get a signature which will contain a single character      * per pointer in the chain, representing that pointer's type.      */     private String pointerSignature(Pointer pointer) {         if (pointer == null) {             return "";         }          char type = '?';         if (pointer instanceof NullPointer) {                 type = 'N'; }         else if (pointer instanceof NullPropertyPointer) {    type = 'n'; }         else if (pointer instanceof NullElementPointer) {     type = 'E'; }         else if (pointer instanceof VariablePointer) {        type = 'V'; }         else if (pointer instanceof CollectionPointer) {      type = 'C'; }         else if (pointer instanceof BeanPointer) {            type = 'B'; }         else if (pointer instanceof BeanPropertyPointer) {    type = 'b'; }         else if (pointer instanceof DynamicPointer) {         type = 'D'; }         else if (pointer instanceof DynamicPropertyPointer) { type = 'd'; }         else if (pointer instanceof DOMNodePointer) {         type = 'M'; }         else {             System.err.println("UNKNOWN TYPE: " + pointer.getClass());         }         NodePointer parent =              ((NodePointer) pointer).getImmediateParentPointer();         return pointerSignature(parent) + type;     } }  
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.compiler;  import org.apache.commons.jxpath.JXPathTestCase; import org.apache.commons.jxpath.ri.Parser;  /**  * Tests the determination of whether an expression is context dependent.  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class ContextDependencyTest extends JXPathTestCase {     public ContextDependencyTest(String name) {         super(name);     }      public void testContextDependency() {         testContextDependency("1", false);         testContextDependency("$x", false);         testContextDependency("/foo", false);         testContextDependency("foo", true);         testContextDependency("/foo[3]", false);         testContextDependency("/foo[$x]", false);         testContextDependency("/foo[bar]", true);         testContextDependency("3 + 5", false);         testContextDependency("test:func(3, 5)", true);         testContextDependency("test:func(3, foo)", true);     }      public void testContextDependency(String xpath, boolean expected) {         Expression expr =             (Expression) Parser.parseExpression(xpath, new TreeCompiler());          assertEquals(             "Context dependency <" + xpath + ">",             expected,             expr.isContextDependent());     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.compiler;  import java.text.DecimalFormatSymbols;  import org.apache.commons.jxpath.IdentityManager; import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathTestCase; import org.apache.commons.jxpath.KeyManager; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.TestMixedModelBean; import org.apache.commons.jxpath.Variables; import org.apache.commons.jxpath.ri.model.NodePointer;  /**  * Test basic functionality of JXPath - core functions.  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class CoreFunctionTest extends JXPathTestCase {     private JXPathContext context;      /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public CoreFunctionTest(String name) {         super(name);     }      public void setUp() {         if (context == null) {             context = JXPathContext.newContext(new TestMixedModelBean());             Variables vars = context.getVariables();             vars.declareVariable("nan", new Double(Double.NaN));             vars.declareVariable("bool_true", new Boolean("true"));             vars.declareVariable("bool_false", new Boolean("false"));         }     }      public void testCoreFunctions() {         assertXPathValue(context, "string(2)", "2");         assertXPathValue(context, "string($nan)", "NaN");         assertXPathValue(context, "string(-$nan)", "NaN");         assertXPathValue(context, "string(-2 div 0)", "-Infinity");         assertXPathValue(context, "string(2 div 0)", "Infinity");         assertXPathValue(context, "concat('a', 'b', 'c')", "abc");         assertXPathValue(context, "starts-with('abc', 'ab')", Boolean.TRUE);         assertXPathValue(context, "starts-with('xabc', 'ab')", Boolean.FALSE);         assertXPathValue(context, "contains('xabc', 'ab')", Boolean.TRUE);         assertXPathValue(context, "contains('xabc', 'ba')", Boolean.FALSE);         assertXPathValue(             context,             "substring-before('1999/04/01', '/')",             "1999");         assertXPathValue(             context,             "substring-after('1999/04/01', '/')",             "04/01");         assertXPathValue(context, "substring('12345', 2, 3)", "234");         assertXPathValue(context, "substring('12345', 2)", "2345");         assertXPathValue(context, "substring('12345', 1.5, 2.6)", "234");         assertXPathValue(context, "substring('12345', 0, 3)", "12");         assertXPathValue(context, "substring('12345', 0 div 0, 3)", "");         assertXPathValue(context, "substring('12345', 1, 0 div 0)", "");         assertXPathValue(context, "substring('12345', -42, 1 div 0)", "12345");         assertXPathValue(context, "substring('12345', -1 div 0, 1 div 0)", "");         assertXPathValue(context, "substring('12345', 6, 6)", "");         assertXPathValue(context, "substring('12345', 7, 8)", "");         assertXPathValue(context, "substring('12345', 7)", "");         assertXPathValue(context, "string-length('12345')", new Double(5));         assertXPathValue(context, "normalize-space(' abc  def  ')", "abc def");         assertXPathValue(context, "normalize-space('abc def')", "abc def");         assertXPathValue(context, "normalize-space('   ')", "");         assertXPathValue(context, "translate('--aaa--', 'abc-', 'ABC')", "AAA");         assertXPathValue(context, "boolean(1)", Boolean.TRUE);         assertXPathValue(context, "boolean(0)", Boolean.FALSE);         assertXPathValue(context, "boolean('x')", Boolean.TRUE);         assertXPathValue(context, "boolean('')", Boolean.FALSE);          assertXPathValue(context, "true()", Boolean.TRUE);         assertXPathValue(context, "false()", Boolean.FALSE);         assertXPathValue(context, "not(false())", Boolean.TRUE);         assertXPathValue(context, "not(true())", Boolean.FALSE);         assertXPathValue(context, "number('1')", new Double(1));         assertXPathValue(context, "number($bool_true)", new Double(1));         assertXPathValue(context, "number($bool_false)", new Double(0));         assertXPathValue(context, "floor(1.5)", new Double(1));         assertXPathValue(context, "floor(-1.5)", new Double(-2));         assertXPathValue(context, "ceiling(1.5)", new Double(2));         assertXPathValue(context, "ceiling(-1.5)", new Double(-1));         assertXPathValue(context, "round(1.5)", new Double(2));         assertXPathValue(context, "round(-1.5)", new Double(-1));         assertXPathValue(context, "null()", null);             }      public void testIDFunction() {         context.setIdentityManager(new IdentityManager() {             public Pointer getPointerByID(JXPathContext context, String id) {                 NodePointer ptr = (NodePointer) context.getPointer("/document");                 ptr = ptr.getValuePointer();                 return ptr.getPointerByID(context, id);             }         });          assertXPathValueAndPointer(             context,             "id(101)//street",             "Tangerine Drive",             "id('101')/address[1]/street[1]");          assertXPathPointerLenient(             context,             "id(105)/address/street",             "id(105)/address/street");     }      public void testKeyFunction() {         context.setKeyManager(new KeyManager() {             public Pointer getPointerByKey(                 JXPathContext context,                 String key,                 String value)              {                 return NodePointer.newNodePointer(null, "42", null);             }         });          assertEquals("Test key", "42", context.getValue("key('a', 'b')"));     }          public void testFormatNumberFunction() {                  DecimalFormatSymbols symbols = new DecimalFormatSymbols();         symbols.setDigit('D');                  context.setDecimalFormatSymbols("test", symbols);                  assertXPathValue(             context,             "format-number(123456789, '#.000000000')",             "123456789.000000000");          assertXPathValue(             context,             "format-number(123456789, '#.0')",             "123456789.0");          assertXPathValue(             context,              "format-number(0.123456789, '##%')",              "12%");          assertXPathValue(             context,             "format-number(123456789, '################')",             "123456789");          assertXPathValue(             context,             "format-number(123456789, 'D.0', 'test')",             "123456789.0");          assertXPathValue(             context,             "format-number(123456789, '$DDD,DDD,DDD.DD', 'test')",             "$123,456,789");     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.compiler;  import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathTestCase; import org.apache.commons.jxpath.Variables;  /**  * Test basic functionality of JXPath - infoset types,  * operations.  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class CoreOperationTest extends JXPathTestCase {     private JXPathContext context;      /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public CoreOperationTest(String name) {         super(name);     }      public void setUp() {         if (context == null) {             context = JXPathContext.newContext(null);             Variables vars = context.getVariables();             vars.declareVariable("integer", new Integer(1));         }     }      public void testInfoSetTypes() {          // Numbers         assertXPathValue(context, "1", new Double(1.0));         assertXPathPointer(context, "1", "1");         assertXPathValueIterator(context, "1", list(new Double(1.0)));          assertXPathPointerIterator(context, "1", list("1"));          assertXPathValue(context, "-1", new Double(-1.0));         assertXPathValue(context, "2 + 2", new Double(4.0));         assertXPathValue(context, "3 - 2", new Double(1.0));         assertXPathValue(context, "1 + 2 + 3 - 4 + 5", new Double(7.0));         assertXPathValue(context, "3 * 2", new Double(3.0 * 2.0));         assertXPathValue(context, "3 div 2", new Double(3.0 / 2.0));         assertXPathValue(context, "5 mod 2", new Double(1.0));          // This test produces a different result with Xalan?         assertXPathValue(context, "5.9 mod 2.1", new Double(1.0));          assertXPathValue(context, "5 mod -2", new Double(1.0));         assertXPathValue(context, "-5 mod 2", new Double(-1.0));         assertXPathValue(context, "-5 mod -2", new Double(-1.0));         assertXPathValue(context, "1 < 2", Boolean.TRUE);         assertXPathValue(context, "1 > 2", Boolean.FALSE);         assertXPathValue(context, "1 <= 1", Boolean.TRUE);         assertXPathValue(context, "1 >= 2", Boolean.FALSE);         assertXPathValue(context, "3 > 2 > 1", Boolean.FALSE);         assertXPathValue(context, "3 > 2 and 2 > 1", Boolean.TRUE);         assertXPathValue(context, "3 > 2 and 2 < 1", Boolean.FALSE);         assertXPathValue(context, "3 < 2 or 2 > 1", Boolean.TRUE);         assertXPathValue(context, "3 < 2 or 2 < 1", Boolean.FALSE);         assertXPathValue(context, "1 = 1", Boolean.TRUE);         assertXPathValue(context, "1 = '1'", Boolean.TRUE);         assertXPathValue(context, "1 > 2 = 2 > 3", Boolean.TRUE);         assertXPathValue(context, "1 > 2 = 0", Boolean.TRUE);         assertXPathValue(context, "1 = 2", Boolean.FALSE);          assertXPathValue(context, "$integer", new Double(1), Double.class);          assertXPathValue(context, "2 + 3", "5.0", String.class);          assertXPathValue(context, "2 + 3", Boolean.TRUE, boolean.class);          assertXPathValue(context, "'true'", Boolean.TRUE, Boolean.class);     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.compiler;  import java.util.ArrayList; import java.util.Collection; import java.util.List; import java.util.Locale;  import junit.textui.TestRunner;  import org.apache.commons.jxpath.ClassFunctions; import org.apache.commons.jxpath.ExpressionContext; import org.apache.commons.jxpath.Function; import org.apache.commons.jxpath.FunctionLibrary; import org.apache.commons.jxpath.Functions; import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathTestCase; import org.apache.commons.jxpath.PackageFunctions; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.TestBean; import org.apache.commons.jxpath.Variables; import org.apache.commons.jxpath.ri.model.NodePointer;  /**  * Test extension functions.  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class ExtensionFunctionTest extends JXPathTestCase {     private Functions functions;     private JXPathContext context;      public static void main(String[] args) {         TestRunner.run(ExtensionFunctionTest.class);     }          /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public ExtensionFunctionTest(String name) {         super(name);     }      public void setUp() {         if (context == null) {             context = JXPathContext.newContext(new TestBean());             Variables vars = context.getVariables();             vars.declareVariable("test", new TestFunctions(4, "test"));              FunctionLibrary lib = new FunctionLibrary();             lib.addFunctions(new ClassFunctions(TestFunctions.class, "test"));             lib.addFunctions(new ClassFunctions(TestFunctions2.class, "test"));             lib.addFunctions(new PackageFunctions("", "call"));             lib.addFunctions(                 new PackageFunctions(                     "org.apache.commons.jxpath.ri.compiler.",                     "jxpathtest"));             lib.addFunctions(new PackageFunctions("", null));             context.setFunctions(lib);         }         functions = new ClassFunctions(TestFunctions.class, "test");     }      public void testConstructorLookup() {         Object[] args = new Object[] { new Integer(1), "x" };         Function func = functions.getFunction("test", "new", args);          assertEquals(             "test:new(1, x)",             func.invoke(new Context(null), args).toString(),             "foo=1; bar=x");     }      public void testConstructorLookupWithExpressionContext() {         Object[] args = new Object[] { "baz" };         Function func = functions.getFunction("test", "new", args);         assertEquals(             "test:new('baz')",             func.invoke(new Context(new Integer(1)), args).toString(),             "foo=1; bar=baz");     }      public void testStaticMethodLookup() {         Object[] args = new Object[] { new Integer(1), "x" };         Function func = functions.getFunction("test", "build", args);         assertEquals(             "test:build(1, x)",             func.invoke(new Context(null), args).toString(),             "foo=1; bar=x");     }      public void testStaticMethodLookupWithConversion() {         Object[] args = new Object[] { "7", new Integer(1)};         Function func = functions.getFunction("test", "build", args);         assertEquals(             "test:build('7', 1)",             func.invoke(new Context(null), args).toString(),             "foo=7; bar=1");     }      public void testMethodLookup() {         Object[] args = new Object[] { new TestFunctions()};         Function func = functions.getFunction("test", "getFoo", args);         assertEquals(             "test:getFoo($test, 1, x)",             func.invoke(new Context(null), args).toString(),             "0");     }      public void testStaticMethodLookupWithExpressionContext() {         Object[] args = new Object[0];         Function func = functions.getFunction("test", "path", args);         assertEquals(             "test:path()",             func.invoke(new Context(new Integer(1)), args),             "1");     }      public void testMethodLookupWithExpressionContext() {         Object[] args = new Object[] { new TestFunctions()};         Function func = functions.getFunction("test", "instancePath", args);         assertEquals(             "test:instancePath()",             func.invoke(new Context(new Integer(1)), args),             "1");     }      public void testMethodLookupWithExpressionContextAndArgument() {         Object[] args = new Object[] { new TestFunctions(), "*" };         Function func = functions.getFunction("test", "pathWithSuffix", args);         assertEquals(             "test:pathWithSuffix('*')",             func.invoke(new Context(new Integer(1)), args),             "1*");     }      public void testAllocation() {                  // Allocate new object using the default constructor         assertXPathValue(context, "string(test:new())", "foo=0; bar=null");          // Allocate new object using PackageFunctions and class name         assertXPathValue(             context,             "string(jxpathtest:TestFunctions.new())",             "foo=0; bar=null");          // Allocate new object using a fully qualified class name         assertXPathValue(             context,             "string(" + TestFunctions.class.getName() + ".new())",             "foo=0; bar=null");          // Allocate new object using a custom constructor         assertXPathValue(             context,             "string(test:new(3, 'baz'))",             "foo=3; bar=baz");          // Allocate new object using a custom constructor - type conversion         assertXPathValue(context, "string(test:new('3', 4))", "foo=3; bar=4.0");                  context.getVariables().declareVariable("A", "baz");                 assertXPathValue(                 context,                 "string(test:new(2, $A, false))",                 "foo=2; bar=baz");     }      public void testMethodCall() {         assertXPathValue(context, "length('foo')", new Integer(3));          // We are just calling a method - prefix is ignored         assertXPathValue(context, "call:substring('foo', 1, 2)", "o");          // Invoke a function implemented as a regular method         assertXPathValue(context, "string(test:getFoo($test))", "4");                  // Note that the prefix is ignored anyway, we are just calling a method         assertXPathValue(context, "string(call:getFoo($test))", "4");          // We don't really need to supply a prefix in this case         assertXPathValue(context, "string(getFoo($test))", "4");          // Method with two arguments         assertXPathValue(             context,             "string(test:setFooAndBar($test, 7, 'biz'))",             "foo=7; bar=biz");     }          public void testCollectionMethodCall() {                  List list = new ArrayList();         list.add("foo");         context.getVariables().declareVariable("myList", list);          assertXPathValue(             context,              "size($myList)",              new Integer(1));              assertXPathValue(             context,              "size(beans)",              new Integer(2));                      context.getValue("add($myList, 'hello')");         assertEquals("After adding an element", 2, list.size());                  JXPathContext context = JXPathContext.newContext(new ArrayList());         assertEquals("Extension function on root collection", "0", String                 .valueOf(context.getValue("size(/)")));     }      public void testStaticMethodCall() {          assertXPathValue(             context,             "string(test:build(8, 'goober'))",             "foo=8; bar=goober");          // Call a static method using PackageFunctions and class name         assertXPathValue(             context,             "string(jxpathtest:TestFunctions.build(8, 'goober'))",             "foo=8; bar=goober");          // Call a static method with a fully qualified class name         assertXPathValue(             context,             "string(" + TestFunctions.class.getName() + ".build(8, 'goober'))",             "foo=8; bar=goober");          // Two ClassFunctions are sharing the same prefix.         // This is TestFunctions2         assertXPathValue(context, "string(test:increment(8))", "9");                  // See that a NodeSet gets properly converted to a string         assertXPathValue(context, "test:string(/beans/name)", "Name 1");     }      public void testExpressionContext() {         // Execute an extension function for each node while searching         // The function uses ExpressionContext to get to the current         // node.         assertXPathValue(             context,              "//.[test:isMap()]/Key1",              "Value 1");          // The function gets all         // nodes in the context that match the pattern.         assertXPathValue(             context,             "count(//.[test:count(strings) = 3])",             new Double(7));          // The function receives a collection of strings         // and checks their type for testing purposes                     assertXPathValue(             context,             "test:count(//strings)",             new Integer(21));                   // The function receives a collection of pointers         // and checks their type for testing purposes                     assertXPathValue(             context,             "test:countPointers(//strings)",             new Integer(21));                      // The function uses ExpressionContext to get to the current         // pointer and returns its path.         assertXPathValue(             context,             "/beans[contains(test:path(), '[2]')]/name",             "Name 2");     }          public void testCollectionReturn() {         assertXPathValueIterator(             context,             "test:collection()/name",             list("foo", "bar"));          assertXPathPointerIterator(             context,             "test:collection()/name",             list("/.[1]/name", "/.[2]/name"));                      assertXPathValue(             context,             "test:collection()/name",             "foo");                  assertXPathValue(             context,             "test:collection()/@name",             "foo");                     List list = new ArrayList();         list.add("foo");         list.add("bar");         context.getVariables().declareVariable("list", list);         Object values = context.getValue("test:items($list)");         assertTrue("Return type: ", values instanceof Collection);         assertEquals(             "Return values: ",             list,             new ArrayList((Collection) values));     }      public void testNodeSetReturn() {         assertXPathValueIterator(             context,             "test:nodeSet()/name",             list("Name 1", "Name 2"));          assertXPathPointerIterator(             context,             "test:nodeSet()/name",             list("/beans[1]/name", "/beans[2]/name"));                      assertXPathValueAndPointer(             context,             "test:nodeSet()/name",             "Name 1",             "/beans[1]/name");                  assertXPathValueAndPointer(             context,             "test:nodeSet()/@name",             "Name 1",             "/beans[1]/@name");     }      private static class Context implements ExpressionContext {         private Object object;          public Context(Object object) {             this.object = object;         }          public Pointer getContextNodePointer() {             return NodePointer                     .newNodePointer(null, object, Locale.getDefault());         }          public List getContextNodeList() {             return null;         }          public JXPathContext getJXPathContext() {             return null;         }          public int getPosition() {             return 0;         }     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.compiler;  import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathTestCase; import org.apache.commons.jxpath.Variables;  /**  * Test basic functionality of JXPath - infoset types,  * operations.  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class VariableTest extends JXPathTestCase {     private JXPathContext context;      /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public VariableTest(String name) {         super(name);     }      public void setUp() {         if (context == null) {             context = JXPathContext.newContext(null);             context.setFactory(new VariableFactory());              Variables vars = context.getVariables();             vars.declareVariable("a", new Double(1));             vars.declareVariable("b", new Double(1));             vars.declareVariable("c", null);             vars.declareVariable("d", new String[] { "a", "b" });             vars.declareVariable("integer", new Integer(1));             vars.declareVariable("nan", new Double(Double.NaN));             vars.declareVariable("x", null);         }     }      public void testVariables() {         // Variables         assertXPathValueAndPointer(context, "$a", new Double(1), "$a");     }      public void testVariablesInExpressions() {         assertXPathValue(context, "$a = $b", Boolean.TRUE);          assertXPathValue(context, "$a = $nan", Boolean.FALSE);          assertXPathValue(context, "$a + 1", new Double(2));          assertXPathValue(context, "$c", null);          assertXPathValue(context, "$d[2]", "b");     }      public void testInvalidVariableName() {         boolean exception = false;         try {             context.getValue("$none");         }         catch (Exception ex) {             exception = true;         }         assertTrue(             "Evaluating '$none', expected exception - did not get it",             exception);          exception = false;         try {             context.setValue("$none", new Integer(1));         }         catch (Exception ex) {             exception = true;         }         assertTrue(             "Setting '$none = 1', expected exception - did not get it",             exception);     }      public void testNestedContext() {         JXPathContext nestedContext = JXPathContext.newContext(context, null);          assertXPathValue(nestedContext, "$a", new Double(1));     }      public void testSetValue() {         assertXPathSetValue(context, "$x", new Integer(1));     }      public void testCreatePathDeclareVariable() {         // Calls factory.declareVariable("string")         assertXPathCreatePath(context, "$string", null, "$string");     }      public void testCreatePathAndSetValueDeclareVariable() {         // Calls factory.declareVariable("string")         assertXPathCreatePathAndSetValue(             context,             "$string",             "Value",             "$string");     }      public void testCreatePathDeclareVariableSetCollectionElement() {         // Calls factory.declareVariable("stringArray").          // The factory needs to create a collection         assertXPathCreatePath(             context,             "$stringArray[2]",             "",             "$stringArray[2]");          // See if the factory populated the first element as well         assertEquals(             "Created <" + "$stringArray[1]" + ">",             "Value1",             context.getValue("$stringArray[1]"));     }      public void testCreateAndSetValuePathDeclareVariableSetCollectionElement() {         // Calls factory.declareVariable("stringArray").          // The factory needs to create a collection         assertXPathCreatePathAndSetValue(             context,             "$stringArray[2]",             "Value2",             "$stringArray[2]");          // See if the factory populated the first element as well         assertEquals(             "Created <" + "$stringArray[1]" + ">",             "Value1",             context.getValue("$stringArray[1]"));     }      public void testCreatePathExpandCollection() {         context.getVariables().declareVariable(             "array",             new String[] { "Value1" });          // Does not involve factory at all - just expands the collection         assertXPathCreatePath(context, "$array[2]", "", "$array[2]");          // Make sure it is still the same array         assertEquals(             "Created <" + "$array[1]" + ">",             "Value1",             context.getValue("$array[1]"));     }      public void testCreatePathAndSetValueExpandCollection() {         context.getVariables().declareVariable(             "array",             new String[] { "Value1" });          // Does not involve factory at all - just expands the collection         assertXPathCreatePathAndSetValue(             context,             "$array[2]",             "Value2",             "$array[2]");          // Make sure it is still the same array         assertEquals(             "Created <" + "$array[1]" + ">",             "Value1",             context.getValue("$array[1]"));     }      public void testCreatePathDeclareVariableSetProperty() {         // Calls factory.declareVariable("test").          // The factory should create a TestBean         assertXPathCreatePath(             context,             "$test/boolean",             Boolean.FALSE,             "$test/boolean");      }      public void testCreatePathAndSetValueDeclareVariableSetProperty() {         // Calls factory.declareVariable("test").          // The factory should create a TestBean         assertXPathCreatePathAndSetValue(             context,             "$test/boolean",             Boolean.TRUE,             "$test/boolean");      }      public void testCreatePathDeclareVariableSetCollectionElementProperty() {         // Calls factory.declareVariable("testArray").         // The factory should create a collection of TestBeans.         // Then calls factory.createObject(..., collection, "testArray", 1).         // That one should produce an instance of TestBean and          // put it in the collection at index 1.         assertXPathCreatePath(             context,             "$testArray[2]/boolean",             Boolean.FALSE,             "$testArray[2]/boolean");     }      public void testCreatePathAndSetValueDeclVarSetCollectionElementProperty() {         // Calls factory.declareVariable("testArray").         // The factory should create a collection of TestBeans.         // Then calls factory.createObject(..., collection, "testArray", 1).         // That one should produce an instance of TestBean and          // put it in the collection at index 1.         assertXPathCreatePathAndSetValue(             context,             "$testArray[2]/boolean",             Boolean.TRUE,             "$testArray[2]/boolean");     }      public void testRemovePathUndeclareVariable() {         // Undeclare variable         context.getVariables().declareVariable("temp", "temp");         context.removePath("$temp");         assertTrue(             "Undeclare variable",             !context.getVariables().isDeclaredVariable("temp"));      }      public void testRemovePathArrayElement() {         // Remove array element - reassigns the new array to the var         context.getVariables().declareVariable(             "temp",             new String[] { "temp1", "temp2" });         context.removePath("$temp[1]");         assertEquals(             "Remove array element",             "temp2",             context.getValue("$temp[1]"));     }      public void testRemovePathCollectionElement() {         // Remove list element - does not create a new list         context.getVariables().declareVariable("temp", list("temp1", "temp2"));         context.removePath("$temp[1]");         assertEquals(             "Remove collection element",             "temp2",             context.getValue("$temp[1]"));     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.model;  import java.util.ArrayList; import java.util.Collections; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Locale; import java.util.Map; import java.util.Vector;  import junit.framework.Test; import junit.framework.TestSuite; import junit.textui.TestRunner;  import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathTestCase; import org.apache.commons.jxpath.Pointer; import org.apache.commons.jxpath.TestBean; import org.apache.commons.jxpath.TestMixedModelBean; import org.apache.commons.jxpath.TestNull; import org.apache.commons.jxpath.Variables;  /**  * Tests JXPath with mixed model: beans, maps, DOM etc.  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class MixedModelTest extends JXPathTestCase {     private JXPathContext context;      /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public MixedModelTest(String name) {         super(name);     }      public static void main(String[] args) {         TestRunner.run(new MixedModelTest("testContainerWithCollection"));     }          /**      * Return the tests included in this test suite.      */     public static Test suite() {         return (new TestSuite(MixedModelTest.class));     }      public void setUp() {         TestMixedModelBean bean = new TestMixedModelBean();         context = JXPathContext.newContext(bean);         context.setFactory(new TestMixedModelFactory());         context.setLocale(Locale.US);         Variables vars = context.getVariables();         vars.declareVariable("string", bean.getString());         vars.declareVariable("bean", bean.getBean());         vars.declareVariable("map", bean.getMap());         vars.declareVariable("list", bean.getList());         vars.declareVariable("document", bean.getDocument());         vars.declareVariable("element", bean.getElement());         vars.declareVariable("container", bean.getContainer());         vars.declareVariable("testnull", new TestNull());          int[][] matrix = new int[1][];         matrix[0] = new int[1];         matrix[0][0] = 3;         vars.declareVariable("matrix", matrix);     }      public void testVar() {         context.getVariables().declareVariable("foo:bar", "baz");          assertXPathValueAndPointer(context,              "$foo:bar",              "baz",              "$foo:bar");              }          public void testVarPrimitive() {         assertXPathValueAndPointer(context, "$string", "string", "$string");     }      public void testVarBean() {         assertXPathValueAndPointer(             context,             "$bean/int",             new Integer(1),             "$bean/int");     }      public void testVarMap() {         assertXPathValueAndPointer(             context,             "$map/string",             "string",             "$map[@name='string']");     }      public void testVarList() {         assertXPathValueAndPointer(context, "$list[1]", "string", "$list[1]");     }      public void testVarDocument() {         assertXPathValueAndPointer(             context,             "$document/vendor/location/address/city",             "Fruit Market",             "$document/vendor[1]/location[2]/address[1]/city[1]");     }      public void testVarElement() {         assertXPathValueAndPointer(             context,             "$element/location/address/city",             "Fruit Market",             "$element/location[2]/address[1]/city[1]");     }      public void testVarContainer() {         assertXPathValueAndPointer(             context,             "$container/vendor/location/address/city",             "Fruit Market",             "$container/vendor[1]/location[2]/address[1]/city[1]");     }      // ----------------------------------------------------------------------      public void testBeanPrimitive() {         assertXPathValueAndPointer(context, "string", "string", "/string");     }      public void testBeanBean() {         assertXPathValueAndPointer(             context,             "bean/int",             new Integer(1),             "/bean/int");     }      public void testBeanMap() {         assertXPathValueAndPointer(             context,             "map/string",             "string",             "/map[@name='string']");     }      public void testBeanList() {         assertXPathValueAndPointer(context, "list[1]", "string", "/list[1]");     }      public void testBeanDocument() {         assertXPathValueAndPointer(             context,             "document/vendor/location/address/city",             "Fruit Market",             "/document/vendor[1]/location[2]/address[1]/city[1]");     }      public void testBeanElement() {         assertXPathValueAndPointer(             context,             "element/location/address/city",             "Fruit Market",             "/element/location[2]/address[1]/city[1]");     }      public void testBeanContainer() {         assertXPathValueAndPointer(             context,             "container/vendor/location/address/city",             "Fruit Market",             "/container/vendor[1]/location[2]/address[1]/city[1]");     }      // ----------------------------------------------------------------------      public void testMapPrimitive() {         assertXPathValueAndPointer(             context,             "map/string",             "string",             "/map[@name='string']");     }      public void testMapBean() {         assertXPathValueAndPointer(             context,             "map/bean/int",             new Integer(1),             "/map[@name='bean']/int");     }      public void testMapMap() {         assertXPathValueAndPointer(             context,             "map/map/string",             "string",             "/map[@name='map'][@name='string']");     }      public void testMapList() {         assertXPathValueAndPointer(             context,             "map/list[1]",             "string",             "/map[@name='list'][1]");     }      public void testMapDocument() {         assertXPathValueAndPointer(             context,             "map/document/vendor/location/address/city",             "Fruit Market",             "/map[@name='document']"                 + "/vendor[1]/location[2]/address[1]/city[1]");     }      public void testMapElement() {         assertXPathValueAndPointer(             context,             "map/element/location/address/city",             "Fruit Market",             "/map[@name='element']/location[2]/address[1]/city[1]");     }      public void testMapContainer() {         assertXPathValueAndPointer(             context,             "map/container/vendor/location/address/city",             "Fruit Market",             "/map[@name='container']"                 + "/vendor[1]/location[2]/address[1]/city[1]");     }      // ----------------------------------------------------------------------      public void testListPrimitive() {         assertXPathValueAndPointer(context, "list[1]", "string", "/list[1]");     }      public void testListBean() {         assertXPathValueAndPointer(             context,             "list[2]/int",             new Integer(1),             "/list[2]/int");     }      public void testListMap() {         assertXPathValueAndPointer(             context,             "list[3]/string",             "string",             "/list[3][@name='string']");     }      public void testListList() {         /** @todo: what is this supposed to do? Should we stick to XPath,          *  in which case [1] is simply ignored, or Java, in which case          *  it is supposed to extract the first element from the list?          */ //        assertXPathValueAndPointer(context, //                "list[4][1]", //                "string2", //                "/list[4][1]");          assertXPathValueAndPointer(             context,             "list[4]/.[1]",             "string2",             "/list[4]/.[1]");     }      public void testListDocument() {         assertXPathValueAndPointer(             context,             "list[5]/vendor/location/address/city",             "Fruit Market",             "/list[5]/vendor[1]/location[2]/address[1]/city[1]");     }      public void testListElement() {         assertXPathValueAndPointer(             context,             "list[6]/location/address/city",             "Fruit Market",             "/list[6]/location[2]/address[1]/city[1]");     }      public void testListContainer() {         assertXPathValueAndPointer(             context,             "list[7]/vendor/location/address/city",             "Fruit Market",             "/list[7]/vendor[1]/location[2]/address[1]/city[1]");     }      public void testNull() {          assertXPathPointerLenient(context, "$null", "$null");          assertXPathPointerLenient(context, "$null[3]", "$null[3]");          assertXPathPointerLenient(             context,             "$testnull/nothing",             "$testnull/nothing");          assertXPathPointerLenient(             context,             "$testnull/nothing[2]",             "$testnull/nothing[2]");          assertXPathPointerLenient(context, "beans[8]/int", "/beans[8]/int");          assertXPathValueIterator(             context,             "$testnull/nothing[1]",             Collections.EMPTY_LIST);          JXPathContext ctx = JXPathContext.newContext(new TestNull());         assertXPathValue(ctx, "nothing", null);          assertXPathValue(ctx, "child/nothing", null);          assertXPathValue(ctx, "array[2]", null);          assertXPathValueLenient(ctx, "nothing/something", null);          assertXPathValueLenient(ctx, "array[2]/something", null);     }      public void testRootAsCollection() {         assertXPathValue(context, ".[1]/string", "string");     }      public void testCreatePath() {         context = JXPathContext.newContext(new TestBean());         context.setFactory(new TestMixedModelFactory());          TestBean bean = (TestBean) context.getContextBean();         bean.setMap(null);          assertXPathCreatePath(             context,             "/map[@name='TestKey5']/nestedBean/int",             new Integer(1),             "/map[@name='TestKey5']/nestedBean/int");          bean.setMap(null);         assertXPathCreatePath(             context,             "/map[@name='TestKey5']/beans[2]/int",             new Integer(1),             "/map[@name='TestKey5']/beans[2]/int");     }      /**      * Test JXPath.iterate() with map containing an array      */     public void testIterateArray() {         Map map = new HashMap();         map.put("foo", new String[] { "a", "b", "c" });          JXPathContext context = JXPathContext.newContext(map);          assertXPathValueIterator(context, "foo", list("a", "b", "c"));     }      public void testIteratePointersArray() {         Map map = new HashMap();         map.put("foo", new String[] { "a", "b", "c" });          JXPathContext context = JXPathContext.newContext(map);          Iterator it = context.iteratePointers("foo");         List actual = new ArrayList();         while (it.hasNext()) {             Pointer ptr = (Pointer) it.next();             actual.add(context.getValue(ptr.asPath()));         }         assertEquals(             "Iterating pointers <" + "foo" + ">",             list("a", "b", "c"),             actual);     }      public void testIteratePointersArrayElementWithVariable() {         Map map = new HashMap();         map.put("foo", new String[] { "a", "b", "c" });          JXPathContext context = JXPathContext.newContext(map);         context.getVariables().declareVariable("x", new Integer(2));         Iterator it = context.iteratePointers("foo[$x]");         List actual = new ArrayList();         while (it.hasNext()) {             Pointer ptr = (Pointer) it.next();             actual.add(context.getValue(ptr.asPath()));         }         assertEquals("Iterating pointers <" + "foo" + ">", list("b"), actual);     }      public void testIterateVector() {         Map map = new HashMap();         Vector vec = new Vector();         vec.add(new HashMap());         vec.add(new HashMap());          map.put("vec", vec);         JXPathContext context = JXPathContext.newContext(map);         assertXPathPointerIterator(             context,             "/vec",             list("/.[@name='vec'][1]", "/.[@name='vec'][2]"));     }      public void testErrorProperty() {         context.getVariables().declareVariable(             "e",             new ExceptionPropertyTestBean());          boolean ex = false;         try {             assertXPathValue(context, "$e/errorString", null);         }         catch (Throwable t) {             ex = true;         }         assertTrue("Legitimate exception accessing property", ex);          assertXPathPointer(context, "$e/errorString", "$e/errorString");          assertXPathPointerLenient(             context,             "$e/errorStringArray[1]",             "$e/errorStringArray[1]");          assertXPathPointerIterator(             context,             "$e/errorString",             list("$e/errorString"));          assertXPathPointerIterator(             context,             "$e//error",             Collections.EMPTY_LIST);     }      public void testMatrix() {         assertXPathValueAndPointer(             context,             "$matrix[1]/.[1]",             new Integer(3),             "$matrix[1]/.[1]");          context.setValue("$matrix[1]/.[1]", new Integer(2));          assertXPathValueAndPointer(             context,             "matrix[1]/.[1]",             new Integer(3),             "/matrix[1]/.[1]");          context.setValue("matrix[1]/.[1]", "2");          assertXPathValue(context, "matrix[1]/.[1]", new Integer(2));          context.getVariables().declareVariable(             "wholebean",             context.getContextBean());          assertXPathValueAndPointer(             context,             "$wholebean/matrix[1]/.[1]",             new Integer(2),             "$wholebean/matrix[1]/.[1]");          boolean ex = false;         try {             context.setValue("$wholebean/matrix[1]/.[2]", "4");         }         catch (Exception e) {             ex = true;         }         assertTrue("Exception setting value of non-existent element", ex);          ex = false;         try {             context.setValue("$wholebean/matrix[2]/.[1]", "4");         }         catch (Exception e) {             ex = true;         }         assertTrue("Exception setting value of non-existent element", ex);     }      public void testCreatePathAndSetValueWithMatrix() {          context.setValue("matrix", null);          // Calls factory.createObject(..., TestMixedModelBean, "matrix")         // Calls factory.createObject(..., nestedBean, "strings", 2)         assertXPathCreatePathAndSetValue(             context,             "/matrix[1]/.[1]",             new Integer(4),             "/matrix[1]/.[1]");     }          /**      * Scott Heaberlin's test - collection of collections      */     public void testCollectionPointer() {         List list = new ArrayList();         Map map = new HashMap();         map.put("KeyOne", "SomeStringOne");         map.put("KeyTwo", "SomeStringTwo");                  Map map2 = new HashMap();         map2.put("KeyA", "StringA");         map2.put("KeyB", "StringB");                  map.put("KeyThree", map2);         list.add(map);                  List list2 = new ArrayList();         list2.add("foo");         list2.add(map);         list2.add(map);         list.add(list2);                  context = JXPathContext.newContext(list);                  assertEquals("SomeStringOne", context.getValue(".[1]/KeyOne"));         assertEquals("StringA", context.getValue(".[1]/KeyThree/KeyA"));         assertEquals(new Integer(3), context.getValue("size(.[1]/KeyThree)"));         assertEquals(new Double(6.0), context.getValue("count(.[1]/KeyThree/*)"));         assertEquals(new Double(3.0), context.getValue("count(.[1]/KeyThree/KeyA)"));     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.model.beans;  import junit.framework.TestSuite;  import org.apache.commons.jxpath.AbstractFactory; import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.TestBean; import org.apache.commons.jxpath.ri.model.BeanModelTestCase;  /**  * Tests JXPath with JavaBeans *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class BeanModelTest extends BeanModelTestCase {     /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public BeanModelTest(String name) {         super(name);     }      /**      * Return the tests included in this test suite.      */     public static TestSuite suite() {         return (new TestSuite(BeanModelTest.class));     }      protected Object createContextBean() {         return new TestBean();     }      protected AbstractFactory getAbstractFactory() {         return new TestBeanFactory();     }          public void testIndexedProperty() {         JXPathContext context =             JXPathContext.newContext(null, new TestIndexedPropertyBean());                      assertXPathValueAndPointer(             context,             "indexed[1]",             new Integer(0),             "/indexed[1]");     }   }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.model.container;  import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map;  import junit.framework.Test; import junit.framework.TestSuite; import junit.textui.TestRunner;  import org.apache.commons.jxpath.Container; import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathTestCase;  /**  * Tests JXPath with containers as root or value of a variable, property, etc.  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class ContainerModelTest extends JXPathTestCase {     private JXPathContext context;      /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public ContainerModelTest(String name) {         super(name);     }      public static void main(String[] args) {         TestRunner.run(suite());     }          /**      * Return the tests included in this test suite.      */     public static Test suite() {         return (new TestSuite(ContainerModelTest.class));     }           private class ArrayContainer implements Container     {         private String[] array = new String[]{"foo", "bar"};         public Object getValue() {             return array;         }          public void setValue(Object value) {             throw new UnsupportedOperationException();         }     };      public class ListContainer implements Container     {         private List list;          public ListContainer() {             list = new ArrayList();             list.add("foo");             list.add("bar");         }          public Object getValue() {             return list;         }          public void setValue(Object value) {             throw new UnsupportedOperationException();         }     }      public class Bean     {         private ListContainer container = new ListContainer();          public ListContainer getContainer() {             return container;         }     }              public void testContainerVariableWithCollection() {         ArrayContainer container = new ArrayContainer();         String[] array = (String[]) container.getValue();                  JXPathContext context = JXPathContext.newContext(null);         context.getVariables().declareVariable("list", container);                  assertXPathValueAndPointer(context, "$list", array, "$list");         assertXPathValueAndPointer(context, "$list[1]", "foo", "$list[1]");         assertXPathValueAndPointer(context, "$list[2]", "bar", "$list[2]");                  assertXPathSetValue(context, "$list[1]", "baz");         assertEquals("Checking setValue(index)", "baz", array[0]);     }          public void testContainerPropertyWithCollection() {         Bean bean = new Bean();         List list = (List) bean.getContainer().getValue();                  JXPathContext context = JXPathContext.newContext(bean);                  assertXPathValueAndPointer(context, "/container",                  list, "/container");         assertXPathValueAndPointer(context, "/container[1]",                 list.get(0), "/container[1]");         assertXPathValueAndPointer(context, "/container[2]",                 list.get(1), "/container[2]");                  assertXPathSetValue(context, "/container[1]", "baz");         assertEquals("Checking setValue(index)", "baz", list.get(0));     }          public void testContainerMapWithCollection() {         ListContainer container = new ListContainer();         List list = (List) container.getValue();                          Map map = new HashMap();         map.put("container", container);                  JXPathContext context = JXPathContext.newContext(map);                  assertXPathValueAndPointer(context, "/container",                  list, "/.[@name='container']");         assertXPathValueAndPointer(context, "/container[1]",                 list.get(0), "/.[@name='container'][1]");         assertXPathValueAndPointer(context, "/container[2]",                 list.get(1), "/.[@name='container'][2]");                  assertXPathSetValue(context, "/container[1]", "baz");         assertEquals("Checking setValue(index)", "baz", list.get(0));     }          public void testContainerRootWithCollection() {         ArrayContainer container = new ArrayContainer();         String[] array = (String[]) container.getValue();                  JXPathContext context = JXPathContext.newContext(container);         context.getVariables().declareVariable("list", container);                  assertXPathValueAndPointer(context, "/", array, "/");         assertXPathValueAndPointer(context, "/.[1]", "foo", "/.[1]");         assertXPathValueAndPointer(context, "/.[2]", "bar", "/.[2]");                  assertXPathSetValue(context, "/.[1]", "baz");         assertEquals("Checking setValue(index)", "baz", array[0]);    }      }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.model.dom;  import junit.framework.Test; import junit.framework.TestSuite;  import org.apache.commons.jxpath.AbstractFactory; import org.apache.commons.jxpath.ri.model.XMLModelTestCase; import org.apache.commons.jxpath.xml.DocumentContainer; import org.w3c.dom.Attr; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList;  /**  * Tests JXPath with DOM  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class DOMModelTest extends XMLModelTestCase {          /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public DOMModelTest(String name) {         super(name);     }      /**      * Return the tests included in this test suite.      */     public static Test suite() {         return (new TestSuite(DOMModelTest.class));     }      protected String getModel() {         return DocumentContainer.MODEL_DOM;     }      protected AbstractFactory getAbstractFactory() {         return new TestDOMFactory();     }          public void testGetNode() {         assertXPathNodeType(context, "/", Document.class);         assertXPathNodeType(context, "/vendor/location", Element.class);         assertXPathNodeType(context, "//location/@name", Attr.class);         assertXPathNodeType(context, "//vendor", Element.class);     }          protected String getXMLSignature(         Object node,         boolean elements,         boolean attributes,         boolean text,         boolean pi)      {         StringBuffer buffer = new StringBuffer();         appendXMLSignature(buffer, node, elements, attributes, text, pi);         return buffer.toString();     }      private void appendXMLSignature(         StringBuffer buffer,         Object object,         boolean elements,         boolean attributes,         boolean text,         boolean pi)      {         Node node = (Node) object;         int type = node.getNodeType();         switch (type) {             case Node.DOCUMENT_NODE :                 buffer.append("<D>");                 appendXMLSignature(                     buffer,                     node.getChildNodes(),                     elements,                     attributes,                     text,                     pi);                 buffer.append("</D");                 break;              case Node.ELEMENT_NODE :                 String tag = elements ? ((Element) node).getTagName() : "E";                 buffer.append("<");                 buffer.append(tag);                 buffer.append(">");                 appendXMLSignature(                     buffer,                     node.getChildNodes(),                     elements,                     attributes,                     text,                     pi);                 buffer.append("</");                 buffer.append(tag);                 buffer.append(">");                 break;              case Node.TEXT_NODE :             case Node.CDATA_SECTION_NODE :                 if (text) {                     String string = node.getNodeValue();                     string = string.replace('\n', '=');                     buffer.append(string);                 }                 break;         }     }      private void appendXMLSignature(         StringBuffer buffer,         NodeList children,         boolean elements,         boolean attributes,         boolean text,         boolean pi)      {         for (int i = 0; i < children.getLength(); i++) {             appendXMLSignature(                 buffer,                 children.item(i),                 elements,                 attributes,                 text,                 pi);         }     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.model.dynabeans;  import junit.framework.TestSuite;  import org.apache.commons.beanutils.WrapDynaBean; import org.apache.commons.jxpath.AbstractFactory; import org.apache.commons.jxpath.TestBean; import org.apache.commons.jxpath.ri.model.BeanModelTestCase;  /**  * Test for support of DynaBeans (see BeanUtils)  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class DynaBeanModelTest extends BeanModelTestCase {     public DynaBeanModelTest(String name) {         super(name);     }      public static TestSuite suite() {         return new TestSuite(DynaBeanModelTest.class); //        TestSuite s = new TestSuite(); //        s.addTest(new DynaBeanModelTest("testAxisParent")); //        return s;     }      protected Object createContextBean() {         return new WrapDynaBean(new TestBean());     }      protected AbstractFactory getAbstractFactory() {         return new TestDynaBeanFactory();     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.model.dynamic;  import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map;  import org.apache.commons.jxpath.JXPathContext; import org.apache.commons.jxpath.JXPathTestCase; import org.apache.commons.jxpath.TestBean;  /**  * @todo more iterator testing with maps  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class DynamicPropertiesModelTest extends JXPathTestCase {     private static boolean enabled = true;     private JXPathContext context;      /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public DynamicPropertiesModelTest(String name) {         super(name);     }      public void setUp() {         if (context == null) {             context = JXPathContext.newContext(new TestBean());             context.setFactory(new TestDynamicPropertyFactory());         }     }      public void testAxisChild() {         assertXPathValue(context, "map/Key1", "Value 1");          assertXPathPointer(context, "map/Key1", "/map[@name='Key1']");          assertXPathValue(context, "map/Key2/name", "Name 6");          assertXPathPointer(context, "map/Key2/name", "/map[@name='Key2']/name");     }      public void testAxisDescendant() {         assertXPathValue(context, "//Key1", "Value 1");     }      /**      * Testing the pseudo-attribute "name" that dynamic property      * objects appear to have.      */     public void testAttributeName() {         assertXPathValue(context, "map[@name = 'Key1']", "Value 1");          assertXPathPointer(             context,             "map[@name = 'Key1']",             "/map[@name='Key1']");          assertXPathPointerLenient(             context,             "map[@name = 'Key&quot;&apos;&quot;&apos;1']",             "/map[@name='Key&quot;&apos;&quot;&apos;1']");          assertXPathValue(context, "/.[@name='map']/Key2/name", "Name 6");          assertXPathPointer(             context,             "/.[@name='map']/Key2/name",             "/map[@name='Key2']/name");          // Bean in a map         assertXPathValue(context, "/map[@name='Key2'][@name='name']", "Name 6");          assertXPathPointer(             context,             "/map[@name='Key2'][@name='name']",             "/map[@name='Key2']/name");          // Map in a bean in a map         assertXPathValue(             context,             "/.[@name='map'][@name='Key2'][@name='name']",             "Name 6");          assertXPathPointer(             context,             "/.[@name='map'][@name='Key2'][@name='name']",             "/map[@name='Key2']/name");                                  ((Map)context.getValue("map")).put("Key:3", "value3");                  assertXPathValueAndPointer(             context,             "/map[@name='Key:3']",             "value3",             "/map[@name='Key:3']");          assertXPathValueAndPointer(             context,             "/map[@name='Key:4:5']",             null,             "/map[@name='Key:4:5']");     }      public void testSetPrimitiveValue() {         assertXPathSetValue(context, "map/Key1", new Integer(6));     }      public void testSetCollection() {         // See if we can assign a whole collection                 context.setValue(             "map/Key1",             new Integer[] { new Integer(7), new Integer(8)});          // And then an element in that collection         assertXPathSetValue(context, "map/Key1[1]", new Integer(9));     }      /**      * The key does not exist, but the assignment should succeed anyway,      * because you should always be able to store anything in a Map.      */     public void testSetNewKey() {         // Using a "simple" path         assertXPathSetValue(context, "map/Key4", new Integer(7));                  // Using a "non-simple" path         assertXPathPointerLenient(context, "//map/Key5", "/map/Key5");                  assertXPathSetValue(context, "//map/Key5", new Integer(8));     }      public void testCreatePath() {         TestBean bean = (TestBean) context.getContextBean();         bean.setMap(null);          // Calls factory.createObject(..., testBean, "map"), then         // sets the value         assertXPathCreatePath(             context,             "/map[@name='TestKey1']",             "",             "/map[@name='TestKey1']");     }      public void testCreatePathAndSetValue() {         TestBean bean = (TestBean) context.getContextBean();         bean.setMap(null);          // Calls factory.createObject(..., testBean, "map"), then         // sets the value         assertXPathCreatePathAndSetValue(             context,             "/map[@name='TestKey1']",             "Test",             "/map[@name='TestKey1']");     }      public void testCreatePathCreateBean() {         TestBean bean = (TestBean) context.getContextBean();         bean.setMap(null);          // Calls factory.createObject(..., testBean, "map"), then         // then factory.createObject(..., map, "TestKey2"), then         // sets the value         assertXPathCreatePath(             context,             "/map[@name='TestKey2']/int",             new Integer(1),             "/map[@name='TestKey2']/int");     }      public void testCreatePathAndSetValueCreateBean() {         TestBean bean = (TestBean) context.getContextBean();         bean.setMap(null);          // Calls factory.createObject(..., testBean, "map"), then         // then factory.createObject(..., map, "TestKey2"), then         // sets the value         assertXPathCreatePathAndSetValue(             context,             "/map[@name='TestKey2']/int",             new Integer(4),             "/map[@name='TestKey2']/int");     }      public void testCreatePathCollectionElement() {         TestBean bean = (TestBean) context.getContextBean();         bean.setMap(null);          assertXPathCreatePath(             context,             "/map/TestKey3[2]",             null,             "/map[@name='TestKey3'][2]");          // Should be the same as the one before         assertXPathCreatePath(             context,             "/map[@name='TestKey3'][3]",             null,             "/map[@name='TestKey3'][3]");     }      public void testCreatePathAndSetValueCollectionElement() {         TestBean bean = (TestBean) context.getContextBean();         bean.setMap(null);          assertXPathCreatePathAndSetValue(             context,             "/map/TestKey3[2]",             "Test1",             "/map[@name='TestKey3'][2]");          // Should be the same as the one before         assertXPathCreatePathAndSetValue(             context,             "/map[@name='TestKey3'][3]",             "Test2",             "/map[@name='TestKey3'][3]");     }      public void testCreatePathNewCollectionElement() {         TestBean bean = (TestBean) context.getContextBean();         bean.setMap(null);          // Create an element of a dynamic map element, which is a collection         assertXPathCreatePath(             context,             "/map/TestKey4[1]/int",             new Integer(1),             "/map[@name='TestKey4'][1]/int");          bean.getMap().remove("TestKey4");          // Should be the same as the one before         assertXPathCreatePath(             context,             "/map/TestKey4[1]/int",             new Integer(1),             "/map[@name='TestKey4'][1]/int");     }      public void testCreatePathAndSetValueNewCollectionElement() {         TestBean bean = (TestBean) context.getContextBean();         bean.setMap(null);          // Create an element of a dynamic map element, which is a collection         assertXPathCreatePathAndSetValue(             context,             "/map/TestKey4[1]/int",             new Integer(2),             "/map[@name='TestKey4'][1]/int");          bean.getMap().remove("TestKey4");          // Should be the same as the one before         assertXPathCreatePathAndSetValue(             context,             "/map/TestKey4[1]/int",             new Integer(3),             "/map[@name='TestKey4'][1]/int");     }      public void testRemovePath() {         TestBean bean = (TestBean) context.getContextBean();         bean.getMap().put("TestKey1", "test");          // Remove dynamic property         context.removePath("map[@name = 'TestKey1']");         assertEquals(             "Remove dynamic property value",             null,             context.getValue("map[@name = 'TestKey1']"));     }      public void testRemovePathArrayElement() {         TestBean bean = (TestBean) context.getContextBean();          bean.getMap().put("TestKey2", new String[] { "temp1", "temp2" });         context.removePath("map[@name = 'TestKey2'][1]");         assertEquals(             "Remove dynamic property collection element",             "temp2",             context.getValue("map[@name = 'TestKey2'][1]"));     }          public void testCollectionOfMaps() {         TestBean bean = (TestBean) context.getContextBean();         List list = new ArrayList();          bean.getMap().put("stuff", list);                  Map m = new HashMap();         m.put("fruit", "apple");         list.add(m);          m = new HashMap();         m.put("berry", "watermelon");         list.add(m);          m = new HashMap();         m.put("fruit", "banana");         list.add(m);          assertXPathValueIterator(             context,             "/map/stuff/fruit",             list("apple", "banana"));          assertXPathValueIterator(             context,             "/map/stuff[@name='fruit']",             list("apple", "banana"));             }      public void testMapOfMaps() {         TestBean bean = (TestBean) context.getContextBean();          Map fruit = new HashMap();         fruit.put("apple", "green");         fruit.put("orange", "red");                  Map meat = new HashMap();         meat.put("pork", "pig");         meat.put("beef", "cow");                  bean.getMap().put("fruit", fruit);                 bean.getMap().put("meat", meat);                                  assertXPathPointer(             context,             "//beef",             "/map[@name='meat'][@name='beef']");                  assertXPathPointer(             context,             "map//apple",             "/map[@name='fruit'][@name='apple']");          // Ambiguous search - will return nothing         assertXPathPointerLenient(context, "map//banana", "null()");                  // Unambiguous, even though the particular key is missing          assertXPathPointerLenient(             context,             "//fruit/pear",             "/map[@name='fruit']/pear");     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.ri.model.jdom;  import java.util.List;  import junit.framework.Test; import junit.framework.TestSuite;  import org.apache.commons.jxpath.AbstractFactory; import org.apache.commons.jxpath.ri.model.XMLModelTestCase; import org.apache.commons.jxpath.xml.DocumentContainer; import org.jdom.Attribute; import org.jdom.CDATA; import org.jdom.Document; import org.jdom.Element; import org.jdom.Text;  /**  * Tests JXPath with JDOM  *  * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class JDOMModelTest extends XMLModelTestCase {     /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public JDOMModelTest(String name) {         super(name);     }      /**      * Return the tests included in this test suite.      */     public static Test suite() {         return (new TestSuite(JDOMModelTest.class));     }      protected String getModel() {         return DocumentContainer.MODEL_JDOM;     }          public void testGetNode() {         assertXPathNodeType(context, "/", Document.class);         assertXPathNodeType(context, "/vendor/location", Element.class);         assertXPathNodeType(context, "//location/@name", Attribute.class);         assertXPathNodeType(context, "//vendor", Element.class); //bugzilla #38586     }          public void testID() {         // id() is not supported by JDOM     }      protected AbstractFactory getAbstractFactory() {         return new TestJDOMFactory();     }      protected String getXMLSignature(         Object node,         boolean elements,         boolean attributes,         boolean text,         boolean pi)      {         StringBuffer buffer = new StringBuffer();         appendXMLSignature(buffer, node, elements, attributes, text, pi);         return buffer.toString();     }      private void appendXMLSignature(         StringBuffer buffer,         Object object,         boolean elements,         boolean attributes,         boolean text,         boolean pi)      {         if (object instanceof Document) {             buffer.append("<D>");             appendXMLSignature(                 buffer,                 ((Document) object).getContent(),                 elements,                 attributes,                 text,                 pi);             buffer.append("</D");         }         else if (object instanceof Element) {             String tag = elements ? ((Element) object).getName() : "E";             buffer.append("<");             buffer.append(tag);             buffer.append(">");             appendXMLSignature(                 buffer,                 ((Element) object).getContent(),                 elements,                 attributes,                 text,                 pi);             buffer.append("</");             buffer.append(tag);             buffer.append(">");         }         else if (object instanceof Text || object instanceof CDATA) {             if (text) {                 String string = ((Text) object).getText();                 string = string.replace('\n', '=');                 buffer.append(string);             }         }     }      private void appendXMLSignature(         StringBuffer buffer,         List children,         boolean elements,         boolean attributes,         boolean text,         boolean pi)      {         for (int i = 0; i < children.size(); i++) {             appendXMLSignature(                 buffer,                 children.get(i),                 elements,                 attributes,                 text,                 pi);         }     } }
/*  * Licensed to the Apache Software Foundation (ASF) under one or more  * contributor license agreements.  See the NOTICE file distributed with  * this work for additional information regarding copyright ownership.  * The ASF licenses this file to You under the Apache License, Version 2.0  * (the "License"); you may not use this file except in compliance with  * the License.  You may obtain a copy of the License at  *  *     http://www.apache.org/licenses/LICENSE-2.0  *  * Unless required by applicable law or agreed to in writing, software  * distributed under the License is distributed on an "AS IS" BASIS,  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  * See the License for the specific language governing permissions and  * limitations under the License.  */ package org.apache.commons.jxpath.util;  import java.lang.reflect.Array; import java.math.BigDecimal; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Date; import java.util.List;  import junit.framework.TestCase;  import org.apache.commons.jxpath.NodeSet; import org.apache.commons.jxpath.Pointer;  /**  * Tests BasicTypeConverter  *   * @author Dmitri Plotnikov  * @version $Revision$ $Date$  */  public class BasicTypeConverterTest extends TestCase {     /**      * Construct a new instance of this test case.      *      * @param name Name of the test case      */     public BasicTypeConverterTest(String name) {         super(name);     }      public void testPrimitiveToString() {         assertConversion(new Integer(1), String.class, "1");     }      public void testArrayToList() {         assertConversion(             new int[] { 1, 2 },             List.class,             Arrays.asList(new Object[] { new Integer(1), new Integer(2)}));     }      public void testArrayToArray() {         assertConversion(             new int[] { 1, 2 },             String[].class,             Arrays.asList(new String[] { "1", "2" }));     }      public void testListToArray() {         assertConversion(             Arrays.asList(new Integer[] { new Integer(1), new Integer(2)}),             String[].class,             Arrays.asList(new String[] { "1", "2" }));          assertConversion(             Arrays.asList(new String[] { "1", "2" }),             int[].class,             Arrays.asList(new Integer[] { new Integer(1), new Integer(2)}));     }      public void testInvalidConversion() {         boolean exception = false;         try {             TypeUtils.convert("'foo'", Date.class);         }         catch (Throwable ex) {             exception = true;         }         assertTrue("Type conversion exception", exception);     }      public void assertConversion(Object from, Class toType, Object expected) {         boolean can = TypeUtils.canConvert(from, toType);         assertTrue("Can convert: " + from.getClass() + " to " + toType, can);         Object result = TypeUtils.convert(from, toType);         if (result.getClass().isArray()) {             ArrayList list = new ArrayList();             for (int j = 0; j < Array.getLength(result); j++) {                 list.add(Array.get(result, j));             }             result = list;         }         assertEquals(             "Convert: " + from.getClass() + " to " + toType,             expected,             result);     }          public void testSingletonCollectionToString() {         assertConversion(Collections.singleton("Earth"), String.class, "Earth");     }      public void testSingletonArrayToString() {         assertConversion(new String[] { "Earth" }, String.class, "Earth");     }      public void testPointerToString() {         assertConversion(new Pointer() {             public Object getValue() {                 return "value";             }             public Object getNode() {                 return null;             }             public void setValue(Object value) {             }             public Object getRootNode() {                 return null;             }             public String asPath() {                 return null;             }             public Object clone() {                 return null;             }             public int compareTo(Object o) {                 return 0;             }         }, String.class, "value");     }      public void testNodeSetToString() {         assertConversion(new NodeSet() {             public List getNodes() {                 return null;             }             public List getPointers() {                 return null;             }             public List getValues() {                 List list = new ArrayList();                 list.add("hello");                 list.add("goodbye");                 return Collections.singletonList(list);             }         }, String.class, "hello");     }      // succeeds in current version     public void testNodeSetToInteger() {         assertConversion(new NodeSet() {             public List getNodes() {                 return null;             }             public List getPointers() {                 return null;             }             public List getValues() {                 return Collections.singletonList("9");             }         }, Integer.class, new Integer(9));     }              public void testBeanUtilsConverter() {         assertConversion("12", BigDecimal.class, new BigDecimal(12));     } }
